var tipuesearch = {"pages":[{"title":" rte-rrtmgp ","text":"rte-rrtmgp Welcome to the rte-rrtmgp developer documentation. How to Read This Documentation Start with the README and the Tutorial .\nAdditionally, there is a page that provides a higher level organizational overview that you can find here . The listings below are not exhaustive.\nTo see the full listings use the links at the top of the page.\nAlso, if you know what you're looking for, there is a search bar in the top right.","tags":"home","loc":"index.html"},{"title":"mo_rrtmgp_util_string.F90 – rte-rrtmgp","text":"Files dependent on this one sourcefile~~mo_rrtmgp_util_string.f90~~AfferentGraph sourcefile~mo_rrtmgp_util_string.f90 mo_rrtmgp_util_string.F90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rrtmgp_util_string Source Code mo_rrtmgp_util_string.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Routines for handling strings: !   convert to lower case !   does a string exist within an array of strings? !   what is the location of a string with an array? ! ! ------------------------------------------------------------------------------------------------- module mo_rrtmgp_util_string implicit none private public :: lower_case , string_in_array , string_loc_in_array ! List of character for case conversion character ( len = 26 ), parameter :: LOWER_CASE_CHARS = 'abcdefghijklmnopqrstuvwxyz' character ( len = 26 ), parameter :: UPPER_CASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' contains ! ------------------------------------------------------------------------------------------------- pure function lower_case ( input_string ) result ( output_string ) character ( len =* ), intent ( in ) :: input_string character ( len = len ( input_string )) :: output_string integer :: i , n ! Copy input string output_string = input_string ! Convert case character by character do i = 1 , len ( output_string ) n = index ( UPPER_CASE_CHARS , output_string ( i : i )) if ( n /= 0 ) output_string ( i : i ) = LOWER_CASE_CHARS ( n : n ) end do end function ! -------------------------------------------------------------------------------------- ! ! Is string somewhere in array? ! pure function string_in_array ( string , array ) character ( len =* ), intent ( in ) :: string character ( len =* ), dimension (:), intent ( in ) :: array logical :: string_in_array integer :: i character ( len = len_trim ( string )) :: lc_string string_in_array = . false . lc_string = lower_case ( trim ( string )) do i = 1 , size ( array ) if ( lc_string == lower_case ( trim ( array ( i )))) then string_in_array = . true . exit end if end do end function string_in_array ! -------------------------------------------------------------------------------------- ! ! Is string somewhere in array? ! pure function string_loc_in_array ( string , array ) character ( len =* ), intent ( in ) :: string character ( len =* ), dimension (:), intent ( in ) :: array integer :: string_loc_in_array integer :: i character ( len = len_trim ( string )) :: lc_string string_loc_in_array = - 1 lc_string = lower_case ( trim ( string )) do i = 1 , size ( array ) if ( lc_string == lower_case ( trim ( array ( i )))) then string_loc_in_array = i exit end if end do end function string_loc_in_array ! -------------------------------------------------------------------------------------- end module","tags":"","loc":"sourcefile/mo_rrtmgp_util_string.f90.html"},{"title":"mo_rrtmgp_util_reorder.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rrtmgp_util_reorder.f90~~EfferentGraph sourcefile~mo_rrtmgp_util_reorder.f90 mo_rrtmgp_util_reorder.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rrtmgp_util_reorder.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rrtmgp_util_reorder.f90~~AfferentGraph sourcefile~mo_rrtmgp_util_reorder.f90 mo_rrtmgp_util_reorder.F90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_util_reorder.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rrtmgp_util_reorder Source Code mo_rrtmgp_util_reorder.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Routines for permuting arrays: here one (x,y,z) -> (z,x,y) and (x,y,z) -> (z,y,x) !   Routines are just the front end to kernels ! ! ------------------------------------------------------------------------------------------------- module mo_rrtmgp_util_reorder use mo_rte_kind , only : wp use mo_rrtmgp_util_reorder_kernels , & only : reorder_123x321_kernel implicit none private public :: reorder123x321 contains ! ------------------------------------------------------------------------------------------------- ! ! (x,y,z) -> (z,y,x) ! subroutine reorder123x321 ( array , array_out ) real ( wp ), dimension (:,:,:), intent ( in ) :: array real ( wp ), dimension (:,:,:), intent ( out ) :: array_out call reorder_123x321_kernel ( size ( array , dim = 1 ), size ( array , dim = 2 ), size ( array , dim = 3 ), array , array_out ) end subroutine reorder123x321 ! ------------------------------------------------------------------------------------------------- end module","tags":"","loc":"sourcefile/mo_rrtmgp_util_reorder.f90.html"},{"title":"mo_gas_concentrations.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_gas_concentrations.f90~~EfferentGraph sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rrtmgp_util_string.f90 mo_rrtmgp_util_string.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_gas_concentrations.f90~~AfferentGraph sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_gas_concentrations Source Code mo_gas_concentrations.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! Encapsulates a collection of volume mixing ratios (concentrations) of gases. !   Each concentration is associated with a name, normally the chemical formula. ! ! Values may be provided as scalars, 1-dimensional profiles (nlay), or 2-D fields (ncol,nlay). !   (nlay and ncol are determined from the input arrays; self-consistency is enforced) !   example: !   error_msg = gas_concs%set_vmr('h2o', values(:,:)) !   error_msg = gas_concs%set_vmr('o3' , values(:)  ) !   error_msg = gas_concs%set_vmr('co2', value      ) ! ! Values can be requested as profiles (valid only if there are no 2D fields present in the object) !   or as 2D fields. Values for all columns are returned although the entire collection !   can be subsetted in the column dimension ! ! Subsets can be extracted in the column dimension ! ! Functions return strings. Non-empty strings indicate an error. ! ! ------------------------------------------------------------------------------------------------- module mo_gas_concentrations use mo_rte_kind , only : wp use mo_rte_config , only : check_values use mo_rrtmgp_util_string , only : lower_case use mo_rte_util_array , only : any_vals_outside implicit none integer , parameter :: GAS_NOT_IN_LIST = - 1 type , private :: conc_field real ( wp ), dimension (:,:), pointer :: conc => NULL () end type conc_field type , public :: ty_gas_concs ! ! Data ! character ( len = 32 ), dimension (:), allocatable :: gas_name type ( conc_field ), dimension (:), allocatable :: concs integer :: ncol = 0 , nlay = 0 contains ! ! Procedures ! procedure , private :: find_gas procedure , private :: set_vmr_scalar procedure , private :: set_vmr_1d procedure , private :: set_vmr_2d procedure , private :: get_vmr_1d procedure , private :: get_vmr_2d procedure , private :: get_subset_range final :: del ! ! public interface ! procedure , public :: init procedure , public :: reset generic , public :: set_vmr => set_vmr_scalar , & set_vmr_1d , & set_vmr_2d generic , public :: get_vmr => get_vmr_1d , & get_vmr_2d generic , public :: get_subset => get_subset_range procedure , public :: get_num_gases procedure , public :: get_gas_names end type ty_gas_concs contains ! ------------------------------------------------------------------------------------- function init ( this , gas_names ) result ( error_msg ) class ( ty_gas_concs ), intent ( inout ) :: this character ( len =* ), dimension (:), intent ( in ) :: gas_names character ( len = 128 ) :: error_msg ! --------- integer :: i , j , ngas ! --------- error_msg = '' ngas = size ( gas_names ) ! ! Check for no duplicate gas names, no empty names ! if ( any ( len_trim ( gas_names ) == 0 )) & error_msg = \"ty_gas_concs%init(): must provide non-empty gas names\" do i = 1 , ngas - 1 do j = i + 1 , ngas if ( lower_case ( trim ( gas_names ( i ))) == lower_case ( trim ( gas_names ( j )))) then error_msg = \"ty_gas_concs%init(): duplicate gas names aren't allowed\" exit end if end do end do if ( error_msg /= \"\" ) return ! ! Allocate fixed-size arrays ! call this % reset () allocate ( this % gas_name ( ngas ), this % concs ( ngas )) !$acc enter data copyin(this) !$acc enter data copyin(this%concs) !$omp target enter data map(to:this%concs) this % gas_name (:) = gas_names (:) end function ! ------------------------------------------------------------------------------------- ! ! Set concentrations --- scalar, 1D, 2D ! ! ------------------------------------------------------------------------------------- function set_vmr_scalar ( this , gas , w ) result ( error_msg ) ! In OpenACC context scalar w always assumed to be on the CPU class ( ty_gas_concs ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: gas real ( wp ), intent ( in ) :: w character ( len = 128 ) :: error_msg ! --------- real ( wp ), dimension (:,:), pointer :: p integer :: igas ! --------- error_msg = '' if ( w < 0._wp . or . w > 1._wp ) then error_msg = 'ty_gas_concs%set_vmr(): concentrations should be >= 0, <= 1' return endif igas = this % find_gas ( gas ) if ( igas == GAS_NOT_IN_LIST ) then error_msg = 'ty_gas_concs%set_vmr(): trying to set ' // trim ( gas ) // ' but name not provided at initialization' return end if ! ! Deallocate anything existing -- could be more efficient to test if it's already the correct size ! ! This cannot be made a function, because we need all the hierarchy for the correct OpenACC attach if ( associated ( this % concs ( igas )% conc )) then if ( any ( shape ( this % concs ( igas )% conc ) /= [ 1 , 1 ]) ) then !$acc exit data delete(this%concs(igas)%conc) !$omp target exit data map(release:this%concs(igas)%conc) deallocate ( this % concs ( igas )% conc ) nullify ( this % concs ( igas )% conc ) end if end if if (. not . associated ( this % concs ( igas )% conc )) then allocate ( this % concs ( igas )% conc ( 1 , 1 )) !$acc enter data create(this%concs(igas)%conc) !$omp target enter data map(alloc:this%concs(igas)%conc) end if p => this % concs ( igas )% conc (:,:) !$acc kernels !$omp target map(to:w) #ifdef _CRAYFTN p (:,:) = w #else this % concs ( igas )% conc (:,:) = w #endif !$acc end kernels !$omp end target end function set_vmr_scalar ! ------------------------------------------------------------------------------------- function set_vmr_1d ( this , gas , w ) result ( error_msg ) ! In OpenACC context w assumed to be either on the CPU or on the GPU class ( ty_gas_concs ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: gas real ( wp ), dimension (:), & intent ( in ) :: w character ( len = 128 ) :: error_msg ! --------- real ( wp ), dimension (:,:), pointer :: p integer :: igas ! --------- error_msg = '' if ( check_values ) then if ( any_vals_outside ( w , 0._wp , 1._wp )) & error_msg = 'ty_gas_concs%set_vmr: concentrations should be >= 0, <= 1' end if if ( this % nlay > 0 ) then if ( size ( w ) /= this % nlay ) error_msg = 'ty_gas_concs%set_vmr: different dimension (nlay)' else this % nlay = size ( w ) end if if ( error_msg /= \"\" ) return igas = this % find_gas ( gas ) if ( igas == GAS_NOT_IN_LIST ) then error_msg = 'ty_gas_concs%set_vmr(): trying to set ' // trim ( gas ) // ' but name not provided at initialization' return end if ! ! Deallocate anything existing -- could be more efficient to test if it's already the correct size ! ! This cannot be made a function, because we need all the hierarchy for the correct OpenACC attach if ( associated ( this % concs ( igas )% conc )) then if ( any ( shape ( this % concs ( igas )% conc ) /= [ 1 , this % nlay ]) ) then !$acc exit data delete(this%concs(igas)%conc) !$omp target exit data map(release:this%concs(igas)%conc) deallocate ( this % concs ( igas )% conc ) nullify ( this % concs ( igas )% conc ) end if end if if (. not . associated ( this % concs ( igas )% conc )) then allocate ( this % concs ( igas )% conc ( 1 , this % nlay )) !$acc enter data create(this%concs(igas)%conc) !$omp target enter data map(alloc:this%concs(igas)%conc) end if p => this % concs ( igas )% conc (:,:) !$acc kernels copyin(w) !$omp target map(to:w) #ifdef _CRAYFTN p ( 1 ,:) = w #else this % concs ( igas )% conc ( 1 ,:) = w #endif !$acc end kernels !$omp end target !$acc exit data delete(w) end function set_vmr_1d ! ------------------------------------------------------------------------------------- function set_vmr_2d ( this , gas , w ) result ( error_msg ) ! In OpenACC context w assumed to be either on the CPU or on the GPU class ( ty_gas_concs ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: gas real ( wp ), dimension (:,:), & intent ( in ) :: w character ( len = 128 ) :: error_msg ! --------- real ( wp ), dimension (:,:), pointer :: p integer :: igas ! --------- error_msg = '' if ( check_values ) then if ( any_vals_outside ( w , 0._wp , 1._wp )) & error_msg = 'ty_gas_concs%set_vmr: concentrations should be >= 0, <= 1' end if if ( this % ncol > 0 . and . size ( w , 1 ) /= this % ncol ) then error_msg = 'ty_gas_concs%set_vmr: different dimension (ncol)' else this % ncol = size ( w , 1 ) end if if ( this % nlay > 0 . and . size ( w , 2 ) /= this % nlay ) then error_msg = 'ty_gas_concs%set_vmr: different dimension (nlay)' else this % nlay = size ( w , 2 ) end if if ( error_msg /= \"\" ) return igas = this % find_gas ( gas ) if ( igas == GAS_NOT_IN_LIST ) then error_msg = 'ty_gas_concs%set_vmr(): trying to set ' // trim ( gas ) // 'but name not provided at initialization' return end if ! ! Deallocate anything existing -- could be more efficient to test if it's already the correct size ! ! This cannot be made a function, because we need all the hierarchy for the correct OpenACC attach if ( associated ( this % concs ( igas )% conc )) then if ( any ( shape ( this % concs ( igas )% conc ) /= [ this % ncol , this % nlay ]) ) then !$acc exit data delete(this%concs(igas)%conc) !$omp target exit data map(release:this%concs(igas)%conc) deallocate ( this % concs ( igas )% conc ) nullify ( this % concs ( igas )% conc ) end if end if if (. not . associated ( this % concs ( igas )% conc )) then allocate ( this % concs ( igas )% conc ( this % ncol , this % nlay )) !$acc enter data create(this%concs(igas)%conc) !$omp target enter data map(alloc:this%concs(igas)%conc) end if p => this % concs ( igas )% conc (:,:) !$acc kernels copyin(w) !$omp target map(to:w) #ifdef _CRAYFTN p (:,:) = w (:,:) #else this % concs ( igas )% conc (:,:) = w (:,:) #endif !$acc end kernels !$omp end target end function set_vmr_2d ! ------------------------------------------------------------------------------------- ! ! Return volume mixing ratio as 1D or 2D array ! ! ------------------------------------------------------------------------------------- ! ! 1D array ( lay depdendence only) ! function get_vmr_1d ( this , gas , array ) result ( error_msg ) class ( ty_gas_concs ) :: this character ( len =* ), intent ( in ) :: gas real ( wp ), dimension (:), intent ( out ) :: array character ( len = 128 ) :: error_msg ! --------------------- real ( wp ), dimension (:,:), pointer :: p integer :: igas ! --------------------- error_msg = '' igas = this % find_gas ( gas ) if ( igas == GAS_NOT_IN_LIST ) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // ' not found' else if (. not . associated ( this % concs ( igas )% conc )) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // \" concentration hasn't been set\" else if ( size ( this % concs ( igas )% conc , 1 ) > 1 ) then ! Are we requesting a single profile when many are present? error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // ' requesting single profile but many are available' end if if ( this % nlay > 0 . and . this % nlay /= size ( array )) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // ' array is wrong size (nlay)' end if if ( error_msg /= \"\" ) return p => this % concs ( igas )% conc (:,:) !$acc data copyout (array) present(this) !$omp target data map(from:array) if ( size ( this % concs ( igas )% conc , 2 ) > 1 ) then !$acc kernels default(none) !$omp target #ifdef _CRAYFTN array (:) = p ( 1 ,:) #else array (:) = this % concs ( igas )% conc ( 1 ,:) #endif !$acc end kernels !$omp end target else !$acc kernels default(none) !$omp target #ifdef _CRAYFTN array (:) = p ( 1 , 1 ) #else array (:) = this % concs ( igas )% conc ( 1 , 1 ) #endif !$acc end kernels !$omp end target end if !$acc end data !$omp end target data end function get_vmr_1d ! ------------------------------------------------------------------------------------- ! ! 2D array (col, lay) ! function get_vmr_2d ( this , gas , array ) result ( error_msg ) class ( ty_gas_concs ) :: this character ( len =* ), intent ( in ) :: gas real ( wp ), dimension (:,:), intent ( out ) :: array character ( len = 128 ) :: error_msg ! --------------------- real ( wp ), dimension (:,:), pointer :: p integer :: icol , ilay , igas ! --------------------- error_msg = '' igas = this % find_gas ( gas ) if ( igas == GAS_NOT_IN_LIST ) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // ' not found' else if (. not . associated ( this % concs ( igas )% conc )) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // \" concentration hasn't been set\" end if ! ! Is the requested array the correct size? ! if ( this % ncol > 0 . and . this % ncol /= size ( array , 1 )) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // ' array is wrong size (ncol)' end if if ( this % nlay > 0 . and . this % nlay /= size ( array , 2 )) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // ' array is wrong size (nlay)' end if if ( error_msg /= \"\" ) return p => this % concs ( igas )% conc (:,:) !$acc data copyout (array) present(this, this%concs) !$omp target data map(from:array) if ( size ( this % concs ( igas )% conc , 1 ) > 1 ) then ! Concentration stored as 2D !$acc parallel loop collapse(2) default(none) !$omp target teams distribute parallel do simd do ilay = 1 , size ( array , 2 ) do icol = 1 , size ( array , 1 ) !print *, (size(this%concs)) #ifdef _CRAYFTN array ( icol , ilay ) = p ( icol , ilay ) #else array ( icol , ilay ) = this % concs ( igas )% conc ( icol , ilay ) #endif end do end do else if ( size ( this % concs ( igas )% conc , 2 ) > 1 ) then ! Concentration stored as 1D !$acc parallel loop collapse(2) default(none) !$omp target teams distribute parallel do simd do ilay = 1 , size ( array , 2 ) do icol = 1 , size ( array , 1 ) #ifdef _CRAYFTN array ( icol , ilay ) = p ( 1 , ilay ) #else array ( icol , ilay ) = this % concs ( igas )% conc ( 1 , ilay ) #endif end do end do else ! Concentration stored as scalar !$acc parallel loop collapse(2) default(none) !$omp target teams distribute parallel do simd do ilay = 1 , size ( array , 2 ) do icol = 1 , size ( array , 1 ) #ifdef _CRAYFTN array ( icol , ilay ) = p ( 1 , 1 ) #else array ( icol , ilay ) = this % concs ( igas )% conc ( 1 , 1 ) #endif end do end do end if !$acc end data !$omp end target data end function get_vmr_2d ! ------------------------------------------------------------------------------------- ! ! Extract a subset of n columns starting with column 'start' ! ! ------------------------------------------------------------------------------------- function get_subset_range ( this , start , n , subset ) result ( error_msg ) class ( ty_gas_concs ), intent ( in ) :: this integer , intent ( in ) :: start , n class ( ty_gas_concs ), intent ( inout ) :: subset character ( len = 128 ) :: error_msg ! --------------------- real ( wp ), dimension (:,:), pointer :: p1 , p2 integer :: i ! --------------------- error_msg = '' if ( n <= 0 ) & error_msg = \"gas_concs%get_vmr: Asking for 0 or fewer columns \" if ( start < 1 ) & error_msg = \"gas_concs%get_vmr: Asking for columns outside range\" if ( this % ncol > 0 . and . start > this % ncol . or . start + n - 1 > this % ncol ) & error_msg = \"gas_concs%get_vmr: Asking for columns outside range\" if ( error_msg /= \"\" ) return call subset % reset () allocate ( subset % gas_name ( size ( this % gas_name )), & subset % concs ( size ( this % concs ))) ! These two arrays should be the same length !$acc enter data create(subset, subset%concs) !$omp target enter data map(alloc:subset%concs) subset % nlay = this % nlay subset % ncol = merge ( n , 0 , this % ncol > 0 ) subset % gas_name (:) = this % gas_name (:) do i = 1 , size ( this % gas_name ) ! ! Preserve scalar/1D/2D representation in subset, !   but need to ensure at least extent 1 in col dimension (ncol = 0 means no gas exploits this dimension) ! allocate ( subset % concs ( i )% conc ( min ( max ( subset % ncol , 1 ), size ( this % concs ( i )% conc , 1 )), & min ( subset % nlay , size ( this % concs ( i )% conc , 2 )))) p1 => subset % concs ( i )% conc (:,:) p2 => this % concs ( i )% conc (:,:) !$acc enter data create(subset%concs(i)%conc) !$omp target enter data map(alloc:subset%concs(i)%conc) if ( size ( this % concs ( i )% conc , 1 ) > 1 ) then ! Concentration stored as 2D !$acc kernels !$omp target #ifdef _CRAYFTN p1 (:,:) = p2 ( start :( start + n - 1 ),:) #else subset % concs ( i )% conc (:,:) = this % concs ( i )% conc ( start :( start + n - 1 ),:) #endif !$acc end kernels !$omp end target else !$acc kernels !$omp target #ifdef _CRAYFTN p1 (:,:) = p2 (:,:) #else subset % concs ( i )% conc (:,:) = this % concs ( i )% conc (:,:) #endif !$acc end kernels !$omp end target end if end do end function get_subset_range ! ------------------------------------------------------------------------------------- ! ! Deallocate memory ! ! ------------------------------------------------------------------------------------- subroutine reset ( this ) class ( ty_gas_concs ), intent ( inout ) :: this ! ----------------- integer :: i ! ----------------- this % nlay = 0 this % ncol = 0 if ( allocated ( this % gas_name )) deallocate ( this % gas_name ) if ( allocated ( this % concs )) then do i = 1 , size ( this % concs ) if ( associated ( this % concs ( i )% conc )) then !$acc exit data delete(this%concs(i)%conc) !$omp target exit data map(release:this%concs(i)%conc) deallocate ( this % concs ( i )% conc ) nullify ( this % concs ( i )% conc ) end if end do !$acc exit data delete(this%concs) !$omp target exit data map(release:this%concs) deallocate ( this % concs ) end if end subroutine reset ! ------------------------------------------------------------------------------------- ! ! Inquiry functions ! ! ------------------------------------------------------------------------------------- pure function get_num_gases ( this ) class ( ty_gas_concs ), intent ( in ) :: this integer :: get_num_gases get_num_gases = size ( this % gas_name ) return end function get_num_gases ! ------------------------------------------------------------------------------------- pure function get_gas_names ( this ) class ( ty_gas_concs ), intent ( in ) :: this character ( len = 32 ), dimension ( this % get_num_gases ()) :: get_gas_names get_gas_names (:) = this % gas_name (:) return end function get_gas_names ! ------------------------------------------------------------------------------------- ! ! Private procedures ! ! ------------------------------------------------------------------------------------- ! ! find gas in list; GAS_NOT_IN_LIST if not found ! function find_gas ( this , gas ) character ( len =* ), intent ( in ) :: gas class ( ty_gas_concs ), intent ( in ) :: this integer :: find_gas ! ----------------- integer :: igas ! ----------------- find_gas = GAS_NOT_IN_LIST if (. not . allocated ( this % gas_name )) return ! search gases using a loop. Fortran intrinsic findloc would be faster, but only supported since gfortran 9 do igas = 1 , size ( this % gas_name ) if ( lower_case ( trim ( this % gas_name ( igas ))) == lower_case ( trim ( gas ))) then find_gas = igas end if end do end function ! ------------------------------------------------------------------------------------- subroutine del ( this ) type ( ty_gas_concs ), intent ( inout ) :: this call this % reset () !$acc exit data delete(this) end subroutine del ! ------------------------------------------------------------------------------------- end module mo_gas_concentrations","tags":"","loc":"sourcefile/mo_gas_concentrations.f90.html"},{"title":"mo_gas_optics.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_gas_optics.f90~~EfferentGraph sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_gas_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rrtmgp_util_string.f90 mo_rrtmgp_util_string.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_gas_optics.f90~~AfferentGraph sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_gas_optics Source Code mo_gas_optics.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! ------------------------------------------------------------------------------------------------- module mo_gas_optics use mo_rte_kind , only : wp use mo_source_functions , only : ty_source_func_lw use mo_gas_concentrations , only : ty_gas_concs use mo_optical_props , only : ty_optical_props , ty_optical_props_arry type , abstract , extends ( ty_optical_props ), public :: ty_gas_optics contains generic , public :: gas_optics => gas_optics_int , gas_optics_ext ! ! Deferred procedures -- each must be implemented in each child class with !   arguments following the abstract interface (defined below) ! ! gas_optics_int and gas_optics_ext should be declared private in concrete classes !    but need to be visible in the abstract type or the interfaces won't be inherited ! See https://software.intel.com/en-us/forums/intel-fortran-compiler-for-linux-and-mac-os-x/topic/681705 ! procedure ( gas_optics_int_abstract ), deferred :: gas_optics_int procedure ( gas_optics_ext_abstract ), deferred :: gas_optics_ext procedure ( logical_abstract ), deferred , public :: source_is_internal procedure ( logical_abstract ), deferred , public :: source_is_external procedure ( real_abstract ), deferred , public :: get_press_min procedure ( real_abstract ), deferred , public :: get_press_max procedure ( real_abstract ), deferred , public :: get_temp_min procedure ( real_abstract ), deferred , public :: get_temp_max end type ! ! Interfaces for the methods to be implemented ! abstract interface !-------------------------------------------------------------------------------------------------------------------- ! ! Compute gas optical depth given temperature, pressure, and composition ! function gas_optics_ext_abstract ( this , & play , plev , tlay , gas_desc , & ! mandatory inputs optical_props , toa_src , & ! mandatory outputs col_dry ) result ( error_msg ) ! optional input import ty_gas_optics , wp , ty_gas_concs , ty_optical_props_arry class ( ty_gas_optics ), intent ( in ) :: this real ( wp ), dimension (:,:), intent ( in ) :: play , & ! layer pressures [Pa, mb]; (ncol,nlay) plev , & ! level pressures [Pa, mb]; (ncol,nlay+1) tlay ! layer temperatures [K]; (ncol,nlay) type ( ty_gas_concs ), intent ( in ) :: gas_desc ! Gas volume mixing ratios class ( ty_optical_props_arry ), & intent ( inout ) :: optical_props real ( wp ), dimension (:,:), intent ( out ) :: toa_src ! Incoming solar irradiance(ncol,ngpt) character ( len = 128 ) :: error_msg ! Optional inputs real ( wp ), dimension (:,:), intent ( in ), & optional , target :: col_dry ! Column dry amount; dim(ncol,nlay) end function gas_optics_ext_abstract !-------------------------------------------------------------------------------------------------------------------- ! ! Compute gas optical depth and Planck source functions, !  given temperature, pressure, and composition ! function gas_optics_int_abstract ( this , & play , plev , tlay , tsfc , gas_desc , & optical_props , sources , & col_dry , tlev ) result ( error_msg ) import ty_gas_optics , wp , ty_gas_concs , ty_optical_props_arry , ty_source_func_lw class ( ty_gas_optics ), intent ( in ) :: this real ( wp ), dimension (:,:), intent ( in ) :: play , & ! layer pressures [Pa, mb]; (ncol,nlay) plev , & ! level pressures [Pa, mb]; (ncol,nlay+1) tlay ! layer temperatures [K]; (ncol,nlay) real ( wp ), dimension (:), intent ( in ) :: tsfc ! surface skin temperatures [K]; (ncol) type ( ty_gas_concs ), intent ( in ) :: gas_desc ! Gas volume mixing ratios class ( ty_optical_props_arry ), & intent ( inout ) :: optical_props ! Optical properties class ( ty_source_func_lw ), & intent ( inout ) :: sources ! Planck sources character ( len = 128 ) :: error_msg real ( wp ), dimension (:,:), intent ( in ), & optional , target :: col_dry , & ! Column dry amount; dim(ncol,nlay) tlev ! level temperatures [K]l (ncol,nlay+1) end function gas_optics_int_abstract !-------------------------------------------------------------------------------------------------------------------- function logical_abstract ( this ) import ty_gas_optics class ( ty_gas_optics ), intent ( in ) :: this logical :: logical_abstract end function logical_abstract !-------------------------------------------------------------------------------------------------------------------- function real_abstract ( this ) import ty_gas_optics , wp class ( ty_gas_optics ), intent ( in ) :: this real ( wp ) :: real_abstract end function real_abstract !-------------------------------------------------------------------------------------------------------------------- end interface end module mo_gas_optics","tags":"","loc":"sourcefile/mo_gas_optics.f90.html"},{"title":"mo_gas_optics_rrtmgp.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_gas_optics_rrtmgp.f90~~EfferentGraph sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rrtmgp_util_string.f90 mo_rrtmgp_util_string.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_rrtmgp_constants.f90 mo_rrtmgp_constants.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_constants.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_util_reorder.f90 mo_rrtmgp_util_reorder.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_util_reorder.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rrtmgp_constants.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rrtmgp_util_reorder.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_gas_optics_rrtmgp Source Code mo_gas_optics_rrtmgp.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Class for computing spectrally-resolved gas optical properties and source functions !   given atmopsheric physical properties (profiles of temperature, pressure, and gas concentrations) !   The class must be initialized with data (provided as a netCDF file) before being used. ! ! Two variants apply to internal Planck sources (longwave radiation in the Earth's atmosphere) and to !   external stellar radiation (shortwave radiation in the Earth's atmosphere). !   The variant is chosen based on what information is supplied during initialization. !   (It might make more sense to define two sub-classes) ! ! ------------------------------------------------------------------------------------------------- module mo_gas_optics_rrtmgp use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_extents , check_values use mo_rte_util_array , only : zero_array , any_vals_less_than , any_vals_outside , extents_are use mo_optical_props , only : ty_optical_props use mo_source_functions , only : ty_source_func_lw use mo_gas_optics_kernels , only : interpolation , & compute_tau_absorption , compute_tau_rayleigh , compute_Planck_source use mo_rrtmgp_constants , only : avogad , m_dry , m_h2o , grav use mo_rrtmgp_util_string , only : lower_case , string_in_array , string_loc_in_array use mo_gas_concentrations , only : ty_gas_concs use mo_optical_props , only : ty_optical_props_arry , ty_optical_props_1scl , ty_optical_props_2str , ty_optical_props_nstr use mo_gas_optics , only : ty_gas_optics use mo_rrtmgp_util_reorder implicit none private real ( wp ), parameter :: pi = acos ( - 1._wp ) ! ------------------------------------------------------------------------------------------------- type , extends ( ty_gas_optics ), public :: ty_gas_optics_rrtmgp private ! ! RRTMGP computes absorption in each band arising from !   two major species in each band, which are combined to make !     a relative mixing ratio eta and a total column amount (col_mix) !   contributions from zero or more minor species whose concentrations !     may be scaled by other components of the atmosphere ! ! Absorption coefficients are interpolated from tables on a pressure/temperature/(eta) grid ! ! ------------------------------------ ! Interpolation variables: Temperature and pressure grids ! real ( wp ), dimension (:), allocatable :: press_ref , press_ref_log , temp_ref ! ! Derived and stored for convenience: !   Min and max for temperature and pressure intepolation grids !   difference in ln pressure between consecutive reference levels !   log of reference pressure separating the lower and upper atmosphere ! real ( wp ) :: press_ref_min , press_ref_max , & temp_ref_min , temp_ref_max real ( wp ) :: press_ref_log_delta , temp_ref_delta , press_ref_trop_log ! ------------------------------------ ! Major absorbers (\"key species\") !   Each unique set of major species is called a flavor. ! ! Names  and reference volume mixing ratios of major gases ! character ( 32 ), dimension (:), allocatable :: gas_names ! gas names real ( wp ), dimension (:,:,:), allocatable :: vmr_ref ! vmr_ref(lower or upper atmosphere, gas, temp) ! ! Which two gases are in each flavor? By index ! integer , dimension (:,:), allocatable :: flavor ! major species pair; (2,nflav) ! ! Which flavor for each g-point? One each for lower, upper atmosphere ! integer , dimension (:,:), allocatable :: gpoint_flavor ! flavor = gpoint_flavor(2, g-point) ! ! Major gas absorption coefficients ! real ( wp ), dimension (:,:,:,:), allocatable :: kmajor !  kmajor(g-point,eta,pressure,temperature) ! ! ------------------------------------ ! Minor species, independently for upper and lower atmospheres !   Array extents in the n_minor dimension will differ between upper and lower atmospheres !   Each contribution has starting and ending g-points ! integer , dimension (:,:), allocatable :: minor_limits_gpt_lower , & minor_limits_gpt_upper ! ! Minor gas contributions might be scaled by other gas amounts; if so we need to know !   the total density and whether the contribution is scaled by the partner gas !   or its complement (i.e. all other gases) ! Water vapor self- and foreign continua work like this, as do !   all collision-induced abosption pairs ! logical ( wl ), dimension (:), allocatable :: minor_scales_with_density_lower , & minor_scales_with_density_upper logical ( wl ), dimension (:), allocatable :: scale_by_complement_lower , scale_by_complement_upper integer , dimension (:), allocatable :: idx_minor_lower , idx_minor_upper integer , dimension (:), allocatable :: idx_minor_scaling_lower , idx_minor_scaling_upper ! ! Index into table of absorption coefficients ! integer , dimension (:), allocatable :: kminor_start_lower , kminor_start_upper ! ! The absorption coefficients themselves ! real ( wp ), dimension (:,:,:), allocatable :: kminor_lower , kminor_upper ! kminor_lower(n_minor,eta,temperature) ! ! ----------------------------------------------------------------------------------- ! ! Rayleigh scattering coefficients ! real ( wp ), dimension (:,:,:,:), allocatable :: krayl ! krayl(g-point,eta,temperature,upper/lower atmosphere) ! ! ----------------------------------------------------------------------------------- ! Planck function spectral mapping !   Allocated only when gas optics object is internal-source ! real ( wp ), dimension (:,:,:,:), allocatable :: planck_frac ! stored fraction of Planck irradiance in band for given g-point ! planck_frac(g-point, eta, pressure, temperature) real ( wp ), dimension (:,:), allocatable :: totplnk ! integrated Planck irradiance by band; (Planck temperatures,band) real ( wp ) :: totplnk_delta ! temperature steps in totplnk real ( wp ), dimension (:,:), allocatable :: optimal_angle_fit ! coefficients of linear function ! of vertical path clear-sky transmittance that is used to ! determine the secant of single angle used for the ! no-scattering calculation, ! optimal_angle_fit(coefficient, band) ! ----------------------------------------------------------------------------------- ! Solar source function spectral mapping with solar variability capability !   Allocated  when gas optics object is external-source !   n-solar-terms: quiet sun, facular brightening and sunspot dimming components !   following the NRLSSI2 model of Coddington et al. 2016, doi:10.1175/BAMS-D-14-00265.1. ! real ( wp ), dimension (:), allocatable :: solar_source ! incoming solar irradiance, computed from other three terms (g-point) real ( wp ), dimension (:), allocatable :: solar_source_quiet ! incoming solar irradiance, quiet sun term (g-point) real ( wp ), dimension (:), allocatable :: solar_source_facular ! incoming solar irradiance, facular term (g-point) real ( wp ), dimension (:), allocatable :: solar_source_sunspot ! incoming solar irradiance, sunspot term (g-point) ! ! ----------------------------------------------------------------------------------- ! Ancillary ! ----------------------------------------------------------------------------------- ! Index into %gas_names -- is this a key species in any band? logical , dimension (:), allocatable :: is_key ! ----------------------------------------------------------------------------------- contains ! Type-bound procedures ! Public procedures ! public interface generic , public :: load => load_int , load_ext procedure , public :: source_is_internal procedure , public :: source_is_external procedure , public :: get_ngas procedure , public :: get_gases procedure , public :: get_press_min procedure , public :: get_press_max procedure , public :: get_temp_min procedure , public :: get_temp_max procedure , public :: compute_optimal_angles procedure , public :: set_solar_variability procedure , public :: set_tsi ! Internal procedures procedure , private :: load_int procedure , private :: load_ext procedure , public :: gas_optics_int procedure , public :: gas_optics_ext procedure , private :: check_key_species_present ! Interpolation table dimensions procedure , private :: get_nflav procedure , private :: get_neta procedure , private :: get_npres procedure , private :: get_ntemp procedure , private :: get_nPlanckTemp end type ! ------------------------------------------------------------------------------------------------- ! ! col_dry is the number of molecules per cm-2 of dry air ! public :: get_col_dry ! Utility function, not type-bound contains ! -------------------------------------------------------------------------------------- ! ! Public procedures ! ! -------------------------------------------------------------------------------------- ! ! Two functions to define array sizes needed by gas_optics() ! pure function get_ngas ( this ) ! return the number of gases registered in the spectral configuration class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer :: get_ngas get_ngas = size ( this % gas_names ) end function get_ngas !-------------------------------------------------------------------------------------------------------------------- ! ! return the number of distinct major gas pairs in the spectral bands (referred to as ! \"flavors\" - all bands have a flavor even if there is one or no major gas) ! pure function get_nflav ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer :: get_nflav get_nflav = size ( this % flavor , dim = 2 ) end function get_nflav !-------------------------------------------------------------------------------------------------------------------- ! ! Compute gas optical depth and Planck source functions, !  given temperature, pressure, and composition ! function gas_optics_int ( this , & play , plev , tlay , tsfc , gas_desc , & optical_props , sources , & col_dry , tlev ) result ( error_msg ) ! inputs class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this real ( wp ), dimension (:,:), intent ( in ) :: play , & ! layer pressures [Pa, mb]; (ncol,nlay) plev , & ! level pressures [Pa, mb]; (ncol,nlay+1) tlay ! layer temperatures [K]; (ncol,nlay) real ( wp ), dimension (:), intent ( in ) :: tsfc ! surface skin temperatures [K]; (ncol) type ( ty_gas_concs ), intent ( in ) :: gas_desc ! Gas volume mixing ratios ! output class ( ty_optical_props_arry ), & intent ( inout ) :: optical_props ! Optical properties class ( ty_source_func_lw ), & intent ( inout ) :: sources ! Planck sources character ( len = 128 ) :: error_msg ! Optional inputs real ( wp ), dimension (:,:), intent ( in ), & optional , target :: col_dry , & ! Column dry amount; dim(ncol,nlay) tlev ! level temperatures [K]; (ncol,nlay+1) ! ---------------------------------------------------------- ! Local variables ! Interpolation coefficients for use in source function integer , dimension ( size ( play , dim = 1 ), size ( play , dim = 2 )) :: jtemp , jpress logical ( wl ), dimension ( size ( play , dim = 1 ), size ( play , dim = 2 )) :: tropo real ( wp ), dimension ( 2 , 2 , 2 , size ( play , dim = 1 ), size ( play , dim = 2 ), get_nflav ( this )) :: fmajor integer , dimension ( 2 , size ( play , dim = 1 ), size ( play , dim = 2 ), get_nflav ( this )) :: jeta integer :: ncol , nlay , ngpt , nband ! ---------------------------------------------------------- ncol = size ( play , dim = 1 ) nlay = size ( play , dim = 2 ) ngpt = this % get_ngpt () nband = this % get_nband () ! ! Gas optics ! !$acc enter data create(jtemp, jpress, tropo, fmajor, jeta) !$omp target enter data map(alloc:jtemp, jpress, tropo, fmajor, jeta) error_msg = compute_gas_taus ( this , & ncol , nlay , ngpt , nband , & play , plev , tlay , gas_desc , & optical_props , & jtemp , jpress , jeta , tropo , fmajor , & col_dry ) if ( error_msg /= '' ) return ! ---------------------------------------------------------- ! ! External source -- check arrays sizes and values ! input data sizes and values ! !$acc enter data copyin(tsfc, tlev) ! Should be fine even if tlev is not supplied !$omp target enter data map(to:tsfc, tlev) if ( check_extents ) then if (. not . extents_are ( tsfc , ncol )) & error_msg = \"gas_optics(): array tsfc has wrong size\" if ( present ( tlev )) then if (. not . extents_are ( tlev , ncol , nlay + 1 )) & error_msg = \"gas_optics(): array tlev has wrong size\" end if ! !   output extents ! if ( any ([ sources % get_ncol (), sources % get_nlay (), sources % get_ngpt ()] /= [ ncol , nlay , ngpt ])) & error_msg = \"gas_optics%gas_optics: source function arrays inconsistently sized\" end if if ( error_msg /= '' ) return if ( check_values ) then if ( any_vals_outside ( tsfc , this % temp_ref_min , this % temp_ref_max )) & error_msg = \"gas_optics(): array tsfc has values outside range\" if ( present ( tlev )) then if ( any_vals_outside ( tlev , this % temp_ref_min , this % temp_ref_max )) & error_msg = \"gas_optics(): array tlev has values outside range\" end if end if if ( error_msg /= '' ) return ! ! Interpolate source function ! if ( present ( tlev )) then ! ! present status of optional argument should be passed to source() !   but isn't with PGI 19.10 ! error_msg = source ( this , & ncol , nlay , nband , ngpt , & play , plev , tlay , tsfc , & jtemp , jpress , jeta , tropo , fmajor , & sources , & tlev ) !$acc exit data delete(tlev) !$omp target exit data map(release:tlev) else error_msg = source ( this , & ncol , nlay , nband , ngpt , & play , plev , tlay , tsfc , & jtemp , jpress , jeta , tropo , fmajor , & sources ) end if !$acc exit data delete(tsfc) !$omp target exit data map(release:tsfc) !$acc exit data delete(jtemp, jpress, tropo, fmajor, jeta) !$omp target exit data map(release:jtemp, jpress, tropo, fmajor, jeta) end function gas_optics_int !------------------------------------------------------------------------------------------ ! ! Compute gas optical depth given temperature, pressure, and composition ! function gas_optics_ext ( this , & play , plev , tlay , gas_desc , & ! mandatory inputs optical_props , toa_src , & ! mandatory outputs col_dry ) result ( error_msg ) ! optional input class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this real ( wp ), dimension (:,:), intent ( in ) :: play , & ! layer pressures [Pa, mb]; (ncol,nlay) plev , & ! level pressures [Pa, mb]; (ncol,nlay+1) tlay ! layer temperatures [K]; (ncol,nlay) type ( ty_gas_concs ), intent ( in ) :: gas_desc ! Gas volume mixing ratios ! output class ( ty_optical_props_arry ), & intent ( inout ) :: optical_props real ( wp ), dimension (:,:), intent ( out ) :: toa_src ! Incoming solar irradiance(ncol,ngpt) character ( len = 128 ) :: error_msg ! Optional inputs real ( wp ), dimension (:,:), intent ( in ), & optional , target :: col_dry ! Column dry amount; dim(ncol,nlay) ! ---------------------------------------------------------- ! Local variables ! Interpolation coefficients for use in source function integer , dimension ( size ( play , dim = 1 ), size ( play , dim = 2 )) :: jtemp , jpress logical ( wl ), dimension ( size ( play , dim = 1 ), size ( play , dim = 2 )) :: tropo real ( wp ), dimension ( 2 , 2 , 2 , size ( play , dim = 1 ), size ( play , dim = 2 ), get_nflav ( this )) :: fmajor integer , dimension ( 2 , size ( play , dim = 1 ), size ( play , dim = 2 ), get_nflav ( this )) :: jeta integer :: ncol , nlay , ngpt , nband , ngas , nflav integer :: igpt , icol ! ---------------------------------------------------------- ncol = size ( play , dim = 1 ) nlay = size ( play , dim = 2 ) ngpt = this % get_ngpt () nband = this % get_nband () ngas = this % get_ngas () nflav = get_nflav ( this ) ! ! Gas optics ! !$acc enter data create(jtemp, jpress, tropo, fmajor, jeta) !$omp target enter data map(alloc:jtemp, jpress, tropo, fmajor, jeta) error_msg = compute_gas_taus ( this , & ncol , nlay , ngpt , nband , & play , plev , tlay , gas_desc , & optical_props , & jtemp , jpress , jeta , tropo , fmajor , & col_dry ) !$acc exit data delete(jtemp, jpress, tropo, fmajor, jeta) !$omp target exit data map(release:jtemp, jpress, tropo, fmajor, jeta) if ( error_msg /= '' ) return ! ---------------------------------------------------------- ! ! External source function is constant ! !$acc enter data create(toa_src) !$omp target enter data map(alloc:toa_src) if ( check_extents ) then if (. not . extents_are ( toa_src , ncol , ngpt )) & error_msg = \"gas_optics(): array toa_src has wrong size\" end if if ( error_msg /= '' ) return !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol toa_src ( icol , igpt ) = this % solar_source ( igpt ) end do end do !$acc exit data copyout(toa_src) !$omp target exit data map(from:toa_src) end function gas_optics_ext !------------------------------------------------------------------------------------------ ! ! Returns optical properties and interpolation coefficients ! function compute_gas_taus ( this , & ncol , nlay , ngpt , nband , & play , plev , tlay , gas_desc , & optical_props , & jtemp , jpress , jeta , tropo , fmajor , & col_dry ) result ( error_msg ) class ( ty_gas_optics_rrtmgp ), & intent ( in ) :: this integer , intent ( in ) :: ncol , nlay , ngpt , nband real ( wp ), dimension (:,:), intent ( in ) :: play , & ! layer pressures [Pa, mb]; (ncol,nlay) plev , & ! level pressures [Pa, mb]; (ncol,nlay+1) tlay ! layer temperatures [K]; (ncol,nlay) type ( ty_gas_concs ), intent ( in ) :: gas_desc ! Gas volume mixing ratios class ( ty_optical_props_arry ), intent ( inout ) :: optical_props !inout because components are allocated ! Interpolation coefficients for use in internal source function integer , dimension ( ncol , nlay ), intent ( out ) :: jtemp , jpress integer , dimension ( 2 , ncol , nlay , get_nflav ( this )), intent ( out ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( out ) :: tropo real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , get_nflav ( this )), intent ( out ) :: fmajor character ( len = 128 ) :: error_msg ! Optional inputs real ( wp ), dimension (:,:), intent ( in ), & optional , target :: col_dry ! Column dry amount; dim(ncol,nlay) ! ---------------------------------------------------------- ! Local variables real ( wp ), dimension ( ncol , nlay , ngpt ) :: tau , tau_rayleigh ! absorption, Rayleigh scattering optical depths ! Number of molecules per cm&#94;2 real ( wp ), dimension ( ncol , nlay ), target :: col_dry_arr real ( wp ), dimension (:,:), pointer :: col_dry_wk ! ! Interpolation variables used in major gas but not elsewhere, so don't need exporting ! real ( wp ), dimension ( ncol , nlay , this % get_ngas ()) :: vmr ! volume mixing ratios real ( wp ), dimension ( ncol , nlay , 0 : this % get_ngas ()) :: col_gas ! column amounts for each gas, plus col_dry real ( wp ), dimension ( 2 , ncol , nlay , get_nflav ( this )) :: col_mix ! combination of major species's column amounts ! index(1) : reference temperature level ! index(2) : flavor ! index(3) : layer real ( wp ), dimension ( 2 , 2 , ncol , nlay , get_nflav ( this )) :: fminor ! interpolation fractions for minor species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference temperature level ! index(3) : flavor ! index(4) : layer integer :: ngas , nflav , neta , npres , ntemp integer :: icol , ilay , igas integer :: idx_h2o ! index of water vapor integer :: nminorlower , nminorklower , nminorupper , nminorkupper logical :: use_rayl ! ---------------------------------------------------------- ! ! Error checking ! use_rayl = allocated ( this % krayl ) error_msg = '' ! Check for initialization if (. not . this % is_initialized ()) then error_msg = 'ERROR: spectral configuration not loaded' return end if ! ! Check for presence of key species in ty_gas_concs; return error if any key species are not present ! error_msg = this % check_key_species_present ( gas_desc ) if ( error_msg /= '' ) return ! ! Check input data sizes and values ! !$acc        data copyin(play,plev,tlay) create(   vmr,col_gas) !$omp target data map(to:play,plev,tlay) map(alloc:vmr,col_gas) if ( check_extents ) then if (. not . extents_are ( play , ncol , nlay )) & error_msg = \"gas_optics(): array play has wrong size\" if (. not . extents_are ( tlay , ncol , nlay )) & error_msg = \"gas_optics(): array tlay has wrong size\" if (. not . extents_are ( plev , ncol , nlay + 1 )) & error_msg = \"gas_optics(): array plev has wrong size\" if ( optical_props % get_ncol () /= ncol . or . & optical_props % get_nlay () /= nlay . or . & optical_props % get_ngpt () /= ngpt ) & error_msg = \"gas_optics(): optical properties have the wrong extents\" if ( present ( col_dry )) then if (. not . extents_are ( col_dry , ncol , nlay )) & error_msg = \"gas_optics(): array col_dry has wrong size\" end if end if if ( error_msg == '' ) then if ( check_values ) then if ( any_vals_outside ( play , this % press_ref_min , this % press_ref_max )) & error_msg = \"gas_optics(): array play has values outside range\" if ( any_vals_less_than ( plev , 0._wp )) & error_msg = \"gas_optics(): array plev has values outside range\" if ( any_vals_outside ( tlay , this % temp_ref_min , this % temp_ref_max )) & error_msg = \"gas_optics(): array tlay has values outside range\" if ( present ( col_dry )) then if ( any_vals_less_than ( col_dry , 0._wp )) & error_msg = \"gas_optics(): array col_dry has values outside range\" end if end if end if ! ---------------------------------------------------------- if ( error_msg == '' ) then ngas = this % get_ngas () nflav = get_nflav ( this ) neta = this % get_neta () npres = this % get_npres () ntemp = this % get_ntemp () ! number of minor contributors, total num absorption coeffs nminorlower = size ( this % minor_scales_with_density_lower ) nminorklower = size ( this % kminor_lower , 3 ) nminorupper = size ( this % minor_scales_with_density_upper ) nminorkupper = size ( this % kminor_upper , 3 ) ! ! Fill out the array of volume mixing ratios ! do igas = 1 , ngas ! ! Get vmr if  gas is provided in ty_gas_concs ! if ( any ( lower_case ( this % gas_names ( igas )) == gas_desc % gas_name (:))) then error_msg = gas_desc % get_vmr ( this % gas_names ( igas ), vmr (:,:, igas )) endif end do end if if ( error_msg == '' ) then select type ( optical_props ) type is ( ty_optical_props_1scl ) !$acc        enter data copyin(optical_props) create(   optical_props%tau) !$omp target enter data                       map(alloc:optical_props%tau) type is ( ty_optical_props_2str ) !$acc        enter data copyin(optical_props) create(   optical_props%tau, optical_props%ssa, optical_props%g) !$omp target enter data                       map(alloc:optical_props%tau, optical_props%ssa, optical_props%g) type is ( ty_optical_props_nstr ) !$acc        enter data copyin(optical_props) create(   optical_props%tau, optical_props%ssa, optical_props%p) !$omp target enter data                       map(alloc:optical_props%tau, optical_props%ssa, optical_props%p) end select ! ! Compute dry air column amounts (number of molecule per cm&#94;2) if user hasn't provided them ! idx_h2o = string_loc_in_array ( 'h2o' , this % gas_names ) if ( present ( col_dry )) then !$acc        enter data copyin(col_dry) !$omp target enter data map(to:col_dry) col_dry_wk => col_dry else !$acc        enter data create(   col_dry_arr) !$omp target enter data map(alloc:col_dry_arr) col_dry_arr = get_col_dry ( vmr (:,:, idx_h2o ), plev ) ! dry air column amounts computation col_dry_wk => col_dry_arr end if ! ! compute column gas amounts [molec/cm&#94;2] ! !$acc parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol col_gas ( icol , ilay , 0 ) = col_dry_wk ( icol , ilay ) end do end do !$acc parallel loop gang vector collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igas = 1 , ngas do ilay = 1 , nlay do icol = 1 , ncol col_gas ( icol , ilay , igas ) = vmr ( icol , ilay , igas ) * col_dry_wk ( icol , ilay ) end do end do end do ! ! ---- calculate gas optical depths ---- ! !$acc        data copyout( jtemp, jpress, jeta, tropo, fmajor) create(   col_mix, fminor) !$omp target data map(from:jtemp, jpress, jeta, tropo, fmajor) map(alloc:col_mix, fminor) call interpolation ( & ncol , nlay , & ! problem dimensions ngas , nflav , neta , npres , ntemp , & ! interpolation dimensions this % flavor , & this % press_ref_log , & this % temp_ref , & this % press_ref_log_delta , & this % temp_ref_min , & this % temp_ref_delta , & this % press_ref_trop_log , & this % vmr_ref , & play , & tlay , & col_gas , & jtemp , & ! outputs fmajor , fminor ,& col_mix , & tropo , & jeta , jpress ) if ( allocated ( this % krayl )) then !$acc        data copyin(this%gpoint_flavor, this%krayl)    create(tau, tau_rayleigh) !$omp target data map(to:this%gpoint_flavor, this%krayl) map(alloc:tau, tau_rayleigh) call zero_array ( ngpt , nlay , ncol , tau ) call compute_tau_absorption ( & ncol , nlay , nband , ngpt , & ! dimensions ngas , nflav , neta , npres , ntemp , & nminorlower , nminorklower , & ! number of minor contributors, total num absorption coeffs nminorupper , nminorkupper , & idx_h2o , & this % gpoint_flavor , & this % get_band_lims_gpoint (), & this % kmajor , & this % kminor_lower , & this % kminor_upper , & this % minor_limits_gpt_lower , & this % minor_limits_gpt_upper , & this % minor_scales_with_density_lower , & this % minor_scales_with_density_upper , & this % scale_by_complement_lower , & this % scale_by_complement_upper , & this % idx_minor_lower , & this % idx_minor_upper , & this % idx_minor_scaling_lower , & this % idx_minor_scaling_upper , & this % kminor_start_lower , & this % kminor_start_upper , & tropo , & col_mix , fmajor , fminor , & play , tlay , col_gas , & jeta , jtemp , jpress , & tau ) call compute_tau_rayleigh ( & !Rayleigh scattering optical depths ncol , nlay , nband , ngpt , & ngas , nflav , neta , npres , ntemp , & ! dimensions this % gpoint_flavor , & this % get_band_lims_gpoint (), & this % krayl , & ! inputs from object idx_h2o , col_dry_wk , col_gas , & fminor , jeta , tropo , jtemp , & ! local input tau_rayleigh ) call combine_abs_and_rayleigh ( tau , tau_rayleigh , optical_props ) !$acc end        data !$omp end target data else call zero_array ( ngpt , nlay , ncol , optical_props % tau ) call compute_tau_absorption ( & ncol , nlay , nband , ngpt , & ! dimensions ngas , nflav , neta , npres , ntemp , & nminorlower , nminorklower , & ! number of minor contributors, total num absorption coeffs nminorupper , nminorkupper , & idx_h2o , & this % gpoint_flavor , & this % get_band_lims_gpoint (), & this % kmajor , & this % kminor_lower , & this % kminor_upper , & this % minor_limits_gpt_lower , & this % minor_limits_gpt_upper , & this % minor_scales_with_density_lower , & this % minor_scales_with_density_upper , & this % scale_by_complement_lower , & this % scale_by_complement_upper , & this % idx_minor_lower , & this % idx_minor_upper , & this % idx_minor_scaling_lower , & this % idx_minor_scaling_upper , & this % kminor_start_lower , & this % kminor_start_upper , & tropo , & col_mix , fmajor , fminor , & play , tlay , col_gas , & jeta , jtemp , jpress , & optical_props % tau ) ! select type ( optical_props ) type is ( ty_optical_props_2str ) call zero_array ( ncol , nlay , ngpt , optical_props % ssa ) call zero_array ( ncol , nlay , ngpt , optical_props % g ) type is ( ty_optical_props_nstr ) call zero_array ( ncol , nlay , ngpt , optical_props % ssa ) call zero_array ( optical_props % get_nmom (), & ncol , nlay , ngpt , optical_props % p ) end select end if !$acc end        data !$omp end target data end if !$acc end        data !$omp end target data !$acc        exit data delete(     col_dry_wk) !$omp target exit data map(release:col_dry_wk) select type ( optical_props ) type is ( ty_optical_props_1scl ) !$acc        exit data delete(optical_props) copyout( optical_props%tau) !$omp target exit data                       map(from:optical_props%tau) type is ( ty_optical_props_2str ) !$acc        exit data delete(optical_props) copyout( optical_props%tau, optical_props%ssa, optical_props%g) !$omp target exit data                       map(from:optical_props%tau, optical_props%ssa, optical_props%g) type is ( ty_optical_props_nstr ) !$acc        exit data delete(optical_props) copyout( optical_props%tau, optical_props%ssa, optical_props%p) !$omp target exit data                       map(from:optical_props%tau, optical_props%ssa, optical_props%p) end select end function compute_gas_taus !------------------------------------------------------------------------------------------ ! ! Compute the spectral solar source function adjusted to account for solar variability !   following the NRLSSI2 model of Coddington et al. 2016, doi:10.1175/BAMS-D-14-00265.1. ! as specified by the facular brightening (mg_index) and sunspot dimming (sb_index) ! indices provided as input. ! ! Users provide the NRLSSI2 facular (\"Bremen\") index and sunspot (\"SPOT67\") index. !   Changing either of these indicies will change the total solar irradiance (TSI) !   Code in extensions/mo_solar_variability may be used to compute the value of these !   indices through an average solar cycle ! Users may also specify the TSI, either alone or in conjunction with the facular and sunspot indices ! !------------------------------------------------------------------------------------------ function set_solar_variability ( this , & mg_index , sb_index , tsi ) & result ( error_msg ) ! ! Updates the spectral distribution and, optionally, !   the integrated value of the solar source function !   Modifying either index will change the total solar irradiance ! class ( ty_gas_optics_rrtmgp ), intent ( inout ) :: this ! real ( wp ), intent ( in ) :: mg_index , & ! facular brightening index (NRLSSI2 facular \"Bremen\" index) sb_index ! sunspot dimming index     (NRLSSI2 sunspot \"SPOT67\" index) real ( wp ), optional , intent ( in ) :: tsi ! total solar irradiance character ( len = 128 ) :: error_msg ! ---------------------------------------------------------- integer :: igpt real ( wp ), parameter :: a_offset = 0.1495954_wp real ( wp ), parameter :: b_offset = 0.00066696_wp ! ---------------------------------------------------------- error_msg = \"\" if ( mg_index < 0._wp ) error_msg = 'mg_index out of range' if ( sb_index < 0._wp ) error_msg = 'sb_index out of range' if ( error_msg /= \"\" ) return ! ! Calculate solar source function for provided facular and sunspot indices ! !$acc parallel loop !$omp target teams distribute parallel do simd do igpt = 1 , size ( this % solar_source_quiet ) this % solar_source ( igpt ) = this % solar_source_quiet ( igpt ) + & ( mg_index - a_offset ) * this % solar_source_facular ( igpt ) + & ( sb_index - b_offset ) * this % solar_source_sunspot ( igpt ) end do ! ! Scale solar source to input TSI value ! if ( present ( tsi )) error_msg = this % set_tsi ( tsi ) end function set_solar_variability !------------------------------------------------------------------------------------------ function set_tsi ( this , tsi ) result ( error_msg ) ! ! Scale the solar source function without changing the spectral distribution ! class ( ty_gas_optics_rrtmgp ), intent ( inout ) :: this real ( wp ), intent ( in ) :: tsi ! user-specified total solar irradiance; character ( len = 128 ) :: error_msg real ( wp ) :: norm ! ---------------------------------------------------------- error_msg = \"\" if ( tsi < 0._wp ) then error_msg = 'tsi out of range' else ! ! Scale the solar source function to the input tsi ! !$acc kernels !$omp target norm = 1._wp / sum ( this % solar_source (:)) this % solar_source (:) = this % solar_source (:) * tsi * norm !$acc end kernels !$omp end target end if end function set_tsi !------------------------------------------------------------------------------------------ ! ! Compute Planck source functions at layer centers and levels ! function source ( this , & ncol , nlay , nbnd , ngpt , & play , plev , tlay , tsfc , & jtemp , jpress , jeta , tropo , fmajor , & sources , & ! Planck sources tlev ) & ! optional input result ( error_msg ) ! inputs class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer , intent ( in ) :: ncol , nlay , nbnd , ngpt real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play ! layer pressures [Pa, mb] real ( wp ), dimension ( ncol , nlay + 1 ), intent ( in ) :: plev ! level pressures [Pa, mb] real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: tlay ! layer temperatures [K] real ( wp ), dimension ( ncol ), intent ( in ) :: tsfc ! surface skin temperatures [K] ! Interplation coefficients integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , get_nflav ( this )), & intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , get_nflav ( this )), & intent ( in ) :: jeta class ( ty_source_func_lw ), intent ( inout ) :: sources real ( wp ), dimension ( ncol , nlay + 1 ), intent ( in ), & optional , target :: tlev ! level temperatures [K] character ( len = 128 ) :: error_msg ! ---------------------------------------------------------- logical ( wl ) :: top_at_1 integer :: icol , ilay , igpt ! Variables for temperature at layer edges [K] (ncol, nlay+1) real ( wp ), dimension ( ncol , nlay + 1 ), target :: tlev_arr real ( wp ), dimension (:,:), pointer :: tlev_wk ! ---------------------------------------------------------- error_msg = \"\" ! ! Source function needs temperature at interfaces/levels and at layer centers ! if ( present ( tlev )) then !   Users might have provided these tlev_wk => tlev else tlev_wk => tlev_arr ! ! Interpolate temperature to levels if not provided !   Interpolation and extrapolation at boundaries is weighted by pressure ! do icol = 1 , ncol tlev_arr ( icol , 1 ) = tlay ( icol , 1 ) & + ( plev ( icol , 1 ) - play ( icol , 1 )) * ( tlay ( icol , 2 ) - tlay ( icol , 1 )) & & / ( play ( icol , 2 ) - play ( icol , 1 )) end do do ilay = 2 , nlay do icol = 1 , ncol tlev_arr ( icol , ilay ) = ( play ( icol , ilay - 1 ) * tlay ( icol , ilay - 1 ) * ( plev ( icol , ilay ) - play ( icol , ilay )) & + play ( icol , ilay ) * tlay ( icol , ilay ) * ( play ( icol , ilay - 1 ) - plev ( icol , ilay ))) / & ( plev ( icol , ilay ) * ( play ( icol , ilay - 1 ) - play ( icol , ilay ))) end do end do do icol = 1 , ncol tlev_arr ( icol , nlay + 1 ) = tlay ( icol , nlay ) & + ( plev ( icol , nlay + 1 ) - play ( icol , nlay )) * ( tlay ( icol , nlay ) - tlay ( icol , nlay - 1 )) & / ( play ( icol , nlay ) - play ( icol , nlay - 1 )) end do end if !------------------------------------------------------------------- ! Compute internal (Planck) source functions at layers and levels, !  which depend on mapping from spectral space that creates k-distribution. !$acc        data copyin(sources) copyout( sources%lay_source, sources%lev_source_inc, sources%lev_source_dec) & !$acc                             copyout( sources%sfc_source, sources%sfc_source_Jac) !$omp target data                 map(from:sources%lay_source, sources%lev_source_inc, sources%lev_source_dec) & !$omp                             map(from:sources%sfc_source, sources%sfc_source_Jac) !$acc kernels copyout(top_at_1) !$omp target map(from:top_at_1) top_at_1 = play ( 1 , 1 ) < play ( 1 , nlay ) !$acc end kernels !$omp end target call compute_Planck_source ( ncol , nlay , nbnd , ngpt , & get_nflav ( this ), this % get_neta (), this % get_npres (), this % get_ntemp (), this % get_nPlanckTemp (), & tlay , tlev_wk , tsfc , merge ( nlay , 1 , top_at_1 ), & fmajor , jeta , tropo , jtemp , jpress , & this % get_gpoint_bands (), this % get_band_lims_gpoint (), this % planck_frac , this % temp_ref_min ,& this % totplnk_delta , this % totplnk , this % gpoint_flavor , & sources % sfc_source , sources % lay_source , sources % lev_source_inc , sources % lev_source_dec , & sources % sfc_source_Jac ) !$acc end        data !$omp end target data end function source !-------------------------------------------------------------------------------------------------------------------- ! ! Initialization ! !-------------------------------------------------------------------------------------------------------------------- ! Initialize object based on data read from netCDF file however the user desires. !  Rayleigh scattering tables may or may not be present; this is indicated with allocation status ! This interface is for the internal-sources object -- includes Plank functions and fractions ! function load_int ( this , available_gases , gas_names , key_species , & band2gpt , band_lims_wavenum , & press_ref , press_ref_trop , temp_ref , & temp_ref_p , temp_ref_t , vmr_ref , & kmajor , kminor_lower , kminor_upper , & gas_minor , identifier_minor , & minor_gases_lower , minor_gases_upper , & minor_limits_gpt_lower , minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scaling_gas_lower , scaling_gas_upper , & scale_by_complement_lower , & scale_by_complement_upper , & kminor_start_lower , & kminor_start_upper , & totplnk , planck_frac , & rayl_lower , rayl_upper , & optimal_angle_fit ) result ( err_message ) class ( ty_gas_optics_rrtmgp ), intent ( inout ) :: this class ( ty_gas_concs ), intent ( in ) :: available_gases ! Which gases does the host model have available? character ( len =* ), dimension (:), intent ( in ) :: gas_names integer , dimension (:,:,:), intent ( in ) :: key_species integer , dimension (:,:), intent ( in ) :: band2gpt real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wavenum real ( wp ), dimension (:), intent ( in ) :: press_ref , temp_ref real ( wp ), intent ( in ) :: press_ref_trop , temp_ref_p , temp_ref_t real ( wp ), dimension (:,:,:), intent ( in ) :: vmr_ref real ( wp ), dimension (:,:,:,:), intent ( in ) :: kmajor real ( wp ), dimension (:,:,:), intent ( in ) :: kminor_lower , kminor_upper real ( wp ), dimension (:,:), intent ( in ) :: totplnk real ( wp ), dimension (:,:,:,:), intent ( in ) :: planck_frac real ( wp ), dimension (:,:,:), intent ( in ), & allocatable :: rayl_lower , rayl_upper real ( wp ), dimension (:,:), intent ( in ) :: optimal_angle_fit character ( len =* ), dimension (:), intent ( in ) :: gas_minor , identifier_minor character ( len =* ), dimension (:), intent ( in ) :: minor_gases_lower , & minor_gases_upper integer , dimension (:,:), intent ( in ) :: minor_limits_gpt_lower , & minor_limits_gpt_upper logical ( wl ), dimension (:), intent ( in ) :: minor_scales_with_density_lower , & minor_scales_with_density_upper character ( len =* ), dimension (:), intent ( in ) :: scaling_gas_lower , & scaling_gas_upper logical ( wl ), dimension (:), intent ( in ) :: scale_by_complement_lower ,& scale_by_complement_upper integer , dimension (:), intent ( in ) :: kminor_start_lower ,& kminor_start_upper character ( len = 128 ) :: err_message ! ---- !$acc enter data copyin(this) err_message = init_abs_coeffs ( this , & available_gases , & gas_names , key_species , & band2gpt , band_lims_wavenum , & press_ref , temp_ref , & press_ref_trop , temp_ref_p , temp_ref_t , & vmr_ref , & kmajor , kminor_lower , kminor_upper , & gas_minor , identifier_minor ,& minor_gases_lower , minor_gases_upper , & minor_limits_gpt_lower , & minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scaling_gas_lower , scaling_gas_upper , & scale_by_complement_lower , & scale_by_complement_upper , & kminor_start_lower , & kminor_start_upper , & rayl_lower , rayl_upper ) ! Planck function tables ! allocate ( this % totplnk ( size ( totplnk , 1 ), size ( totplnk , 2 )), & this % planck_frac ( size ( planck_frac , 4 ), size ( planck_frac , 2 ), size ( planck_frac , 3 ), size ( planck_frac , 1 )), & this % optimal_angle_fit ( size ( optimal_angle_fit , 1 ), size ( optimal_angle_fit , 2 ))) this % totplnk = totplnk !    this%planck_frac = planck_frac this % planck_frac = RESHAPE ( planck_frac ,( / size ( planck_frac , 4 ), size ( planck_frac , 2 ), size ( planck_frac , 3 ), size ( planck_frac , 1 ) / ), ORDER = ( / 4 , 2 , 3 , 1 / )) this % optimal_angle_fit = optimal_angle_fit !$acc        enter data copyin(this%totplnk, this%planck_frac, this%optimal_angle_fit) !$omp target enter data map(to:this%totplnk, this%planck_frac, this%optimal_angle_fit) ! Temperature steps for Planck function interpolation !   Assumes that temperature minimum and max are the same for the absorption coefficient grid and the !   Planck grid and the Planck grid is equally spaced this % totplnk_delta = ( this % temp_ref_max - this % temp_ref_min ) / ( size ( this % totplnk , dim = 1 ) - 1 ) end function load_int !-------------------------------------------------------------------------------------------------------------------- ! ! Initialize object based on data read from netCDF file however the user desires. !  Rayleigh scattering tables may or may not be present; this is indicated with allocation status ! This interface is for the external-sources object -- includes TOA source function table ! function load_ext ( this , available_gases , gas_names , key_species , & band2gpt , band_lims_wavenum , & press_ref , press_ref_trop , temp_ref , & temp_ref_p , temp_ref_t , vmr_ref , & kmajor , kminor_lower , kminor_upper , & gas_minor , identifier_minor , & minor_gases_lower , minor_gases_upper , & minor_limits_gpt_lower , minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scaling_gas_lower , scaling_gas_upper , & scale_by_complement_lower , & scale_by_complement_upper , & kminor_start_lower , & kminor_start_upper , & solar_quiet , solar_facular , solar_sunspot , & tsi_default , mg_default , sb_default , & rayl_lower , rayl_upper ) result ( err_message ) class ( ty_gas_optics_rrtmgp ), intent ( inout ) :: this class ( ty_gas_concs ), intent ( in ) :: available_gases ! Which gases does the host model have available? character ( len =* ), & dimension (:), intent ( in ) :: gas_names integer , dimension (:,:,:), intent ( in ) :: key_species integer , dimension (:,:), intent ( in ) :: band2gpt real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wavenum real ( wp ), dimension (:), intent ( in ) :: press_ref , temp_ref real ( wp ), intent ( in ) :: press_ref_trop , temp_ref_p , temp_ref_t real ( wp ), dimension (:,:,:), intent ( in ) :: vmr_ref real ( wp ), dimension (:,:,:,:), intent ( in ) :: kmajor real ( wp ), dimension (:,:,:), intent ( in ) :: kminor_lower , kminor_upper character ( len =* ), dimension (:), & intent ( in ) :: gas_minor , & identifier_minor character ( len =* ), dimension (:), & intent ( in ) :: minor_gases_lower , & minor_gases_upper integer , dimension (:,:), intent ( in ) :: & minor_limits_gpt_lower , & minor_limits_gpt_upper logical ( wl ), dimension (:), intent ( in ) :: & minor_scales_with_density_lower , & minor_scales_with_density_upper character ( len =* ), dimension (:), intent ( in ) :: & scaling_gas_lower , & scaling_gas_upper logical ( wl ), dimension (:), intent ( in ) :: & scale_by_complement_lower , & scale_by_complement_upper integer , dimension (:), intent ( in ) :: & kminor_start_lower , & kminor_start_upper real ( wp ), dimension (:), intent ( in ) :: solar_quiet , & solar_facular , & solar_sunspot real ( wp ), intent ( in ) :: tsi_default , & mg_default , sb_default real ( wp ), dimension (:,:,:), intent ( in ), & allocatable :: rayl_lower , rayl_upper character ( len = 128 ) err_message integer :: ngpt ! ---- !$acc enter data copyin(this) err_message = init_abs_coeffs ( this , & available_gases , & gas_names , key_species , & band2gpt , band_lims_wavenum , & press_ref , temp_ref , & press_ref_trop , temp_ref_p , temp_ref_t , & vmr_ref , & kmajor , kminor_lower , kminor_upper , & gas_minor , identifier_minor , & minor_gases_lower , minor_gases_upper , & minor_limits_gpt_lower , & minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scaling_gas_lower , scaling_gas_upper , & scale_by_complement_lower , & scale_by_complement_upper , & kminor_start_lower , & kminor_start_upper , & rayl_lower , rayl_upper ) if ( err_message /= \"\" ) return ! ! Spectral solar irradiance terms init ! ngpt = size ( solar_quiet ) allocate ( this % solar_source_quiet ( ngpt ), this % solar_source_facular ( ngpt ), & this % solar_source_sunspot ( ngpt ), this % solar_source ( ngpt )) !$acc        enter data create(   this%solar_source_quiet, this%solar_source_facular, this%solar_source_sunspot, this%solar_source) !$omp target enter data map(alloc:this%solar_source_quiet, this%solar_source_facular, this%solar_source_sunspot, this%solar_source) !$acc kernels !$omp target this % solar_source_quiet = solar_quiet this % solar_source_facular = solar_facular this % solar_source_sunspot = solar_sunspot !$acc end kernels !$omp end target err_message = this % set_solar_variability ( mg_default , sb_default ) end function load_ext !-------------------------------------------------------------------------------------------------------------------- ! ! Initialize absorption coefficient arrays, !   including Rayleigh scattering tables if provided (allocated) ! function init_abs_coeffs ( this , & available_gases , & gas_names , key_species , & band2gpt , band_lims_wavenum , & press_ref , temp_ref , & press_ref_trop , temp_ref_p , temp_ref_t , & vmr_ref , & kmajor , kminor_lower , kminor_upper , & gas_minor , identifier_minor ,& minor_gases_lower , minor_gases_upper , & minor_limits_gpt_lower , & minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scaling_gas_lower , scaling_gas_upper , & scale_by_complement_lower , & scale_by_complement_upper , & kminor_start_lower , & kminor_start_upper , & rayl_lower , rayl_upper ) result ( err_message ) class ( ty_gas_optics_rrtmgp ), intent ( inout ) :: this class ( ty_gas_concs ), intent ( in ) :: available_gases character ( len =* ), & dimension (:), intent ( in ) :: gas_names integer , dimension (:,:,:), intent ( in ) :: key_species integer , dimension (:,:), intent ( in ) :: band2gpt real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wavenum real ( wp ), dimension (:), intent ( in ) :: press_ref , temp_ref real ( wp ), intent ( in ) :: press_ref_trop , temp_ref_p , temp_ref_t real ( wp ), dimension (:,:,:), intent ( in ) :: vmr_ref real ( wp ), dimension (:,:,:,:), intent ( in ) :: kmajor real ( wp ), dimension (:,:,:), intent ( in ) :: kminor_lower , kminor_upper real ( wp ), dimension (:,:,:), allocatable :: kminor_lower_t , kminor_upper_t character ( len =* ), dimension (:), & intent ( in ) :: gas_minor , & identifier_minor character ( len =* ), dimension (:), & intent ( in ) :: minor_gases_lower , & minor_gases_upper integer , dimension (:,:), intent ( in ) :: minor_limits_gpt_lower , & minor_limits_gpt_upper logical ( wl ), dimension (:), intent ( in ) :: minor_scales_with_density_lower , & minor_scales_with_density_upper character ( len =* ), dimension (:),& intent ( in ) :: scaling_gas_lower , & scaling_gas_upper logical ( wl ), dimension (:), intent ( in ) :: scale_by_complement_lower , & scale_by_complement_upper integer , dimension (:), intent ( in ) :: kminor_start_lower , & kminor_start_upper real ( wp ), dimension (:,:,:), intent ( in ), & allocatable :: rayl_lower , rayl_upper character ( len = 128 ) :: err_message ! -------------------------------------------------------------------------- logical , dimension (:), allocatable :: gas_is_present logical , dimension (:), allocatable :: key_species_present_init integer , dimension (:,:,:), allocatable :: key_species_red real ( wp ), dimension (:,:,:), allocatable :: vmr_ref_red character ( len = 256 ), & dimension (:), allocatable :: minor_gases_lower_red , & minor_gases_upper_red character ( len = 256 ), & dimension (:), allocatable :: scaling_gas_lower_red , & scaling_gas_upper_red integer :: i , j , idx integer :: ngas ! -------------------------------------- err_message = this % ty_optical_props % init ( band_lims_wavenum , band2gpt ) if ( len_trim ( err_message ) /= 0 ) return ! ! Which gases known to the gas optics are present in the host model (available_gases)? ! ngas = size ( gas_names ) allocate ( gas_is_present ( ngas )) do i = 1 , ngas gas_is_present ( i ) = string_in_array ( gas_names ( i ), available_gases % gas_name ) end do ! ! Now the number of gases is the union of those known to the k-distribution and provided !   by the host model ! ngas = count ( gas_is_present ) ! ! Initialize the gas optics object, keeping only those gases known to the !   gas optics and also present in the host model ! this % gas_names = pack ( gas_names , mask = gas_is_present ) ! Copy-ins below allocate ( vmr_ref_red ( size ( vmr_ref , dim = 1 ), 0 : ngas , & size ( vmr_ref , dim = 3 ))) ! Gas 0 is used in single-key species method, set to 1.0 (col_dry) vmr_ref_red (:, 0 ,:) = vmr_ref (:, 1 ,:) do i = 1 , ngas idx = string_loc_in_array ( this % gas_names ( i ), gas_names ) vmr_ref_red (:, i ,:) = vmr_ref (:, idx + 1 ,:) enddo call move_alloc ( vmr_ref_red , this % vmr_ref ) !$acc        enter data copyin(this%vmr_ref, this%gas_names) !$omp target enter data map(to:this%vmr_ref, this%gas_names) ! ! Reduce minor arrays so variables only contain minor gases that are available ! Reduce size of minor Arrays ! call reduce_minor_arrays ( available_gases , & gas_names , & gas_minor , identifier_minor , & kminor_lower , & minor_gases_lower , & minor_limits_gpt_lower , & minor_scales_with_density_lower , & scaling_gas_lower , & scale_by_complement_lower , & kminor_start_lower , & this % kminor_lower , & minor_gases_lower_red , & this % minor_limits_gpt_lower , & this % minor_scales_with_density_lower , & scaling_gas_lower_red , & this % scale_by_complement_lower , & this % kminor_start_lower ) call reduce_minor_arrays ( available_gases , & gas_names , & gas_minor , identifier_minor ,& kminor_upper , & minor_gases_upper , & minor_limits_gpt_upper , & minor_scales_with_density_upper , & scaling_gas_upper , & scale_by_complement_upper , & kminor_start_upper , & this % kminor_upper , & minor_gases_upper_red , & this % minor_limits_gpt_upper , & this % minor_scales_with_density_upper , & scaling_gas_upper_red , & this % scale_by_complement_upper , & this % kminor_start_upper ) !$acc        enter data copyin(this%minor_limits_gpt_lower, this%minor_limits_gpt_upper) !$omp target enter data map(to:this%minor_limits_gpt_lower, this%minor_limits_gpt_upper) !$acc        enter data copyin(this%minor_scales_with_density_lower, this%minor_scales_with_density_upper) !$omp target enter data map(to:this%minor_scales_with_density_lower, this%minor_scales_with_density_upper) !$acc        enter data copyin(this%scale_by_complement_lower, this%scale_by_complement_upper) !$omp target enter data map(to:this%scale_by_complement_lower, this%scale_by_complement_upper) !$acc        enter data copyin(this%kminor_start_lower, this%kminor_start_upper) !$omp target enter data map(to:this%kminor_start_lower, this%kminor_start_upper) !$acc        enter data copyin(this%kminor_lower, this%kminor_upper) !$omp target enter data map(to:this%kminor_lower, this%kminor_upper) ! Arrays not reduced by the presence, or lack thereof, of a gas allocate ( this % press_ref ( size ( press_ref )), this % temp_ref ( size ( temp_ref )), & this % kmajor ( size ( kmajor , 4 ), size ( kmajor , 2 ), size ( kmajor , 3 ), size ( kmajor , 1 ))) this % press_ref (:) = press_ref (:) this % temp_ref (:) = temp_ref (:) this % kmajor = RESHAPE ( kmajor ,( / size ( kmajor , 4 ), size ( kmajor , 2 ), size ( kmajor , 3 ), size ( kmajor , 1 ) / ), ORDER = ( / 4 , 2 , 3 , 1 / )) !$acc        enter data copyin(this%press_ref, this%temp_ref, this%kmajor) !$omp target enter data map(to:this%press_ref, this%temp_ref, this%kmajor) if ( allocated ( rayl_lower ) . neqv . allocated ( rayl_upper )) then err_message = \"rayl_lower and rayl_upper must have the same allocation status\" return end if if ( allocated ( rayl_lower )) then allocate ( this % krayl ( size ( rayl_lower , dim = 3 ), size ( rayl_lower , dim = 2 ), size ( rayl_lower , dim = 1 ), 2 )) this % krayl (:,:,:, 1 ) = RESHAPE ( rayl_lower ,( / size ( rayl_lower , dim = 3 ), size ( rayl_lower , dim = 2 ), size ( rayl_lower , dim = 1 ) / ), ORDER = ( / 3 , 2 , 1 / )) this % krayl (:,:,:, 2 ) = RESHAPE ( rayl_upper ,( / size ( rayl_lower , dim = 3 ), size ( rayl_lower , dim = 2 ), size ( rayl_lower , dim = 1 ) / ), ORDER = ( / 3 , 2 , 1 / )) !$acc        enter data copyin(this%krayl) !$omp target enter data map(to:this%krayl) end if ! ---- post processing ---- ! creates log reference pressure allocate ( this % press_ref_log ( size ( this % press_ref ))) this % press_ref_log (:) = log ( this % press_ref (:)) !$acc        enter data copyin(this%press_ref_log) !$omp target enter data map(to:this%press_ref_log) ! log scale of reference pressure this % press_ref_trop_log = log ( press_ref_trop ) ! Get index of gas (if present) for determining col_gas call create_idx_minor ( this % gas_names , gas_minor , identifier_minor , minor_gases_lower_red , this % idx_minor_lower ) call create_idx_minor ( this % gas_names , gas_minor , identifier_minor , minor_gases_upper_red , this % idx_minor_upper ) ! Get index of gas (if present) that has special treatment in density scaling call create_idx_minor_scaling ( this % gas_names , scaling_gas_lower_red , this % idx_minor_scaling_lower ) call create_idx_minor_scaling ( this % gas_names , scaling_gas_upper_red , this % idx_minor_scaling_upper ) !$acc        enter data copyin(this%idx_minor_lower, this%idx_minor_upper) !$omp target enter data map(to:this%idx_minor_lower, this%idx_minor_upper) !$acc        enter data copyin(this%idx_minor_scaling_lower, this%idx_minor_scaling_upper) !$omp target enter data map(to:this%idx_minor_scaling_lower, this%idx_minor_scaling_upper) ! create flavor list ! Reduce (remap) key_species list; checks that all key gases are present in incoming call create_key_species_reduce ( gas_names , this % gas_names , & key_species , key_species_red , key_species_present_init ) err_message = check_key_species_present_init ( gas_names , key_species_present_init ) if ( len_trim ( err_message ) /= 0 ) return ! create flavor list call create_flavor ( key_species_red , this % flavor ) ! create gpoint_flavor list call create_gpoint_flavor ( key_species_red , this % get_gpoint_bands (), this % flavor , this % gpoint_flavor ) !Copy-ins at end of subroutine ! minimum, maximum reference temperature, pressure -- assumes low-to-high ordering !   for T, high-to-low ordering for p this % temp_ref_min = this % temp_ref ( 1 ) this % temp_ref_max = this % temp_ref ( size ( this % temp_ref )) this % press_ref_min = this % press_ref ( size ( this % press_ref )) this % press_ref_max = this % press_ref ( 1 ) ! creates press_ref_log, temp_ref_delta this % press_ref_log_delta = ( log ( this % press_ref_min ) - log ( this % press_ref_max )) / ( size ( this % press_ref ) - 1 ) this % temp_ref_delta = ( this % temp_ref_max - this % temp_ref_min ) / ( size ( this % temp_ref ) - 1 ) ! Which species are key in one or more bands? !   this%flavor is an index into this%gas_names ! if ( allocated ( this % is_key )) deallocate ( this % is_key ) ! Shouldn't ever happen... allocate ( this % is_key ( this % get_ngas ())) this % is_key (:) = . False . do j = 1 , size ( this % flavor , 2 ) do i = 1 , size ( this % flavor , 1 ) ! extents should be 2 if ( this % flavor ( i , j ) /= 0 ) this % is_key ( this % flavor ( i , j )) = . true . end do end do !$acc        enter data copyin(this%flavor, this%gpoint_flavor, this%is_key) !$omp target enter data map(to:this%flavor, this%gpoint_flavor, this%is_key) end function init_abs_coeffs ! ---------------------------------------------------------------------------------------------------- function check_key_species_present_init ( gas_names , key_species_present_init ) result ( err_message ) logical , dimension (:), intent ( in ) :: key_species_present_init character ( len =* ), dimension (:), intent ( in ) :: gas_names character ( len = 128 ) :: err_message integer :: i err_message = '' do i = 1 , size ( key_species_present_init ) if (. not . key_species_present_init ( i )) & err_message = ' ' // trim ( gas_names ( i )) // trim ( err_message ) end do if ( len_trim ( err_message ) > 0 ) err_message = \"gas_optics: required gases\" // trim ( err_message ) // \" are not provided\" end function check_key_species_present_init !------------------------------------------------------------------------------------------ ! ! Ensure that every key gas required by the k-distribution is !    present in the gas concentration object ! function check_key_species_present ( this , gas_desc ) result ( error_msg ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this class ( ty_gas_concs ), intent ( in ) :: gas_desc character ( len = 128 ) :: error_msg ! Local variables character ( len = 32 ), dimension ( count ( this % is_key (:) )) :: key_gas_names integer :: igas ! -------------------------------------- error_msg = \"\" key_gas_names = pack ( this % gas_names , mask = this % is_key ) do igas = 1 , size ( key_gas_names ) if (. not . string_in_array ( key_gas_names ( igas ), gas_desc % gas_name )) & error_msg = ' ' // trim ( lower_case ( key_gas_names ( igas ))) // trim ( error_msg ) end do if ( len_trim ( error_msg ) > 0 ) error_msg = \"gas_optics: required gases\" // trim ( error_msg ) // \" are not provided\" end function check_key_species_present !-------------------------------------------------------------------------------------------------------------------- ! ! Inquiry functions ! !-------------------------------------------------------------------------------------------------------------------- ! ! return true if initialized for internal sources, false otherwise ! pure function source_is_internal ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this logical :: source_is_internal source_is_internal = allocated ( this % totplnk ) . and . allocated ( this % planck_frac ) end function source_is_internal !-------------------------------------------------------------------------------------------------------------------- ! ! return true if initialized for external sources, false otherwise ! pure function source_is_external ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this logical :: source_is_external source_is_external = allocated ( this % solar_source ) end function source_is_external !-------------------------------------------------------------------------------------------------------------------- ! ! return the gas names ! pure function get_gases ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this character ( 32 ), dimension ( get_ngas ( this )) :: get_gases get_gases = this % gas_names end function get_gases !-------------------------------------------------------------------------------------------------------------------- ! ! return the minimum pressure on the interpolation grids ! pure function get_press_min ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this real ( wp ) :: get_press_min get_press_min = this % press_ref_min end function get_press_min !-------------------------------------------------------------------------------------------------------------------- ! ! return the maximum pressure on the interpolation grids ! pure function get_press_max ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this real ( wp ) :: get_press_max get_press_max = this % press_ref_max end function get_press_max !-------------------------------------------------------------------------------------------------------------------- ! ! return the minimum temparature on the interpolation grids ! pure function get_temp_min ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this real ( wp ) :: get_temp_min get_temp_min = this % temp_ref_min end function get_temp_min !-------------------------------------------------------------------------------------------------------------------- ! ! return the maximum temparature on the interpolation grids ! pure function get_temp_max ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this real ( wp ) :: get_temp_max get_temp_max = this % temp_ref_max end function get_temp_max !-------------------------------------------------------------------------------------------------------------------- ! ! Utility function, provided for user convenience ! computes column amounts of dry air using hydrostatic equation ! function get_col_dry ( vmr_h2o , plev , latitude ) result ( col_dry ) ! input real ( wp ), dimension (:,:), intent ( in ) :: vmr_h2o ! volume mixing ratio of water vapor to dry air; (ncol,nlay) real ( wp ), dimension (:,:), intent ( in ) :: plev ! Layer boundary pressures [Pa] (ncol,nlay+1) real ( wp ), dimension (:), optional , & intent ( in ) :: latitude ! Latitude [degrees] (ncol) ! output real ( wp ), dimension ( size ( plev , dim = 1 ), size ( plev , dim = 2 ) - 1 ) :: col_dry ! Column dry amount (ncol,nlay) ! ------------------------------------------------ ! first and second term of Helmert formula real ( wp ), parameter :: helmert1 = 9.80665_wp real ( wp ), parameter :: helmert2 = 0.02586_wp ! local variables real ( wp ), dimension ( size ( plev , dim = 1 )) :: g0 ! (ncol) real ( wp ) :: delta_plev , m_air , fact integer :: ncol , nlev integer :: icol , ilev ! nlay = nlev-1 ! ------------------------------------------------ ncol = size ( plev , dim = 1 ) nlev = size ( plev , dim = 2 ) !$acc        data    create(g0) !$omp target data map(alloc:g0) if ( present ( latitude )) then ! A purely OpenACC implementation would probably compute g0 within the kernel below !$acc parallel loop !$omp target teams distribute parallel do simd do icol = 1 , ncol g0 ( icol ) = helmert1 - helmert2 * cos ( 2.0_wp * pi * latitude ( icol ) / 18 0.0_wp ) ! acceleration due to gravity [m/s&#94;2] end do else !$acc parallel loop !$omp target teams distribute parallel do simd do icol = 1 , ncol g0 ( icol ) = grav end do end if !$acc                parallel loop gang vector collapse(2) copyin(plev,vmr_h2o)  copyout(col_dry) !$omp target teams distribute parallel do simd collapse(2) map(to:plev,vmr_h2o) map(from:col_dry) do ilev = 1 , nlev - 1 do icol = 1 , ncol delta_plev = abs ( plev ( icol , ilev ) - plev ( icol , ilev + 1 )) ! Get average mass of moist air per mole of moist air fact = 1._wp / ( 1. + vmr_h2o ( icol , ilev )) m_air = ( m_dry + m_h2o * vmr_h2o ( icol , ilev )) * fact col_dry ( icol , ilev ) = 1 0._wp * delta_plev * avogad * fact / ( 100 0._wp * m_air * 10 0._wp * g0 ( icol )) end do end do !$acc end        data !$omp end target data end function get_col_dry !-------------------------------------------------------------------------------------------------------------------- ! ! Compute a transport angle that minimizes flux errors at surface and TOA based on empirical fits ! function compute_optimal_angles ( this , optical_props , optimal_angles ) result ( err_msg ) ! input class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this class ( ty_optical_props_arry ), intent ( in ) :: optical_props real ( wp ), dimension (:,:), intent ( out ) :: optimal_angles character ( len = 128 ) :: err_msg !---------------------------- integer :: ncol , nlay , ngpt integer :: icol , ilay , igpt , bnd real ( wp ) :: t , trans_total !---------------------------- ncol = optical_props % get_ncol () nlay = optical_props % get_nlay () ngpt = optical_props % get_ngpt () err_msg = \"\" if (. not . this % gpoints_are_equal ( optical_props )) & err_msg = \"gas_optics%compute_optimal_angles: optical_props has different spectral discretization than gas_optics\" if (. not . extents_are ( optimal_angles , ncol , ngpt )) & err_msg = \"gas_optics%compute_optimal_angles: optimal_angles different dimension (ncol)\" if ( err_msg /= \"\" ) return ! ! column transmissivity ! !$acc                parallel loop gang vector collapse(2) copyin(optical_props, optical_props%tau, optical_props%gpt2band) copyout(optimal_angles) !$omp target teams distribute parallel do simd collapse(2) map(to:optical_props%tau, optical_props%gpt2band) map(from:optimal_angles) do icol = 1 , ncol do igpt = 1 , ngpt ! ! Column transmissivity ! t = 0._wp trans_total = 0._wp do ilay = 1 , nlay t = t + optical_props % tau ( icol , ilay , igpt ) end do trans_total = exp ( - t ) ! ! Optimal transport angle is a linear fit to column transmissivity ! bnd = optical_props % gpt2band ( igpt ) optimal_angles ( icol , igpt ) = this % optimal_angle_fit ( 1 , bnd ) * trans_total + & this % optimal_angle_fit ( 2 , bnd ) end do end do end function compute_optimal_angles !-------------------------------------------------------------------------------------------------------------------- ! ! Internal procedures ! !-------------------------------------------------------------------------------------------------------------------- pure function rewrite_key_species_pair ( key_species_pair ) ! (0,0) becomes (2,2) -- because absorption coefficients for these g-points will be 0. integer , dimension ( 2 ) :: rewrite_key_species_pair integer , dimension ( 2 ), intent ( in ) :: key_species_pair rewrite_key_species_pair = key_species_pair if ( all ( key_species_pair (:). eq .( / 0 , 0 / ))) then rewrite_key_species_pair (:) = ( / 2 , 2 / ) end if end function ! --------------------------------------------------------------------------------------- ! true is key_species_pair exists in key_species_list pure function key_species_pair_exists ( key_species_list , key_species_pair ) logical :: key_species_pair_exists integer , dimension (:,:), intent ( in ) :: key_species_list integer , dimension ( 2 ), intent ( in ) :: key_species_pair integer :: i do i = 1 , size ( key_species_list , dim = 2 ) if ( all ( key_species_list (:, i ). eq . key_species_pair (:))) then key_species_pair_exists = . true . return end if end do key_species_pair_exists = . false . end function key_species_pair_exists ! --------------------------------------------------------------------------------------- ! create flavor list -- !   an unordered array of extent (2,:) containing all possible pairs of key species !   used in either upper or lower atmos ! subroutine create_flavor ( key_species , flavor ) integer , dimension (:,:,:), intent ( in ) :: key_species integer , dimension (:,:), allocatable , intent ( out ) :: flavor integer , dimension ( 2 , size ( key_species , 3 ) * 2 ) :: key_species_list integer :: ibnd , iatm , i , iflavor ! prepare list of key_species i = 1 do ibnd = 1 , size ( key_species , 3 ) ! bands do iatm = 1 , size ( key_species , 2 ) ! upper/lower atmosphere key_species_list (:, i ) = key_species (:, iatm , ibnd ) i = i + 1 end do end do ! rewrite single key_species pairs do i = 1 , size ( key_species_list , 2 ) key_species_list (:, i ) = rewrite_key_species_pair ( key_species_list (:, i )) end do ! count unique key species pairs iflavor = 0 do i = 1 , size ( key_species_list , 2 ) if (. not . key_species_pair_exists ( key_species_list (:, 1 : i - 1 ), key_species_list (:, i ))) then iflavor = iflavor + 1 end if end do ! fill flavors allocate ( flavor ( 2 , iflavor )) iflavor = 0 do i = 1 , size ( key_species_list , 2 ) if (. not . key_species_pair_exists ( key_species_list (:, 1 : i - 1 ), key_species_list (:, i ))) then iflavor = iflavor + 1 flavor (:, iflavor ) = key_species_list (:, i ) end if end do end subroutine create_flavor ! --------------------------------------------------------------------------------------- ! ! create index list for extracting col_gas needed for minor gas optical depth calculations ! subroutine create_idx_minor ( gas_names , & gas_minor , identifier_minor , minor_gases_atm , idx_minor_atm ) character ( len =* ), dimension (:), intent ( in ) :: gas_names character ( len =* ), dimension (:), intent ( in ) :: & gas_minor , & identifier_minor character ( len =* ), dimension (:), intent ( in ) :: minor_gases_atm integer , dimension (:), allocatable , & intent ( out ) :: idx_minor_atm ! local integer :: imnr integer :: idx_mnr allocate ( idx_minor_atm ( size ( minor_gases_atm , dim = 1 ))) do imnr = 1 , size ( minor_gases_atm , dim = 1 ) ! loop over minor absorbers in each band ! Find identifying string for minor species in list of possible identifiers (e.g. h2o_slf) idx_mnr = string_loc_in_array ( minor_gases_atm ( imnr ), identifier_minor ) ! Find name of gas associated with minor species identifier (e.g. h2o) idx_minor_atm ( imnr ) = string_loc_in_array ( gas_minor ( idx_mnr ), gas_names ) enddo end subroutine create_idx_minor ! --------------------------------------------------------------------------------------- ! ! create index for special treatment in density scaling of minor gases ! subroutine create_idx_minor_scaling ( gas_names , & scaling_gas_atm , idx_minor_scaling_atm ) character ( len =* ), dimension (:), intent ( in ) :: gas_names character ( len =* ), dimension (:), intent ( in ) :: scaling_gas_atm integer , dimension (:), allocatable , & intent ( out ) :: idx_minor_scaling_atm ! local integer :: imnr allocate ( idx_minor_scaling_atm ( size ( scaling_gas_atm , dim = 1 ))) do imnr = 1 , size ( scaling_gas_atm , dim = 1 ) ! loop over minor absorbers in each band ! This will be -1 if there's no interacting gas idx_minor_scaling_atm ( imnr ) = string_loc_in_array ( scaling_gas_atm ( imnr ), gas_names ) enddo end subroutine create_idx_minor_scaling ! --------------------------------------------------------------------------------------- subroutine create_key_species_reduce ( gas_names , gas_names_red , & key_species , key_species_red , key_species_present_init ) character ( len =* ), & dimension (:), intent ( in ) :: gas_names character ( len =* ), & dimension (:), intent ( in ) :: gas_names_red integer , dimension (:,:,:), intent ( in ) :: key_species integer , dimension (:,:,:), allocatable , intent ( out ) :: key_species_red logical , dimension (:), allocatable , intent ( out ) :: key_species_present_init integer :: ip , ia , it , np , na , nt np = size ( key_species , dim = 1 ) na = size ( key_species , dim = 2 ) nt = size ( key_species , dim = 3 ) allocate ( key_species_red ( size ( key_species , dim = 1 ), & size ( key_species , dim = 2 ), & size ( key_species , dim = 3 ))) allocate ( key_species_present_init ( size ( gas_names ))) key_species_present_init = . true . do ip = 1 , np do ia = 1 , na do it = 1 , nt if ( key_species ( ip , ia , it ) . ne . 0 ) then key_species_red ( ip , ia , it ) = string_loc_in_array ( gas_names ( key_species ( ip , ia , it )), gas_names_red ) if ( key_species_red ( ip , ia , it ) . eq . - 1 ) key_species_present_init ( key_species ( ip , ia , it )) = . false . else key_species_red ( ip , ia , it ) = key_species ( ip , ia , it ) endif enddo end do enddo end subroutine create_key_species_reduce ! --------------------------------------------------------------------------------------- subroutine reduce_minor_arrays ( available_gases , & gas_names , & gas_minor , identifier_minor ,& kminor_atm , & minor_gases_atm , & minor_limits_gpt_atm , & minor_scales_with_density_atm , & scaling_gas_atm , & scale_by_complement_atm , & kminor_start_atm , & kminor_atm_red , & minor_gases_atm_red , & minor_limits_gpt_atm_red , & minor_scales_with_density_atm_red , & scaling_gas_atm_red , & scale_by_complement_atm_red , & kminor_start_atm_red ) class ( ty_gas_concs ), intent ( in ) :: available_gases character ( len =* ), dimension (:), intent ( in ) :: gas_names real ( wp ), dimension (:,:,:), intent ( in ) :: kminor_atm character ( len =* ), dimension (:), intent ( in ) :: gas_minor , & identifier_minor character ( len =* ), dimension (:), intent ( in ) :: minor_gases_atm integer , dimension (:,:), intent ( in ) :: minor_limits_gpt_atm logical ( wl ), dimension (:), intent ( in ) :: minor_scales_with_density_atm character ( len =* ), dimension (:), intent ( in ) :: scaling_gas_atm logical ( wl ), dimension (:), intent ( in ) :: scale_by_complement_atm integer , dimension (:), intent ( in ) :: kminor_start_atm real ( wp ), dimension (:,:,:), allocatable , & intent ( out ) :: kminor_atm_red character ( len =* ), dimension (:), allocatable , & intent ( out ) :: minor_gases_atm_red integer , dimension (:,:), allocatable , & intent ( out ) :: minor_limits_gpt_atm_red logical ( wl ), dimension (:), allocatable , & intent ( out ) :: minor_scales_with_density_atm_red character ( len =* ), dimension (:), allocatable , & intent ( out ) :: scaling_gas_atm_red logical ( wl ), dimension (:), allocatable , intent ( out ) :: & scale_by_complement_atm_red integer , dimension (:), allocatable , intent ( out ) :: & kminor_start_atm_red ! Local variables integer :: i , j , ks integer :: idx_mnr , nm , tot_g , red_nm integer :: icnt , n_elim , ng logical , dimension (:), allocatable :: gas_is_present integer , dimension (:), allocatable :: indexes real ( wp ), dimension (:,:,:), allocatable :: kminor_atm_red_t nm = size ( minor_gases_atm ) tot_g = 0 allocate ( gas_is_present ( nm )) do i = 1 , size ( minor_gases_atm ) idx_mnr = string_loc_in_array ( minor_gases_atm ( i ), identifier_minor ) gas_is_present ( i ) = string_in_array ( gas_minor ( idx_mnr ), available_gases % gas_name ) if ( gas_is_present ( i )) then tot_g = tot_g + ( minor_limits_gpt_atm ( 2 , i ) - minor_limits_gpt_atm ( 1 , i ) + 1 ) endif enddo red_nm = count ( gas_is_present ) allocate ( minor_gases_atm_red ( red_nm ),& minor_scales_with_density_atm_red ( red_nm ), & scaling_gas_atm_red ( red_nm ), & scale_by_complement_atm_red ( red_nm ), & kminor_start_atm_red ( red_nm )) allocate ( minor_limits_gpt_atm_red ( 2 , red_nm )) allocate ( kminor_atm_red_t ( tot_g , size ( kminor_atm , 2 ), size ( kminor_atm , 3 ))) allocate ( kminor_atm_red ( size ( kminor_atm , 3 ), size ( kminor_atm , 2 ), tot_g )) if (( red_nm . eq . nm )) then ! Character data not allowed in OpenACC regions? minor_gases_atm_red = minor_gases_atm scaling_gas_atm_red = scaling_gas_atm kminor_atm_red_t = kminor_atm minor_limits_gpt_atm_red = minor_limits_gpt_atm minor_scales_with_density_atm_red = minor_scales_with_density_atm scale_by_complement_atm_red = scale_by_complement_atm kminor_start_atm_red = kminor_start_atm else allocate ( indexes ( red_nm )) ! Find the integer indexes for the gases that are present indexes = pack ([( i , i = 1 , size ( minor_gases_atm ))], mask = gas_is_present ) minor_gases_atm_red = minor_gases_atm ( indexes ) scaling_gas_atm_red = scaling_gas_atm ( indexes ) minor_scales_with_density_atm_red = & minor_scales_with_density_atm ( indexes ) scale_by_complement_atm_red = & scale_by_complement_atm ( indexes ) kminor_start_atm_red = kminor_start_atm ( indexes ) icnt = 0 n_elim = 0 do i = 1 , nm ng = minor_limits_gpt_atm ( 2 , i ) - minor_limits_gpt_atm ( 1 , i ) + 1 if ( gas_is_present ( i )) then icnt = icnt + 1 minor_limits_gpt_atm_red ( 1 : 2 , icnt ) = minor_limits_gpt_atm ( 1 : 2 , i ) kminor_start_atm_red ( icnt ) = kminor_start_atm ( i ) - n_elim ks = kminor_start_atm_red ( icnt ) do j = 1 , ng kminor_atm_red_t ( kminor_start_atm_red ( icnt ) + j - 1 ,:,:) = & kminor_atm ( kminor_start_atm ( i ) + j - 1 ,:,:) enddo else n_elim = n_elim + ng endif enddo endif kminor_atm_red = RESHAPE ( kminor_atm_red_t ,( / size ( kminor_atm_red_t , dim = 3 ), size ( kminor_atm_red_t , dim = 2 ), size ( kminor_atm_red_t , dim = 1 ) / ), ORDER = ( / 3 , 2 , 1 / )) deallocate ( kminor_atm_red_t ) end subroutine reduce_minor_arrays ! --------------------------------------------------------------------------------------- ! returns flavor index; -1 if not found pure function key_species_pair2flavor ( flavor , key_species_pair ) integer :: key_species_pair2flavor integer , dimension (:,:), intent ( in ) :: flavor integer , dimension ( 2 ), intent ( in ) :: key_species_pair integer :: iflav do iflav = 1 , size ( flavor , 2 ) if ( all ( key_species_pair (:). eq . flavor (:, iflav ))) then key_species_pair2flavor = iflav return end if end do key_species_pair2flavor = - 1 end function key_species_pair2flavor ! --------------------------------------------------------------------------------------- ! ! create gpoint_flavor list !   a map pointing from each g-point to the corresponding entry in the \"flavor list\" ! subroutine create_gpoint_flavor ( key_species , gpt2band , flavor , gpoint_flavor ) integer , dimension (:,:,:), intent ( in ) :: key_species integer , dimension (:), intent ( in ) :: gpt2band integer , dimension (:,:), intent ( in ) :: flavor integer , dimension (:,:), intent ( out ), allocatable :: gpoint_flavor integer :: ngpt , igpt , iatm ngpt = size ( gpt2band ) allocate ( gpoint_flavor ( 2 , ngpt )) do igpt = 1 , ngpt do iatm = 1 , 2 gpoint_flavor ( iatm , igpt ) = key_species_pair2flavor ( & flavor , & rewrite_key_species_pair ( key_species (:, iatm , gpt2band ( igpt ))) & ) end do end do end subroutine create_gpoint_flavor !-------------------------------------------------------------------------------------------------------------------- ! ! Utility function to combine optical depths from gas absorption and Rayleigh scattering !   (and reorder them for convenience, while we're at it) ! subroutine combine_abs_and_rayleigh ( tau , tau_rayleigh , optical_props ) real ( wp ), dimension (:,:,:), intent ( in ) :: tau real ( wp ), dimension (:,:,:), intent ( in ) :: tau_rayleigh class ( ty_optical_props_arry ), intent ( inout ) :: optical_props integer :: icol , ilay , igpt , ncol , nlay , ngpt , nmom real ( wp ) :: t ncol = size ( tau , 1 ) nlay = size ( tau , 2 ) ngpt = size ( tau , 3 ) select type ( optical_props ) type is ( ty_optical_props_1scl ) ! ! Extinction optical depth ! !$acc parallel loop gang vector                collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol optical_props % tau ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) + & tau_rayleigh ( icol , ilay , igpt ) end do end do end do ! ! asymmetry factor or phase function moments ! type is ( ty_optical_props_2str ) ! ! Extinction optical depth and single scattering albedo ! !$acc parallel loop gang vector                collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol t = tau ( icol , ilay , igpt ) + tau_rayleigh ( icol , ilay , igpt ) if ( t > 2._wp * tiny ( t )) then optical_props % ssa ( icol , ilay , igpt ) = tau_rayleigh ( icol , ilay , igpt ) / t else optical_props % ssa ( icol , ilay , igpt ) = 0._wp end if optical_props % tau ( icol , ilay , igpt ) = t end do end do end do call zero_array ( ncol , nlay , ngpt , optical_props % g ) type is ( ty_optical_props_nstr ) ! ! Extinction optical depth and single scattering albedo ! !$acc parallel loop gang vector                collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol t = tau ( icol , ilay , igpt ) + tau_rayleigh ( icol , ilay , igpt ) if ( t > 2._wp * tiny ( t )) then optical_props % ssa ( icol , ilay , igpt ) = tau_rayleigh ( icol , ilay , igpt ) / t else optical_props % ssa ( icol , ilay , igpt ) = 0._wp end if optical_props % tau ( icol , ilay , igpt ) = t end do end do end do nmom = size ( optical_props % p , 1 ) call zero_array ( nmom , ncol , nlay , ngpt , optical_props % p ) if ( nmom >= 2 ) then !$acc parallel loop gang vector                collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol optical_props % p ( 2 , icol , ilay , igpt ) = 0.1_wp end do end do end do end if end select end subroutine combine_abs_and_rayleigh !-------------------------------------------------------------------------------------------------------------------- ! Sizes of tables: pressure, temperate, eta (mixing fraction) !   Equivalent routines for the number of gases and flavors (get_ngas(), get_nflav()) are defined above because they're !   used in function defintions ! Table kmajor has dimensions (ngpt, neta, npres, ntemp) !-------------------------------------------------------------------------------------------------------------------- ! ! return extent of eta dimension ! pure function get_neta ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer :: get_neta get_neta = size ( this % kmajor , dim = 2 ) end function ! -------------------------------------------------------------------------------------- ! ! return the number of pressures in reference profile !   absorption coefficient table is one bigger since a pressure is repeated in upper/lower atmos ! pure function get_npres ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer :: get_npres get_npres = size ( this % kmajor , dim = 3 ) - 1 end function get_npres ! -------------------------------------------------------------------------------------- ! ! return the number of temperatures ! pure function get_ntemp ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer :: get_ntemp get_ntemp = size ( this % kmajor , dim = 1 ) end function get_ntemp ! -------------------------------------------------------------------------------------- ! ! return the number of temperatures for Planck function ! pure function get_nPlanckTemp ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer :: get_nPlanckTemp get_nPlanckTemp = size ( this % totplnk , dim = 1 ) ! dimensions are Planck-temperature, band end function get_nPlanckTemp end module mo_gas_optics_rrtmgp","tags":"","loc":"sourcefile/mo_gas_optics_rrtmgp.f90.html"},{"title":"mo_rrtmgp_constants.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rrtmgp_constants.f90~~EfferentGraph sourcefile~mo_rrtmgp_constants.f90 mo_rrtmgp_constants.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rrtmgp_constants.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rrtmgp_constants.f90~~AfferentGraph sourcefile~mo_rrtmgp_constants.f90 mo_rrtmgp_constants.F90 sourcefile~mo_heating_rates.f90 mo_heating_rates.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rrtmgp_constants.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rrtmgp_constants Source Code mo_rrtmgp_constants.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! Physical and mathematical constants used in gas optics calculation !   If the host model in which RRTGMP is embedded has defined these constants elsewhere !   the model definitions can be used instead by renaming. For example, ! use  mo_model_constants, only k_boltz => boltzman_k, ... !   where the syntax is local_name => original_name !   and all the local names need to be defined ! ! \"Constants\" specific to the earth's atmosphere should also be made consistent with the !   host model but may be changed in a call to init_constants(), normally at initialization ! ------------------------------------------------------------------------------------------------- module mo_rrtmgp_constants use mo_rte_kind , only : wp public ! ----------------------------------------- ! Physical constants, 2018 SI defintion of metric system !   doi:10.1088/1681-7575/aa950a (see also https://www.nist.gov/si-redefinition/meet-constants) ! Boltzmann constant [J/K] = [(kg m&#94;2)/(K s&#94;2)] real ( wp ), parameter :: k_boltz = 1.380649e-23_wp !  molecular weight of water [kg/mol] real ( wp ), parameter :: m_h2o = 0.018016_wp ! Avogadro's number [molec/mol] real ( wp ), parameter :: avogad = 6.02214076e23_wp ! Universal gas constant [J/(mol K)] real ( wp ), parameter :: R_univ_gconst = avogad * k_boltz ! ----------------------------------------- ! ! Constants specific to the earth's atmosphere -- changeable in init() because they !   might be different on e.g. other planets ! molecular weight of dry air [kg/mol] real ( wp ), protected :: m_dry = 0.028964_wp ! Gravity at Earth's surface [m/s2] real ( wp ), protected :: grav = 9.80665_wp ! Specific heat at constant pressure for dry air [J/(K kg)] real ( wp ), protected :: cp_dry = 100 4.64_wp contains ! ----------------------------------------- subroutine init_constants ( gravity , mol_weight_dry_air , heat_capacity_dry_air ) real ( wp ), optional , intent ( in ) :: gravity , mol_weight_dry_air , heat_capacity_dry_air if ( present ( gravity )) grav = gravity if ( present ( mol_weight_dry_air )) m_dry = mol_weight_dry_air if ( present ( heat_capacity_dry_air )) cp_dry = heat_capacity_dry_air end subroutine init_constants ! ----------------------------------------- end module mo_rrtmgp_constants","tags":"","loc":"sourcefile/mo_rrtmgp_constants.f90.html"},{"title":"mo_rte_config.F90 – rte-rrtmgp","text":"This code is part of RRTM for GCM Applications - Parallel (RRTMGP) Contacts: Robert Pincus and Eli Mlawer\nemail:  rrtmgp@aer.com Copyright 2020,  Atmospheric and Environmental Research and\nRegents of the University of Colorado.  All right reserved. Use and duplication is permitted under the terms of the\n   BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause This file depends on sourcefile~~mo_rte_config.f90~~EfferentGraph sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rte_config.f90~~AfferentGraph sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_heating_rates.f90 mo_heating_rates.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_cloud_optics.f90 mo_cloud_optics.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_cloud_sampling.f90 mo_cloud_sampling.F90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_optical_props.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_config Source Code mo_rte_config.F90 Source Code !! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) !! !! Contacts: Robert Pincus and Eli Mlawer !! email:  rrtmgp@aer.com !! !! Copyright 2020,  Atmospheric and Environmental Research and !! Regents of the University of Colorado.  All right reserved. !! !! Use and duplication is permitted under the terms of the !!    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause !> ------------------------------------------------------------------------------------------------- !> !> Control over input sanitization in Fortan front-end !>   Module variables can be changed only by calling one of the included subroutine !> !> ------------------------------------------------------------------------------------------------- module mo_rte_config use mo_rte_kind , only : wl implicit none private logical ( wl ), protected , public :: check_extents = . true . logical ( wl ), protected , public :: check_values = . true . interface rte_config_checks module procedure rte_config_checks_each , rte_config_checks_all end interface public :: rte_config_checks contains ! -------------------------------------------------------------- subroutine rte_config_checks_each ( extents , values ) logical ( wl ), intent ( in ) :: extents , values check_extents = extents check_values = values end subroutine rte_config_checks_each ! -------------------------------------------------------------- subroutine rte_config_checks_all ( do_checks ) logical ( wl ), intent ( in ) :: do_checks check_extents = do_checks check_values = do_checks end subroutine rte_config_checks_all ! -------------------------------------------------------------- end module mo_rte_config","tags":"","loc":"sourcefile/mo_rte_config.f90.html"},{"title":"mo_rte_kind.F90 – rte-rrtmgp","text":"Files dependent on this one sourcefile~~mo_rte_kind.f90~~AfferentGraph sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_cloud_optics.f90 mo_cloud_optics.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_cloud_sampling.f90 mo_cloud_sampling.F90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rrtmgp_util_reorder.f90 mo_rrtmgp_util_reorder.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_util_reorder.f90 sourcefile~mo_rrtmgp_constants.f90 mo_rrtmgp_constants.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_constants.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_solar_variability.f90 mo_solar_variability.F90 sourcefile~mo_solar_variability.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rrtmgp_util_reorder.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rrtmgp_constants.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_heating_rates.f90 mo_heating_rates.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rrtmgp_constants.f90 sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_kind Source Code mo_rte_kind.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! This module provides the Fortran KIND parameters for REAL and INTEGER variables. !   By default we use constant from the ISO C binding and use double precision for working. !   If the host model in which RRTGMP is embedded has defined these constants elsewhere !   the model definitions can be used instead by renaming. For example, ! use  mo_model_kind, only wp => dp, ... !   where the syntax is local_name => original_name !   and all the local names need to be defined module mo_rte_kind use , intrinsic :: iso_c_binding , only : c_float , c_double , c_long , c_int , c_bool implicit none public integer , parameter :: dp = c_double , sp = c_float , i8 = c_long , i4 = c_int ! ! Floating point working precision ! integer , parameter :: wp = dp ! ! Logical - for use with kernels ! ! Note that c_boolians don't work with PGI compiler currently ! #ifdef USE_CBOOL integer , parameter :: wl = c_bool #else integer , parameter :: wl = kind (. true .) #endif end module mo_rte_kind","tags":"","loc":"sourcefile/mo_rte_kind.f90.html"},{"title":"mo_fluxes.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_fluxes.f90~~EfferentGraph sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_fluxes.f90~~AfferentGraph sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_fluxes Source Code mo_fluxes.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Compute output quantities from RTE based on spectrally-resolved flux profiles !    This module contains an abstract class and a broadband implmentation that sums over all spectral points !    The abstract base class defines the routines that extenstions must implement: reduce() and are_desired() !    The intent is for users to extend it as required, using mo_flxues_broadband as an example ! ! ------------------------------------------------------------------------------------------------- module mo_fluxes use mo_rte_kind , only : wp use mo_rte_config , only : check_extents use mo_rte_util_array , only : extents_are use mo_optical_props , only : ty_optical_props use mo_fluxes_broadband_kernels , & only : sum_broadband , net_broadband implicit none private ! ----------------------------------------------------------------------------------------------- ! ! Abstract base class !   reduce() function accepts spectral flux profiles, computes desired outputs !   are_desired() returns a logical - does it makes sense to invoke reduce()? ! ! ----------------------------------------------------------------------------------------------- type , abstract , public :: ty_fluxes contains procedure ( reduce_abstract ), deferred , public :: reduce procedure ( are_desired_abstract ), deferred , public :: are_desired end type ty_fluxes ! ----------------------------------------------------------------------------------------------- ! ! Class implementing broadband integration for the complete flux profile !   Data components are pointers so results can be written directly into memory ! ! ----------------------------------------------------------------------------------------------- type , extends ( ty_fluxes ), public :: ty_fluxes_broadband real ( wp ), dimension (:,:), pointer :: flux_up => NULL (), flux_dn => NULL () real ( wp ), dimension (:,:), pointer :: flux_net => NULL () ! Net (down - up) real ( wp ), dimension (:,:), pointer :: flux_dn_dir => NULL () ! Direct flux down contains procedure , public :: reduce => reduce_broadband procedure , public :: are_desired => are_desired_broadband end type ty_fluxes_broadband ! ----------------------------------------------------------------------------------------------- ! ----------------------------------------------------------------------------------------------- ! ! Abstract interfaces: any implemntation has to provide routines with these interfaces ! abstract interface ! ------------------- ! ! This routine takes the fully resolved calculation (detailed in spectral and vertical dimensions) and !   computes desired outputs. Output values will normally be data components of the derived type. ! function reduce_abstract ( this , gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) result ( error_msg ) import ty_fluxes , ty_optical_props import wp class ( ty_fluxes ), intent ( inout ) :: this real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_up ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_dn ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) class ( ty_optical_props ), intent ( in ) :: spectral_disc !< derived type with spectral information logical , intent ( in ) :: top_at_1 real ( kind = wp ), dimension (:,:,:), optional , & intent ( in ) :: gpt_flux_dn_dir ! Direct flux down character ( len = 128 ) :: error_msg end function reduce_abstract ! ------------------- ! ! This routine determines if the reduction should proceed - it's useful in ensuring !   that space has been allocated for the results, for example. ! function are_desired_abstract ( this ) import ty_fluxes class ( ty_fluxes ), intent ( in ) :: this logical :: are_desired_abstract end function are_desired_abstract ! ---------------------- end interface contains ! -------------------------------------------------------------------------------------- ! ! Broadband fluxes -- simply sum over the spectral dimension and report the whole profile ! ! -------------------------------------------------------------------------------------- function reduce_broadband ( this , gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) result ( error_msg ) class ( ty_fluxes_broadband ), intent ( inout ) :: this real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_up ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_dn ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) class ( ty_optical_props ), intent ( in ) :: spectral_disc !< derived type with spectral information logical , intent ( in ) :: top_at_1 real ( kind = wp ), dimension (:,:,:), optional , & intent ( in ) :: gpt_flux_dn_dir ! Direct flux down character ( len = 128 ) :: error_msg ! ------ integer :: ncol , nlev , ngpt ! ------ ncol = size ( gpt_flux_up , DIM = 1 ) nlev = size ( gpt_flux_up , DIM = 2 ) ngpt = size ( gpt_flux_up , DIM = 3 ) error_msg = \"\" if ( check_extents ) then ! ! Check array sizes !  Input arrays ! if (. not . extents_are ( gpt_flux_dn , ncol , nlev , ngpt )) & error_msg = \"reduce: gpt_flux_dn array incorrectly sized\" if ( present ( gpt_flux_dn_dir )) then if (. not . extents_are ( gpt_flux_dn_dir , ncol , nlev , ngpt )) & error_msg = \"reduce: gpt_flux_dn_dir array incorrectly sized\" end if ! ! Output arrays ! if ( associated ( this % flux_up )) then if (. not . extents_are ( this % flux_up , ncol , nlev )) & error_msg = 'reduce: flux_up array incorrectly sized' end if if ( associated ( this % flux_dn )) then if (. not . extents_are ( this % flux_dn , ncol , nlev )) & error_msg = 'reduce: flux_dn array incorrectly sized' end if if ( associated ( this % flux_net )) then if (. not . extents_are ( this % flux_net , ncol , nlev )) & error_msg = 'reduce: flux_net array incorrectly sized' end if if ( associated ( this % flux_dn_dir )) then if (. not . extents_are ( this % flux_dn_dir , ncol , nlev )) & error_msg = 'reduce: flux_dn_dir array incorrectly sized' end if if ( error_msg /= \"\" ) return end if ! ! Self-consistency -- shouldn't be asking for direct beam flux if it isn't supplied ! if ( associated ( this % flux_dn_dir ) . and . . not . present ( gpt_flux_dn_dir )) then error_msg = \"reduce: requesting direct downward flux but this hasn't been supplied\" return end if ! ! Broadband fluxes - call the kernels ! if ( associated ( this % flux_up )) & call sum_broadband ( ncol , nlev , ngpt , gpt_flux_up , this % flux_up ) if ( associated ( this % flux_dn )) & call sum_broadband ( ncol , nlev , ngpt , gpt_flux_dn , this % flux_dn ) if ( associated ( this % flux_dn_dir )) & call sum_broadband ( ncol , nlev , ngpt , gpt_flux_dn_dir , this % flux_dn_dir ) if ( associated ( this % flux_net )) then ! !  Reuse down and up results if possible ! if ( associated ( this % flux_dn ) . and . associated ( this % flux_up )) then call net_broadband ( ncol , nlev , this % flux_dn , this % flux_up , this % flux_net ) else call net_broadband ( ncol , nlev , ngpt , gpt_flux_dn , gpt_flux_up , this % flux_net ) end if end if end function reduce_broadband ! -------------------------------------------------------------------------------------- ! ! Are any fluxes desired from this set of g-point fluxes? We can tell because memory will !   be allocated for output ! ! -------------------------------------------------------------------------------------- function are_desired_broadband ( this ) class ( ty_fluxes_broadband ), intent ( in ) :: this logical :: are_desired_broadband are_desired_broadband = any ( [ associated ( this % flux_up ), & associated ( this % flux_dn ), & associated ( this % flux_dn_dir ), & associated ( this % flux_net )] ) end function are_desired_broadband ! -------------------------------------------------------------------------------------- end module mo_fluxes","tags":"","loc":"sourcefile/mo_fluxes.f90.html"},{"title":"mo_rte_lw.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rte_lw.f90~~EfferentGraph sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rte_lw.f90~~AfferentGraph sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_lw Source Code mo_rte_lw.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2021,  Atmospheric and Environmental Research, ! Regents of the University of Colorado, Trustees of Columbia University.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! !  Contains a single routine to compute direct and diffuse fluxes of solar radiation given !    atmospheric optical properties, spectrally-resolved !    information about vertical ordering !    internal Planck source functions, defined per g-point on the same spectral grid at the atmosphere !    boundary conditions: surface emissivity defined per band !    optionally, a boundary condition for incident diffuse radiation !    optionally, an integer number of angles at which to do Gaussian quadrature if scattering is neglected ! ! If optical properties are supplied via class ty_optical_props_1scl (absorption optical thickenss only) !    then an emission/absorption solver is called !    If optical properties are supplied via class ty_optical_props_2str fluxes are computed via !    two-stream calculations and adding. ! ! It is the user's responsibility to ensure that emissivity is on the same !   spectral grid as the optical properties. ! ! Final output is via user-extensible ty_fluxes which must reduce the detailed spectral fluxes to !   whatever summary the user needs. ! ! The routine does error checking and choses which lower-level kernel to invoke based on !   what kinds of optical properties are supplied ! ! ------------------------------------------------------------------------------------------------- module mo_rte_lw use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_extents , check_values use mo_rte_util_array , only : any_vals_less_than , any_vals_outside , extents_are , zero_array use mo_optical_props , only : ty_optical_props , & ty_optical_props_arry , ty_optical_props_1scl , ty_optical_props_2str , ty_optical_props_nstr use mo_source_functions , & only : ty_source_func_lw use mo_fluxes , only : ty_fluxes , ty_fluxes_broadband use mo_rte_solver_kernels , & only : lw_solver_noscat , lw_solver_noscat_GaussQuad , lw_solver_2stream implicit none private public :: rte_lw contains ! -------------------------------------------------- ! ! Interface using only optical properties and source functions as inputs; fluxes as outputs. ! ! -------------------------------------------------- function rte_lw ( optical_props , top_at_1 , & sources , sfc_emis , & fluxes , & inc_flux , n_gauss_angles , use_2stream , & lw_Ds , flux_up_Jac ) result ( error_msg ) class ( ty_optical_props_arry ), intent ( in ) :: optical_props ! Set of optical properties as one or more arrays logical , intent ( in ) :: top_at_1 ! Is the top of the domain at index 1? ! (if not, ordering is bottom-to-top) type ( ty_source_func_lw ), intent ( in ) :: sources ! Derived type with Planck source functions real ( wp ), dimension (:,:), intent ( in ) :: sfc_emis ! emissivity at surface [] (nband, ncol) class ( ty_fluxes ), intent ( inout ) :: fluxes ! Dervied type for computing spectral integrals from g-point fluxes. ! Default computes broadband fluxes at all levels ! if output arrays are defined. Can be extended per user desires. real ( wp ), dimension (:,:), & target , optional , intent ( in ) :: inc_flux ! incident flux at domain top [W/m2] (ncol, ngpts) integer , optional , intent ( in ) :: n_gauss_angles ! Number of angles used in Gaussian quadrature (max 3) ! (no-scattering solution) logical , optional , intent ( in ) :: use_2stream ! When 2-stream parameters (tau/ssa/g) are provided, use 2-stream methods ! Default is to use re-scaled longwave transport real ( wp ), dimension (:,:), & optional , intent ( in ) :: lw_Ds ! User-specifed 1/cos of transport angle per col, g-point real ( wp ), dimension (:,:), target , & optional , intent ( inout ) :: flux_up_Jac ! surface temperature flux  Jacobian [W/m2/K] (ncol, nlay+1) character ( len = 128 ) :: error_msg ! If empty, calculation was successful ! -------------------------------- ! ! Local variables ! integer :: ncol , nlay , ngpt , nband integer :: icol , ilev , igpt , imu integer :: n_quad_angs logical ( wl ) :: using_2stream , do_Jacobians , do_broadband real ( wp ), dimension (:,:), allocatable :: sfc_emis_gpt real ( wp ), dimension (:,:,:), allocatable :: secants real ( wp ), dimension (:,:), pointer :: jacobian real ( wp ), dimension ( optical_props % get_ncol (), & optical_props % get_nlay () + 1 ), target & :: decoy2D ! Used for optional outputs - needs to be full size. ! Memory needs to be allocated for the full g-point fluxes even if they aren't !    used later because a) the GPU kernels use this memory to work in parallel and !    b) the fluxes are intent(out) in the solvers ! Shortwave solver takes a different approach since three fields are needed real ( wp ), dimension ( optical_props % get_ncol (), & optical_props % get_nlay () + 1 , & optical_props % get_ngpt ()) & :: gpt_flux_up , gpt_flux_dn real ( wp ), dimension (:,:), pointer :: flux_dn_loc , flux_up_loc real ( wp ), dimension (:,:), pointer :: inc_flux_diffuse ! -------------------------------------------------- ! ! Weights and angle secants for first order (k=1) Gaussian quadrature. !   Values from Table 2, Clough et al, 1992, doi:10.1029/92JD01419 !   after Abramowitz & Stegun 1972, page 921 ! integer , parameter :: max_gauss_pts = 4 real ( wp ), parameter , & dimension ( max_gauss_pts , max_gauss_pts ) :: & gauss_Ds = RESHAPE ([ 1.66_wp , 0._wp , 0._wp , 0._wp , & ! Diffusivity angle, not Gaussian angle 1.18350343_wp , 2.81649655_wp , 0._wp , 0._wp , & 1.09719858_wp , 1.69338507_wp , 4.70941630_wp , 0._wp , & 1.06056257_wp , 1.38282560_wp , 2.40148179_wp , 7.15513024_wp ], & [ max_gauss_pts , max_gauss_pts ]), & gauss_wts = RESHAPE ([ 0.5_wp , 0._wp , 0._wp , 0._wp , & 0.3180413817_wp , 0.1819586183_wp , 0._wp , 0._wp , & 0.2009319137_wp , 0.2292411064_wp , 0.0698269799_wp , 0._wp , & 0.1355069134_wp , 0.2034645680_wp , 0.1298475476_wp , 0.0311809710_wp ], & [ max_gauss_pts , max_gauss_pts ]) ! ------------------------------------------------------------------------------------ ncol = optical_props % get_ncol () nlay = optical_props % get_nlay () ngpt = optical_props % get_ngpt () nband = optical_props % get_nband () do_Jacobians = present ( flux_up_Jac ) error_msg = \"\" ! ------------------------------------------------------------------------------------ ! ! Error checking -- input consistency of sizes and validity of values if (. not . fluxes % are_desired ()) & error_msg = \"rte_lw: no space allocated for fluxes\" if ( do_Jacobians . and . check_extents ) then if ( . not . extents_are ( flux_up_Jac , ncol , nlay + 1 )) & error_msg = \"rte_lw: flux Jacobian inconsistently sized\" endif if ( check_extents ) then ! ! Source functions ! if ( any ([ sources % get_ncol (), sources % get_nlay (), sources % get_ngpt ()] /= [ ncol , nlay , ngpt ])) & error_msg = \"rte_lw: sources and optical properties inconsistently sized\" ! ! Surface emissivity ! if (. not . extents_are ( sfc_emis , nband , ncol )) & error_msg = \"rte_lw: sfc_emis inconsistently sized\" ! ! Incident flux, if present ! if ( present ( inc_flux )) then if (. not . extents_are ( inc_flux , ncol , ngpt )) & error_msg = \"rte_lw: inc_flux inconsistently sized\" end if if ( present ( lw_Ds )) then if (. not . extents_are ( lw_Ds , ncol , ngpt )) & error_msg = \"rte_lw: lw_Ds inconsistently sized\" end if end if if ( check_values ) then if ( any_vals_outside ( sfc_emis , 0._wp , 1._wp )) & error_msg = \"rte_lw: sfc_emis has values < 0 or > 1\" if ( present ( inc_flux )) then if ( any_vals_less_than ( inc_flux , 0._wp )) & error_msg = \"rte_lw: inc_flux has values < 0\" end if if ( present ( lw_Ds )) then if ( any_vals_less_than ( lw_Ds , 1._wp )) & error_msg = \"rte_lw: one or more values of lw_Ds < 1.\" end if if ( present ( n_gauss_angles )) then if ( n_gauss_angles > max_gauss_pts ) & error_msg = \"rte_lw: asking for too many quadrature points for no-scattering calculation\" if ( n_gauss_angles < 1 ) & error_msg = \"rte_lw: have to ask for at least one quadrature point for no-scattering calculation\" end if end if if ( len_trim ( error_msg ) > 0 ) return ! ! Number of quadrature points for no-scattering calculation ! n_quad_angs = 1 if ( present ( n_gauss_angles )) n_quad_angs = n_gauss_angles ! ! Optionally - use 2-stream methods when low-order scattering properties are provided? ! using_2stream = . false . if ( present ( use_2stream )) using_2stream = use_2stream ! ! Checking that optional arguments are consistent with one another and with optical properties ! select type ( optical_props ) class is ( ty_optical_props_1scl ) if ( using_2stream ) & error_msg = \"rte_lw: can't use two-stream methods with only absorption optical depth\" if ( present ( lw_Ds ) . and . n_quad_angs /= 1 ) & error_msg = \"rte_lw: providing lw_Ds incompatible with specifying n_gauss_angles\" class is ( ty_optical_props_2str ) if ( present ( lw_Ds )) & error_msg = \"rte_lw: lw_Ds not valid when providing scattering optical properties\" if ( using_2stream . and . n_quad_angs /= 1 ) & error_msg = \"rte_lw: using_2stream=true incompatible with specifying n_gauss_angles\" if ( using_2stream . and . do_Jacobians ) & error_msg = \"rte_lw: can't provide Jacobian of fluxes w.r.t surface temperature with 2-stream\" class default error_msg = \"rte_lw: lw_solver(...ty_optical_props_nstr...) not yet implemented\" end select if ( len_trim ( error_msg ) > 0 ) then if ( len_trim ( optical_props % get_name ()) > 0 ) & error_msg = trim ( optical_props % get_name ()) // ': ' // trim ( error_msg ) return end if ! ------------------------------------------------------------------------------------ !  Boundary conditions !    Lower boundary condition -- expand surface emissivity by band to gpoints ! allocate ( sfc_emis_gpt ( ncol , ngpt )) !   Upper boundary condition -  use values in optional arg or be set to 0 ! if ( present ( inc_flux )) then inc_flux_diffuse => inc_flux !$acc        enter data copyin(   inc_flux_diffuse) !$omp target enter data map(to:   inc_flux_diffuse) else allocate ( inc_flux_diffuse ( ncol , ngpt )) !$acc        enter data create(   inc_flux_diffuse) !$omp target enter data map(alloc:inc_flux_diffuse) call zero_array ( ncol , ngpt , inc_flux_diffuse ) end if ! ------------------------------------------------------------------------------------ if ( do_Jacobians ) then jacobian => flux_up_Jac else jacobian => decoy2D end if select type ( fluxes ) ! ! Broadband fluxes are treated as a special case within the solvers; memory !   for both up and down fluxes needs to be available even if the user doesn't !   want one of them ! type is ( ty_fluxes_broadband ) do_broadband = . true . _ wl ! ! Broadband fluxes class has three possible outputs; allocate memory for local use !   if one or more haven't been requested ! if ( associated ( fluxes % flux_up )) then flux_up_loc => fluxes % flux_up else allocate ( flux_up_loc ( ncol , nlay + 1 )) end if if ( associated ( fluxes % flux_dn )) then flux_dn_loc => fluxes % flux_dn else allocate ( flux_dn_loc ( ncol , nlay + 1 )) end if !$acc        enter data create(   flux_up_loc, flux_dn_loc) !$omp target enter data map(alloc:flux_up_loc, flux_dn_loc) class default ! ! If broadband integrals aren't being computed, allocate working space !   and decoy addresses for spectrally-integrated fields ! do_broadband = . false . _ wl flux_up_loc => decoy2D flux_dn_loc => decoy2D end select ! ! Compute the radiative transfer... ! !$acc        data create(   sfc_emis_gpt, flux_up_loc, flux_dn_loc, gpt_flux_up, gpt_flux_dn) !$omp target data map(alloc:sfc_emis_gpt, flux_up_loc, flux_dn_loc, gpt_flux_up, gpt_flux_dn) call expand_and_transpose ( optical_props , sfc_emis , sfc_emis_gpt ) if ( check_values ) error_msg = optical_props % validate () if ( len_trim ( error_msg ) == 0 ) then ! Can't do an early return within OpenACC/MP data regions select type ( optical_props ) class is ( ty_optical_props_1scl ) ! ! No scattering two-stream calculation ! ! ! Secant of radiation angle - either user-supplied, one per g-point, or !   taken from first-order Gaussian quadrate and applied to all columns a g-points ! allocate ( secants ( ncol , ngpt , n_quad_angs )) !$acc        data create(   secants) !$omp target data map(alloc:secants) if ( present ( lw_Ds )) then !$acc                         parallel loop    collapse(2) copyin(lw_Ds) !$omp target teams distribute parallel do simd collapse(2) ! nmu is 1 do igpt = 1 , ngpt do icol = 1 , ncol secants ( icol , igpt , 1 ) = lw_Ds ( icol , igpt ) end do end do else ! !   Is there an alternative to making ncol x ngpt copies of each value? ! !$acc                         parallel loop    collapse(3) copyin(gauss_Ds) !$omp target teams distribute parallel do simd collapse(3) do imu = 1 , n_quad_angs do igpt = 1 , ngpt do icol = 1 , ncol secants ( icol , igpt , imu ) = gauss_Ds ( imu , n_quad_angs ) end do end do end do end if call lw_solver_noscat_GaussQuad ( ncol , nlay , ngpt , & logical ( top_at_1 , wl ), n_quad_angs , & secants , gauss_wts ( 1 : n_quad_angs , n_quad_angs ), & optical_props % tau , & sources % lay_source , sources % lev_source_inc , & sources % lev_source_dec , & sfc_emis_gpt , sources % sfc_source , & inc_flux_diffuse , & gpt_flux_up , gpt_flux_dn , & do_broadband , flux_up_loc , flux_dn_loc , & logical ( do_Jacobians , wl ), sources % sfc_source_Jac , jacobian , & logical (. false ., wl ), optical_props % tau , optical_props % tau ) ! The last two arguments won't be used since the ! third-to-last is .false. but need valid addresses !$acc        end data !$omp end target data class is ( ty_optical_props_2str ) if ( using_2stream ) then ! ! two-stream calculation with scattering ! call lw_solver_2stream ( ncol , nlay , ngpt , logical ( top_at_1 , wl ), & optical_props % tau , optical_props % ssa , optical_props % g , & sources % lay_source , sources % lev_source_inc , sources % lev_source_dec , & sfc_emis_gpt , sources % sfc_source , & inc_flux_diffuse , & gpt_flux_up , gpt_flux_dn ) else allocate ( secants ( ncol , ngpt , n_quad_angs )) !$acc        data create(   secants) !$omp target data map(alloc:secants) !$acc                         parallel loop    collapse(3) copyin(gauss_Ds) !$omp target teams distribute parallel do simd collapse(3) do imu = 1 , n_quad_angs do igpt = 1 , ngpt do icol = 1 , ncol secants ( icol , igpt , imu ) = gauss_Ds ( imu , n_quad_angs ) end do end do end do ! ! Re-scaled solution to account for scattering ! call lw_solver_noscat_GaussQuad ( ncol , nlay , ngpt , & logical ( top_at_1 , wl ), n_quad_angs , & secants , gauss_wts ( 1 : n_quad_angs , n_quad_angs ), & optical_props % tau , & sources % lay_source , sources % lev_source_inc , & sources % lev_source_dec , & sfc_emis_gpt , sources % sfc_source , & inc_flux_diffuse , & gpt_flux_up , gpt_flux_dn , & do_broadband , flux_up_loc , flux_dn_loc , & logical ( do_Jacobians , wl ), sources % sfc_source_Jac , jacobian , & logical (. true ., wl ), optical_props % ssa , optical_props % g ) !$acc        end data !$omp end target data endif class is ( ty_optical_props_nstr ) ! ! n-stream calculation ! error_msg = 'lw_solver(...ty_optical_props_nstr...) not yet implemented' end select select type ( fluxes ) ! ! Tidy up memory for broadband fluxes on GPUs ! type is ( ty_fluxes_broadband ) if ( associated ( fluxes % flux_net )) then ! ! FIXME: Do we need the create/copyout here? ! !$acc                         parallel loop    collapse(2) copyin(fluxes) copyout( fluxes%flux_net) !$omp target teams distribute parallel do simd collapse(2) map(from:fluxes%flux_net) do ilev = 1 , nlay + 1 do icol = 1 , ncol fluxes % flux_net ( icol , ilev ) = flux_dn_loc ( icol , ilev ) - flux_up_loc ( icol , ilev ) end do end do end if class default ! ! ...or reduce spectral fluxes to desired output quantities ! error_msg = fluxes % reduce ( gpt_flux_up , gpt_flux_dn , optical_props , top_at_1 ) end select end if ! no error message from validation !$acc        end data !$omp end target data if (. not . present ( inc_flux )) then !$acc        exit data delete(     inc_flux_diffuse) !$omp target exit data map(release:inc_flux_diffuse) deallocate ( inc_flux_diffuse ) end if select type ( fluxes ) type is ( ty_fluxes_broadband ) !$acc        exit data copyout( flux_up_loc, flux_dn_loc) !$omp target exit data map(from:flux_up_loc, flux_dn_loc) if (. not . associated ( flux_up_loc , fluxes % flux_up )) deallocate ( flux_up_loc ) if (. not . associated ( flux_dn_loc , fluxes % flux_dn )) deallocate ( flux_dn_loc ) end select end function rte_lw !-------------------------------------------------------------------------------------------------------------------- ! ! Expand from band to g-point dimension, transpose dimensions (nband, ncol) -> (ncol,ngpt) ! subroutine expand_and_transpose ( ops , arr_in , arr_out ) class ( ty_optical_props ), intent ( in ) :: ops real ( wp ), dimension (:,:), intent ( in ) :: arr_in ! (nband, ncol) real ( wp ), dimension (:,:), intent ( out ) :: arr_out ! (ncol, igpt) ! ------------- integer :: ncol , nband , ngpt integer :: icol , iband , igpt integer , dimension ( 2 , ops % get_nband ()) :: limits ncol = size ( arr_in , 2 ) nband = ops % get_nband () ngpt = ops % get_ngpt () limits = ops % get_band_lims_gpoint () !$acc                         parallel loop    collapse(2) copyin(arr_in, limits) !$omp target teams distribute parallel do simd collapse(2) map(to:arr_in, limits) do iband = 1 , nband do icol = 1 , ncol do igpt = limits ( 1 , iband ), limits ( 2 , iband ) arr_out ( icol , igpt ) = arr_in ( iband , icol ) end do end do end do end subroutine expand_and_transpose !-------------------------------------------------------------------------------------------------------------------- end module mo_rte_lw","tags":"","loc":"sourcefile/mo_rte_lw.f90.html"},{"title":"mo_rte_sw.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rte_sw.f90~~EfferentGraph sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rte_sw.f90~~AfferentGraph sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_sw Source Code mo_rte_sw.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2021,  Atmospheric and Environmental Research, ! Regents of the University of Colorado, Trustees of Columbia University.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! !  Contains a single routine to compute direct and diffuse fluxes of solar radiation given !    atmospheric optical properties on a spectral grid !    information about vertical ordering !    boundary conditions !      solar zenith angle, spectrally-resolved incident colimated flux, surface albedos for direct and diffuse radiation !    optionally, a boundary condition for incident diffuse radiation ! ! It is the user's responsibility to ensure that boundary conditions (incident fluxes, surface albedos) are on the same !   spectral grid as the optical properties. ! ! Final output is via user-extensible ty_fluxes which must reduce the detailed spectral fluxes to !   whatever summary the user needs. ! ! The routine does error checking and choses which lower-level kernel to invoke based on !   what kinds of optical properties are supplied ! ! ------------------------------------------------------------------------------------------------- module mo_rte_sw use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_extents , check_values use mo_rte_util_array , only : any_vals_less_than , any_vals_outside , extents_are , zero_array use mo_optical_props , only : ty_optical_props , & ty_optical_props_arry , ty_optical_props_1scl , ty_optical_props_2str , ty_optical_props_nstr use mo_fluxes , only : ty_fluxes , ty_fluxes_broadband use mo_rte_solver_kernels , & only : sw_solver_noscat , sw_solver_2stream implicit none private public :: rte_sw contains ! -------------------------------------------------- function rte_sw ( atmos , top_at_1 , & mu0 , inc_flux , & sfc_alb_dir , sfc_alb_dif , & fluxes , inc_flux_dif ) result ( error_msg ) class ( ty_optical_props_arry ), intent ( in ) :: atmos ! Optical properties provided as arrays logical , intent ( in ) :: top_at_1 ! Is the top of the domain at index 1? ! (if not, ordering is bottom-to-top) real ( wp ), dimension (:), intent ( in ) :: mu0 ! cosine of solar zenith angle (ncol) real ( wp ), dimension (:,:), intent ( in ) :: inc_flux , & ! incident flux at top of domain [W/m2] (ncol, ngpt) sfc_alb_dir , & ! surface albedo for direct and sfc_alb_dif ! diffuse radiation (nband, ncol) class ( ty_fluxes ), intent ( inout ) :: fluxes ! Class describing output calculations real ( wp ), dimension (:,:), optional , target , & intent ( in ) :: inc_flux_dif ! incident diffuse flux at top of domain [W/m2] (ncol, ngpt) character ( len = 128 ) :: error_msg ! If empty, calculation was successful ! -------------------------------- ! ! Local variables ! integer :: ncol , nlay , ngpt , nband integer :: icol , ilev logical ( wl ) :: has_dif_bc , do_broadband real ( wp ), dimension (:,:,:), pointer :: gpt_flux_up , gpt_flux_dn , gpt_flux_dir real ( wp ), dimension (:,:), allocatable :: sfc_alb_dir_gpt , sfc_alb_dif_gpt real ( wp ), dimension (:,:), pointer :: flux_dn_loc , flux_up_loc , flux_dir_loc real ( wp ), dimension (:,:), pointer :: inc_flux_diffuse real ( wp ), dimension (:,:,:), allocatable , target :: decoy3D real ( wp ), dimension (:,:), allocatable , target :: decoy2D ! ------------------------------------------------------------------------------------ ncol = atmos % get_ncol () nlay = atmos % get_nlay () ngpt = atmos % get_ngpt () nband = atmos % get_nband () error_msg = \"\" ! ------------------------------------------------------------------------------------ ! ! Error checking -- consistency of sizes and validity of values ! ! -------------------------------- if (. not . fluxes % are_desired ()) & error_msg = \"rte_sw: no space allocated for fluxes\" has_dif_bc = logical ( present ( inc_flux_dif ), wl ) ! ! Sizes of input arrays ! ! Copy variables whose sizes and values are checked to the GPU so the checks can happen there. !   No harm done if checks are not performed  (?) !$acc        data copyin(mu0, inc_flux, sfc_alb_dir, sfc_alb_dif) !$omp target data map(to:mu0, inc_flux, sfc_alb_dir, sfc_alb_dif) !$acc        data copyin(inc_flux_dif) if (has_dif_bc) !$omp target data map(to:inc_flux_dif) if (has_dif_bc) if ( check_extents ) then if (. not . extents_are ( mu0 , ncol )) & error_msg = \"rte_sw: mu0 inconsistently sized\" if (. not . extents_are ( inc_flux , ncol , ngpt )) & error_msg = \"rte_sw: inc_flux inconsistently sized\" if (. not . extents_are ( sfc_alb_dir , nband , ncol )) & error_msg = \"rte_sw: sfc_alb_dir inconsistently sized\" if (. not . extents_are ( sfc_alb_dif , nband , ncol )) & error_msg = \"rte_sw: sfc_alb_dif inconsistently sized\" if ( has_dif_bc ) then if (. not . extents_are ( inc_flux_dif , ncol , ngpt )) & error_msg = \"rte_sw: inc_flux_dif inconsistently sized\" end if end if ! ! Values of input arrays ! if ( check_values ) then if ( any_vals_outside ( mu0 , 0._wp , 1._wp )) & error_msg = \"rte_sw: one or more mu0 <= 0 or > 1\" if ( any_vals_less_than ( inc_flux , 0._wp )) & error_msg = \"rte_sw: one or more inc_flux < 0\" if ( any_vals_outside ( sfc_alb_dir , 0._wp , 1._wp )) & error_msg = \"rte_sw: sfc_alb_dir out of bounds [0,1]\" if ( any_vals_outside ( sfc_alb_dif , 0._wp , 1._wp )) & error_msg = \"rte_sw: sfc_alb_dif out of bounds [0,1]\" if ( has_dif_bc ) then if ( any_vals_less_than ( inc_flux_dif , 0._wp )) & error_msg = \"rte_sw: one or more inc_flux_dif < 0\" end if end if ! ------------------------------------------------------------------------------------ select type ( fluxes ) type is ( ty_fluxes_broadband ) do_broadband = . true . _ wl ! ! Solvers will integrate in place (one g-point at a time on CPUs) !   so won't need big working arrays ! allocate ( decoy3D ( ncol , nlay + 1 , ngpt )) gpt_flux_up => decoy3D gpt_flux_dn => decoy3D gpt_flux_dir => decoy3D ! ! Broadband fluxes class has three possible outputs; allocate memory for local use !   if one or more haven't been requested ! if ( associated ( fluxes % flux_up )) then flux_up_loc => fluxes % flux_up else allocate ( flux_up_loc ( ncol , nlay + 1 )) end if if ( associated ( fluxes % flux_dn )) then flux_dn_loc => fluxes % flux_dn else allocate ( flux_dn_loc ( ncol , nlay + 1 )) end if if ( associated ( fluxes % flux_dn_dir )) then flux_dir_loc => fluxes % flux_dn_dir else allocate ( flux_dir_loc ( ncol , nlay + 1 )) end if !$acc        enter data create(   flux_up_loc, flux_dn_loc, flux_dir_loc) !$omp target enter data map(alloc:flux_up_loc, flux_dn_loc, flux_dir_loc) class default ! ! If broadband integrals aren't being computed, allocate working space !   and decoy addresses for spectrally-integrated fields ! do_broadband = . false . _ wl allocate ( decoy2D ( ncol , nlay + 1 )) flux_up_loc => decoy2D flux_dn_loc => decoy2D flux_dir_loc => decoy2D allocate ( gpt_flux_up ( ncol , nlay + 1 , ngpt ), & gpt_flux_dn ( ncol , nlay + 1 , ngpt ), & gpt_flux_dir ( ncol , nlay + 1 , ngpt )) end select allocate ( sfc_alb_dir_gpt ( ncol , ngpt ), sfc_alb_dif_gpt ( ncol , ngpt )) if ( len_trim ( error_msg ) > 0 ) then if ( len_trim ( atmos % get_name ()) > 0 ) & error_msg = trim ( atmos % get_name ()) // ': ' // trim ( error_msg ) end if ! Fluxes need to be copied out only if do_broadband is .true. !$acc        data copyin(   flux_up_loc,flux_dn_loc,flux_dir_loc) if (      do_broadband) !$omp target data map(to:   flux_up_loc,flux_dn_loc,flux_dir_loc) if (      do_broadband) !$acc        data create(   flux_up_loc,flux_dn_loc,flux_dir_loc) if (.not. do_broadband) !$omp target data map(alloc:flux_up_loc,flux_dn_loc,flux_dir_loc) if (.not. do_broadband) !$acc        data create(   gpt_flux_up,gpt_flux_dn,gpt_flux_dir) & !$acc             create(   sfc_alb_dir_gpt, sfc_alb_dif_gpt) !$omp target data map(alloc:gpt_flux_up,gpt_flux_dn,gpt_flux_dir) & !$omp             map(alloc:sfc_alb_dir_gpt, sfc_alb_dif_gpt) ! ------------------------------------------------------------------------------------ ! Boundary conditions !   Lower boundary condition -- expand surface albedos by band to gpoints !     and switch dimension ordering call expand_and_transpose ( atmos , sfc_alb_dir , sfc_alb_dir_gpt ) call expand_and_transpose ( atmos , sfc_alb_dif , sfc_alb_dif_gpt ) ! !   Diffuse flux boundary condition - will use values in optional arg or be set to 0 ! if ( has_dif_bc ) then inc_flux_diffuse => inc_flux_dif !$acc        enter data copyin(   inc_flux_diffuse) !$omp target enter data map(to:   inc_flux_diffuse) else allocate ( inc_flux_diffuse ( ncol , ngpt )) !$acc        enter data create(   inc_flux_diffuse) !$omp target enter data map(alloc:inc_flux_diffuse) call zero_array ( ncol , ngpt , inc_flux_diffuse ) end if ! ------------------------------------------------------------------------------------ if ( check_values ) error_msg = atmos % validate () ! ! Compute the radiative transfer... ! if ( len_trim ( error_msg ) == 0 ) then select type ( atmos ) class is ( ty_optical_props_1scl ) ! ! Direct beam only - for completeness, unlikely to be used in practice ! call sw_solver_noscat ( ncol , nlay , ngpt , logical ( top_at_1 , wl ), & atmos % tau , mu0 , inc_flux , & gpt_flux_dir ) call zero_array ( ncol , nlay + 1 , ngpt , gpt_flux_up ) ! !$acc kernels !$omp target gpt_flux_dn (:,:,:) = gpt_flux_dir (:,:,:) !$acc end kernels !$omp end target class is ( ty_optical_props_2str ) ! ! two-stream calculation with scattering ! call sw_solver_2stream ( ncol , nlay , ngpt , logical ( top_at_1 , wl ), & atmos % tau , atmos % ssa , atmos % g , mu0 , & sfc_alb_dir_gpt , sfc_alb_dif_gpt , & inc_flux , & gpt_flux_up , gpt_flux_dn , gpt_flux_dir , & has_dif_bc , inc_flux_diffuse , & do_broadband , flux_up_loc , flux_dn_loc , flux_dir_loc ) class is ( ty_optical_props_nstr ) ! ! n-stream calculation ! ! not yet implemented so fail ! error_msg = 'sw_solver(...ty_optical_props_nstr...) not yet implemented' end select if ( len_trim ( error_msg ) > 0 ) then if ( len_trim ( atmos % get_name ()) > 0 ) & error_msg = trim ( atmos % get_name ()) // ': ' // trim ( error_msg ) end if ! ! Flux reduction (summarizing for output) ! select type ( fluxes ) ! ! Tidy up memory for broadband fluxes ! type is ( ty_fluxes_broadband ) if ( associated ( fluxes % flux_net )) then !$acc                         parallel loop    collapse(2) copyout(fluxes%flux_net) !$omp target teams distribute parallel do simd collapse(2) do ilev = 1 , nlay + 1 do icol = 1 , ncol fluxes % flux_net ( icol , ilev ) = flux_dn_loc ( icol , ilev ) - flux_up_loc ( icol , ilev ) end do end do end if class default ! ! ...or reduce spectral fluxes to desired output quantities ! error_msg = fluxes % reduce ( gpt_flux_up , gpt_flux_dn , atmos , top_at_1 , gpt_flux_dir ) end select end if ! In case of an error we exit here !$acc        end data !$omp end target data !$acc        end data !$omp end target data !$acc        end data !$omp end target data !$acc        end data !$omp end target data !$acc        end data !$omp end target data ! ! Deallocate any memory allocated locally to pointer variables ! select type ( fluxes ) type is ( ty_fluxes_broadband ) !$acc        exit data copyout( flux_up_loc, flux_dn_loc, flux_dir_loc) !$omp target exit data map(from:flux_up_loc, flux_dn_loc, flux_dir_loc) if (. not . associated ( fluxes % flux_up )) deallocate ( flux_up_loc ) if (. not . associated ( fluxes % flux_dn )) deallocate ( flux_dn_loc ) if (. not . associated ( fluxes % flux_dn_dir )) deallocate ( flux_dir_loc ) class default deallocate ( gpt_flux_up , gpt_flux_dn , gpt_flux_dir ) end select if (. not . has_dif_bc ) then !$acc        exit data delete(     inc_flux_diffuse) !$omp target exit data map(release:inc_flux_diffuse) deallocate ( inc_flux_diffuse ) end if end function rte_sw !-------------------------------------------------------------------------------------------------------------------- ! ! Expand from band to g-point dimension, transpose dimensions (nband, ncol) -> (ncol,ngpt) ! subroutine expand_and_transpose ( ops , arr_in , arr_out ) class ( ty_optical_props ), intent ( in ) :: ops real ( wp ), dimension (:,:), intent ( in ) :: arr_in ! (nband, ncol) real ( wp ), dimension (:,:), intent ( out ) :: arr_out ! (ncol, igpt) ! ------------- integer :: ncol , nband , ngpt integer :: icol , iband , igpt integer , dimension ( 2 , ops % get_nband ()) :: limits ncol = size ( arr_in , 2 ) nband = ops % get_nband () ngpt = ops % get_ngpt () limits = ops % get_band_lims_gpoint () !$acc                         parallel loop    collapse(2) copyin(arr_in, limits) !$omp target teams distribute parallel do simd collapse(2) map(to:arr_in, limits) do iband = 1 , nband do icol = 1 , ncol do igpt = limits ( 1 , iband ), limits ( 2 , iband ) arr_out ( icol , igpt ) = arr_in ( iband , icol ) end do end do end do end subroutine expand_and_transpose end module mo_rte_sw","tags":"","loc":"sourcefile/mo_rte_sw.f90.html"},{"title":"mo_optical_props.F90 – rte-rrtmgp","text":"This code is part of Radiative Transfer for Energetics (RTE) Contacts: Robert Pincus and Eli Mlawer\nemail:  rrtmgp@aer.com Copyright 2015-2018,  Atmospheric and Environmental Research and\nRegents of the University of Colorado.  All right reserved. Use and duplication is permitted under the terms of the\n   BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause This file depends on sourcefile~~mo_optical_props.f90~~EfferentGraph sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_optical_props.f90~~AfferentGraph sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_cloud_optics.f90 mo_cloud_optics.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_cloud_sampling.f90 mo_cloud_sampling.F90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_optical_props.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_optical_props Source Code mo_optical_props.F90 Source Code !! This code is part of Radiative Transfer for Energetics (RTE) !! !! Contacts: Robert Pincus and Eli Mlawer !! email:  rrtmgp@aer.com !! !! Copyright 2015-2018,  Atmospheric and Environmental Research and !! Regents of the University of Colorado.  All right reserved. !! !! Use and duplication is permitted under the terms of the !!    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause !! ------------------------------------------------------------------------------------------------- !> Encapsulate optical properties defined on a spectral grid of N bands. !>   The bands are described by their limiting wavenumbers. They need not be contiguous or complete. !>   A band may contain more than one spectral sub-point (g-point) in which case a mapping must be supplied. !>   A name may be provided and will be prepended to error messages. !>   The base class (ty_optical_props) encapsulates only this spectral discretization and must be initialized !>      with the spectral information before use. !> !>   Optical properties may be represented as arrays with dimensions ncol, nlay, ngpt !>   (abstract class ty_optical_props_arry). !>   The type holds arrays depending on how much information is needed !>   There are three possibilites !>      ty_optical_props_1scl holds absorption optical depth tau, used in calculations accounting for extinction and emission !>      ty_optical_props_2str holds extincion optical depth tau, single-scattering albedo ssa, and !>        asymmetry parameter g. These fields are what's needed for two-stream calculations. !>      ty_optical_props_nstr holds extincion optical depth tau, single-scattering albedo ssa, and !>        phase function moments p with leading dimension nmom. These fields are what's needed for multi-stream calculations. !>   These classes must be allocated before use. Initialization and allocation can be combined. !>   The classes have a validate() function that checks all arrays for valid values (e.g. tau > 0.) !> !> Optical properties can be delta-scaled (though this is currently implemented only for two-stream arrays) !> !> Optical properties can increment or \"add themselves to\" a set of properties represented with arrays !>   as long as both sets have the same underlying band structure. Properties defined by band !>   may be added to properties defined by g-point; the same value is assumed for all g-points with each band. !> !> Subsets of optical properties held as arrays may be extracted along the column dimension. !>@note !>example of a note with links to other modules and variables !> !> 1. [[mo_rte_config(module):check_extents(variable)]] in module [[mo_rte_config]] !> !>@endnote !> ------------------------------------------------------------------------------------------------- module mo_optical_props use mo_rte_kind , only : wp use mo_rte_config , only : check_extents , check_values use mo_rte_util_array , only : any_vals_less_than , any_vals_outside , extents_are use mo_optical_props_kernels , only : & increment_1scalar_by_1scalar , increment_1scalar_by_2stream , increment_1scalar_by_nstream , & increment_2stream_by_1scalar , increment_2stream_by_2stream , increment_2stream_by_nstream , & increment_nstream_by_1scalar , increment_nstream_by_2stream , increment_nstream_by_nstream , & inc_1scalar_by_1scalar_bybnd , inc_1scalar_by_2stream_bybnd , inc_1scalar_by_nstream_bybnd , & inc_2stream_by_1scalar_bybnd , inc_2stream_by_2stream_bybnd , inc_2stream_by_nstream_bybnd , & inc_nstream_by_1scalar_bybnd , inc_nstream_by_2stream_bybnd , inc_nstream_by_nstream_bybnd , & delta_scale_2str_kernel , & extract_subset implicit none integer , parameter :: name_len = 32 !> ------------------------------------------------------------------------------------------------- !> !> Base class for optical properties !>   Describes the spectral discretization including the wavenumber limits !>   of each band (spectral region) and the mapping between g-points and bands !> !> ------------------------------------------------------------------------------------------------- type , public :: ty_optical_props integer , dimension (:,:), allocatable :: band2gpt !! (begin g-point, end g-point) = band2gpt(2,band) integer , dimension (:), allocatable :: gpt2band !! band = gpt2band(g-point) real ( wp ), dimension (:,:), allocatable :: band_lims_wvn !! (upper and lower wavenumber by band) = band_lims_wvn(2,band) character ( len = name_len ) :: name = \"\" contains generic , public :: init => init_base , init_base_from_copy procedure , private :: init_base procedure , private :: init_base_from_copy procedure , public :: is_initialized => is_initialized_base procedure , private :: is_initialized_base procedure , public :: finalize => finalize_base procedure , private :: finalize_base procedure , public :: get_nband procedure , public :: get_ngpt procedure , public :: get_gpoint_bands procedure , public :: convert_band2gpt procedure , public :: convert_gpt2band procedure , public :: get_band_lims_gpoint procedure , public :: get_band_lims_wavenumber procedure , public :: get_band_lims_wavelength procedure , public :: bands_are_equal procedure , public :: gpoints_are_equal procedure , public :: expand procedure , public :: set_name procedure , public :: get_name end type !>---------------------------------------------------------------------------------------- !> !> Optical properties as arrays, normally dimensioned ncol, nlay, ngpt/nbnd !>   The abstract base class for arrays defines what procedures will be available !>   The optical depth field is also part of the abstract base class, since !>    any representation of values as arrays needs an optical depth field !> !> ------------------------------------------------------------------------------------------------- type , extends ( ty_optical_props ), abstract , public :: ty_optical_props_arry real ( wp ), dimension (:,:,:), allocatable :: tau !! optical depth (ncol, nlay, ngpt) contains procedure , public :: get_ncol procedure , public :: get_nlay !> !> Increment another set of values !> procedure , public :: increment !> !> Deferred procedures -- each must be implemented in each child class with !>   arguments following the abstract interface (defined below) !> procedure ( validate_abstract ), deferred , public :: validate procedure ( delta_scale_abstract ), deferred , public :: delta_scale procedure ( subset_range_abstract ), deferred , public :: get_subset end type !> !> Interfaces for the methods to be implemented !> abstract interface !> !> Validation function looks only at internal data !> function validate_abstract ( this ) result ( err_message ) import ty_optical_props_arry class ( ty_optical_props_arry ), intent ( in ) :: this character ( len = 128 ) :: err_message end function validate_abstract !> !> Delta-scaling !> function delta_scale_abstract ( this , for ) result ( err_message ) import ty_optical_props_arry import wp class ( ty_optical_props_arry ), intent ( inout ) :: this real ( wp ), dimension (:,:,:), optional , & intent ( in ) :: for !> Forward scattering fraction; g**2 if not provided character ( len = 128 ) :: err_message end function delta_scale_abstract !> !> Subsetting -- currently there are only routines with start col and count !> function subset_range_abstract ( full , start , n , subset ) result ( err_message ) import ty_optical_props_arry class ( ty_optical_props_arry ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_optical_props_arry ), intent ( inout ) :: subset character ( 128 ) :: err_message end function subset_range_abstract end interface !>---------------------------------------------------------------------------------------- !> !>   ty_optical_props_arry  includes only (extinction) optical depth !>   Class two-stream adds arrays for single scattering albedo ssa and !>     asymmetry parameter needed in two-stream methods !>   Class n-stream adds arrays for single scattering albedo ssa and !>     phase function moments (index 1 = g) for use with discrete ordinate methods !> !> ------------------------------------------------------------------------------------------------- type , public , extends ( ty_optical_props_arry ) :: ty_optical_props_1scl contains procedure , public :: validate => validate_1scalar procedure , public :: get_subset => subset_1scl_range procedure , public :: delta_scale => delta_scale_1scl procedure , public :: finalize_1scl procedure , private :: alloc_only_1scl procedure , private :: init_and_alloc_1scl procedure , private :: copy_and_alloc_1scl generic , public :: alloc_1scl => alloc_only_1scl , init_and_alloc_1scl , copy_and_alloc_1scl end type ! --- 2 stream ------------------------------------------------------------------------ type , public , extends ( ty_optical_props_arry ) :: ty_optical_props_2str real ( wp ), dimension (:,:,:), allocatable :: ssa !! single-scattering albedo (ncol, nlay, ngpt) real ( wp ), dimension (:,:,:), allocatable :: g !! asymmetry parameter (ncol, nlay, ngpt) contains procedure , public :: validate => validate_2stream procedure , public :: get_subset => subset_2str_range procedure , public :: delta_scale => delta_scale_2str procedure , public :: finalize_2str procedure , private :: alloc_only_2str procedure , private :: init_and_alloc_2str procedure , private :: copy_and_alloc_2str generic , public :: alloc_2str => alloc_only_2str , init_and_alloc_2str , copy_and_alloc_2str end type ! --- n stream ------------------------------------------------------------------------ type , public , extends ( ty_optical_props_arry ) :: ty_optical_props_nstr real ( wp ), dimension (:,:,:), allocatable :: ssa !! single-scattering albedo (ncol, nlay, ngpt) real ( wp ), dimension (:,:,:,:), allocatable :: p !! phase-function moments (nmom, ncol, nlay, ngpt) contains procedure , public :: validate => validate_nstream procedure , public :: get_subset => subset_nstr_range procedure , public :: delta_scale => delta_scale_nstr procedure , public :: get_nmom procedure , public :: finalize_nstr procedure , private :: alloc_only_nstr procedure , private :: init_and_alloc_nstr procedure , private :: copy_and_alloc_nstr generic , public :: alloc_nstr => alloc_only_nstr , init_and_alloc_nstr , copy_and_alloc_nstr end type ! ------------------------------------------------------------------------------------------------- contains ! ------------------------------------------------------------------------------------------------- ! !  Routines for the base class: initialization, validity checking, finalization ! !> ------------------------------------------------------------------------------------------------- !> !> Base class: Initialization !>   Values are assumed to be defined in bands a mapping between bands and g-points is provided !> !> ------------------------------------------------------------------------------------------------- function init_base ( this , band_lims_wvn , band_lims_gpt , name ) result ( err_message ) class ( ty_optical_props ), intent ( inout ) :: this real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn integer , dimension (:,:), & optional , intent ( in ) :: band_lims_gpt character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message integer :: iband integer , dimension ( 2 , size ( band_lims_wvn , 2 )) :: band_lims_gpt_lcl ! ------------------------- ! ! Error checking -- are the arrays the size we expect, contain positive values? ! err_message = \"\" if ( size ( band_lims_wvn , 1 ) /= 2 ) & err_message = \"optical_props%init(): band_lims_wvn 1st dim should be 2\" if ( check_values ) then if ( any_vals_less_than ( band_lims_wvn , 0._wp ) ) & err_message = \"optical_props%init(): band_lims_wvn has values <  0., respectively\" end if if ( err_message /= \"\" ) return if ( present ( band_lims_gpt )) then if ( check_extents ) then if (. not . extents_are ( band_lims_gpt , 2 , size ( band_lims_wvn , 2 ))) & err_message = \"optical_props%init(): band_lims_gpt size inconsistent with band_lims_wvn\" end if if ( check_values ) then if ( any ( band_lims_gpt < 1 ) ) & err_message = \"optical_props%init(): band_lims_gpt has values < 1\" end if if ( err_message /= \"\" ) return band_lims_gpt_lcl (:,:) = band_lims_gpt (:,:) else ! ! Assume that values are defined by band, one g-point per band ! do iband = 1 , size ( band_lims_wvn , 2 ) band_lims_gpt_lcl ( 1 : 2 , iband ) = iband end do end if ! ! Assignment ! if ( allocated ( this % band2gpt )) deallocate ( this % band2gpt ) if ( allocated ( this % band_lims_wvn )) deallocate ( this % band_lims_wvn ) allocate ( this % band2gpt ( 2 , size ( band_lims_wvn , 2 )), & this % band_lims_wvn ( 2 , size ( band_lims_wvn , 2 ))) this % band2gpt = band_lims_gpt_lcl this % band_lims_wvn = band_lims_wvn if ( present ( name )) this % name = trim ( name ) ! ! Make a map between g-points and bands !   Efficient only when g-point indexes start at 1 and are contiguous. ! if ( allocated ( this % gpt2band )) deallocate ( this % gpt2band ) allocate ( this % gpt2band ( maxval ( band_lims_gpt_lcl ))) do iband = 1 , size ( band_lims_gpt_lcl , dim = 2 ) this % gpt2band ( band_lims_gpt_lcl ( 1 , iband ): band_lims_gpt_lcl ( 2 , iband )) = iband end do end function init_base !------------------------------------------------------------------------------------------------- function init_base_from_copy ( this , spectral_desc ) result ( err_message ) class ( ty_optical_props ), intent ( inout ) :: this class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len = 128 ) :: err_message if (. not . spectral_desc % is_initialized ()) then err_message = \"optical_props%init(): can't initialize based on un-initialized input\" return else err_message = this % init ( spectral_desc % get_band_lims_wavenumber (), & spectral_desc % get_band_lims_gpoint ()) end if end function init_base_from_copy !>------------------------------------------------------------------------------------------------- !> !> Base class: return true if initialized, false otherwise !> !> ------------------------------------------------------------------------------------------------- pure function is_initialized_base ( this ) class ( ty_optical_props ), intent ( in ) :: this logical :: is_initialized_base is_initialized_base = allocated ( this % band2gpt ) end function is_initialized_base !>------------------------------------------------------------------------------------------------- !> !> Base class: finalize (deallocate memory) !> !> ------------------------------------------------------------------------------------------------- subroutine finalize_base ( this ) class ( ty_optical_props ), intent ( inout ) :: this if ( allocated ( this % band2gpt )) deallocate ( this % band2gpt ) if ( allocated ( this % gpt2band )) deallocate ( this % gpt2band ) if ( allocated ( this % band_lims_wvn )) & deallocate ( this % band_lims_wvn ) this % name = \"\" end subroutine finalize_base ! ------------------------------------------------------------------------------------------ ! !  Routines for array classes: initialization, allocation, and finalization !    Initialization and allocation can be combined by supplying either ! !> ------------------------------------------------------------------------------------------ !> !> Straight allocation routines !> !> --- 1 scalar ------------------------------------------------------------------------ function alloc_only_1scl ( this , ncol , nlay ) result ( err_message ) class ( ty_optical_props_1scl ) :: this integer , intent ( in ) :: ncol , nlay character ( len = 128 ) :: err_message err_message = \"\" if (. not . this % is_initialized ()) then err_message = \"optical_props%alloc: spectral discretization hasn't been provided\" return end if if ( any ([ ncol , nlay ] <= 0 )) then err_message = \"optical_props%alloc: must provide positive extents for ncol, nlay\" else if ( allocated ( this % tau )) deallocate ( this % tau ) allocate ( this % tau ( ncol , nlay , this % get_ngpt ())) end if end function alloc_only_1scl !> --- 2 stream ------------------------------------------------------------------------ function alloc_only_2str ( this , ncol , nlay ) result ( err_message ) class ( ty_optical_props_2str ) :: this integer , intent ( in ) :: ncol , nlay character ( len = 128 ) :: err_message err_message = \"\" if (. not . this % is_initialized ()) & err_message = \"optical_props%alloc: spectral discretization hasn't been provided\" if ( any ([ ncol , nlay ] <= 0 )) & err_message = \"optical_props%alloc: must provide positive extents for ncol, nlay\" if ( err_message /= \"\" ) return if ( allocated ( this % tau )) deallocate ( this % tau ) allocate ( this % tau ( ncol , nlay , this % get_ngpt ())) if ( allocated ( this % ssa )) deallocate ( this % ssa ) if ( allocated ( this % g )) deallocate ( this % g ) allocate ( this % ssa ( ncol , nlay , this % get_ngpt ()), this % g ( ncol , nlay , this % get_ngpt ())) end function alloc_only_2str !> --- n stream ------------------------------------------------------------------------ function alloc_only_nstr ( this , nmom , ncol , nlay ) result ( err_message ) class ( ty_optical_props_nstr ) :: this integer , intent ( in ) :: nmom ! number of moments integer , intent ( in ) :: ncol , nlay character ( len = 128 ) :: err_message err_message = \"\" if (. not . this % is_initialized ()) & err_message = \"optical_props%alloc: spectral discretization hasn't been provided\" if ( any ([ ncol , nlay ] <= 0 )) & err_message = \"optical_props%alloc: must provide positive extents for ncol, nlay\" if ( err_message /= \"\" ) return if ( allocated ( this % tau )) deallocate ( this % tau ) allocate ( this % tau ( ncol , nlay , this % get_ngpt ())) if ( allocated ( this % ssa )) deallocate ( this % ssa ) if ( allocated ( this % p )) deallocate ( this % p ) allocate ( this % ssa ( ncol , nlay , this % get_ngpt ()), this % p ( nmom , ncol , nlay , this % get_ngpt ())) end function alloc_only_nstr ! ------------------------------------------------------------------------------------------ ! ! Combined allocation/initialization routines ! !> ------------------------------------------------------------------------------------------ !> !> Initialization by specifying band limits and possibly g-point/band mapping !> !> --------------------------------------------------------------------------- function init_and_alloc_1scl ( this , ncol , nlay , band_lims_wvn , band_lims_gpt , name ) result ( err_message ) class ( ty_optical_props_1scl ) :: this integer , intent ( in ) :: ncol , nlay real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn integer , dimension (:,:), & optional , intent ( in ) :: band_lims_gpt character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = this % ty_optical_props % init ( band_lims_wvn , & band_lims_gpt , name ) if ( err_message /= \"\" ) return err_message = this % alloc_1scl ( ncol , nlay ) end function init_and_alloc_1scl ! --------------------------------------------------------------------------- function init_and_alloc_2str ( this , ncol , nlay , band_lims_wvn , band_lims_gpt , name ) result ( err_message ) class ( ty_optical_props_2str ) :: this integer , intent ( in ) :: ncol , nlay real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn integer , dimension (:,:), & optional , intent ( in ) :: band_lims_gpt character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = this % ty_optical_props % init ( band_lims_wvn , & band_lims_gpt , name ) if ( err_message /= \"\" ) return err_message = this % alloc_2str ( ncol , nlay ) end function init_and_alloc_2str ! --------------------------------------------------------------------------- function init_and_alloc_nstr ( this , nmom , ncol , nlay , band_lims_wvn , band_lims_gpt , name ) result ( err_message ) class ( ty_optical_props_nstr ) :: this integer , intent ( in ) :: nmom , ncol , nlay real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn integer , dimension (:,:), & optional , intent ( in ) :: band_lims_gpt character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = this % ty_optical_props % init ( band_lims_wvn , & band_lims_gpt , name ) if ( err_message /= \"\" ) return err_message = this % alloc_nstr ( nmom , ncol , nlay ) end function init_and_alloc_nstr !>------------------------------------------------------------------------------------------------- !> !> Initialization from an existing spectral discretization/ty_optical_props !> !>------------------------------------------------------------------------------------------------- function copy_and_alloc_1scl ( this , ncol , nlay , spectral_desc , name ) result ( err_message ) class ( ty_optical_props_1scl ) :: this integer , intent ( in ) :: ncol , nlay class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = \"\" if ( this % ty_optical_props % is_initialized ()) call this % ty_optical_props % finalize () err_message = this % ty_optical_props % init ( spectral_desc % get_band_lims_wavenumber (), & spectral_desc % get_band_lims_gpoint (), name ) if ( err_message /= \"\" ) return err_message = this % alloc_1scl ( ncol , nlay ) end function copy_and_alloc_1scl ! --------------------------------------------------------------------------- function copy_and_alloc_2str ( this , ncol , nlay , spectral_desc , name ) result ( err_message ) class ( ty_optical_props_2str ) :: this integer , intent ( in ) :: ncol , nlay class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = \"\" if ( this % ty_optical_props % is_initialized ()) call this % ty_optical_props % finalize () err_message = this % ty_optical_props % init ( spectral_desc % get_band_lims_wavenumber (), & spectral_desc % get_band_lims_gpoint (), name ) if ( err_message /= \"\" ) return err_message = this % alloc_2str ( ncol , nlay ) end function copy_and_alloc_2str ! --------------------------------------------------------------------------- function copy_and_alloc_nstr ( this , nmom , ncol , nlay , spectral_desc , name ) result ( err_message ) class ( ty_optical_props_nstr ) :: this integer , intent ( in ) :: nmom , ncol , nlay class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = \"\" if ( this % ty_optical_props % is_initialized ()) call this % ty_optical_props % finalize () err_message = this % ty_optical_props % init ( spectral_desc % get_band_lims_wavenumber (), & spectral_desc % get_band_lims_gpoint (), name ) if ( err_message /= \"\" ) return err_message = this % alloc_nstr ( nmom , ncol , nlay ) end function copy_and_alloc_nstr !> ------------------------------------------------------------------------------------------ !> !> Finalize routines !> !> ------------------------------------------------------------------------------------------ function finalize_1scl ( this ) result ( err_message ) class ( ty_optical_props_1scl ) :: this character ( len = 128 ) :: err_message if ( allocated ( this % tau )) deallocate ( this % tau ) err_message = \"\" end function finalize_1scl ! --------------------------------------------------------------------------- function finalize_2str ( this ) result ( err_message ) class ( ty_optical_props_2str ) :: this character ( len = 128 ) :: err_message if ( allocated ( this % tau )) deallocate ( this % tau ) if ( allocated ( this % ssa )) deallocate ( this % ssa ) if ( allocated ( this % g )) deallocate ( this % g ) err_message = \"\" end function finalize_2str ! --------------------------------------------------------------------------- function finalize_nstr ( this ) result ( err_message ) class ( ty_optical_props_nstr ) :: this character ( len = 128 ) :: err_message if ( allocated ( this % tau )) deallocate ( this % tau ) if ( allocated ( this % ssa )) deallocate ( this % ssa ) if ( allocated ( this % p )) deallocate ( this % p ) err_message = \"\" end function finalize_nstr ! ------------------------------------------------------------------------------------------ ! !  Routines for array classes: delta-scaling, validation (ensuring all values can be used ) ! !> ------------------------------------------------------------------------------------------ !> --- delta scaling !> ------------------------------------------------------------------------------------------ function delta_scale_1scl ( this , for ) result ( err_message ) class ( ty_optical_props_1scl ), intent ( inout ) :: this real ( wp ), dimension (:,:,:), optional , & intent ( in ) :: for character ( 128 ) :: err_message ! ! Nothing to do ! err_message = \"\" end function delta_scale_1scl ! ------------------------------------------------------------------------------------------ function delta_scale_2str ( this , for ) result ( err_message ) class ( ty_optical_props_2str ), intent ( inout ) :: this real ( wp ), dimension (:,:,:), optional , & intent ( in ) :: for !! Forward scattering fraction; g**2 if not provided character ( 128 ) :: err_message integer :: ncol , nlay , ngpt ! -------------------------------- ncol = this % get_ncol () nlay = this % get_nlay () ngpt = this % get_ngpt () err_message = \"\" if ( present ( for )) then if ( check_extents ) then if (. not . extents_are ( for , ncol , nlay , ngpt )) then err_message = \"delta_scale: dimension of 'for' don't match optical properties arrays\" return end if end if if ( check_values ) then if ( any_vals_outside ( for , 0._wp , 1._wp )) then err_message = \"delta_scale: values of 'for' out of bounds [0,1]\" return end if end if call delta_scale_2str_kernel ( ncol , nlay , ngpt , this % tau , this % ssa , this % g , for ) else call delta_scale_2str_kernel ( ncol , nlay , ngpt , this % tau , this % ssa , this % g ) end if end function delta_scale_2str ! ------------------------------------------------------------------------------------------ function delta_scale_nstr ( this , for ) result ( err_message ) class ( ty_optical_props_nstr ), intent ( inout ) :: this real ( wp ), dimension (:,:,:), optional , & intent ( in ) :: for character ( 128 ) :: err_message err_message = 'delta_scale_nstr: Not yet implemented' end function delta_scale_nstr !> ------------------------------------------------------------------------------------------ !> !> --- Validation !> !> ------------------------------------------------------------------------------------------ function validate_1scalar ( this ) result ( err_message ) class ( ty_optical_props_1scl ), intent ( in ) :: this character ( len = 128 ) :: err_message err_message = '' if (. not . allocated ( this % tau )) then err_message = \"validate: tau not allocated/initialized\" return end if if ( check_values ) then if ( any_vals_less_than ( this % tau , 0._wp )) & err_message = \"validate: tau values out of range\" end if if ( len_trim ( err_message ) > 0 . and . len_trim ( this % get_name ()) > 0 ) & err_message = trim ( this % get_name ()) // ': ' // trim ( err_message ) end function validate_1scalar ! ------------------------------------------------------------------------------------------ function validate_2stream ( this ) result ( err_message ) class ( ty_optical_props_2str ), intent ( in ) :: this character ( len = 128 ) :: err_message integer :: d1 , d2 , d3 err_message = '' ! ! Array allocation status, sizing ! if ( check_extents ) then if (. not . all ([ allocated ( this % tau ), allocated ( this % ssa ), allocated ( this % g )])) then err_message = \"validate: arrays not allocated/initialized\" return end if d1 = size ( this % tau , 1 ) d2 = size ( this % tau , 2 ) d3 = size ( this % tau , 3 ) if (. not . extents_are ( this % ssa , d1 , d2 , d3 ) . or . & . not . extents_are ( this % g , d1 , d2 , d3 )) & err_message = \"validate: arrays not sized consistently\" end if ! ! Valid values ! if ( check_values ) then if ( any_vals_less_than ( this % tau , 0._wp )) & err_message = \"validate: tau values out of range\" if ( any_vals_outside ( this % ssa , 0._wp , 1._wp )) & err_message = \"validate: ssa values out of range\" if ( any_vals_outside ( this % g , - 1._wp , 1._wp )) & err_message = \"validate: g values out of range\" end if if ( len_trim ( err_message ) > 0 . and . len_trim ( this % get_name ()) > 0 ) & err_message = trim ( this % get_name ()) // ': ' // trim ( err_message ) end function validate_2stream ! ------------------------------------------------------------------------------------------ function validate_nstream ( this ) result ( err_message ) class ( ty_optical_props_nstr ), intent ( in ) :: this character ( len = 128 ) :: err_message integer :: d1 , d2 , d3 , d4 err_message = '' ! ! Array allocation status, sizing ! if (. not . all ([ allocated ( this % tau ), allocated ( this % ssa ), allocated ( this % p )])) then err_message = \"validate: arrays not allocated/initialized\" return end if d1 = size ( this % tau , 1 ) d2 = size ( this % tau , 2 ) d3 = size ( this % tau , 3 ) d4 = size ( this % p , 1 ) if ( check_extents ) then if (. not . extents_are ( this % ssa , d1 , d2 , d3 ) . or . & . not . extents_are ( this % p , d4 , d1 , d2 , d3 )) & err_message = \"validate: arrays not sized consistently\" end if ! ! Valid values ! if ( check_values ) then if ( any_vals_less_than ( this % tau , 0._wp )) & err_message = \"validate: tau values out of range\" if ( any_vals_outside ( this % ssa , 0._wp , 1._wp )) & err_message = \"validate: ssa values out of range\" if ( any_vals_outside ( this % p ( 1 ,:,:,:), - 1._wp , 1._wp )) & err_message = \"validate: p(1,:,:,:)  = g values out of range\" end if if ( len_trim ( err_message ) > 0 . and . len_trim ( this % get_name ()) > 0 ) & err_message = trim ( this % get_name ()) // ': ' // trim ( err_message ) end function validate_nstream !> ------------------------------------------------------------------------------------------ !> !>  Routines for array classes: subsetting of optical properties arrays along x (col) direction !> !> Allocate class, then arrays; copy. Could probably be more efficient if !>   classes used pointers internally. !> !> This set takes start position and number as scalars !> !> ------------------------------------------------------------------------------------------ function subset_1scl_range ( full , start , n , subset ) result ( err_message ) class ( ty_optical_props_1scl ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_optical_props_arry ), intent ( inout ) :: subset character ( 128 ) :: err_message integer :: ncol , nlay , ngpt , nmom err_message = \"\" if (. not . full % is_initialized ()) then err_message = \"optical_props%subset: Asking for a subset of uninitialized data\" return end if ncol = full % get_ncol () nlay = full % get_nlay () ngpt = full % get_ngpt () if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return if ( subset % is_initialized ()) call subset % finalize () err_message = subset % init ( full ) ! Seems like the deallocation statements should be needed under Fortran 2003 !   but Intel compiler doesn't run without them if ( allocated ( subset % tau )) deallocate ( subset % tau ) select type ( subset ) class is ( ty_optical_props_1scl ) err_message = subset % alloc_1scl ( n , nlay ) if ( err_message /= \"\" ) return class is ( ty_optical_props_2str ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % g )) deallocate ( subset % g ) err_message = subset % alloc_2str ( n , nlay ) if ( err_message /= \"\" ) return subset % ssa ( 1 : n ,:,:) = 0._wp subset % g ( 1 : n ,:,:) = 0._wp class is ( ty_optical_props_nstr ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % p )) then nmom = subset % get_nmom () deallocate ( subset % p ) else nmom = 1 end if err_message = subset % alloc_nstr ( nmom , n , nlay ) if ( err_message /= \"\" ) return subset % ssa ( 1 : n ,:,:) = 0._wp subset % p (:, 1 : n ,:,:) = 0._wp end select call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) end function subset_1scl_range ! ------------------------------------------------------------------------------------------ function subset_2str_range ( full , start , n , subset ) result ( err_message ) class ( ty_optical_props_2str ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_optical_props_arry ), intent ( inout ) :: subset character ( 128 ) :: err_message integer :: ncol , nlay , ngpt , nmom err_message = \"\" if (. not . full % is_initialized ()) then err_message = \"optical_props%subset: Asking for a subset of uninitialized data\" return end if ncol = full % get_ncol () nlay = full % get_nlay () ngpt = full % get_ngpt () if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return if ( subset % is_initialized ()) call subset % finalize () err_message = subset % init ( full ) select type ( subset ) class is ( ty_optical_props_1scl ) err_message = subset % alloc_1scl ( n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , full % ssa , start , start + n - 1 , subset % tau ) class is ( ty_optical_props_2str ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % g )) deallocate ( subset % g ) err_message = subset % alloc_2str ( n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) call extract_subset ( ncol , nlay , ngpt , full % ssa , start , start + n - 1 , subset % ssa ) call extract_subset ( ncol , nlay , ngpt , full % g , start , start + n - 1 , subset % g ) class is ( ty_optical_props_nstr ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % p )) then nmom = subset % get_nmom () deallocate ( subset % p ) else nmom = 1 end if err_message = subset % alloc_nstr ( nmom , n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) call extract_subset ( ncol , nlay , ngpt , full % ssa , start , start + n - 1 , subset % ssa ) subset % p ( 1 , 1 : n ,:,:) = full % g ( start : start + n - 1 ,:,:) subset % p ( 2 :,:, :,:) = 0._wp end select end function subset_2str_range ! ------------------------------------------------------------------------------------------ function subset_nstr_range ( full , start , n , subset ) result ( err_message ) class ( ty_optical_props_nstr ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_optical_props_arry ), intent ( inout ) :: subset character ( 128 ) :: err_message integer :: ncol , nlay , ngpt , nmom err_message = \"\" if (. not . full % is_initialized ()) then err_message = \"optical_props%subset: Asking for a subset of uninitialized data\" return end if ncol = full % get_ncol () nlay = full % get_nlay () ngpt = full % get_ngpt () if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return if ( subset % is_initialized ()) call subset % finalize () err_message = subset % init ( full ) if ( allocated ( subset % tau )) deallocate ( subset % tau ) select type ( subset ) class is ( ty_optical_props_1scl ) err_message = subset % alloc_1scl ( n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , full % ssa , start , start + n - 1 , subset % tau ) class is ( ty_optical_props_2str ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % g )) deallocate ( subset % g ) err_message = subset % alloc_2str ( n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) call extract_subset ( ncol , nlay , ngpt , full % ssa , start , start + n - 1 , subset % ssa ) subset % g ( 1 : n ,:,:) = full % p ( 1 , start : start + n - 1 ,:,:) class is ( ty_optical_props_nstr ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % p )) deallocate ( subset % p ) err_message = subset % alloc_nstr ( nmom , n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) call extract_subset ( ncol , nlay , ngpt , full % ssa , start , start + n - 1 , subset % ssa ) call extract_subset ( nmom , ncol , nlay , ngpt , full % p , start , start + n - 1 , subset % p ) end select end function subset_nstr_range !> ------------------------------------------------------------------------------------------ !> !>  Routines for array classes: incrementing !>   a%increment(b) adds the values of a to b, changing b and leaving a untouched !> !> ----------------------------------------------------------------------------------------- function increment ( op_in , op_io ) result ( err_message ) class ( ty_optical_props_arry ), intent ( in ) :: op_in class ( ty_optical_props_arry ), intent ( inout ) :: op_io character ( 128 ) :: err_message ! ----- integer :: ncol , nlay , ngpt ! ----- err_message = \"\" if (. not . op_in % is_initialized ()) & err_message = \"ty_optical_props%increment: Incrementing optical properties aren't initialized\" if (. not . op_in % is_initialized ()) & err_message = \"ty_optical_props%increment: optical properties to be incremented aren't initialized\" if ( err_message /= \"\" ) return ncol = op_io % get_ncol () nlay = op_io % get_nlay () ngpt = op_io % get_ngpt () if (. not . op_in % bands_are_equal ( op_io )) & err_message = \"ty_optical_props%increment: optical properties objects have different band structures\" if (. not . all ([ op_in % get_ncol (), op_in % get_nlay ()] == [ ncol , nlay ])) & err_message = \"ty_optical_props%increment: optical properties objects have different ncol and/or nlay\" if ( err_message /= \"\" ) return if ( op_in % gpoints_are_equal ( op_io )) then ! ! Increment by gpoint !   (or by band if both op_in and op_io are defined that way) ! select type ( op_io ) class is ( ty_optical_props_1scl ) select type ( op_in ) class is ( ty_optical_props_1scl ) call increment_1scalar_by_1scalar ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau ) class is ( ty_optical_props_2str ) call increment_1scalar_by_2stream ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , op_in % ssa ) class is ( ty_optical_props_nstr ) call increment_1scalar_by_nstream ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , op_in % ssa ) end select class is ( ty_optical_props_2str ) select type ( op_in ) class is ( ty_optical_props_1scl ) call increment_2stream_by_1scalar ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa ,& op_in % tau ) class is ( ty_optical_props_2str ) call increment_2stream_by_2stream ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , op_io % g , & op_in % tau , op_in % ssa , op_in % g ) class is ( ty_optical_props_nstr ) call increment_2stream_by_nstream ( ncol , nlay , ngpt , op_in % get_nmom (), & op_io % tau , op_io % ssa , op_io % g , & op_in % tau , op_in % ssa , op_in % p ) end select class is ( ty_optical_props_nstr ) select type ( op_in ) class is ( ty_optical_props_1scl ) call increment_nstream_by_1scalar ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , & op_in % tau ) class is ( ty_optical_props_2str ) call increment_nstream_by_2stream ( ncol , nlay , ngpt , op_io % get_nmom (), & op_io % tau , op_io % ssa , op_io % p , & op_in % tau , op_in % ssa , op_in % g ) class is ( ty_optical_props_nstr ) call increment_nstream_by_nstream ( ncol , nlay , ngpt , op_io % get_nmom (), op_in % get_nmom (), & op_io % tau , op_io % ssa , op_io % p , & op_in % tau , op_in % ssa , op_in % p ) end select end select else ! ! Values defined by-band will have ngpt() = nband() ! We can use values by band in op_in to increment op_io !   Anything else is an error ! if ( op_in % get_ngpt () /= op_io % get_nband ()) then err_message = \"ty_optical_props%increment: optical properties objects have incompatible g-point structures\" return end if ! ! Increment by band ! select type ( op_io ) class is ( ty_optical_props_1scl ) select type ( op_in ) class is ( ty_optical_props_1scl ) call inc_1scalar_by_1scalar_bybnd ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_2str ) call inc_1scalar_by_2stream_bybnd ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , op_in % ssa , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_nstr ) call inc_1scalar_by_nstream_bybnd ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , op_in % ssa , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) end select class is ( ty_optical_props_2str ) select type ( op_in ) class is ( ty_optical_props_1scl ) call inc_2stream_by_1scalar_bybnd ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , & op_in % tau , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_2str ) call inc_2stream_by_2stream_bybnd ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , op_io % g , & op_in % tau , op_in % ssa , op_in % g , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_nstr ) call inc_2stream_by_nstream_bybnd ( ncol , nlay , ngpt , op_in % get_nmom (), & op_io % tau , op_io % ssa , op_io % g , & op_in % tau , op_in % ssa , op_in % p , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) end select class is ( ty_optical_props_nstr ) select type ( op_in ) class is ( ty_optical_props_1scl ) call inc_nstream_by_1scalar_bybnd ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , & op_in % tau , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_2str ) call inc_nstream_by_2stream_bybnd ( ncol , nlay , ngpt , op_io % get_nmom (), & op_io % tau , op_io % ssa , op_io % p , & op_in % tau , op_in % ssa , op_in % g , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_nstr ) call inc_nstream_by_nstream_bybnd ( ncol , nlay , ngpt , op_io % get_nmom (), op_in % get_nmom (), & op_io % tau , op_io % ssa , op_io % p , & op_in % tau , op_in % ssa , op_in % p , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) end select end select end if end function increment !> ----------------------------------------------------------------------------------------------- !> !>  Routines for array classes: problem sizes !> !> ----------------------------------------------------------------------------------------------- pure function get_arry_extent ( this , dim ) class ( ty_optical_props_arry ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: get_arry_extent if ( allocated ( this % tau )) then get_arry_extent = size ( this % tau , dim ) else get_arry_extent = 0 end if end function get_arry_extent ! ------------------------------------------------------------------------------------------ pure function get_ncol ( this ) class ( ty_optical_props_arry ), intent ( in ) :: this integer :: get_ncol get_ncol = get_arry_extent ( this , 1 ) end function get_ncol ! ------------------------------------------------------------------------------------------ pure function get_nlay ( this ) class ( ty_optical_props_arry ), intent ( in ) :: this integer :: get_nlay get_nlay = get_arry_extent ( this , 2 ) end function get_nlay ! ------------------------------------------------------------------------------------------ pure function get_nmom ( this ) class ( ty_optical_props_nstr ), intent ( in ) :: this integer :: get_nmom if ( allocated ( this % p )) then get_nmom = size ( this % p , 1 ) else get_nmom = 0 end if end function get_nmom ! ----------------------------------------------------------------------------------------------- ! !  Routines for base class: spectral discretization ! !> ----------------------------------------------------------------------------------------------- !> !> Number of bands !> pure function get_nband ( this ) class ( ty_optical_props ), intent ( in ) :: this integer :: get_nband if ( this % is_initialized ()) then get_nband = size ( this % band2gpt , dim = 2 ) else get_nband = 0 end if end function get_nband !> ----------------------------------------------------------------------------------------------- !> !> Number of g-points !> pure function get_ngpt ( this ) class ( ty_optical_props ), intent ( in ) :: this integer :: get_ngpt if ( this % is_initialized ()) then get_ngpt = maxval ( this % band2gpt ) else get_ngpt = 0 end if end function get_ngpt !>-------------------------------------------------------------------------------------------------------------------- !> !> The first and last g-point of all bands at once !> dimension (2, nbands) !> pure function get_band_lims_gpoint ( this ) class ( ty_optical_props ), intent ( in ) :: this integer , dimension ( size ( this % band2gpt , dim = 1 ), size ( this % band2gpt , dim = 2 )) & :: get_band_lims_gpoint get_band_lims_gpoint = this % band2gpt end function get_band_lims_gpoint !>-------------------------------------------------------------------------------------------------------------------- !> !> First and last g-point of a specific band !> pure function convert_band2gpt ( this , band ) class ( ty_optical_props ), intent ( in ) :: this integer , intent ( in ) :: band integer , dimension ( 2 ) :: convert_band2gpt if ( this % is_initialized ()) then convert_band2gpt (:) = this % band2gpt (:, band ) else convert_band2gpt (:) = 0 end if end function convert_band2gpt !>-------------------------------------------------------------------------------------------------------------------- !> !> Lower and upper wavenumber of all bands !> (upper and lower wavenumber by band) = band_lims_wvn(2,band) !> pure function get_band_lims_wavenumber ( this ) class ( ty_optical_props ), intent ( in ) :: this real ( wp ), dimension ( size ( this % band_lims_wvn , 1 ), size ( this % band_lims_wvn , 2 )) & :: get_band_lims_wavenumber if ( this % is_initialized ()) then get_band_lims_wavenumber (:,:) = this % band_lims_wvn (:,:) else get_band_lims_wavenumber (:,:) = 0._wp end if end function get_band_lims_wavenumber !>-------------------------------------------------------------------------------------------------------------------- !> !> Lower and upper wavelength of all bands !> pure function get_band_lims_wavelength ( this ) class ( ty_optical_props ), intent ( in ) :: this real ( wp ), dimension ( size ( this % band_lims_wvn , 1 ), size ( this % band_lims_wvn , 2 )) & :: get_band_lims_wavelength if ( this % is_initialized ()) then get_band_lims_wavelength (:,:) = 1._wp / this % band_lims_wvn (:,:) else get_band_lims_wavelength (:,:) = 0._wp end if end function get_band_lims_wavelength !>-------------------------------------------------------------------------------------------------------------------- !> Bands for all the g-points at once !> dimension (ngpt) !> pure function get_gpoint_bands ( this ) class ( ty_optical_props ), intent ( in ) :: this integer , dimension ( size ( this % gpt2band , dim = 1 )) & :: get_gpoint_bands if ( this % is_initialized ()) then get_gpoint_bands (:) = this % gpt2band (:) else get_gpoint_bands (:) = 0 end if end function get_gpoint_bands !>-------------------------------------------------------------------------------------------------------------------- !> !> Band associated with a specific g-point !> pure function convert_gpt2band ( this , gpt ) class ( ty_optical_props ), intent ( in ) :: this integer , intent ( in ) :: gpt integer :: convert_gpt2band if ( this % is_initialized ()) then convert_gpt2band = this % gpt2band ( gpt ) else convert_gpt2band = 0 end if end function convert_gpt2band !>-------------------------------------------------------------------------------------------------------------------- !> !> Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) !> pure function expand ( this , arr_in ) result ( arr_out ) class ( ty_optical_props ), intent ( in ) :: this real ( wp ), dimension (:), intent ( in ) :: arr_in ! (nband) real ( wp ), dimension ( size ( this % gpt2band )) :: arr_out integer :: iband do iband = 1 , this % get_nband () arr_out ( this % band2gpt ( 1 , iband ): this % band2gpt ( 2 , iband )) = arr_in ( iband ) end do end function expand !>-------------------------------------------------------------------------------------------------------------------- !> !> Are the bands of two objects the same? (same number, same wavelength limits) !> pure function bands_are_equal ( this , that ) class ( ty_optical_props ), intent ( in ) :: this , that logical :: bands_are_equal bands_are_equal = this % get_nband () == that % get_nband () . and . & this % get_nband () > 0 if (. not . bands_are_equal ) return bands_are_equal = & all ( abs ( this % get_band_lims_wavenumber () - that % get_band_lims_wavenumber ()) < & 5._wp * spacing ( this % get_band_lims_wavenumber ())) end function bands_are_equal !>-------------------------------------------------------------------------------------------------------------------- !> !> Is the g-point structure of two objects the same? !>   (same bands, same number of g-points, same mapping between bands and g-points) !> pure function gpoints_are_equal ( this , that ) class ( ty_optical_props ), intent ( in ) :: this , that logical :: gpoints_are_equal gpoints_are_equal = this % bands_are_equal ( that ) . and . & this % get_ngpt () == that % get_ngpt () if (. not . gpoints_are_equal ) return gpoints_are_equal = & all ( this % get_gpoint_bands () == that % get_gpoint_bands ()) end function gpoints_are_equal !> ----------------------------------------------------------------------------------------------- !> !> --- Setting/getting the name !> !> ----------------------------------------------------------------------------------------------- subroutine set_name ( this , name ) class ( ty_optical_props ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: name this % name = trim ( name ) end subroutine set_name ! -------------------------------------------------------- function get_name ( this ) class ( ty_optical_props ), intent ( in ) :: this character ( len = name_len ) :: get_name get_name = trim ( this % name ) end function get_name ! ------------------------------------------------------------------------------------------ end module mo_optical_props","tags":"","loc":"sourcefile/mo_optical_props.f90.html"},{"title":"mo_source_functions.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_source_functions.f90~~EfferentGraph sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_source_functions.f90~~AfferentGraph sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_source_functions Source Code mo_source_functions.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Encapsulate source function arrays for longwave/lw/internal sources !    and shortwave/sw/external source. ! ! ------------------------------------------------------------------------------------------------- module mo_source_functions use mo_rte_kind , only : wp use mo_optical_props , only : ty_optical_props implicit none ! ------------------------------------------------------------------------------------------------- ! ! Type for longwave sources: computed at layer center, at layer edges using !   spectral mapping in each direction separately, and at the surface ! type , extends ( ty_optical_props ), public :: ty_source_func_lw real ( wp ), allocatable , dimension (:,:,:) :: lay_source , & ! Planck source at layer average temperature ! [W/m2] (ncol, nlay, ngpt) lev_source_inc , & ! Planck source at layer edge, lev_source_dec ! [W/m2] (ncol, nlay, ngpt) ! in increasing/decreasing ilay direction ! Includes spectral weighting that accounts for state-dependent ! frequency to g-space mapping real ( wp ), allocatable , dimension (:,: ) :: sfc_source real ( wp ), allocatable , dimension (:,: ) :: sfc_source_Jac ! surface source Jacobian contains generic , public :: alloc => alloc_lw , copy_and_alloc_lw procedure , private :: alloc_lw procedure , private :: copy_and_alloc_lw procedure , public :: is_allocated => is_allocated_lw procedure , public :: finalize => finalize_lw procedure , public :: get_subset => get_subset_range_lw procedure , public :: get_ncol => get_ncol_lw procedure , public :: get_nlay => get_nlay_lw ! validate? end type ty_source_func_lw ! ------------------------------------------------------------------------------------------------- ! ! Type for shortave sources: top-of-domain spectrally-resolved flux ! type , extends ( ty_optical_props ), public :: ty_source_func_sw real ( wp ), allocatable , dimension (:,: ) :: toa_source contains generic , public :: alloc => alloc_sw , copy_and_alloc_sw procedure , private :: alloc_sw procedure , private :: copy_and_alloc_sw procedure , public :: is_allocated => is_allocated_sw procedure , public :: finalize => finalize_sw procedure , public :: get_subset => get_subset_range_sw procedure , public :: get_ncol => get_ncol_sw ! validate? end type ty_source_func_sw ! ------------------------------------------------------------------------------------------------- contains ! ------------------------------------------------------------------------------------------ ! !  Routines for initialization, validity checking, finalization ! ! ------------------------------------------------------------------------------------------ ! ! Longwave ! ! ------------------------------------------------------------------------------------------ pure function is_allocated_lw ( this ) class ( ty_source_func_lw ), intent ( in ) :: this logical :: is_allocated_lw is_allocated_lw = this % is_initialized () . and . & allocated ( this % sfc_source ) end function is_allocated_lw ! -------------------------------------------------------------- function alloc_lw ( this , ncol , nlay ) result ( err_message ) class ( ty_source_func_lw ), intent ( inout ) :: this integer , intent ( in ) :: ncol , nlay character ( len = 128 ) :: err_message integer :: ngpt err_message = \"\" if (. not . this % is_initialized ()) & err_message = \"source_func_lw%alloc: not initialized so can't allocate\" if ( any ([ ncol , nlay ] <= 0 )) & err_message = \"source_func_lw%alloc: must provide positive extents for ncol, nlay\" if ( err_message /= \"\" ) return if ( allocated ( this % sfc_source )) deallocate ( this % sfc_source ) if ( allocated ( this % sfc_source_Jac )) deallocate ( this % sfc_source_Jac ) if ( allocated ( this % lay_source )) deallocate ( this % lay_source ) if ( allocated ( this % lev_source_inc )) deallocate ( this % lev_source_inc ) if ( allocated ( this % lev_source_dec )) deallocate ( this % lev_source_dec ) ngpt = this % get_ngpt () allocate ( this % sfc_source ( ncol , ngpt ), this % lay_source ( ncol , nlay , ngpt ), & this % lev_source_inc ( ncol , nlay , ngpt ), this % lev_source_dec ( ncol , nlay , ngpt )) allocate ( this % sfc_source_Jac ( ncol , ngpt )) end function alloc_lw ! -------------------------------------------------------------- function copy_and_alloc_lw ( this , ncol , nlay , spectral_desc ) result ( err_message ) class ( ty_source_func_lw ), intent ( inout ) :: this integer , intent ( in ) :: ncol , nlay class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len = 128 ) :: err_message err_message = \"\" if (. not . spectral_desc % is_initialized ()) then err_message = \"source_func_lw%alloc: spectral_desc not initialized\" return end if call this % finalize () err_message = this % init ( spectral_desc ) if ( err_message /= \"\" ) return err_message = this % alloc ( ncol , nlay ) end function copy_and_alloc_lw ! ------------------------------------------------------------------------------------------ ! ! Shortwave ! ! ------------------------------------------------------------------------------------------ pure function is_allocated_sw ( this ) class ( ty_source_func_sw ), intent ( in ) :: this logical :: is_allocated_sw is_allocated_sw = this % ty_optical_props % is_initialized () . and . & allocated ( this % toa_source ) end function is_allocated_sw ! -------------------------------------------------------------- function alloc_sw ( this , ncol ) result ( err_message ) class ( ty_source_func_sw ), intent ( inout ) :: this integer , intent ( in ) :: ncol character ( len = 128 ) :: err_message err_message = \"\" if (. not . this % is_initialized ()) & err_message = \"source_func_sw%alloc: not initialized so can't allocate\" if ( ncol <= 0 ) & err_message = \"source_func_sw%alloc: must provide positive extents for ncol\" if ( err_message /= \"\" ) return if ( allocated ( this % toa_source )) deallocate ( this % toa_source ) allocate ( this % toa_source ( ncol , this % get_ngpt ())) end function alloc_sw ! -------------------------------------------------------------- function copy_and_alloc_sw ( this , ncol , spectral_desc ) result ( err_message ) class ( ty_source_func_sw ), intent ( inout ) :: this integer , intent ( in ) :: ncol class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len = 128 ) :: err_message err_message = \"\" if (. not . spectral_desc % is_initialized ()) then err_message = \"source_func_sw%alloc: spectral_desc not initialized\" return end if err_message = this % init ( spectral_desc ) if ( err_message /= \"\" ) return err_message = this % alloc ( ncol ) end function copy_and_alloc_sw ! ------------------------------------------------------------------------------------------ ! ! Finalization (memory deallocation) ! ! ------------------------------------------------------------------------------------------ subroutine finalize_lw ( this ) class ( ty_source_func_lw ), intent ( inout ) :: this if ( allocated ( this % lay_source )) deallocate ( this % lay_source ) if ( allocated ( this % lev_source_inc )) deallocate ( this % lev_source_inc ) if ( allocated ( this % lev_source_dec )) deallocate ( this % lev_source_dec ) if ( allocated ( this % sfc_source )) deallocate ( this % sfc_source ) if ( allocated ( this % sfc_source_Jac )) deallocate ( this % sfc_source_Jac ) call this % ty_optical_props % finalize () end subroutine finalize_lw ! -------------------------------------------------------------- subroutine finalize_sw ( this ) class ( ty_source_func_sw ), intent ( inout ) :: this if ( allocated ( this % toa_source )) deallocate ( this % toa_source ) call this % ty_optical_props % finalize () end subroutine finalize_sw ! ------------------------------------------------------------------------------------------ ! !  Routines for finding the problem size ! ! ------------------------------------------------------------------------------------------ pure function get_ncol_lw ( this ) class ( ty_source_func_lw ), intent ( in ) :: this integer :: get_ncol_lw if ( this % is_allocated ()) then get_ncol_lw = size ( this % lay_source , 1 ) else get_ncol_lw = 0 end if end function get_ncol_lw ! -------------------------------------------------------------- pure function get_nlay_lw ( this ) class ( ty_source_func_lw ), intent ( in ) :: this integer :: get_nlay_lw if ( this % is_allocated ()) then get_nlay_lw = size ( this % lay_source , 2 ) else get_nlay_lw = 0 end if end function get_nlay_lw ! -------------------------------------------------------------- pure function get_ncol_sw ( this ) class ( ty_source_func_sw ), intent ( in ) :: this integer :: get_ncol_sw if ( this % is_allocated ()) then get_ncol_sw = size ( this % toa_source , 1 ) else get_ncol_sw = 0 end if end function get_ncol_sw ! ------------------------------------------------------------------------------------------ ! !  Routines for subsetting ! ! ------------------------------------------------------------------------------------------ function get_subset_range_lw ( full , start , n , subset ) result ( err_message ) class ( ty_source_func_lw ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_source_func_lw ), intent ( inout ) :: subset character ( 128 ) :: err_message err_message = \"\" if (. not . full % is_allocated ()) then err_message = \"source_func_lw%subset: Asking for a subset of unallocated data\" return end if if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return ! ! Could check to see if subset is correctly sized, has consistent spectral discretization ! if ( subset % is_allocated ()) call subset % finalize () err_message = subset % alloc ( n , full % get_nlay (), full ) if ( err_message /= \"\" ) return subset % sfc_source ( 1 : n , :) = full % sfc_source ( start : start + n - 1 , :) subset % sfc_source_Jac ( 1 : n , :) = full % sfc_source_Jac ( start : start + n - 1 , :) subset % lay_source ( 1 : n ,:,:) = full % lay_source ( start : start + n - 1 ,:,:) subset % lev_source_inc ( 1 : n ,:,:) = full % lev_source_inc ( start : start + n - 1 ,:,:) subset % lev_source_dec ( 1 : n ,:,:) = full % lev_source_dec ( start : start + n - 1 ,:,:) end function get_subset_range_lw ! ------------------------------------------------------------------------------------------ function get_subset_range_sw ( full , start , n , subset ) result ( err_message ) class ( ty_source_func_sw ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_source_func_sw ), intent ( inout ) :: subset character ( 128 ) :: err_message err_message = \"\" if (. not . full % is_allocated ()) then err_message = \"source_func_sw%subset: Asking for a subset of unallocated data\" return end if if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return ! ! Could check to see if subset is correctly sized, has consistent spectral discretization ! if ( subset % is_allocated ()) call subset % finalize () ! Seems like I should be able to call \"alloc\" generically but the compilers are complaining err_message = subset % copy_and_alloc_sw ( n , full ) subset % toa_source ( 1 : n , :) = full % toa_source ( start : start + n - 1 , :) end function get_subset_range_sw end module mo_source_functions","tags":"","loc":"sourcefile/mo_source_functions.f90.html"},{"title":"mo_rte_util_array.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rte_util_array.f90~~EfferentGraph sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rte_util_array.f90~~AfferentGraph sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_heating_rates.f90 mo_heating_rates.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_cloud_optics.f90 mo_cloud_optics.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_cloud_sampling.f90 mo_cloud_sampling.F90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_optical_props.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_util_array Source Code mo_rte_util_array.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2019,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- module mo_rte_util_array ! ! This module provide utilites for sanitizing input arrays: !    checking values and sizes ! These are in a module so code can be written for both CPUs and GPUs ! Used only by Fortran classes so routines don't need C bindings and can use assumed-shape ! use mo_rte_kind , only : wp , wl implicit none interface any_vals_less_than module procedure any_vals_less_than_1D , any_vals_less_than_2D , any_vals_less_than_3D module procedure any_vals_less_than_1D_masked , any_vals_less_than_2D_masked , any_vals_less_than_3D_masked end interface interface any_vals_outside module procedure any_vals_outside_1D , any_vals_outside_2D , any_vals_outside_3D module procedure any_vals_outside_1D_masked , any_vals_outside_2D_masked , any_vals_outside_3D_masked end interface interface zero_array module procedure zero_array_1D , zero_array_2D , zero_array_3D , zero_array_4D end interface interface extents_are module procedure extents_are_1D , extents_are_2D , extents_are_3D module procedure extents_are_4D , extents_are_5D , extents_are_6D module procedure extents_are_2d_int end interface extents_are private public :: any_vals_less_than , any_vals_outside , extents_are , zero_array contains !------------------------------------------------------------------------------------------------- ! Values less than a floor !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_1D ( array , check_value ) real ( wp ), dimension (:), intent ( in ) :: array real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array) !$omp target map(to:array) map(from:minValue) minValue = minval ( array ) !$acc end kernels !$omp end target any_vals_less_than_1D = ( minValue < check_value ) end function any_vals_less_than_1D !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_2D ( array , check_value ) real ( wp ), dimension (:,:), intent ( in ) :: array real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array) !$omp target map(to:array) map(from:minValue) minValue = minval ( array ) !$acc end kernels !$omp end target any_vals_less_than_2D = ( minValue < check_value ) end function any_vals_less_than_2D !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_3D ( array , check_value ) real ( wp ), dimension (:,:,:), intent ( in ) :: array real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue #ifdef _OPENMP integer :: dim1 , dim2 , dim3 , i , j , k dim1 = size ( array , 1 ) dim2 = size ( array , 2 ) dim3 = size ( array , 3 ) minValue = check_value + epsilon ( check_value ) ! initialize to some value !$omp target teams map(to:array) & !$omp defaultmap(tofrom:scalar) reduction(min:minValue) !$omp distribute parallel do simd reduction(min:minValue) do i = 1 , dim1 do j = 1 , dim2 do k = 1 , dim3 minValue = min ( minValue , array ( i , j , k )) enddo enddo enddo !$omp end target teams #else !$acc kernels copyin(array) minValue = minval ( array ) !$acc end kernels #endif any_vals_less_than_3D = ( minValue < check_value ) end function any_vals_less_than_3D !------------------------------------------------------------------------------------------------- ! Masked versions !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_1D_masked ( array , mask , check_value ) real ( wp ), dimension (:), intent ( in ) :: array logical ( wl ), dimension (:), intent ( in ) :: mask real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array) !$omp target map(to:array, mask) map(from:minValue) minValue = minval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_less_than_1D_masked = ( minValue < check_value ) end function any_vals_less_than_1D_masked !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_2D_masked ( array , mask , check_value ) real ( wp ), dimension (:,:), intent ( in ) :: array logical ( wl ), dimension (:,:), intent ( in ) :: mask real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array) !$omp target map(to:array, mask) map(from:minValue) minValue = minval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_less_than_2D_masked = ( minValue < check_value ) end function any_vals_less_than_2D_masked !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_3D_masked ( array , mask , check_value ) real ( wp ), dimension (:,:,:), intent ( in ) :: array logical ( wl ), dimension (:,:,:), intent ( in ) :: mask real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array) !$omp target map(to:array, mask) map(from:minValue) minValue = minval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_less_than_3D_masked = ( minValue < check_value ) end function any_vals_less_than_3D_masked !------------------------------------------------------------------------------------------------- ! Values outside a range !------------------------------------------------------------------------------------------------- logical function any_vals_outside_1D ( array , checkMin , checkMax ) real ( wp ), dimension (:), intent ( in ) :: array real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array) !$omp target map(to:array) map(from:minValue, maxValue) minValue = minval ( array ) maxValue = maxval ( array ) !$acc end kernels !$omp end target any_vals_outside_1D = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_1D ! ---------------------------------------------------------- logical function any_vals_outside_2D ( array , checkMin , checkMax ) real ( wp ), dimension (:,:), intent ( in ) :: array real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array) !$omp target map(to:array) map(from:minValue, maxValue) minValue = minval ( array ) maxValue = maxval ( array ) !$acc end kernels !$omp end target any_vals_outside_2D = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_2D ! ---------------------------------------------------------- logical function any_vals_outside_3D ( array , checkMin , checkMax ) real ( wp ), dimension (:,:,:), intent ( in ) :: array real ( wp ), intent ( in ) :: checkMin , checkMax ! Compact version using intrinsics below ! but an explicit loop is the only current solution on GPUs real ( wp ) :: minValue , maxValue #ifdef _OPENMP integer :: dim1 , dim2 , dim3 , i , j , k dim1 = size ( array , 1 ) dim2 = size ( array , 2 ) dim3 = size ( array , 3 ) minValue = checkMin + epsilon ( checkMin ) ! initialize to some value maxValue = checkMax - epsilon ( checkMax ) ! initialize to some value !$omp target teams map(to:array) & !$omp defaultmap(tofrom:scalar) reduction(min:minValue) reduction(max:maxValue) !$omp distribute parallel do simd reduction(min:minValue) reduction(max:maxValue) do i = 1 , dim1 do j = 1 , dim2 do k = 1 , dim3 minValue = min ( minValue , array ( i , j , k )) maxValue = max ( maxValue , array ( i , j , k )) enddo enddo enddo !$omp end target teams #else !$acc kernels copyin(array) minValue = minval ( array ) maxValue = maxval ( array ) !$acc end kernels #endif any_vals_outside_3D = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_3D ! ---------------------------------------------------------- ! Masked versions ! ---------------------------------------------------------- logical function any_vals_outside_1D_masked ( array , mask , checkMin , checkMax ) real ( wp ), dimension (:), intent ( in ) :: array logical ( wl ), dimension (:), intent ( in ) :: mask real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array) !$omp target map(to:array, mask) map(from:minValue, maxValue) minValue = minval ( array , mask = mask ) maxValue = maxval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_outside_1D_masked = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_1D_masked ! ---------------------------------------------------------- logical function any_vals_outside_2D_masked ( array , mask , checkMin , checkMax ) real ( wp ), dimension (:,:), intent ( in ) :: array logical ( wl ), dimension (:,:), intent ( in ) :: mask real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array) !$omp target map(to:array, mask) map(from:minValue, maxValue) minValue = minval ( array , mask = mask ) maxValue = maxval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_outside_2D_masked = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_2D_masked ! ---------------------------------------------------------- logical function any_vals_outside_3D_masked ( array , mask , checkMin , checkMax ) real ( wp ), dimension (:,:,:), intent ( in ) :: array logical ( wl ), dimension (:,:,:), intent ( in ) :: mask real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array) !$omp target map(to:array, mask) map(from:minValue, maxValue) minValue = minval ( array , mask = mask ) maxValue = maxval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_outside_3D_masked = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_3D_masked !-------------------------------------------------------------------------------------------------------------------- ! ! Extents ! ! -------------------------------------------------------------------------------------- function extents_are_1d ( array , n1 ) real ( wp ), dimension (: ), intent ( in ) :: array integer , intent ( in ) :: n1 logical ( wl ) :: extents_are_1d extents_are_1d = ( size ( array , 1 ) == n1 ) end function extents_are_1d ! -------------------------------------------------------------------------------------- function extents_are_2d ( array , n1 , n2 ) real ( wp ), dimension (:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 logical ( wl ) :: extents_are_2d extents_are_2d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 ) end function extents_are_2d ! -------------------------------------------------------------------------------------- function extents_are_3d ( array , n1 , n2 , n3 ) real ( wp ), dimension (:,:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 , n3 logical ( wl ) :: extents_are_3d extents_are_3d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 . and . & size ( array , 3 ) == n3 ) end function extents_are_3d ! -------------------------------------------------------------------------------------- function extents_are_4d ( array , n1 , n2 , n3 , n4 ) real ( wp ), dimension (:,:,:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 , n3 , n4 logical ( wl ) :: extents_are_4d extents_are_4d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 . and . & size ( array , 3 ) == n3 . and . & size ( array , 4 ) == n4 ) end function extents_are_4d ! -------------------------------------------------------------------------------------- function extents_are_5d ( array , n1 , n2 , n3 , n4 , n5 ) real ( wp ), dimension (:,:,:,:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 , n3 , n4 , n5 logical ( wl ) :: extents_are_5d extents_are_5d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 . and . & size ( array , 3 ) == n3 . and . & size ( array , 4 ) == n4 . and . & size ( array , 5 ) == n5 ) end function extents_are_5d ! -------------------------------------------------------------------------------------- function extents_are_6d ( array , n1 , n2 , n3 , n4 , n5 , n6 ) real ( wp ), dimension (:,:,:,:,:,:), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 , n3 , n4 , n5 , n6 logical ( wl ) :: extents_are_6d extents_are_6d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 . and . & size ( array , 3 ) == n3 . and . & size ( array , 4 ) == n4 . and . & size ( array , 5 ) == n5 . and . & size ( array , 6 ) == n6 ) end function extents_are_6d ! -------------------------------------------------------------------------------------- function extents_are_2d_int ( array , n1 , n2 ) integer , dimension (:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 logical ( wl ) :: extents_are_2d_int extents_are_2d_int = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 ) end function extents_are_2d_int !------------------------------------------------------------------------------------------------- ! Initializing arrays to 0 !------------------------------------------------------------------------------------------------- subroutine zero_array_1D ( ni , array ) bind ( C , name = \"zero_array_1D\" ) integer , intent ( in ) :: ni real ( wp ), dimension ( ni ), intent ( out ) :: array ! ----------------------- integer :: i ! ----------------------- !$acc parallel loop copyout(array) !$omp target teams distribute parallel do simd map(from:array) do i = 1 , ni array ( i ) = 0.0_wp end do end subroutine zero_array_1D ! ---------------------------------------------------------- subroutine zero_array_2D ( ni , nj , array ) bind ( C , name = \"zero_array_2D\" ) integer , intent ( in ) :: ni , nj real ( wp ), dimension ( ni , nj ), intent ( out ) :: array ! ----------------------- integer :: i , j ! ----------------------- !$acc parallel loop collapse(2) copyout(array) !$omp target teams distribute parallel do simd collapse(2) map(from:array) do j = 1 , nj do i = 1 , ni array ( i , j ) = 0.0_wp end do end do end subroutine zero_array_2D ! ---------------------------------------------------------- subroutine zero_array_3D ( ni , nj , nk , array ) bind ( C , name = \"zero_array_3D\" ) integer , intent ( in ) :: ni , nj , nk real ( wp ), dimension ( ni , nj , nk ), intent ( out ) :: array ! ----------------------- integer :: i , j , k ! ----------------------- !$acc parallel loop collapse(3) copyout(array) !$omp target teams distribute parallel do simd collapse(3) map(from:array) do k = 1 , nk do j = 1 , nj do i = 1 , ni array ( i , j , k ) = 0.0_wp end do end do end do end subroutine zero_array_3D ! ---------------------------------------------------------- subroutine zero_array_4D ( ni , nj , nk , nl , array ) bind ( C , name = \"zero_array_4D\" ) integer , intent ( in ) :: ni , nj , nk , nl real ( wp ), dimension ( ni , nj , nk , nl ), intent ( out ) :: array ! ----------------------- integer :: i , j , k , l ! ----------------------- !$acc parallel loop collapse(4) copyout(array) !$omp target teams distribute parallel do simd collapse(4) map(from:array) do l = 1 , nl do k = 1 , nk do j = 1 , nj do i = 1 , ni array ( i , j , k , l ) = 0.0_wp end do end do end do end do end subroutine zero_array_4D end module mo_rte_util_array","tags":"","loc":"sourcefile/mo_rte_util_array.f90.html"},{"title":"mo_heating_rates.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_heating_rates.f90~~EfferentGraph sourcefile~mo_heating_rates.f90 mo_heating_rates.F90 sourcefile~mo_rrtmgp_constants.f90 mo_rrtmgp_constants.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rrtmgp_constants.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rrtmgp_constants.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_heating_rates Source Code mo_heating_rates.F90 Source Code ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2016-2017,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! Description:  Heating rate calculation module mo_heating_rates use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_extents use mo_rte_util_array , only : extents_are use mo_rrtmgp_constants , only : cp_dry , grav ! Only needed for heating rate calculation implicit none private public :: compute_heating_rate contains ! Compute heating rate from fluxes ! heating rate H [K/sec] = 1/(rho cp) d f_net/d z ! Here use hydrostatic equation for density and heat capacity of dry air function compute_heating_rate ( flux_up , flux_dn , plev , heating_rate ) result ( error_msg ) real ( wp ), dimension (:,:), intent ( in ) :: flux_up , flux_dn , & !< fluxes at interfaces [W/m2] plev !< pressure at interfaces [Pa] real ( wp ), dimension (:,:), intent ( out ) :: heating_rate !< heating rate within layer [K/sec] character ( len = 128 ) :: error_msg ! --------- integer :: ncol , nlay , ilay ! --------- error_msg = \"\" ncol = size ( flux_up , 1 ) nlay = size ( flux_up , 2 ) - 1 if ( check_extents ) then if (. not . extents_are ( flux_dn , ncol , nlay + 1 )) & error_msg = \"heating_rate: flux_dn array inconsistently sized.\" if (. not . extents_are ( plev , ncol , nlay + 1 )) & error_msg = \"heating_rate: plev array inconsistently sized.\" if (. not . extents_are ( heating_rate , ncol , nlay )) & error_msg = \"heating_rate: heating_rate array inconsistently sized.\" if ( error_msg /= \"\" ) return end if do ilay = 1 , nlay heating_rate ( 1 : ncol , ilay ) = ( flux_up ( 1 : ncol , ilay + 1 ) - flux_up ( 1 : ncol , ilay ) - & flux_dn ( 1 : ncol , ilay + 1 ) + flux_dn ( 1 : ncol , ilay )) * & grav / ( cp_dry * ( plev ( 1 : ncol , ilay + 1 ) - plev ( 1 : ncol , ilay ))) end do end function compute_heating_rate end module mo_heating_rates","tags":"","loc":"sourcefile/mo_heating_rates.f90.html"},{"title":"mo_compute_bc.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_compute_bc.f90~~EfferentGraph sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rrtmgp_util_string.f90 mo_rrtmgp_util_string.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_compute_bc Source Code mo_compute_bc.F90 Source Code module mo_compute_bc ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! This modules lets users determine upper boundary condition by !   computing the spectrally-resolved fluxes at the bottom of an isothermal layer !   extending from the lowest supplied pressure to the minimum pressure allowed by !   RRTMGP. ! This is only sensible if the user's domain extends nearly to the top of the atmosphere. ! Adding this thin extra layer makes heating rates in the top-most layer more reasonable !   especially in the longwave ! The boundary condition is on diffuse flux in the LW and direct flux in the SW ! ------------------------------------------------------------------------------------------------- use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_extents use mo_rte_util_array , only : extents_are use mo_source_functions , only : ty_source_func_lw use mo_gas_concentrations , only : ty_gas_concs use mo_optical_props , only : ty_optical_props , ty_optical_props_arry , & ty_optical_props_1scl , ty_optical_props_2str use mo_gas_optics , only : ty_gas_optics use mo_fluxes , only : ty_fluxes use mo_rte_lw , only : rte_lw use mo_rte_sw , only : rte_sw implicit none private public :: compute_bc ! ! Extend ty_fluxes to report spectrally-resolved downwelling flux at a single layer ! type , extends ( ty_fluxes ) :: ty_fluxes_1lev real ( wp ), dimension (:,:), pointer :: gpt_flux_dn => NULL () ! (ncol, nlev, nband) contains procedure :: reduce => reduce_1lev procedure :: are_desired => are_desired_1lev end type ty_fluxes_1lev contains !-------------------------------------------------------------------------------------------------------------------- ! ! The arguments to this routine follow those to the gas_optics routines ! function compute_bc ( k_dist , & play , plev , tlay , gas_concs , & flux_bc , mu0 ) result ( error_msg ) class ( ty_gas_optics ), intent ( in ) :: k_dist real ( wp ), dimension (:,:), intent ( in ) :: play , & ! layer pressures [Pa, mb]; (ncol,nlay) plev , & ! level pressures [Pa, mb]; (ncol,nlay+1) tlay ! layer temperatures [K]; (ncol,nlay) type ( ty_gas_concs ), intent ( in ) :: gas_concs ! Gas volume mixing ratios real ( wp ), dimension (:,:), target , & intent ( out ) :: flux_bc ! Boundary condition to be applied (ncol,ngpt) real ( wp ), dimension (:), optional , & intent ( in ) :: mu0 ! Must be provided for solar problems character ( len = 128 ) :: error_msg ! ---------------------------------------------------------- ! ! Local variables ! logical :: top_at_1 integer :: ncol , nlay , ngpt integer :: igas , ngases character ( len = 32 ), dimension (:), allocatable :: gas_names real ( wp ), dimension ( size ( play , 1 ), size ( play , 2 )) :: vmr integer :: top_lay real ( wp ), dimension ( size ( play , 1 ), 1 ) :: play_1lay , tlay_1lay real ( wp ), dimension ( size ( play , 1 ), 2 ) :: plev_1lay , tlev_1lay real ( wp ), dimension ( k_dist % get_nband (), size ( play , 1 )) & :: lower_bc ! emissivity or surface albedo type ( ty_gas_concs ) :: gas_concs_1lay ! Gas volume mixing ratios class ( ty_optical_props_arry ), & allocatable :: optical_props_1lay type ( ty_fluxes_1lev ) :: fluxes_1lev type ( ty_source_func_lw ) :: lw_sources_1lay real ( wp ), dimension ( size ( play , 1 ), k_dist % get_ngpt ()) :: solar_src ! ---------------------------------------------------------- ! ! Problem extent ! ncol = size ( play , dim = 1 ) nlay = size ( play , dim = 2 ) ngpt = k_dist % get_ngpt () if ( check_extents ) then if (. not . extents_are ( plev , ncol , nlay + 1 )) & error_msg = \"compute_bc: array plev has wrong dimensions\" if (. not . extents_are ( tlay , ncol , nlay )) & error_msg = \"compute_bc: array tlay has wrong dimensions\" if ( present ( mu0 )) then if ( size ( mu0 ) /= ncol ) & error_msg = \"compute bc: array mu0 has wrong dimensions\" end if if ( error_msg /= \"\" ) return end if ! ! Vertical ordering? ! top_at_1 = play ( 1 , 1 ) < play ( 1 , nlay ) top_lay = merge ( 1 , nlay , top_at_1 ) if ( any ( plev (:, top_lay ) <= & k_dist % get_press_min () + 2._wp * spacing ( k_dist % get_press_min ()))) then error_msg = \"compute_bc: pressures are too close to (or less than) min in gas optics \" return end if ! ! Make a single-layer isothermal atmosphere ! tlay_1lay ( 1 : ncol , 1 ) = tlay ( 1 : ncol , top_lay ) tlev_1lay ( 1 : ncol , 1 ) = tlay ( 1 : ncol , top_lay ) tlev_1lay ( 1 : ncol , 2 ) = tlay ( 1 : ncol , top_lay ) plev_1lay ( 1 : ncol , 1 ) = k_dist % get_press_min () plev_1lay ( 1 : ncol , 2 ) = plev ( 1 : ncol , top_lay + 1 ) ! ! Maybe there are better ways to interpolate pressure but the single layer !   should be thin enough that interpolation doesn't have much impact ! play_1lay ( 1 : ncol , 1 ) = 0.5 * ( plev_1lay ( 1 : ncol , 1 ) + plev_1lay ( 1 : ncol , 2 )) ! ! Gas concentrations in the single layer are the same as in the top layer ! ngases = gas_concs % get_num_gases () allocate ( gas_names ( ngases )) gas_names = gas_concs % get_gas_names () do igas = 1 , ngases error_msg = gas_concs % get_vmr ( gas_names ( igas ), vmr ) if ( error_msg /= \"\" ) return error_msg = gas_concs_1lay % set_vmr ( gas_names ( igas ), vmr (:, top_lay )) if ( error_msg /= \"\" ) return end do lower_bc (:,:) = 1._wp ! Value doesn't affect downward flux fluxes_1lev % gpt_flux_dn => flux_bc ! --------------------------------------------------- if ( k_dist % source_is_internal ()) then ! ! Longwave specific variables ! allocate ( ty_optical_props_1scl :: optical_props_1lay ) select type ( optical_props_1lay ) type is ( ty_optical_props_1scl ) error_msg = optical_props_1lay % alloc_1scl ( ncol , 1 , k_dist ) if ( error_msg /= \"\" ) return end select error_msg = lw_sources_1lay % alloc ( ncol , 1 , k_dist ) if ( error_msg /= \"\" ) return ! ! Gas optics and sources ! error_msg = k_dist % gas_optics ( play_1lay , plev_1lay , & tlay_1lay , tlay_1lay ( 1 : ncol , 1 ), & gas_concs_1lay , optical_props_1lay , & lw_sources_1lay , tlev = tlev_1lay ) !                                                                  ! ! Compute fluxes ! error_msg = rte_lw ( optical_props_1lay , & top_at_1 , & lw_sources_1lay , & lower_bc , fluxes_1lev ) else ! ! Shortwave specific variables ! if (. not . present ( mu0 )) then error_msg = \"compute_bc: have to supply mu0 for solar calculations\" return end if allocate ( ty_optical_props_2str :: optical_props_1lay ) select type ( optical_props_1lay ) type is ( ty_optical_props_2str ) error_msg = optical_props_1lay % alloc_2str ( ncol , 1 , k_dist ) if ( error_msg /= \"\" ) return end select ! ! Gas optics and sources ! error_msg = k_dist % gas_optics ( play_1lay , plev_1lay , & tlay_1lay , gas_concs_1lay , & optical_props_1lay , & solar_src ) error_msg = rte_sw ( optical_props_1lay , & top_at_1 , mu0 , & solar_src , & lower_bc , lower_bc , fluxes_1lev ) endif end function ! -------------------------------------------------------------------------------------- function reduce_1lev ( this , gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) result ( error_msg ) class ( ty_fluxes_1lev ), intent ( inout ) :: this real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_up ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_dn ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) class ( ty_optical_props ), intent ( in ) :: spectral_disc !< derived type with spectral information logical , intent ( in ) :: top_at_1 real ( kind = wp ), dimension (:,:,:), optional , & intent ( in ) :: gpt_flux_dn_dir ! Direct flux down character ( len = 128 ) :: error_msg ! ------ integer :: ncol , nlev , ngpt , bottom_lev ! ------ error_msg = \"\" ncol = size ( gpt_flux_up , DIM = 1 ) nlev = size ( gpt_flux_up , DIM = 2 ) ngpt = size ( gpt_flux_up , DIM = 3 ) if ( nlev /= 2 ) then error_msg = \"reduce: expecting only two layers when computing boundary condition fluxes\" return end if bottom_lev = merge ( 2 , 1 , top_at_1 ) ! ! Return the g-point flux at the bottomw of a two-layer domain ! if ( associated ( this % gpt_flux_dn )) then if ( any ([ size ( this % gpt_flux_dn , 1 ) /= ncol , & size ( this % gpt_flux_dn , 2 ) /= ngpt ])) then error_msg = \"reduce: gpt_flux_dn array incorrectly sized\" else if ( present ( gpt_flux_dn_dir )) then this % gpt_flux_dn (:,:) = gpt_flux_dn_dir (:, bottom_lev ,:) else this % gpt_flux_dn (:,:) = gpt_flux_dn (:, bottom_lev ,:) end if end if end if end function reduce_1lev ! -------------------------------------------------------------------------------------- ! Are any fluxes desired from this set of g-point fluxes? We can tell because memory will !   be allocated for output ! function are_desired_1lev ( this ) class ( ty_fluxes_1lev ), intent ( in ) :: this logical :: are_desired_1lev are_desired_1lev = associated ( this % gpt_flux_dn ) end function are_desired_1lev end module mo_compute_bc","tags":"","loc":"sourcefile/mo_compute_bc.f90.html"},{"title":"mo_rrtmgp_clr_all_sky.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rrtmgp_clr_all_sky.f90~~EfferentGraph sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rrtmgp_util_string.f90 mo_rrtmgp_util_string.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rrtmgp_clr_all_sky Source Code mo_rrtmgp_clr_all_sky.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2017,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! ! This module provides an interface to RRTMGP for a common use case -- !   users want to start from gas concentrations, pressures, and temperatures, !   and compute clear-sky (aerosol plus gases) and all-sky fluxes. ! The routines here have the same names as those in mo_rrtmgp_[ls]w; normally users !   will use either this module or the underling modules, but not both ! module mo_rrtmgp_clr_all_sky use mo_rte_kind , only : wp use mo_gas_optics , & only : ty_gas_optics use mo_gas_concentrations , & only : ty_gas_concs use mo_optical_props , only : ty_optical_props , & ty_optical_props_arry , ty_optical_props_1scl , ty_optical_props_2str , ty_optical_props_nstr use mo_source_functions , & only : ty_source_func_lw use mo_fluxes , only : ty_fluxes use mo_rte_lw , only : base_rte_lw => rte_lw use mo_rte_sw , only : base_rte_sw => rte_sw implicit none private public :: rte_lw , rte_sw contains ! -------------------------------------------------- ! ! Interfaces using clear (gas + aerosol) and all-sky categories, starting from !   pressures, temperatures, and gas amounts for the gas contribution ! ! -------------------------------------------------- function rte_lw ( k_dist , gas_concs , p_lay , t_lay , p_lev , & t_sfc , sfc_emis , cloud_props , & allsky_fluxes , clrsky_fluxes , & aer_props , col_dry , t_lev , inc_flux , n_gauss_angles ) result ( error_msg ) class ( ty_gas_optics ), intent ( in ) :: k_dist !< derived type with spectral information type ( ty_gas_concs ), intent ( in ) :: gas_concs !< derived type encapsulating gas concentrations real ( wp ), dimension (:,:), intent ( in ) :: p_lay , t_lay !< pressure [Pa], temperature [K] at layer centers (ncol,nlay) real ( wp ), dimension (:,:), intent ( in ) :: p_lev !< pressure at levels/interfaces [Pa] (ncol,nlay+1) real ( wp ), dimension (:), intent ( in ) :: t_sfc !< surface temperature           [K]  (ncol) real ( wp ), dimension (:,:), intent ( in ) :: sfc_emis !< emissivity at surface         []   (nband, ncol) class ( ty_optical_props_arry ), intent ( in ) :: cloud_props !< cloud optical properties (ncol,nlay,ngpt) class ( ty_fluxes ), intent ( inout ) :: allsky_fluxes , clrsky_fluxes ! Optional inputs class ( ty_optical_props_arry ), & optional , intent ( in ) :: aer_props !< aerosol optical properties real ( wp ), dimension (:,:), & optional , intent ( in ) :: col_dry !< Molecular number density (ncol, nlay) real ( wp ), dimension (:,:), target , & optional , intent ( in ) :: t_lev !< temperature at levels [K] (ncol, nlay+1) real ( wp ), dimension (:,:), target , & optional , intent ( in ) :: inc_flux !< incident flux at domain top [W/m2] (ncol, ngpts) integer , optional , intent ( in ) :: n_gauss_angles ! Number of angles used in Gaussian quadrature (no-scattering solution) character ( len = 128 ) :: error_msg ! -------------------------------- ! Local variables ! class ( ty_optical_props_arry ), allocatable :: optical_props type ( ty_source_func_lw ) :: sources integer :: ncol , nlay , ngpt , nband , nstr logical :: top_at_1 ! -------------------------------- ! Problem sizes ! error_msg = \"\" ncol = size ( p_lay , 1 ) nlay = size ( p_lay , 2 ) ngpt = k_dist % get_ngpt () nband = k_dist % get_nband () !$acc kernels copyout(top_at_1) !$omp target map(from:top_at_1) top_at_1 = p_lay ( 1 , 1 ) < p_lay ( 1 , nlay ) !$acc end kernels !$omp end target ! ------------------------------------------------------------------------------------ !  Error checking ! if ( present ( aer_props )) then if ( any ([ aer_props % get_ncol (), & aer_props % get_nlay ()] /= [ ncol , nlay ])) & error_msg = \"rrtmpg_lw: aerosol properties inconsistently sized\" if (. not . any ( aer_props % get_ngpt () /= [ ngpt , nband ])) & error_msg = \"rrtmpg_lw: aerosol properties inconsistently sized\" end if if ( present ( t_lev )) then if ( any ([ size ( t_lev , 1 ), & size ( t_lev , 2 )] /= [ ncol , nlay + 1 ])) & error_msg = \"rrtmpg_lw: t_lev inconsistently sized\" end if if ( present ( inc_flux )) then if ( any ([ size ( inc_flux , 1 ), & size ( inc_flux , 2 )] /= [ ncol , ngpt ])) & error_msg = \"rrtmpg_lw: incident flux inconsistently sized\" end if if ( len_trim ( error_msg ) > 0 ) return ! ------------------------------------------------------------------------------------ ! Optical properties arrays ! select type ( cloud_props ) class is ( ty_optical_props_1scl ) ! No scattering allocate ( ty_optical_props_1scl :: optical_props ) class is ( ty_optical_props_2str ) allocate ( ty_optical_props_2str :: optical_props ) class is ( ty_optical_props_nstr ) allocate ( ty_optical_props_nstr :: optical_props ) nstr = size ( cloud_props % tau , 1 ) end select error_msg = optical_props % init ( k_dist ) if ( len_trim ( error_msg ) > 0 ) return select type ( optical_props ) class is ( ty_optical_props_1scl ) ! No scattering error_msg = optical_props % alloc_1scl ( ncol , nlay ) class is ( ty_optical_props_2str ) error_msg = optical_props % alloc_2str ( ncol , nlay ) class is ( ty_optical_props_nstr ) error_msg = optical_props % alloc_nstr ( nstr , ncol , nlay ) end select if ( error_msg /= '' ) return ! ! Source function ! error_msg = sources % init ( k_dist ) error_msg = sources % alloc ( ncol , nlay ) if ( error_msg /= '' ) return ! ------------------------------------------------------------------------------------ ! Clear skies ! ! Gas optical depth -- pressure need to be expressed as Pa ! error_msg = k_dist % gas_optics ( p_lay , p_lev , t_lay , t_sfc , gas_concs , & optical_props , sources , & col_dry , t_lev ) if ( error_msg /= '' ) return ! ---------------------------------------------------- ! Clear sky is gases + aerosols (if they're supplied) ! if ( present ( aer_props )) error_msg = aer_props % increment ( optical_props ) if ( error_msg /= '' ) return error_msg = base_rte_lw ( optical_props , top_at_1 , sources , & sfc_emis , clrsky_fluxes , & inc_flux , n_gauss_angles ) if ( error_msg /= '' ) return ! ------------------------------------------------------------------------------------ ! All-sky fluxes = clear skies + clouds ! error_msg = cloud_props % increment ( optical_props ) if ( error_msg /= '' ) return error_msg = base_rte_lw ( optical_props , top_at_1 , sources , & sfc_emis , allsky_fluxes , & inc_flux , n_gauss_angles ) call sources % finalize () call optical_props % finalize () end function rte_lw ! -------------------------------------------------- function rte_sw ( k_dist , gas_concs , p_lay , t_lay , p_lev , & mu0 , sfc_alb_dir , sfc_alb_dif , cloud_props , & allsky_fluxes , clrsky_fluxes , & aer_props , col_dry , inc_flux ) result ( error_msg ) class ( ty_gas_optics ), intent ( in ) :: k_dist !< derived type with spectral information type ( ty_gas_concs ), intent ( in ) :: gas_concs !< derived type encapsulating gas concentrations real ( wp ), dimension (:,:), intent ( in ) :: p_lay , t_lay !< pressure [Pa], temperature [K] at layer centers (ncol,nlay) real ( wp ), dimension (:,:), intent ( in ) :: p_lev !< pressure at levels/interfaces [Pa] (ncol,nlay+1) real ( wp ), dimension (: ), intent ( in ) :: mu0 !< cosine of solar zenith angle real ( wp ), dimension (:,:), intent ( in ) :: sfc_alb_dir , sfc_alb_dif !  surface albedo for direct and diffuse radiation (band, col) class ( ty_optical_props_arry ), intent ( in ) :: cloud_props !< cloud optical properties (ncol,nlay,ngpt) class ( ty_fluxes ), intent ( inout ) :: allsky_fluxes , clrsky_fluxes ! Optional inputs class ( ty_optical_props_arry ), target , & optional , intent ( in ) :: aer_props !< aerosol optical properties real ( wp ), dimension (:,:), & optional , intent ( in ) :: col_dry , & !< Molecular number density (ncol, nlay) inc_flux !< incident flux at domain top [W/m2] (ncol, ngpts) character ( len = 128 ) :: error_msg ! -------------------------------- ! Local variables ! class ( ty_optical_props_arry ), allocatable :: optical_props real ( wp ), dimension (:,:), allocatable :: toa_flux integer :: ncol , nlay , ngpt , nband , nstr logical :: top_at_1 ! -------------------------------- ! Problem sizes ! error_msg = \"\" ncol = size ( p_lay , 1 ) nlay = size ( p_lay , 2 ) ngpt = k_dist % get_ngpt () nband = k_dist % get_nband () !$acc kernels copyout(top_at_1) !$omp target map(from:top_at_1) top_at_1 = p_lay ( 1 , 1 ) < p_lay ( 1 , nlay ) !$acc end kernels !$omp end target ! ------------------------------------------------------------------------------------ !  Error checking ! if ( present ( aer_props )) then if ( any ([ aer_props % get_ncol (), & aer_props % get_nlay ()] /= [ ncol , nlay ])) & error_msg = \"rrtmpg_sw: aerosol properties inconsistently sized\" if (. not . any ( aer_props % get_ngpt () /= [ ngpt , nband ])) & error_msg = \"rrtmpg_sw: aerosol properties inconsistently sized\" end if if ( present ( inc_flux )) then if ( any ([ size ( inc_flux , 1 ), & size ( inc_flux , 2 )] /= [ ncol , ngpt ])) & error_msg = \"rrtmpg_sw: incident flux inconsistently sized\" end if if ( len_trim ( error_msg ) > 0 ) return ! ------------------------------------------------------------------------------------ ! ! Optical properties arrays ! select type ( cloud_props ) class is ( ty_optical_props_1scl ) ! No scattering allocate ( ty_optical_props_1scl :: optical_props ) class is ( ty_optical_props_2str ) allocate ( ty_optical_props_2str :: optical_props ) class is ( ty_optical_props_nstr ) allocate ( ty_optical_props_nstr :: optical_props ) nstr = cloud_props % get_nmom () end select error_msg = optical_props % init ( k_dist % get_band_lims_wavenumber (), & k_dist % get_band_lims_gpoint ()) if ( len_trim ( error_msg ) > 0 ) return select type ( optical_props ) class is ( ty_optical_props_1scl ) ! No scattering error_msg = optical_props % alloc_1scl ( ncol , nlay ) class is ( ty_optical_props_2str ) error_msg = optical_props % alloc_2str ( ncol , nlay ) class is ( ty_optical_props_nstr ) error_msg = optical_props % alloc_nstr ( nstr , ncol , nlay ) end select if ( error_msg /= '' ) return allocate ( toa_flux ( ncol , ngpt )) ! ------------------------------------------------------------------------------------ ! Clear skies ! ! Gas optical depth -- pressure need to be expressed as Pa ! error_msg = k_dist % gas_optics ( p_lay , p_lev , t_lay , gas_concs , & optical_props , toa_flux , & col_dry ) if ( error_msg /= '' ) return ! ! If users have supplied an incident flux, use that ! if ( present ( inc_flux )) toa_flux (:,:) = inc_flux (:,:) ! ---------------------------------------------------- ! Clear sky is gases + aerosols (if they're supplied) ! if ( present ( aer_props )) error_msg = aer_props % increment ( optical_props ) if ( error_msg /= '' ) return error_msg = base_rte_sw ( optical_props , top_at_1 , & mu0 , toa_flux , & sfc_alb_dir , sfc_alb_dif , & clrsky_fluxes ) if ( error_msg /= '' ) return ! ------------------------------------------------------------------------------------ ! All-sky fluxes = clear skies + clouds ! error_msg = cloud_props % increment ( optical_props ) if ( error_msg /= '' ) return error_msg = base_rte_sw ( optical_props , top_at_1 , & mu0 , toa_flux , & sfc_alb_dir , sfc_alb_dif , & allsky_fluxes ) call optical_props % finalize () end function rte_sw end module mo_rrtmgp_clr_all_sky","tags":"","loc":"sourcefile/mo_rrtmgp_clr_all_sky.f90.html"},{"title":"mo_fluxes_byband.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_fluxes_byband.f90~~EfferentGraph sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_fluxes_byband Source Code mo_fluxes_byband.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2015,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! ! This module is for packaging output quantities from RRTMGP based on spectral flux profiles !    This implementation provides band-by-band flux profiles ! module mo_fluxes_byband use mo_rte_kind , only : wp use mo_rte_config , only : check_extents use mo_rte_util_array , only : extents_are use mo_fluxes , only : ty_fluxes , ty_fluxes_broadband use mo_optical_props , only : ty_optical_props implicit none ! Output from radiation calculations !   Data components are pointers so results can be written directly into memory !   reduce() function accepts spectral flux profiles type , extends ( ty_fluxes_broadband ) :: ty_fluxes_byband real ( wp ), dimension (:,:,:), pointer :: bnd_flux_up => NULL (), & ! Band-by-band fluxes bnd_flux_dn => NULL () ! (ncol, nlev, nband) real ( wp ), dimension (:,:,:), pointer :: bnd_flux_net => NULL () ! Net (down - up) real ( wp ), dimension (:,:,:), pointer :: bnd_flux_dn_dir => NULL () ! Direct flux down contains procedure :: reduce => reduce_byband procedure :: are_desired => are_desired_byband end type ty_fluxes_byband interface net_byband module procedure net_byband_full , net_byband_precalc end interface net_byband contains ! -------------------------------------------------------------------------------------- function reduce_byband ( this , gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) result ( error_msg ) class ( ty_fluxes_byband ), intent ( inout ) :: this real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_up ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_dn ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) class ( ty_optical_props ), intent ( in ) :: spectral_disc !< derived type with spectral information logical , intent ( in ) :: top_at_1 real ( kind = wp ), dimension (:,:,:), optional , & intent ( in ) :: gpt_flux_dn_dir ! Direct flux down character ( len = 128 ) :: error_msg ! ------ integer :: ncol , nlev , ngpt , nbnd integer , dimension ( 2 , spectral_disc % get_nband ()) :: band_lims ! ------ ncol = size ( gpt_flux_up , DIM = 1 ) nlev = size ( gpt_flux_up , DIM = 2 ) ngpt = spectral_disc % get_ngpt () nbnd = spectral_disc % get_nband () band_lims (:,:) = spectral_disc % get_band_lims_gpoint () ! Compute broadband fluxes !   This also checks that input arrays are consistently sized ! error_msg = this % ty_fluxes_broadband % reduce ( gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) if ( error_msg /= '' ) return if ( size ( gpt_flux_up , 3 ) /= ngpt ) then error_msg = \"reduce: spectral discretization and g-point flux arrays have differing number of g-points\" return end if ! Check sizes of output arrays if ( check_extents ) then if ( associated ( this % bnd_flux_up )) then if (. not . extents_are ( this % bnd_flux_up , ncol , nlev , nbnd )) & error_msg = \"reduce: bnd_flux_up array incorrectly sized (can't compute net flux either)\" end if if ( associated ( this % bnd_flux_dn )) then if (. not . extents_are ( this % bnd_flux_dn , ncol , nlev , nbnd )) & error_msg = \"reduce: bnd_flux_dn array incorrectly sized (can't compute net flux either)\" end if if ( associated ( this % bnd_flux_dn_dir )) then if (. not . extents_are ( this % bnd_flux_dn_dir , ncol , nlev , nbnd )) & error_msg = \"reduce: bnd_flux_dn_dir array incorrectly sized\" end if if ( associated ( this % bnd_flux_net )) then if (. not . extents_are ( this % bnd_flux_net , ncol , nlev , nbnd )) & error_msg = \"reduce: bnd_flux_net array incorrectly sized (can't compute net flux either)\" end if if ( error_msg /= \"\" ) return end if ! ! Self-consistency -- shouldn't be asking for direct beam flux if it isn't supplied if ( associated ( this % bnd_flux_dn_dir ) . and . . not . present ( gpt_flux_dn_dir )) then error_msg = \"reduce: requesting bnd_flux_dn_dir but direct flux hasn't been supplied\" return end if ! ------- !$acc enter data copyin(band_lims) !$omp target enter data map(to:band_lims) ! Band-by-band fluxes ! Up flux if ( associated ( this % bnd_flux_up )) then call sum_byband ( ncol , nlev , ngpt , nbnd , band_lims , gpt_flux_up , this % bnd_flux_up ) end if ! ------- ! Down flux if ( associated ( this % bnd_flux_dn )) then call sum_byband ( ncol , nlev , ngpt , nbnd , band_lims , gpt_flux_dn , this % bnd_flux_dn ) end if if ( associated ( this % bnd_flux_dn_dir )) then call sum_byband ( ncol , nlev , ngpt , nbnd , band_lims , gpt_flux_dn_dir , this % bnd_flux_dn_dir ) end if ! ------- ! Net flux ! if ( associated ( this % bnd_flux_net )) then ! !  Reuse down and up results if possible ! if ( associated ( this % bnd_flux_dn ) . and . associated ( this % bnd_flux_up )) then call net_byband ( ncol , nlev , nbnd , this % bnd_flux_dn , this % bnd_flux_up , this % bnd_flux_net ) else call net_byband ( ncol , nlev , ngpt , nbnd , band_lims , gpt_flux_dn , gpt_flux_up , this % bnd_flux_net ) end if end if !$acc exit data delete(band_lims) !$omp target exit data map(release:band_lims) end function reduce_byband ! -------------------------------------------------------------------------------------- ! Are any fluxes desired from this set of g-point fluxes? We can tell because memory will !   be allocated for output ! function are_desired_byband ( this ) class ( ty_fluxes_byband ), intent ( in ) :: this logical :: are_desired_byband are_desired_byband = any ([ associated ( this % bnd_flux_up ), & associated ( this % bnd_flux_dn ), & associated ( this % bnd_flux_dn_dir ), & associated ( this % bnd_flux_net ), & this % ty_fluxes_broadband % are_desired ()]) end function are_desired_byband ! ---------------------------------------------------------------------------- ! Kernels (private to this module) ! ---------------------------------------------------------------------------- ! ! Spectral reduction over all points ! subroutine sum_byband ( ncol , nlev , ngpt , nbnd , band_lims , spectral_flux , byband_flux ) bind ( C ) integer , intent ( in ) :: ncol , nlev , ngpt , nbnd integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( in ) :: spectral_flux real ( wp ), dimension ( ncol , nlev , nbnd ), intent ( out ) :: byband_flux integer :: icol , ilev , igpt , ibnd !$acc parallel loop collapse(3) copyin(spectral_flux, band_lims) copyout(byband_flux) !$omp target teams distribute parallel do collapse(3) map(to:spectral_flux, band_lims) map(from:byband_flux) do ibnd = 1 , nbnd do ilev = 1 , nlev do icol = 1 , ncol byband_flux ( icol , ilev , ibnd ) = spectral_flux ( icol , ilev , band_lims ( 1 , ibnd )) do igpt = band_lims ( 1 , ibnd ) + 1 , band_lims ( 2 , ibnd ) byband_flux ( icol , ilev , ibnd ) = byband_flux ( icol , ilev , ibnd ) + & spectral_flux ( icol , ilev , igpt ) end do end do end do enddo end subroutine sum_byband ! ---------------------------------------------------------------------------- ! ! Net flux: Spectral reduction over all points ! subroutine net_byband_full ( ncol , nlev , ngpt , nbnd , band_lims , spectral_flux_dn , spectral_flux_up , byband_flux_net ) bind ( C ) integer , intent ( in ) :: ncol , nlev , ngpt , nbnd integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( in ) :: spectral_flux_dn , spectral_flux_up real ( wp ), dimension ( ncol , nlev , nbnd ), intent ( out ) :: byband_flux_net integer :: icol , ilev , igpt , ibnd !$acc parallel loop collapse(3) copyin(spectral_flux_dn, spectral_flux_up, band_lims) copyout(byband_flux_net) !$omp target teams distribute parallel do collapse(3) map(to:spectral_flux_dn, spectral_flux_up, band_lims) map(from:byband_flux_net) do ibnd = 1 , nbnd do ilev = 1 , nlev do icol = 1 , ncol igpt = band_lims ( 1 , ibnd ) byband_flux_net ( icol , ilev , ibnd ) = spectral_flux_dn ( icol , ilev , igpt ) - & spectral_flux_up ( icol , ilev , igpt ) do igpt = band_lims ( 1 , ibnd ) + 1 , band_lims ( 2 , ibnd ) byband_flux_net ( icol , ilev , ibnd ) = byband_flux_net ( icol , ilev , ibnd ) + & spectral_flux_dn ( icol , ilev , igpt ) - & spectral_flux_up ( icol , ilev , igpt ) end do end do end do end do end subroutine net_byband_full ! ---------------------------------------------------------------------------- subroutine net_byband_precalc ( ncol , nlev , nbnd , byband_flux_dn , byband_flux_up , byband_flux_net ) bind ( C ) integer , intent ( in ) :: ncol , nlev , nbnd real ( wp ), dimension ( ncol , nlev , nbnd ), intent ( in ) :: byband_flux_dn , byband_flux_up real ( wp ), dimension ( ncol , nlev , nbnd ), intent ( out ) :: byband_flux_net byband_flux_net ( 1 : ncol , 1 : nlev , 1 : nbnd ) = byband_flux_dn ( 1 : ncol , 1 : nlev , 1 : nbnd ) - byband_flux_up ( 1 : ncol , 1 : nlev , 1 : nbnd ) end subroutine net_byband_precalc ! ---------------------------------------------------------------------------- end module mo_fluxes_byband","tags":"","loc":"sourcefile/mo_fluxes_byband.f90.html"},{"title":"mo_fluxes_bygpoint.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_fluxes_bygpoint.f90~~EfferentGraph sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_fluxes_bygpoint Source Code mo_fluxes_bygpoint.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! This module is for packaging output quantities from RRTMGP based on spectral flux profiles !    This implementation reports the g-point fluxes ! module mo_fluxes_bygpoint use mo_rte_kind , only : wp use mo_rte_util_array , only : extents_are use mo_fluxes , only : ty_fluxes use mo_optical_props , only : ty_optical_props implicit none ! Output from radiation calculations !   Data components are pointers so results can be written directly into memory !   reduce() function accepts spectral flux profiles type , extends ( ty_fluxes ) :: ty_fluxes_bygpoint real ( wp ), dimension (:,:,:), pointer :: gpt_flux_up => NULL (), & ! Band-by-band fluxes gpt_flux_dn => NULL () ! (ncol, nlev, nband) real ( wp ), dimension (:,:,:), pointer :: gpt_flux_net => NULL () ! Net (down - up) real ( wp ), dimension (:,:,:), pointer :: gpt_flux_dn_dir => NULL () ! Direct flux down contains procedure :: reduce => reduce_bygpoint procedure :: are_desired => are_desired_bygpoint end type ty_fluxes_bygpoint contains ! -------------------------------------------------------------------------------------- function reduce_bygpoint ( this , gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) result ( error_msg ) class ( ty_fluxes_bygpoint ), intent ( inout ) :: this real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_up ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_dn ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) class ( ty_optical_props ), intent ( in ) :: spectral_disc !< derived type with spectral information logical , intent ( in ) :: top_at_1 real ( kind = wp ), dimension (:,:,:), optional , & intent ( in ) :: gpt_flux_dn_dir ! Direct flux down character ( len = 128 ) :: error_msg ! ------ integer :: ncol , nlev , ngpt , nbnd ! ------ error_msg = \"\" ncol = size ( gpt_flux_up , DIM = 1 ) nlev = size ( gpt_flux_up , DIM = 2 ) ngpt = size ( gpt_flux_up , DIM = 3 ) if ( associated ( this % gpt_flux_up )) then if (. not . extents_are ( this % gpt_flux_up , ncol , nlev , ngpt )) then error_msg = \"reduce: gpt_flux_up array incorrectly sized (can't compute net flux either)\" else this % gpt_flux_up (:,:,:) = gpt_flux_up (:,:,:) end if end if if ( associated ( this % gpt_flux_dn )) then if (. not . extents_are ( this % gpt_flux_dn , ncol , nlev , ngpt )) then error_msg = \"reduce: gpt_flux_dn array incorrectly sized (can't compute net flux either)\" else this % gpt_flux_dn (:,:,:) = gpt_flux_dn (:,:,:) end if end if if ( associated ( this % gpt_flux_net )) then if (. not . extents_are ( this % gpt_flux_net , ncol , nlev , ngpt )) then error_msg = \"reduce: gpt_flux_net array incorrectly sized (can't compute net flux either)\" else this % gpt_flux_net (:,:,:) = gpt_flux_dn (:,:,:) - gpt_flux_up (:,:,:) end if end if if ( associated ( this % gpt_flux_dn_dir )) then if (. not . extents_are ( this % gpt_flux_dn_dir , ncol , nlev , ngpt )) then error_msg = \"reduce: gpt_flux_dn_dir array incorrectly sized (can't compute net flux either)\" else if ( present ( gpt_flux_dn_dir )) then this % gpt_flux_dn_dir (:,:,:) = gpt_flux_dn_dir (:,:,:) end if end if end function reduce_bygpoint ! -------------------------------------------------------------------------------------- ! Are any fluxes desired from this set of g-point fluxes? We can tell because memory will !   be allocated for output ! function are_desired_bygpoint ( this ) class ( ty_fluxes_bygpoint ), intent ( in ) :: this logical :: are_desired_bygpoint are_desired_bygpoint = any ([ associated ( this % gpt_flux_up ), & associated ( this % gpt_flux_dn ), & associated ( this % gpt_flux_dn_dir ), & associated ( this % gpt_flux_net )]) end function are_desired_bygpoint end module mo_fluxes_bygpoint","tags":"","loc":"sourcefile/mo_fluxes_bygpoint.f90.html"},{"title":"mo_solar_variability.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_solar_variability.f90~~EfferentGraph sourcefile~mo_solar_variability.f90 mo_solar_variability.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_solar_variability.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_solar_variability Source Code mo_solar_variability.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2020,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! Description: Optional calculation of solar variability facular and ! sunspot indices module mo_solar_variability use mo_rte_kind , only : wp implicit none private type , public :: ty_solar_var ! ! Data ! real ( wp ), dimension (:,:), allocatable :: avgcyc_ind ! solar variabilty index lookup table ! time-averaged over solar cycles 13-24. ! (NRLSSI2 facular \"Bremen\" index and ! sunspot \"SPOT67\" index) ! (nsolarterms, nsolarfrac) -> (2,134) contains ! ! Public procedures ! procedure , public :: solar_var_ind_interp procedure , public :: load procedure , public :: finalize ! end type ty_solar_var contains ! ------------------------------------------------------------------------------ ! ! Routine to load mean facular and sunspot index tables ! ! ------------------------------------------------------------------------------ function load ( this , avgcyc_ind ) result ( error_msg ) class ( ty_solar_var ), intent ( inout ) :: this ! Lookup table of mean solar cycle facular brightening and sunspot dimming indices real ( wp ), dimension (:,:), intent ( in ) :: avgcyc_ind character ( len = 128 ) :: error_msg ! ------- ! ! Local variables ! integer :: nsolarterms , nsolarfrac error_msg = \"\" ! ! LUT index dimensions ! nsolarterms = size ( avgcyc_ind , dim = 1 ) nsolarfrac = size ( avgcyc_ind , dim = 2 ) ! ! Allocate LUT index array allocate ( this % avgcyc_ind ( nsolarterms , nsolarfrac )) ! Load LUT index array this % avgcyc_ind = avgcyc_ind end function load !-------------------------------------------------------------------------------------------------------------------- ! ! Finalize ! !-------------------------------------------------------------------------------------------------------------------- subroutine finalize ( this ) class ( ty_solar_var ), intent ( inout ) :: this ! Lookup table solar variability indices if ( allocated ( this % avgcyc_ind )) then deallocate ( this % avgcyc_ind ) end if end subroutine finalize ! ------------------------------------------------------------------------------ ! ! Facular brightening and sunspot dimming indices are derived from the ! averaged solar cycle, which is the mean of Solar Cycles 13-24. The user specifices ! the solar cycle fraction (0 to 1) and the indices are interpolated to the ! requested fractional position within the cycle, where 0 is close to solar minimum. ! function solar_var_ind_interp ( this , & solcycfrac , & mg_index , sb_index ) & result ( error_msg ) class ( ty_solar_var ), intent ( in ) :: this ! Solar variability real ( wp ), intent ( in ) :: solcycfrac ! solar cycle fraction real ( wp ), intent ( out ) :: mg_index ! Facular brightening NRLSSI2 index ! interpolated from the mean solar cycle ! to the provided solar cycle fraction real ( wp ), intent ( out ) :: sb_index ! Sunspot dimmng NRLSSI2 index ! interpolated from the mean solar cycle ! to the provided solar cycle fraction character ( len = 128 ) :: error_msg ! ---------------------------------------------------------- ! Local variables ! integer :: nsolfrac ! Number of solar fraction points in facular ! and sunspot tables integer :: sfid ! Solar variability solar cycle fraction index real ( wp ) :: intrvl_len ! Fractional interval length of mgavgcyc and sbavgcyc real ( wp ) :: intrvl_len_hf ! Fractional half interval length of mgavgcyc and sbavgcyc real ( wp ) :: fraclo , frachi , intfrac ! Solar variability interpolation factors ! ---------------------------------------------------------- ! Error checking error_msg = \"\" ! ! Check input data sizes and values ! if ( solcycfrac . lt . 0._wp . or . solcycfrac . gt . 1._wp ) & error_msg = 'solar_var_ind_interp: solcycfrac out of range' if ( error_msg /= '' ) return ! ! Interpolate solar variability indices to requested solar cycle fraction, ! and derive final facular and sunspot indices ! ! nsolfrac is the length of the time dimension of the interpolation tables ! of facular and sunspot indices over the mean solar cycle (this%avgcyc_ind). ! The end-points of avgcyc_ind represent the indices at solcycfrac values of ! 0 (first day of the first year) and 1 (last day of the 11th year), while ! the intervening values of avgcyc_ind represent the indices at the center ! of each month over the mean 11-year solar cycle. if ( allocated ( this % avgcyc_ind )) then nsolfrac = size ( this % avgcyc_ind , 2 ) ! Define indices for the lowest allowable value of solcycfrac if ( solcycfrac . eq . 0._wp ) then mg_index = this % avgcyc_ind ( 1 , 1 ) sb_index = this % avgcyc_ind ( 2 , 1 ) ! Define indices for the highest allowable value of solcycfrac elseif ( solcycfrac . eq . 1._wp ) then mg_index = this % avgcyc_ind ( 1 , nsolfrac ) sb_index = this % avgcyc_ind ( 2 , nsolfrac ) ! Define indices for intervening values of solcycfrac else intrvl_len = 1._wp / ( nsolfrac - 2 ) intrvl_len_hf = 0.5_wp * intrvl_len ! Define interpolation fractions for the first interval, which represents ! the first half of the first month of the first year of the mean 11-year ! solar cycle if ( solcycfrac . le . intrvl_len_hf ) then sfid = 1 fraclo = 0._wp frachi = intrvl_len_hf endif ! Define interpolation fractions for the intervening intervals, which represent ! the center point of each month in each year of the mean 11-year solar cycle if ( solcycfrac . gt . intrvl_len_hf . and . solcycfrac . lt . 1._wp - intrvl_len_hf ) then sfid = floor (( solcycfrac - intrvl_len_hf ) * ( nsolfrac - 2 )) + 2 fraclo = ( sfid - 2 ) * intrvl_len + intrvl_len_hf frachi = fraclo + intrvl_len endif ! Define interpolation fractions for the last interval, which represents ! the last half of the last month of the last year of the mean 11-year ! solar cycle if ( solcycfrac . ge . 1._wp - intrvl_len_hf ) then sfid = ( nsolfrac - 2 ) + 1 fraclo = 1._wp - intrvl_len_hf frachi = 1._wp endif ! Interpolate the facular (mg_index) and sunspot (sb_index) indices for the ! requested value of solcycfrac intfrac = ( solcycfrac - fraclo ) / ( frachi - fraclo ) mg_index = this % avgcyc_ind ( 1 , sfid ) + & intfrac * ( this % avgcyc_ind ( 1 , sfid + 1 ) - this % avgcyc_ind ( 1 , sfid )) sb_index = this % avgcyc_ind ( 2 , sfid ) + & intfrac * ( this % avgcyc_ind ( 2 , sfid + 1 ) - this % avgcyc_ind ( 2 , sfid )) endif endif end function solar_var_ind_interp ! -------------------------------------------------------------------------------------- end module mo_solar_variability","tags":"","loc":"sourcefile/mo_solar_variability.f90.html"},{"title":"mo_cloud_sampling.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_cloud_sampling.f90~~EfferentGraph sourcefile~mo_cloud_sampling.f90 mo_cloud_sampling.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_cloud_sampling Source Code mo_cloud_sampling.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2019,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! This module provides a simple implementation of sampling for the !   Monte Carlo Independent Pixel Approximation (McICA, doi:10.1029/2002jd003322) ! Cloud optical properties, defined by band and assumed homogenous within each cell (column/layer), !   are randomly sampled to preserve the mean cloud fraction and one of several possible overlap assumptions ! Users supply random numbers with order ngpt,nlay,ncol !   These are only accessed if cloud_fraction(icol,ilay) > 0 so many values don't need to be filled in ! ! ------------------------------------------------------------------------------------------------- module mo_cloud_sampling use mo_rte_kind , only : wp , wl use mo_optical_props , only : ty_optical_props_arry , & ty_optical_props_1scl , & ty_optical_props_2str , & ty_optical_props_nstr implicit none private public :: draw_samples , sampled_mask_max_ran , sampled_mask_exp_ran contains ! ------------------------------------------------------------------------------------------------- ! ! Apply a T/F sampled cloud mask to cloud optical properties defined by band to produce !   McICA-sampled cloud optical properties ! function draw_samples ( cloud_mask , clouds , clouds_sampled ) result ( error_msg ) logical , dimension (:,:,:), intent ( in ) :: cloud_mask ! Dimensions ncol,nlay,ngpt class ( ty_optical_props_arry ), intent ( in ) :: clouds ! Defined by band class ( ty_optical_props_arry ), intent ( inout ) :: clouds_sampled ! Defined by g-point character ( len = 128 ) :: error_msg ! ------------------------ integer :: ncol , nlay , nbnd , ngpt integer :: imom ! ------------------------ ! ! Error checking ! error_msg = \"\" if (. not . clouds % is_initialized ()) then error_msg = \"draw_samples: cloud optical properties are not initialized\" return end if if (. not . clouds_sampled % is_initialized ()) then error_msg = \"draw_samples: sampled cloud optical properties are not initialized\" return end if ! ! Variables clouds and clouds_sampled have to be of the same type (have the same set of fields) !   nstr isn't supported !   2str is checked at assignment ! select type ( clouds ) type is ( ty_optical_props_1scl ) select type ( clouds_sampled ) type is ( ty_optical_props_2str ) error_msg = \"draw_samples: by-band and sampled cloud properties need to be the same variable type\" return type is ( ty_optical_props_nstr ) error_msg = \"draw_samples: by-band and sampled cloud properties need to be the same variable type\" return end select type is ( ty_optical_props_nstr ) error_msg = \"draw_samples: sampling isn't implemented yet for ty_optical_props_nstr\" return end select ! ! Spectral discretization ! if (. not . clouds % bands_are_equal ( clouds_sampled )) then error_msg = \"draw_samples: by-band and sampled cloud properties spectral structure is different\" return end if ! ! Array extents ! ncol = clouds % get_ncol () nlay = clouds % get_nlay () nbnd = clouds % get_nband () ngpt = clouds_sampled % get_ngpt () if ( any ([ size ( cloud_mask , 1 ), size ( cloud_mask , 2 ), size ( cloud_mask , 3 )] /= [ ncol , nlay , ngpt ])) then error_msg = \"draw_samples: cloud mask and cloud optical properties have different ncol and/or nlay\" return end if if ( any ([ clouds_sampled % get_ncol (), clouds_sampled % get_nlay ()] /= [ ncol , nlay ])) then error_msg = \"draw_samples: sampled/unsampled cloud optical properties have different ncol and/or nlay\" return end if ! ------------------------ ! ! Finally - sample fields according to the cloud mask ! ! Optical depth assignment works for 1scl, 2str (also nstr) call apply_cloud_mask ( ncol , nlay , nbnd , ngpt , clouds_sampled % get_band_lims_gpoint (), cloud_mask , clouds % tau , clouds_sampled % tau ) ! ! For 2-stream ! select type ( clouds ) type is ( ty_optical_props_2str ) select type ( clouds_sampled ) type is ( ty_optical_props_2str ) call apply_cloud_mask ( ncol , nlay , nbnd , ngpt , clouds_sampled % get_band_lims_gpoint (), cloud_mask , clouds % ssa , clouds_sampled % ssa ) call apply_cloud_mask ( ncol , nlay , nbnd , ngpt , clouds_sampled % get_band_lims_gpoint (), cloud_mask , clouds % g , clouds_sampled % g ) class default error_msg = \"draw_samples: by-band and sampled cloud properties need to be the same variable type\" end select end select end function draw_samples ! ------------------------------------------------------------------------------------------------- ! ! Generate a McICA-sampled cloud mask for maximum-random overlap ! function sampled_mask_max_ran ( randoms , cloud_frac , cloud_mask ) result ( error_msg ) real ( wp ), dimension (:,:,:), intent ( in ) :: randoms !ngpt,nlay,ncol real ( wp ), dimension (:,:), intent ( in ) :: cloud_frac ! ncol,nlay logical , dimension (:,:,:), intent ( out ) :: cloud_mask ! ncol,nlay,ngpt character ( len = 128 ) :: error_msg ! ------------------------ integer :: ncol , nlay , ngpt , icol , ilay , igpt integer :: cloud_lay_fst , cloud_lay_lst real ( wp ), dimension ( size ( randoms , 1 )) :: local_rands logical , dimension ( size ( randoms , 2 )) :: cloud_mask_layer ! ------------------------ ! ! Error checking ! error_msg = \"\" ncol = size ( randoms , 3 ) nlay = size ( randoms , 2 ) ngpt = size ( randoms , 1 ) if ( any ([ ncol , nlay ] /= [ size ( cloud_frac , 1 ), size ( cloud_frac , 2 )])) then error_msg = \"sampled_mask_max_ran: sizes of randoms(ngpt,nlay,ncol) and cloud_frac(ncol,nlay) are inconsistent\" return end if if ( any ([ ncol , nlay , ngpt ] /= [ size ( cloud_mask , 1 ), size ( cloud_mask , 2 ), size ( cloud_mask , 3 )])) then error_msg = \"sampled_mask_max_ran: sizes of randoms(ngpt,nlay,ncol) and cloud_mask(ncol,nlay,ngpt) are inconsistent\" return end if if ( any ( cloud_frac > 1._wp ) . or . any ( cloud_frac < 0._wp )) then error_msg = \"sampled_mask_max_ran: cloud fraction values out of range [0,1]\" return end if ! ! We chould check the random numbers but that would be computationally heavy ! ! ------------------------ ! ! Construct the cloud mask for each column ! do icol = 1 , ncol cloud_mask_layer ( 1 : nlay ) = cloud_frac ( icol , 1 : nlay ) > 0._wp if (. not . any ( cloud_mask_layer )) then cloud_mask ( icol , 1 : nlay , 1 : ngpt ) = . false . cycle end if cloud_lay_fst = findloc ( cloud_mask_layer , . true ., dim = 1 ) cloud_lay_lst = findloc ( cloud_mask_layer , . true ., dim = 1 , back = . true .) cloud_mask ( icol , 1 : cloud_lay_fst , 1 : ngpt ) = . false . ilay = cloud_lay_fst local_rands ( 1 : ngpt ) = randoms ( 1 : ngpt , cloud_lay_fst , icol ) cloud_mask ( icol , ilay , 1 : ngpt ) = local_rands ( 1 : ngpt ) > ( 1._wp - cloud_frac ( icol , ilay )) do ilay = cloud_lay_fst + 1 , cloud_lay_lst if ( cloud_mask_layer ( ilay )) then ! ! Max-random overlap: !   new  random deviates if the adjacent layer isn't cloudy !   same random deviates if the adjacent layer is    cloudy ! if (. not . cloud_mask_layer ( ilay - 1 )) local_rands ( 1 : ngpt ) = randoms ( 1 : ngpt , ilay , icol ) cloud_mask ( icol , ilay , 1 : ngpt ) = local_rands ( 1 : ngpt ) > ( 1._wp - cloud_frac ( icol , ilay )) else cloud_mask ( icol , ilay , 1 : ngpt ) = . false . end if end do cloud_mask ( icol , cloud_lay_lst + 1 : nlay , 1 : ngpt ) = . false . end do end function sampled_mask_max_ran ! ------------------------------------------------------------------------------------------------- ! ! Generate a McICA-sampled cloud mask for exponential-random overlap !   The overlap parameter alpha is defined between pairs of layers !   for layer i, alpha(i) describes the overlap betwen cloud_frac(i) and cloud_frac(i+1) !   By skipping layers with 0 cloud fraction the code forces alpha(i) = 0 for cloud_frac(i) = 0. ! function sampled_mask_exp_ran ( randoms , cloud_frac , overlap_param , cloud_mask ) result ( error_msg ) real ( wp ), dimension (:,:,:), intent ( in ) :: randoms ! ngpt,nlay,ncol real ( wp ), dimension (:,:), intent ( in ) :: cloud_frac ! ncol,nlay real ( wp ), dimension (:,:), intent ( in ) :: overlap_param ! ncol,nlay-1 logical , dimension (:,:,:), intent ( out ) :: cloud_mask ! ncol,nlay,ngpt character ( len = 128 ) :: error_msg ! ------------------------ integer :: ncol , nlay , ngpt , icol , ilay , igpt integer :: cloud_lay_fst , cloud_lay_lst real ( wp ) :: rho ! correlation coefficient real ( wp ), dimension ( size ( randoms , 1 )) :: local_rands logical , dimension ( size ( randoms , 2 )) :: cloud_mask_layer ! ------------------------ ! ! Error checking ! error_msg = \"\" ncol = size ( randoms , 3 ) nlay = size ( randoms , 2 ) ngpt = size ( randoms , 1 ) if ( any ([ ncol , nlay ] /= [ size ( cloud_frac , 1 ), size ( cloud_frac , 2 )])) then error_msg = \"sampled_mask_max_ran: sizes of randoms(ngpt,nlay,ncol) and cloud_frac(ncol,nlay) are inconsistent\" return end if if ( any ([ ncol , nlay - 1 ] /= [ size ( overlap_param , 1 ), size ( overlap_param , 2 )])) then error_msg = \"sampled_mask_max_ran: sizes of randoms(ngpt,nlay,ncol) and overlap_param(ncol,nlay-1) are inconsistent\" return end if if ( any ([ ncol , nlay , ngpt ] /= [ size ( cloud_mask , 1 ), size ( cloud_mask , 2 ), size ( cloud_mask , 3 )])) then error_msg = \"sampled_mask_max_ran: sizes of randoms(ngpt,nlay,ncol) and cloud_mask(ncol,nlay,ngpt) are inconsistent\" return end if if ( any ( cloud_frac > 1._wp ) . or . any ( cloud_frac < 0._wp )) then error_msg = \"sampled_mask_max_ran: cloud fraction values out of range [0,1]\" return end if if ( any ( overlap_param > 1._wp ) . or . any ( overlap_param < - 1._wp )) then error_msg = \"sampled_mask_max_ran: overlap_param values out of range [-1,1]\" return end if ! ! We chould check the random numbers but that would be computationally heavy ! ! ------------------------ ! Construct the cloud mask for each column ! do icol = 1 , ncol cloud_mask_layer ( 1 : nlay ) = cloud_frac ( icol , 1 : nlay ) > 0._wp if (. not . any ( cloud_mask_layer )) then cloud_mask ( icol , 1 : nlay , 1 : ngpt ) = . false . cycle end if cloud_lay_fst = findloc ( cloud_mask_layer , . true ., dim = 1 ) cloud_lay_lst = findloc ( cloud_mask_layer , . true ., dim = 1 , back = . true .) cloud_mask ( icol , 1 : cloud_lay_fst , 1 : ngpt ) = . false . ilay = cloud_lay_fst local_rands ( 1 : ngpt ) = randoms ( 1 : ngpt , ilay , icol ) cloud_mask ( icol , ilay , 1 : ngpt ) = local_rands ( 1 : ngpt ) > ( 1._wp - cloud_frac ( icol , ilay )) do ilay = cloud_lay_fst + 1 , cloud_lay_lst if ( cloud_mask_layer ( ilay )) then ! ! Exponential-random overlap: !   new  random deviates if the adjacent layer isn't cloudy !   correlated  deviates if the adjacent layer is    cloudy ! if ( cloud_mask_layer ( ilay - 1 )) then ! ! Create random deviates correlated between this layer and the previous layer !    (have to remove mean value before enforcing correlation) ! rho = overlap_param ( icol , ilay - 1 ) local_rands ( 1 : ngpt ) = rho * ( local_rands ( 1 : ngpt ) - 0.5_wp ) + & sqrt ( 1._wp - rho * rho ) * ( randoms ( 1 : ngpt , ilay , icol ) - 0.5_wp ) + 0.5_wp else local_rands ( 1 : ngpt ) = randoms ( 1 : ngpt , ilay , icol ) end if cloud_mask ( icol , ilay , 1 : ngpt ) = local_rands ( 1 : ngpt ) > ( 1._wp - cloud_frac ( icol , ilay )) end if end do cloud_mask ( icol , cloud_lay_lst + 1 : nlay , 1 : ngpt ) = . false . end do end function sampled_mask_exp_ran ! ------------------------------------------------------------------------------------------------- ! ! Apply a true/false cloud mask to a homogeneous field !   This could be a kernel ! subroutine apply_cloud_mask ( ncol , nlay , nbnd , ngpt , band_lims_gpt , cloud_mask , input_field , sampled_field ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt logical , dimension ( ncol , nlay , ngpt ), intent ( in ) :: cloud_mask real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: input_field real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: sampled_field integer :: icol , ilay , ibnd , igpt do ibnd = 1 , nbnd do igpt = band_lims_gpt ( 1 , ibnd ), band_lims_gpt ( 2 , ibnd ) do ilay = 1 , nlay sampled_field ( 1 : ncol , ilay , igpt ) = merge ( input_field ( 1 : ncol , ilay , ibnd ), 0._wp , cloud_mask ( 1 : ncol , ilay , igpt )) end do end do end do end subroutine apply_cloud_mask end module mo_cloud_sampling","tags":"","loc":"sourcefile/mo_cloud_sampling.f90.html"},{"title":"mo_cloud_optics.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_cloud_optics.f90~~EfferentGraph sourcefile~mo_cloud_optics.f90 mo_cloud_optics.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_cloud_optics Source Code mo_cloud_optics.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! Provides cloud optical properties as a function of effective radius for the RRTMGP bands !   Based on Mie calculations for liquid !     and results from doi:10.1175/JAS-D-12-039.1 for ice with variable surface roughness !   Can use either look-up tables or Pade approximates according to which data has been loaded !   Mike Iacono (AER) is the original author ! ! The class can be used as-is but is also intended as an example of how to extend the RTE framework ! ------------------------------------------------------------------------------------------------- module mo_cloud_optics use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_values , check_extents use mo_rte_util_array , only : any_vals_less_than , any_vals_outside , extents_are use mo_optical_props , only : ty_optical_props , & ty_optical_props_arry , & ty_optical_props_1scl , & ty_optical_props_2str , & ty_optical_props_nstr implicit none interface pade_eval module procedure pade_eval_nbnd , pade_eval_1 end interface pade_eval private ! ----------------------------------------------------------------------------------- type , extends ( ty_optical_props ), public :: ty_cloud_optics private ! ! Ice surface roughness category - needed for Yang (2013) ice optics parameterization ! integer :: icergh = 0 ! (1 = none, 2 = medium, 3 = high) ! ! Lookup table information ! ! Upper and lower limits of the tables real ( wp ) :: radliq_lwr = 0._wp , radliq_upr = 0._wp real ( wp ) :: radice_lwr = 0._wp , radice_upr = 0._wp ! How many steps in the table? (for convenience) integer :: liq_nsteps = 0 , ice_nsteps = 0 ! How big is each step in the table? real ( wp ) :: liq_step_size = 0._wp , ice_step_size = 0._wp ! ! The tables themselves. ! real ( wp ), dimension (:,: ), allocatable :: lut_extliq , lut_ssaliq , lut_asyliq ! (nsize_liq, nbnd) real ( wp ), dimension (:,:,: ), allocatable :: lut_extice , lut_ssaice , lut_asyice ! (nsize_ice, nbnd, nrghice) ! ! Pade approximant coefficients ! real ( wp ), dimension (:,:,: ), allocatable :: pade_extliq ! (nbnd, nsizereg, ncoeff_ext) real ( wp ), dimension (:,:,: ), allocatable :: pade_ssaliq , pade_asyliq ! (nbnd, nsizereg, ncoeff_ssa_g) real ( wp ), dimension (:,:,:,:), allocatable :: pade_extice ! (nbnd, nsizereg, ncoeff_ext, nrghice) real ( wp ), dimension (:,:,:,:), allocatable :: pade_ssaice , pade_asyice ! (nbnd, nsizereg, ncoeff_ssa_g, nrghice) ! Particle size regimes for Pade formulations real ( wp ), dimension (:), allocatable :: pade_sizreg_extliq , pade_sizreg_ssaliq , pade_sizreg_asyliq ! (nbound) real ( wp ), dimension (:), allocatable :: pade_sizreg_extice , pade_sizreg_ssaice , pade_sizreg_asyice ! (nbound) ! ----- contains generic , public :: load => load_lut , load_pade procedure , public :: finalize procedure , public :: cloud_optics procedure , public :: get_min_radius_liq procedure , public :: get_min_radius_ice procedure , public :: get_max_radius_liq procedure , public :: get_max_radius_ice procedure , public :: get_num_ice_roughness_types procedure , public :: set_ice_roughness ! Internal procedures procedure , private :: load_lut procedure , private :: load_pade end type ty_cloud_optics contains ! ------------------------------------------------------------------------------ ! ! Routines to load data needed for cloud optics calculations. Two routines: one to load !    lookup-tables and one for coefficients for Pade approximates ! ! ------------------------------------------------------------------------------ function load_lut ( this , band_lims_wvn , & radliq_lwr , radliq_upr , radliq_fac , & radice_lwr , radice_upr , radice_fac , & lut_extliq , lut_ssaliq , lut_asyliq , & lut_extice , lut_ssaice , lut_asyice ) result ( error_msg ) class ( ty_cloud_optics ), intent ( inout ) :: this real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn ! Spectral discretization ! Lookup table interpolation constants ! Lower and upper bounds of the tables; also the constant for calculating interpolation indices for liquid real ( wp ), intent ( in ) :: radliq_lwr , radliq_upr , radliq_fac real ( wp ), intent ( in ) :: radice_lwr , radice_upr , radice_fac ! LUT coefficients ! Extinction, single-scattering albedo, and asymmetry parameter for liquid and ice respectively real ( wp ), dimension (:,:), intent ( in ) :: lut_extliq , lut_ssaliq , lut_asyliq real ( wp ), dimension (:,:,:), intent ( in ) :: lut_extice , lut_ssaice , lut_asyice character ( len = 128 ) :: error_msg ! ------- ! ! Local variables ! integer :: nbnd , nrghice , nsize_liq , nsize_ice error_msg = this % init ( band_lims_wvn , name = \"RRTMGP cloud optics\" ) ! ! LUT coefficient dimensions ! nsize_liq = size ( lut_extliq , dim = 1 ) nsize_ice = size ( lut_extice , dim = 1 ) nbnd = size ( lut_extliq , dim = 2 ) nrghice = size ( lut_extice , dim = 3 ) ! ! Error checking !   Can we check for consistency between table bounds and _fac? ! if ( nbnd /= this % get_nband ()) & error_msg = \"cloud_optics%init(): number of bands inconsistent between lookup tables, spectral discretization\" if ( size ( lut_extice , 2 ) /= nbnd ) & error_msg = \"cloud_optics%init(): array lut_extice has the wrong number of bands\" if (. not . extents_are ( lut_ssaliq , nsize_liq , nbnd )) & error_msg = \"cloud_optics%init(): array lut_ssaliq isn't consistently sized\" if (. not . extents_are ( lut_asyliq , nsize_liq , nbnd )) & error_msg = \"cloud_optics%init(): array lut_asyliq isn't consistently sized\" if (. not . extents_are ( lut_ssaice , nsize_ice , nbnd , nrghice )) & error_msg = \"cloud_optics%init(): array lut_ssaice  isn't consistently sized\" if (. not . extents_are ( lut_asyice , nsize_ice , nbnd , nrghice )) & error_msg = \"cloud_optics%init(): array lut_asyice  isn't consistently sized\" if ( error_msg /= \"\" ) return this % liq_nsteps = nsize_liq this % ice_nsteps = nsize_ice this % liq_step_size = ( radliq_upr - radliq_lwr ) / real ( nsize_liq - 1 , wp ) this % ice_step_size = ( radice_upr - radice_lwr ) / real ( nsize_ice - 1 , wp ) ! Allocate LUT coefficients allocate ( this % lut_extliq ( nsize_liq , nbnd ), & this % lut_ssaliq ( nsize_liq , nbnd ), & this % lut_asyliq ( nsize_liq , nbnd ), & this % lut_extice ( nsize_ice , nbnd , nrghice ), & this % lut_ssaice ( nsize_ice , nbnd , nrghice ), & this % lut_asyice ( nsize_ice , nbnd , nrghice )) !$acc enter data create(this)                                               & !$acc            create(this%lut_extliq, this%lut_ssaliq, this%lut_asyliq)  & !$acc            create(this%lut_extice, this%lut_ssaice, this%lut_asyice) !$omp target enter data & !$omp map(alloc:this%lut_extliq, this%lut_ssaliq, this%lut_asyliq) & !$omp map(alloc:this%lut_extice, this%lut_ssaice, this%lut_asyice) ! Load LUT constants this % radliq_lwr = radliq_lwr this % radliq_upr = radliq_upr this % radice_lwr = radice_lwr this % radice_upr = radice_upr ! Load LUT coefficients !$acc kernels !$omp target this % lut_extliq = lut_extliq this % lut_ssaliq = lut_ssaliq this % lut_asyliq = lut_asyliq this % lut_extice = lut_extice this % lut_ssaice = lut_ssaice this % lut_asyice = lut_asyice !$acc end kernels !$omp end target ! ! Set default ice roughness - min values ! error_msg = this % set_ice_roughness ( 1 ) end function load_lut ! ------------------------------------------------------------------------------ ! ! Cloud optics initialization function - Pade ! ! ------------------------------------------------------------------------------ function load_pade ( this , band_lims_wvn , & pade_extliq , pade_ssaliq , pade_asyliq , & pade_extice , pade_ssaice , pade_asyice , & pade_sizreg_extliq , pade_sizreg_ssaliq , pade_sizreg_asyliq , & pade_sizreg_extice , pade_sizreg_ssaice , pade_sizreg_asyice ) & result ( error_msg ) class ( ty_cloud_optics ), intent ( inout ) :: this ! cloud specification data real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn ! Spectral discretization ! ! Pade coefficients: extinction, single-scattering albedo, and asymmetry factor for liquid and ice ! real ( wp ), dimension (:,:,:), intent ( in ) :: pade_extliq , pade_ssaliq , pade_asyliq real ( wp ), dimension (:,:,:,:), intent ( in ) :: pade_extice , pade_ssaice , pade_asyice ! ! Boundaries of size regimes. Liquid and ice are separate; !   extinction is fit to different numbers of size bins than single-scattering albedo and asymmetry factor ! real ( wp ), dimension (:), intent ( in ) :: pade_sizreg_extliq , pade_sizreg_ssaliq , pade_sizreg_asyliq real ( wp ), dimension (:), intent ( in ) :: pade_sizreg_extice , pade_sizreg_ssaice , pade_sizreg_asyice character ( len = 128 ) :: error_msg ! ------- Local ------- integer :: nbnd , nrghice , nsizereg , ncoeff_ext , ncoeff_ssa_g , nbound ! ------- Definitions ------- ! Pade coefficient dimensions nbnd = size ( pade_extliq , dim = 1 ) nsizereg = size ( pade_extliq , dim = 2 ) ncoeff_ext = size ( pade_extliq , dim = 3 ) ncoeff_ssa_g = size ( pade_ssaliq , dim = 3 ) nrghice = size ( pade_extice , dim = 4 ) nbound = size ( pade_sizreg_extliq ) ! The number of size regimes is assumed in the Pade evaluations if ( nsizereg /= 3 ) & error_msg = \"cloud optics: code assumes exactly three size regimes for Pade approximants but data is otherwise\" error_msg = this % init ( band_lims_wvn , name = \"RRTMGP cloud optics\" ) ! ! Error checking ! if ( nbnd /= this % get_nband ()) & error_msg = \"cloud_optics%init(): number of bands inconsistent between lookup tables, spectral discretization\" if (. not . extents_are ( pade_ssaliq , nbnd , nsizereg , ncoeff_ssa_g )) & error_msg = \"cloud_optics%init(): array pade_ssaliq isn't consistently sized\" if (. not . extents_are ( pade_asyliq , nbnd , nsizereg , ncoeff_ssa_g )) & error_msg = \"cloud_optics%init(): array pade_asyliq isn't consistently sized\" if (. not . extents_are ( pade_extice , nbnd , nsizereg , ncoeff_ext , nrghice )) & error_msg = \"cloud_optics%init(): array pade_extice isn't consistently sized\" if (. not . extents_are ( pade_ssaice , nbnd , nsizereg , ncoeff_ssa_g , nrghice )) & error_msg = \"cloud_optics%init(): array pade_ssaice isn't consistently sized\" if (. not . extents_are ( pade_asyice , nbnd , nsizereg , ncoeff_ssa_g , nrghice )) & error_msg = \"cloud_optics%init(): array pade_asyice isn't consistently sized\" if ( any ([ size ( pade_sizreg_ssaliq ), size ( pade_sizreg_asyliq ), & size ( pade_sizreg_extice ), size ( pade_sizreg_ssaice ), size ( pade_sizreg_asyice )] /= nbound )) & error_msg = \"cloud_optics%init(): one or more Pade size regime arrays are inconsistently sized\" if ( nsizereg /= 3 ) & error_msg = \"cloud_optics%init(): Expecting precisely three size regimes for Pade approximants\" if ( error_msg /= \"\" ) return ! ! Consistency among size regimes ! this % radliq_lwr = pade_sizreg_extliq ( 1 ) this % radliq_upr = pade_sizreg_extliq ( nbound ) this % radice_lwr = pade_sizreg_extice ( 1 ) this % radice_upr = pade_sizreg_extice ( nbound ) if ( error_msg /= \"\" ) return if ( any ([ pade_sizreg_ssaliq ( 1 ), pade_sizreg_asyliq ( 1 )] < this % radliq_lwr )) & error_msg = \"cloud_optics%init(): one or more Pade size regimes have inconsistent lowest values\" if ( any ([ pade_sizreg_ssaice ( 1 ), pade_sizreg_asyice ( 1 )] < this % radice_lwr )) & error_msg = \"cloud_optics%init(): one or more Pade size regimes have inconsistent lower values\" if ( any ([ pade_sizreg_ssaliq ( nbound ), pade_sizreg_asyliq ( nbound )] > this % radliq_upr )) & error_msg = \"cloud_optics%init(): one or more Pade size regimes have lowest value less than radliq_upr\" if ( any ([ pade_sizreg_ssaice ( nbound ), pade_sizreg_asyice ( nbound )] > this % radice_upr )) & error_msg = \"cloud_optics%init(): one or more Pade size regimes have lowest value less than radice_upr\" if ( error_msg /= \"\" ) return ! ! Allocate Pade coefficients ! allocate ( this % pade_extliq ( nbnd , nsizereg , ncoeff_ext ), & this % pade_ssaliq ( nbnd , nsizereg , ncoeff_ssa_g ), & this % pade_asyliq ( nbnd , nsizereg , ncoeff_ssa_g ), & this % pade_extice ( nbnd , nsizereg , ncoeff_ext , nrghice ), & this % pade_ssaice ( nbnd , nsizereg , ncoeff_ssa_g , nrghice ), & this % pade_asyice ( nbnd , nsizereg , ncoeff_ssa_g , nrghice )) ! ! Allocate Pade coefficient particle size regime boundaries ! allocate ( this % pade_sizreg_extliq ( nbound ), & this % pade_sizreg_ssaliq ( nbound ), & this % pade_sizreg_asyliq ( nbound ), & this % pade_sizreg_extice ( nbound ), & this % pade_sizreg_ssaice ( nbound ), & this % pade_sizreg_asyice ( nbound )) !$acc enter data create(this)                                                                       & !$acc            create(this%pade_extliq, this%pade_ssaliq, this%pade_asyliq)                       & !$acc            create(this%pade_extice, this%pade_ssaice, this%pade_asyice)                       & !$acc            create(this%pade_sizreg_extliq, this%pade_sizreg_ssaliq, this%pade_sizreg_asyliq)  & !$acc            create(this%pade_sizreg_extice, this%pade_sizreg_ssaice, this%pade_sizreg_asyice) !$omp target enter data & !$omp map(alloc:this%pade_extliq, this%pade_ssaliq, this%pade_asyliq) & !$omp map(alloc:this%pade_extice, this%pade_ssaice, this%pade_asyice) & !$omp map(alloc:this%pade_sizreg_extliq, this%pade_sizreg_ssaliq, this%pade_sizreg_asyliq) & !$omp map(alloc:this%pade_sizreg_extice, this%pade_sizreg_ssaice, this%pade_sizreg_asyice) ! ! Load data ! !$acc kernels !$omp target this % pade_extliq = pade_extliq this % pade_ssaliq = pade_ssaliq this % pade_asyliq = pade_asyliq this % pade_extice = pade_extice this % pade_ssaice = pade_ssaice this % pade_asyice = pade_asyice this % pade_sizreg_extliq = pade_sizreg_extliq this % pade_sizreg_ssaliq = pade_sizreg_ssaliq this % pade_sizreg_asyliq = pade_sizreg_asyliq this % pade_sizreg_extice = pade_sizreg_extice this % pade_sizreg_ssaice = pade_sizreg_ssaice this % pade_sizreg_asyice = pade_sizreg_asyice !$acc end kernels !$omp end target ! ! Set default ice roughness - min values ! error_msg = this % set_ice_roughness ( 1 ) end function load_pade !-------------------------------------------------------------------------------------------------------------------- ! ! Finalize ! !-------------------------------------------------------------------------------------------------------------------- subroutine finalize ( this ) class ( ty_cloud_optics ), intent ( inout ) :: this this % radliq_lwr = 0._wp this % radliq_upr = 0._wp this % radice_lwr = 0._wp this % radice_upr = 0._wp ! Lookup table cloud optics coefficients if ( allocated ( this % lut_extliq )) then !$acc exit data delete(this%lut_extliq, this%lut_ssaliq, this%lut_asyliq)  & !$acc           delete(this%lut_extice, this%lut_ssaice, this%lut_asyice)  & !$acc           delete(this) !$omp target exit data map(release:this%lut_extliq, this%lut_ssaliq, this%lut_asyliq) & !$omp map(release:this%lut_extice, this%lut_ssaice, this%lut_asyice) deallocate ( this % lut_extliq , this % lut_ssaliq , this % lut_asyliq , & this % lut_extice , this % lut_ssaice , this % lut_asyice ) this % liq_nsteps = 0 this % ice_nsteps = 0 this % liq_step_size = 0._wp this % ice_step_size = 0._wp end if ! Pade cloud optics coefficients if ( allocated ( this % pade_extliq )) then !$acc exit data delete(this%pade_extliq, this%pade_ssaliq, this%pade_asyliq)                       & !$acc           delete(this%pade_extice, this%pade_ssaice, this%pade_asyice)                       & !$acc           delete(this%pade_sizreg_extliq, this%pade_sizreg_ssaliq, this%pade_sizreg_asyliq)  & !$acc           delete(this%pade_sizreg_extice, this%pade_sizreg_ssaice, this%pade_sizreg_asyice)  & !$acc           delete(this) !$omp target exit data map(release:this%pade_extliq, this%pade_ssaliq, this%pade_asyliq) & !$omp map(release:this%pade_extice, this%pade_ssaice, this%pade_asyice) & !$omp map(release:this%pade_sizreg_extliq, this%pade_sizreg_ssaliq, this%pade_sizreg_asyliq) & !$omp map(release:this%pade_sizreg_extice, this%pade_sizreg_ssaice, this%pade_sizreg_asyice) deallocate ( this % pade_extliq , this % pade_ssaliq , this % pade_asyliq , & this % pade_extice , this % pade_ssaice , this % pade_asyice , & this % pade_sizreg_extliq , this % pade_sizreg_ssaliq , this % pade_sizreg_asyliq , & this % pade_sizreg_extice , this % pade_sizreg_ssaice , this % pade_sizreg_asyice ) end if end subroutine finalize ! ------------------------------------------------------------------------------ ! ! Derive cloud optical properties from provided cloud physical properties ! ! ------------------------------------------------------------------------------ ! ! Compute single-scattering properties ! function cloud_optics ( this , & clwp , ciwp , reliq , reice , & optical_props ) result ( error_msg ) class ( ty_cloud_optics ), & intent ( in ) :: this real ( wp ), intent ( in ) :: clwp (:,:), & ! cloud liquid water path (g/m2) ciwp (:,:), & ! cloud ice water path    (g/m2) reliq (:,:), & ! cloud liquid particle effective size (microns) reice (:,:) ! cloud ice particle effective radius  (microns) class ( ty_optical_props_arry ), & intent ( inout ) :: optical_props ! Dimensions: (ncol,nlay,nbnd) character ( len = 128 ) :: error_msg ! ------- Local ------- logical ( wl ), dimension ( size ( clwp , 1 ), size ( clwp , 2 )) :: liqmsk , icemsk real ( wp ), dimension ( size ( clwp , 1 ), size ( clwp , 2 ), this % get_nband ()) :: & ltau , ltaussa , ltaussag , itau , itaussa , itaussag ! Optical properties: tau, tau*ssa, tau*ssa*g ! liquid and ice separately integer :: ncol , nlay , nbnd integer :: nsizereg integer :: icol , ilay , ibnd ! scalars for total tau, tau*ssa real ( wp ) :: tau , taussa ! ---------------------------------------- ! ! Error checking ! ! ---------------------------------------- error_msg = '' if (. not .( allocated ( this % lut_extliq ) . or . allocated ( this % pade_extliq ))) then error_msg = 'cloud optics: no data has been initialized' return end if ncol = size ( clwp , 1 ) nlay = size ( clwp , 2 ) nbnd = this % get_nband () ! ! Array sizes ! if ( check_extents ) then if ( size ( liqmsk , 1 ) /= ncol . or . size ( liqmsk , 2 ) /= nlay ) & error_msg = \"cloud optics: liqmask has wrong extents\" if ( size ( icemsk , 1 ) /= ncol . or . size ( icemsk , 2 ) /= nlay ) & error_msg = \"cloud optics: icemsk has wrong extents\" if ( size ( ciwp , 1 ) /= ncol . or . size ( ciwp , 2 ) /= nlay ) & error_msg = \"cloud optics: ciwp has wrong extents\" if ( size ( reliq , 1 ) /= ncol . or . size ( reliq , 2 ) /= nlay ) & error_msg = \"cloud optics: reliq has wrong extents\" if ( size ( reice , 1 ) /= ncol . or . size ( reice , 2 ) /= nlay ) & error_msg = \"cloud optics: reice has wrong extents\" if ( optical_props % get_ncol () /= ncol . or . optical_props % get_nlay () /= nlay ) & error_msg = \"cloud optics: optical_props have wrong extents\" if ( error_msg /= \"\" ) return end if ! ! Spectral consistency ! if ( check_values ) then if (. not . this % bands_are_equal ( optical_props )) & error_msg = \"cloud optics: optical properties don't have the same band structure\" if ( optical_props % get_nband () /= optical_props % get_ngpt () ) & error_msg = \"cloud optics: optical properties must be requested by band not g-points\" if ( error_msg /= \"\" ) return end if !$acc data copyin(clwp, ciwp, reliq, reice)                         & !$acc      create(ltau, ltaussa, ltaussag, itau, itaussa, itaussag) & !$acc      create(liqmsk,icemsk) !$omp target data map(to:clwp, ciwp, reliq, reice) & !$omp map(alloc:ltau, ltaussa, ltaussag, itau, itaussa, itaussag) & !$omp map(alloc:liqmsk, icemsk) ! ! Cloud masks; don't need value re values if there's no cloud ! !$acc parallel loop gang vector default(none) collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol liqmsk ( icol , ilay ) = clwp ( icol , ilay ) > 0._wp icemsk ( icol , ilay ) = ciwp ( icol , ilay ) > 0._wp end do end do ! ! Particle size, liquid/ice water paths ! if ( check_values ) then if ( any_vals_outside ( reliq , liqmsk , this % radliq_lwr , this % radliq_upr )) & error_msg = 'cloud optics: liquid effective radius is out of bounds' if ( any_vals_outside ( reice , icemsk , this % radice_lwr , this % radice_upr )) & error_msg = 'cloud optics: ice effective radius is out of bounds' if ( any_vals_less_than ( clwp , liqmsk , 0._wp ) . or . any_vals_less_than ( ciwp , icemsk , 0._wp )) & error_msg = 'cloud optics: negative clwp or ciwp where clouds are supposed to be' end if if ( error_msg == \"\" ) then ! ! ! ---------------------------------------- ! ! The tables and Pade coefficients determing extinction coeffient, single-scattering albedo, !   and asymmetry parameter g as a function of effective raduis ! We compute the optical depth tau (=exintinction coeff * condensed water path) !   and the products tau*ssa and tau*ssa*g for liquid and ice cloud separately. ! These are used to determine the optical properties of ice and water cloud together. ! We could compute the properties for liquid and ice separately and !    use ty_optical_props_arry%increment but this involves substantially more division. ! if ( allocated ( this % lut_extliq )) then ! ! Liquid ! call compute_all_from_table ( ncol , nlay , nbnd , liqmsk , clwp , reliq , & this % liq_nsteps , this % liq_step_size , this % radliq_lwr , & this % lut_extliq , this % lut_ssaliq , this % lut_asyliq , & ltau , ltaussa , ltaussag ) ! ! Ice ! call compute_all_from_table ( ncol , nlay , nbnd , icemsk , ciwp , reice , & this % ice_nsteps , this % ice_step_size , this % radice_lwr , & this % lut_extice (:,:, this % icergh ), & this % lut_ssaice (:,:, this % icergh ), & this % lut_asyice (:,:, this % icergh ), & itau , itaussa , itaussag ) else ! ! Cloud optical properties from Pade coefficient method !   Hard coded assumptions: order of approximants, three size regimes ! nsizereg = size ( this % pade_extliq , 2 ) call compute_all_from_pade ( ncol , nlay , nbnd , nsizereg , & liqmsk , clwp , reliq , & 2 , 3 , this % pade_sizreg_extliq , this % pade_extliq , & 2 , 2 , this % pade_sizreg_ssaliq , this % pade_ssaliq , & 2 , 2 , this % pade_sizreg_asyliq , this % pade_asyliq , & ltau , ltaussa , ltaussag ) call compute_all_from_pade ( ncol , nlay , nbnd , nsizereg , & icemsk , ciwp , reice , & 2 , 3 , this % pade_sizreg_extice , this % pade_extice (:,:,:, this % icergh ), & 2 , 2 , this % pade_sizreg_ssaice , this % pade_ssaice (:,:,:, this % icergh ), & 2 , 2 , this % pade_sizreg_asyice , this % pade_asyice (:,:,:, this % icergh ), & itau , itaussa , itaussag ) endif ! ! Combine liquid and ice contributions into total cloud optical properties !   See also the increment routines in mo_optical_props_kernels ! select type ( optical_props ) type is ( ty_optical_props_1scl ) !$acc parallel loop gang vector default(none) collapse(3) & !$acc               copyin(optical_props) copyout(optical_props%tau) !$omp target teams distribute parallel do simd collapse(3) & !$omp map(from:optical_props%tau) do ibnd = 1 , nbnd do ilay = 1 , nlay do icol = 1 , ncol ! Absorption optical depth  = (1-ssa) * tau = tau - taussa optical_props % tau ( icol , ilay , ibnd ) = ( ltau ( icol , ilay , ibnd ) - ltaussa ( icol , ilay , ibnd )) + & ( itau ( icol , ilay , ibnd ) - itaussa ( icol , ilay , ibnd )) end do end do end do type is ( ty_optical_props_2str ) !$acc parallel loop gang vector default(none) collapse(3) & !$acc               copyin(optical_props) copyout(optical_props%tau, optical_props%ssa, optical_props%g) !$omp target teams distribute parallel do simd collapse(3) & !$omp map(from:optical_props%tau, optical_props%ssa, optical_props%g) do ibnd = 1 , nbnd do ilay = 1 , nlay do icol = 1 , ncol tau = ltau ( icol , ilay , ibnd ) + itau ( icol , ilay , ibnd ) taussa = ltaussa ( icol , ilay , ibnd ) + itaussa ( icol , ilay , ibnd ) optical_props % g ( icol , ilay , ibnd ) = ( ltaussag ( icol , ilay , ibnd ) + itaussag ( icol , ilay , ibnd )) / & max ( epsilon ( tau ), taussa ) optical_props % ssa ( icol , ilay , ibnd ) = taussa / max ( epsilon ( tau ), tau ) optical_props % tau ( icol , ilay , ibnd ) = tau end do end do end do type is ( ty_optical_props_nstr ) error_msg = \"cloud optics: n-stream calculations not yet supported\" end select end if !$acc end data !$omp end target data end function cloud_optics !-------------------------------------------------------------------------------------------------------------------- ! ! Inquiry functions ! !-------------------------------------------------------------------------------------------------------------------- function set_ice_roughness ( this , icergh ) result ( error_msg ) class ( ty_cloud_optics ), intent ( inout ) :: this integer , intent ( in ) :: icergh character ( len = 128 ) :: error_msg error_msg = \"\" if (. not . allocated ( this % pade_extice ) . and . . not . allocated ( this % lut_extice )) & error_msg = \"cloud_optics%set_ice_roughness(): can't set before initialization\" if ( icergh < 1 . or . icergh > this % get_num_ice_roughness_types ()) & error_msg = 'cloud optics: cloud ice surface roughness flag is out of bounds' if ( error_msg /= \"\" ) return this % icergh = icergh end function set_ice_roughness !----------------------------------------------- function get_num_ice_roughness_types ( this ) result ( i ) class ( ty_cloud_optics ), intent ( in ) :: this integer :: i i = 0 if ( allocated ( this % pade_extice )) i = size ( this % pade_extice , dim = 4 ) if ( allocated ( this % lut_extice )) i = size ( this % lut_extice , dim = 3 ) end function get_num_ice_roughness_types !----------------------------------------------- function get_min_radius_liq ( this ) result ( r ) class ( ty_cloud_optics ), intent ( in ) :: this real ( wp ) :: r r = this % radliq_lwr end function get_min_radius_liq !----------------------------------------------- function get_max_radius_liq ( this ) result ( r ) class ( ty_cloud_optics ), intent ( in ) :: this real ( wp ) :: r r = this % radliq_upr end function get_max_radius_liq !----------------------------------------------- function get_min_radius_ice ( this ) result ( r ) class ( ty_cloud_optics ), intent ( in ) :: this real ( wp ) :: r r = this % radice_lwr end function get_min_radius_ice !----------------------------------------------- function get_max_radius_ice ( this ) result ( r ) class ( ty_cloud_optics ), intent ( in ) :: this real ( wp ) :: r r = this % radice_upr end function get_max_radius_ice !-------------------------------------------------------------------------------------------------------------------- ! ! Ancillary functions ! !-------------------------------------------------------------------------------------------------------------------- ! ! Linearly interpolate values from a lookup table with \"nsteps\" evenly-spaced !   elements starting at \"offset.\" The table's second dimension is band. ! Returns 0 where the mask is false. ! We could also try gather/scatter for efficiency ! subroutine compute_all_from_table ( ncol , nlay , nbnd , mask , lwp , re , & nsteps , step_size , offset , & tau_table , ssa_table , asy_table , & tau , taussa , taussag ) integer , intent ( in ) :: ncol , nlay , nbnd , nsteps logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: mask real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: lwp , re real ( wp ), intent ( in ) :: step_size , offset real ( wp ), dimension ( nsteps , nbnd ), intent ( in ) :: tau_table , ssa_table , asy_table real ( wp ), dimension ( ncol , nlay , nbnd ) :: tau , taussa , taussag ! --------------------------- integer :: icol , ilay , ibnd integer :: index real ( wp ) :: fint real ( wp ) :: t , ts ! tau, tau*ssa, tau*ssa*g ! --------------------------- !$acc parallel loop gang vector default(present) collapse(3) !$omp target teams distribute parallel do simd collapse(3) do ibnd = 1 , nbnd do ilay = 1 , nlay do icol = 1 , ncol if ( mask ( icol , ilay )) then index = min ( floor (( re ( icol , ilay ) - offset ) / step_size ) + 1 , nsteps - 1 ) fint = ( re ( icol , ilay ) - offset ) / step_size - ( index - 1 ) t = lwp ( icol , ilay ) * & ( tau_table ( index , ibnd ) + fint * ( tau_table ( index + 1 , ibnd ) - tau_table ( index , ibnd ))) ts = t * & ( ssa_table ( index , ibnd ) + fint * ( ssa_table ( index + 1 , ibnd ) - ssa_table ( index , ibnd ))) taussag ( icol , ilay , ibnd ) = & ts * & ( asy_table ( index , ibnd ) + fint * ( asy_table ( index + 1 , ibnd ) - asy_table ( index , ibnd ))) taussa ( icol , ilay , ibnd ) = ts tau ( icol , ilay , ibnd ) = t else tau ( icol , ilay , ibnd ) = 0._wp taussa ( icol , ilay , ibnd ) = 0._wp taussag ( icol , ilay , ibnd ) = 0._wp end if end do end do end do end subroutine compute_all_from_table ! ! Pade functions ! !--------------------------------------------------------------------------- subroutine compute_all_from_pade ( ncol , nlay , nbnd , nsizes , & mask , lwp , re , & m_ext , n_ext , re_bounds_ext , coeffs_ext , & m_ssa , n_ssa , re_bounds_ssa , coeffs_ssa , & m_asy , n_asy , re_bounds_asy , coeffs_asy , & tau , taussa , taussag ) integer , intent ( in ) :: ncol , nlay , nbnd , nsizes logical ( wl ), & dimension ( ncol , nlay ), intent ( in ) :: mask real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: lwp , re real ( wp ), dimension ( nsizes + 1 ), intent ( in ) :: re_bounds_ext , re_bounds_ssa , re_bounds_asy integer , intent ( in ) :: m_ext , n_ext real ( wp ), dimension ( nbnd , nsizes , 0 : m_ext + n_ext ), & intent ( in ) :: coeffs_ext integer , intent ( in ) :: m_ssa , n_ssa real ( wp ), dimension ( nbnd , nsizes , 0 : m_ssa + n_ssa ), & intent ( in ) :: coeffs_ssa integer , intent ( in ) :: m_asy , n_asy real ( wp ), dimension ( nbnd , nsizes , 0 : m_asy + n_asy ), & intent ( in ) :: coeffs_asy real ( wp ), dimension ( ncol , nlay , nbnd ) :: tau , taussa , taussag ! --------------------------- integer :: icol , ilay , ibnd , irad real ( wp ) :: t , ts !$acc parallel loop gang vector default(present) collapse(3) !$omp target teams distribute parallel do simd collapse(3) do ibnd = 1 , nbnd do ilay = 1 , nlay do icol = 1 , ncol if ( mask ( icol , ilay )) then ! ! Finds index into size regime table ! This works only if there are precisely three size regimes (four bounds) and it's !   previously guaranteed that size_bounds(1) <= size <= size_bounds(4) ! irad = min ( floor (( re ( icol , ilay ) - re_bounds_ext ( 2 )) / re_bounds_ext ( 3 )) + 2 , 3 ) t = lwp ( icol , ilay ) * & pade_eval ( ibnd , nbnd , nsizes , m_ext , n_ext , irad , re ( icol , ilay ), coeffs_ext ) irad = min ( floor (( re ( icol , ilay ) - re_bounds_ssa ( 2 )) / re_bounds_ssa ( 3 )) + 2 , 3 ) ! Pade approximants for co-albedo can sometimes be negative ts = t * ( 1._wp - max ( 0._wp , & pade_eval ( ibnd , nbnd , nsizes , m_ssa , n_ssa , irad , re ( icol , ilay ), coeffs_ssa ))) irad = min ( floor (( re ( icol , ilay ) - re_bounds_asy ( 2 )) / re_bounds_asy ( 3 )) + 2 , 3 ) taussag ( icol , ilay , ibnd ) = & ts * & pade_eval ( ibnd , nbnd , nsizes , m_asy , n_asy , irad , re ( icol , ilay ), coeffs_asy ) taussa ( icol , ilay , ibnd ) = ts tau ( icol , ilay , ibnd ) = t else tau ( icol , ilay , ibnd ) = 0._wp taussa ( icol , ilay , ibnd ) = 0._wp taussag ( icol , ilay , ibnd ) = 0._wp end if end do end do end do end subroutine compute_all_from_pade !--------------------------------------------------------------------------- ! ! Evaluate Pade approximant of order [m/n] ! function pade_eval_nbnd ( nbnd , nrads , m , n , irad , re , pade_coeffs ) integer , intent ( in ) :: nbnd , nrads , m , n , irad real ( wp ), dimension ( nbnd , nrads , 0 : m + n ), & intent ( in ) :: pade_coeffs real ( wp ), intent ( in ) :: re real ( wp ), dimension ( nbnd ) :: pade_eval_nbnd integer :: iband real ( wp ) :: numer , denom integer :: i do iband = 1 , nbnd denom = pade_coeffs ( iband , irad , n + m ) do i = n - 1 + m , 1 + m , - 1 denom = pade_coeffs ( iband , irad , i ) + re * denom end do denom = 1._wp + re * denom numer = pade_coeffs ( iband , irad , m ) do i = m - 1 , 1 , - 1 numer = pade_coeffs ( iband , irad , i ) + re * numer end do numer = pade_coeffs ( iband , irad , 0 ) + re * numer pade_eval_nbnd ( iband ) = numer / denom end do end function pade_eval_nbnd !--------------------------------------------------------------------------- ! ! Evaluate Pade approximant of order [m/n] ! function pade_eval_1 ( iband , nbnd , nrads , m , n , irad , re , pade_coeffs ) !$acc routine seq !$omp declare target ! integer , intent ( in ) :: iband , nbnd , nrads , m , n , irad real ( wp ), dimension ( nbnd , nrads , 0 : m + n ), & intent ( in ) :: pade_coeffs real ( wp ), intent ( in ) :: re real ( wp ) :: pade_eval_1 real ( wp ) :: numer , denom integer :: i denom = pade_coeffs ( iband , irad , n + m ) do i = n - 1 + m , 1 + m , - 1 denom = pade_coeffs ( iband , irad , i ) + re * denom end do denom = 1._wp + re * denom numer = pade_coeffs ( iband , irad , m ) do i = m - 1 , 1 , - 1 numer = pade_coeffs ( iband , irad , i ) + re * numer end do numer = pade_coeffs ( iband , irad , 0 ) + re * numer pade_eval_1 = numer / denom end function pade_eval_1 end module mo_cloud_optics","tags":"","loc":"sourcefile/mo_cloud_optics.f90.html"},{"title":"conc_field – rte-rrtmgp ","text":"type, public :: conc_field Inherited by type~~conc_field~~InheritedByGraph type~conc_field conc_field type~ty_gas_concs ty_gas_concs type~ty_gas_concs->type~conc_field concs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables conc Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:), pointer :: conc => NULL()","tags":"","loc":"type/conc_field.html"},{"title":"ty_gas_concs – rte-rrtmgp ","text":"type, public :: ty_gas_concs Inherits type~~ty_gas_concs~~InheritsGraph type~ty_gas_concs ty_gas_concs type~conc_field conc_field type~ty_gas_concs->type~conc_field concs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables concs gas_name ncol nlay Finalization Procedures del Type-Bound Procedures get_gas_names get_num_gases get_subset get_vmr init reset set_vmr Components Type Visibility Attributes Name Initial type( conc_field ), public, dimension(:), allocatable :: concs character(len=32), public, dimension(:), allocatable :: gas_name integer, public :: ncol = 0 integer, public :: nlay = 0 Finalization Procedures final :: del public subroutine del (this) Arguments Type Intent Optional Attributes Name type( ty_gas_concs ), intent(inout) :: this Type-Bound Procedures procedure, public :: get_gas_names public pure function get_gas_names (this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this Return Value character(len=32),\n  dimension(this%get_num_gases()) procedure, public :: get_num_gases public pure function get_num_gases (this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this Return Value integer generic, public :: get_subset => get_subset_range public function get_subset_range (this, start, n, subset) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this integer, intent(in) :: start integer, intent(in) :: n class( ty_gas_concs ), intent(inout) :: subset Return Value character(len=128) generic, public :: get_vmr => get_vmr_1d, get_vmr_2d public function get_vmr_1d (this, gas, array) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(out), dimension(:) :: array Return Value character(len=128) public function get_vmr_2d (this, gas, array) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(out), dimension(:,:) :: array Return Value character(len=128) procedure, public :: init public function init (this, gas_names) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: gas_names Return Value character(len=128) procedure, public :: reset public subroutine reset (this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this generic, public :: set_vmr => set_vmr_scalar, set_vmr_1d, set_vmr_2d public function set_vmr_scalar (this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in) :: w Return Value character(len=128) public function set_vmr_1d (this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in), dimension(:) :: w Return Value character(len=128) public function set_vmr_2d (this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in), dimension(:,:) :: w Return Value character(len=128)","tags":"","loc":"type/ty_gas_concs.html"},{"title":"ty_gas_optics – rte-rrtmgp ","text":"type, public, abstract, extends( ty_optical_props ) :: ty_gas_optics Inherits type~~ty_gas_optics~~InheritsGraph type~ty_gas_optics ty_gas_optics type~ty_optical_props ty_optical_props type~ty_gas_optics->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~ty_gas_optics~~InheritedByGraph type~ty_gas_optics ty_gas_optics type~ty_gas_optics_rrtmgp ty_gas_optics_rrtmgp type~ty_gas_optics_rrtmgp->type~ty_gas_optics Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name Type-Bound Procedures bands_are_equal convert_band2gpt convert_gpt2band expand finalize gas_optics gas_optics_ext gas_optics_int get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ngpt get_press_max get_press_min get_temp_max get_temp_min gpoints_are_equal init is_initialized set_name source_is_external source_is_internal Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this generic, public :: gas_optics => gas_optics_int , gas_optics_ext private function gas_optics_int(this, play, plev, tlay, tsfc, gas_desc, optical_props, sources, col_dry, tlev) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay real(kind=wp), intent(in), dimension(:) :: tsfc type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props class( ty_source_func_lw ), intent(inout) :: sources real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: tlev Return Value character(len=128) private function gas_optics_ext(this, play, plev, tlay, gas_desc, optical_props, toa_src, col_dry) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: toa_src real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry Return Value character(len=128) procedure( gas_optics_ext_abstract ), public, deferred :: gas_optics_ext function gas_optics_ext_abstract(this, play, plev, tlay, gas_desc, optical_props, toa_src, col_dry) result(error_msg) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: toa_src real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry Return Value character(len=128) procedure( gas_optics_int_abstract ), public, deferred :: gas_optics_int function gas_optics_int_abstract(this, play, plev, tlay, tsfc, gas_desc, optical_props, sources, col_dry, tlev) result(error_msg) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay real(kind=wp), intent(in), dimension(:) :: tsfc type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props class( ty_source_func_lw ), intent(inout) :: sources real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: tlev Return Value character(len=128) procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure( real_abstract ), public, deferred :: get_press_max function real_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value real(kind=wp) procedure( real_abstract ), public, deferred :: get_press_min function real_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value real(kind=wp) procedure( real_abstract ), public, deferred :: get_temp_max function real_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value real(kind=wp) procedure( real_abstract ), public, deferred :: get_temp_min function real_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value real(kind=wp) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure( logical_abstract ), public, deferred :: source_is_external function logical_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value logical procedure( logical_abstract ), public, deferred :: source_is_internal function logical_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value logical","tags":"","loc":"type/ty_gas_optics.html"},{"title":"ty_gas_optics_rrtmgp – rte-rrtmgp ","text":"type, public, extends( ty_gas_optics ) :: ty_gas_optics_rrtmgp Inherits type~~ty_gas_optics_rrtmgp~~InheritsGraph type~ty_gas_optics_rrtmgp ty_gas_optics_rrtmgp type~ty_gas_optics ty_gas_optics type~ty_gas_optics_rrtmgp->type~ty_gas_optics type~ty_optical_props ty_optical_props type~ty_gas_optics->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name Type-Bound Procedures bands_are_equal compute_optimal_angles convert_band2gpt convert_gpt2band expand finalize gas_optics gas_optics_ext gas_optics_int get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gases get_gpoint_bands get_name get_nband get_ngas get_ngpt get_press_max get_press_min get_temp_max get_temp_min gpoints_are_equal init is_initialized load set_name set_solar_variability set_tsi source_is_external source_is_internal Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: compute_optimal_angles private function compute_optimal_angles(this, optical_props, optimal_angles) result(err_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this class( ty_optical_props_arry ), intent(in) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: optimal_angles Return Value character(len=128) procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this generic, public :: gas_optics => gas_optics_int , gas_optics_ext private function gas_optics_int(this, play, plev, tlay, tsfc, gas_desc, optical_props, sources, col_dry, tlev) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay real(kind=wp), intent(in), dimension(:) :: tsfc type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props class( ty_source_func_lw ), intent(inout) :: sources real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: tlev Return Value character(len=128) private function gas_optics_ext(this, play, plev, tlay, gas_desc, optical_props, toa_src, col_dry) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: toa_src real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry Return Value character(len=128) procedure, public :: gas_optics_ext private function gas_optics_ext(this, play, plev, tlay, gas_desc, optical_props, toa_src, col_dry) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: toa_src real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry Return Value character(len=128) procedure, public :: gas_optics_int private function gas_optics_int(this, play, plev, tlay, tsfc, gas_desc, optical_props, sources, col_dry, tlev) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay real(kind=wp), intent(in), dimension(:) :: tsfc type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props class( ty_source_func_lw ), intent(inout) :: sources real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: tlev Return Value character(len=128) procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gases private pure function get_gases(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value character(len=32),\n  dimension(get_ngas(this)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ngas private pure function get_ngas(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_press_max private pure function get_press_max(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_press_min private pure function get_press_min(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_temp_max private pure function get_temp_max(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_temp_min private pure function get_temp_min(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value real(kind=wp) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical generic, public :: load => load_int, load_ext private function load_int(this, available_gases, gas_names, key_species, band2gpt, band_lims_wavenum, press_ref, press_ref_trop, temp_ref, temp_ref_p, temp_ref_t, vmr_ref, kmajor, kminor_lower, kminor_upper, gas_minor, identifier_minor, minor_gases_lower, minor_gases_upper, minor_limits_gpt_lower, minor_limits_gpt_upper, minor_scales_with_density_lower, minor_scales_with_density_upper, scaling_gas_lower, scaling_gas_upper, scale_by_complement_lower, scale_by_complement_upper, kminor_start_lower, kminor_start_upper, totplnk, planck_frac, rayl_lower, rayl_upper, optimal_angle_fit) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(inout) :: this class( ty_gas_concs ), intent(in) :: available_gases character(len=*), intent(in), dimension(:) :: gas_names integer, intent(in), dimension(:,:,:) :: key_species integer, intent(in), dimension(:,:) :: band2gpt real(kind=wp), intent(in), dimension(:,:) :: band_lims_wavenum real(kind=wp), intent(in), dimension(:) :: press_ref real(kind=wp), intent(in) :: press_ref_trop real(kind=wp), intent(in), dimension(:) :: temp_ref real(kind=wp), intent(in) :: temp_ref_p real(kind=wp), intent(in) :: temp_ref_t real(kind=wp), intent(in), dimension(:,:,:) :: vmr_ref real(kind=wp), intent(in), dimension(:,:,:,:) :: kmajor real(kind=wp), intent(in), dimension(:,:,:) :: kminor_lower real(kind=wp), intent(in), dimension(:,:,:) :: kminor_upper character(len=*), intent(in), dimension(:) :: gas_minor character(len=*), intent(in), dimension(:) :: identifier_minor character(len=*), intent(in), dimension(:) :: minor_gases_lower character(len=*), intent(in), dimension(:) :: minor_gases_upper integer, intent(in), dimension(:,:) :: minor_limits_gpt_lower integer, intent(in), dimension(:,:) :: minor_limits_gpt_upper logical(kind=wl), intent(in), dimension(:) :: minor_scales_with_density_lower logical(kind=wl), intent(in), dimension(:) :: minor_scales_with_density_upper character(len=*), intent(in), dimension(:) :: scaling_gas_lower character(len=*), intent(in), dimension(:) :: scaling_gas_upper logical(kind=wl), intent(in), dimension(:) :: scale_by_complement_lower logical(kind=wl), intent(in), dimension(:) :: scale_by_complement_upper integer, intent(in), dimension(:) :: kminor_start_lower integer, intent(in), dimension(:) :: kminor_start_upper real(kind=wp), intent(in), dimension(:,:) :: totplnk real(kind=wp), intent(in), dimension(:,:,:,:) :: planck_frac real(kind=wp), intent(in), dimension(:,:,:), allocatable :: rayl_lower real(kind=wp), intent(in), dimension(:,:,:), allocatable :: rayl_upper real(kind=wp), intent(in), dimension(:,:) :: optimal_angle_fit Return Value character(len=128) private function load_ext(this, available_gases, gas_names, key_species, band2gpt, band_lims_wavenum, press_ref, press_ref_trop, temp_ref, temp_ref_p, temp_ref_t, vmr_ref, kmajor, kminor_lower, kminor_upper, gas_minor, identifier_minor, minor_gases_lower, minor_gases_upper, minor_limits_gpt_lower, minor_limits_gpt_upper, minor_scales_with_density_lower, minor_scales_with_density_upper, scaling_gas_lower, scaling_gas_upper, scale_by_complement_lower, scale_by_complement_upper, kminor_start_lower, kminor_start_upper, solar_quiet, solar_facular, solar_sunspot, tsi_default, mg_default, sb_default, rayl_lower, rayl_upper) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(inout) :: this class( ty_gas_concs ), intent(in) :: available_gases character(len=*), intent(in), dimension(:) :: gas_names integer, intent(in), dimension(:,:,:) :: key_species integer, intent(in), dimension(:,:) :: band2gpt real(kind=wp), intent(in), dimension(:,:) :: band_lims_wavenum real(kind=wp), intent(in), dimension(:) :: press_ref real(kind=wp), intent(in) :: press_ref_trop real(kind=wp), intent(in), dimension(:) :: temp_ref real(kind=wp), intent(in) :: temp_ref_p real(kind=wp), intent(in) :: temp_ref_t real(kind=wp), intent(in), dimension(:,:,:) :: vmr_ref real(kind=wp), intent(in), dimension(:,:,:,:) :: kmajor real(kind=wp), intent(in), dimension(:,:,:) :: kminor_lower real(kind=wp), intent(in), dimension(:,:,:) :: kminor_upper character(len=*), intent(in), dimension(:) :: gas_minor character(len=*), intent(in), dimension(:) :: identifier_minor character(len=*), intent(in), dimension(:) :: minor_gases_lower character(len=*), intent(in), dimension(:) :: minor_gases_upper integer, intent(in), dimension(:,:) :: minor_limits_gpt_lower integer, intent(in), dimension(:,:) :: minor_limits_gpt_upper logical(kind=wl), intent(in), dimension(:) :: minor_scales_with_density_lower logical(kind=wl), intent(in), dimension(:) :: minor_scales_with_density_upper character(len=*), intent(in), dimension(:) :: scaling_gas_lower character(len=*), intent(in), dimension(:) :: scaling_gas_upper logical(kind=wl), intent(in), dimension(:) :: scale_by_complement_lower logical(kind=wl), intent(in), dimension(:) :: scale_by_complement_upper integer, intent(in), dimension(:) :: kminor_start_lower integer, intent(in), dimension(:) :: kminor_start_upper real(kind=wp), intent(in), dimension(:) :: solar_quiet real(kind=wp), intent(in), dimension(:) :: solar_facular real(kind=wp), intent(in), dimension(:) :: solar_sunspot real(kind=wp), intent(in) :: tsi_default real(kind=wp), intent(in) :: mg_default real(kind=wp), intent(in) :: sb_default real(kind=wp), intent(in), dimension(:,:,:), allocatable :: rayl_lower real(kind=wp), intent(in), dimension(:,:,:), allocatable :: rayl_upper Return Value character(len=128) procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure, public :: set_solar_variability private function set_solar_variability(this, mg_index, sb_index, tsi) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(inout) :: this real(kind=wp), intent(in) :: mg_index real(kind=wp), intent(in) :: sb_index real(kind=wp), intent(in), optional :: tsi Return Value character(len=128) procedure, public :: set_tsi private function set_tsi(this, tsi) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(inout) :: this real(kind=wp), intent(in) :: tsi Return Value character(len=128) procedure, public :: source_is_external private pure function source_is_external(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value logical procedure, public :: source_is_internal private pure function source_is_internal(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value logical","tags":"","loc":"type/ty_gas_optics_rrtmgp.html"},{"title":"ty_fluxes – rte-rrtmgp ","text":"type, public, abstract :: ty_fluxes Inherited by type~~ty_fluxes~~InheritedByGraph type~ty_fluxes ty_fluxes type~ty_fluxes_bygpoint ty_fluxes_bygpoint type~ty_fluxes_bygpoint->type~ty_fluxes type~ty_fluxes_broadband ty_fluxes_broadband type~ty_fluxes_broadband->type~ty_fluxes type~ty_fluxes_1lev ty_fluxes_1lev type~ty_fluxes_1lev->type~ty_fluxes type~ty_fluxes_byband ty_fluxes_byband type~ty_fluxes_byband->type~ty_fluxes_broadband Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures are_desired reduce Type-Bound Procedures procedure(are_desired_abstract), public, deferred :: are_desired function are_desired_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_fluxes ), intent(in) :: this Return Value logical procedure(reduce_abstract), public, deferred :: reduce function reduce_abstract(this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Prototype Arguments Type Intent Optional Attributes Name class( ty_fluxes ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"type/ty_fluxes.html"},{"title":"ty_fluxes_broadband – rte-rrtmgp ","text":"type, public, extends( ty_fluxes ) :: ty_fluxes_broadband Inherits type~~ty_fluxes_broadband~~InheritsGraph type~ty_fluxes_broadband ty_fluxes_broadband type~ty_fluxes ty_fluxes type~ty_fluxes_broadband->type~ty_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~ty_fluxes_broadband~~InheritedByGraph type~ty_fluxes_broadband ty_fluxes_broadband type~ty_fluxes_byband ty_fluxes_byband type~ty_fluxes_byband->type~ty_fluxes_broadband Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures are_desired reduce Type-Bound Procedures procedure, public :: are_desired => are_desired_broadband private function are_desired_broadband(this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_broadband ), intent(in) :: this Return Value logical procedure, public :: reduce => reduce_broadband private function reduce_broadband(this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_broadband ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"type/ty_fluxes_broadband.html"},{"title":"ty_optical_props – rte-rrtmgp ","text":"type, public :: ty_optical_props Base class for optical properties\n  Describes the spectral discretization including the wavenumber limits\n  of each band (spectral region) and the mapping between g-points and bands Inherited by type~~ty_optical_props~~InheritedByGraph type~ty_optical_props ty_optical_props type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_arry->type~ty_optical_props type~ty_cloud_optics ty_cloud_optics type~ty_cloud_optics->type~ty_optical_props type~ty_source_func_sw ty_source_func_sw type~ty_source_func_sw->type~ty_optical_props type~ty_gas_optics ty_gas_optics type~ty_gas_optics->type~ty_optical_props type~ty_source_func_lw ty_source_func_lw type~ty_source_func_lw->type~ty_optical_props type~ty_optical_props_nstr ty_optical_props_nstr type~ty_optical_props_nstr->type~ty_optical_props_arry type~ty_optical_props_2str ty_optical_props_2str type~ty_optical_props_2str->type~ty_optical_props_arry type~ty_gas_optics_rrtmgp ty_gas_optics_rrtmgp type~ty_gas_optics_rrtmgp->type~ty_gas_optics type~ty_optical_props_1scl ty_optical_props_1scl type~ty_optical_props_1scl->type~ty_optical_props_arry Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name Type-Bound Procedures bands_are_equal convert_band2gpt convert_gpt2band expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ngpt gpoints_are_equal init is_initialized set_name Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name","tags":"","loc":"type/ty_optical_props.html"},{"title":"ty_optical_props_1scl – rte-rrtmgp ","text":"type, public, extends( ty_optical_props_arry ) :: ty_optical_props_1scl ty_optical_props_arry  includes only (extinction) optical depth\n   Class two-stream adds arrays for single scattering albedo ssa and\n     asymmetry parameter needed in two-stream methods\n   Class n-stream adds arrays for single scattering albedo ssa and\n     phase function moments (index 1 = g) for use with discrete ordinate methods Inherits type~~ty_optical_props_1scl~~InheritsGraph type~ty_optical_props_1scl ty_optical_props_1scl type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_1scl->type~ty_optical_props_arry type~ty_optical_props ty_optical_props type~ty_optical_props_arry->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name tau Type-Bound Procedures alloc_1scl bands_are_equal convert_band2gpt convert_gpt2band delta_scale expand finalize finalize_1scl get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_subset gpoints_are_equal increment init is_initialized set_name validate Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_1scl => alloc_only_1scl, init_and_alloc_1scl, copy_and_alloc_1scl public function alloc_only_1scl (this, ncol, nlay) result(err_message) Straight allocation routines Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function init_and_alloc_1scl (this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Initialization by specifying band limits and possibly g-point/band mapping Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function copy_and_alloc_1scl (this, ncol, nlay, spectral_desc, name) result(err_message) Initialization from an existing spectral discretization/ty_optical_props Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: delta_scale => delta_scale_1scl public function delta_scale_1scl (this, for) result(err_message) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: finalize_1scl public function finalize_1scl (this) result(err_message) Finalize routines Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this Return Value character(len=128) procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol public pure function get_ncol (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay public pure function get_nlay (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_subset => subset_1scl_range public function subset_1scl_range (full, start, n, subset) result(err_message) Routines for array classes: subsetting of optical properties arrays along x (col) direction Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: increment Increment another set of values public function increment (op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure, public :: validate => validate_1scalar public function validate_1scalar (this) result(err_message) --- Validation Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(in) :: this Return Value character(len=128)","tags":"","loc":"type/ty_optical_props_1scl.html"},{"title":"ty_optical_props_2str – rte-rrtmgp ","text":"type, public, extends( ty_optical_props_arry ) :: ty_optical_props_2str Inherits type~~ty_optical_props_2str~~InheritsGraph type~ty_optical_props_2str ty_optical_props_2str type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_2str->type~ty_optical_props_arry type~ty_optical_props ty_optical_props type~ty_optical_props_arry->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn g gpt2band name ssa tau Type-Bound Procedures alloc_2str bands_are_equal convert_band2gpt convert_gpt2band delta_scale expand finalize finalize_2str get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_subset gpoints_are_equal increment init is_initialized set_name validate Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) real(kind=wp), public, dimension(:,:,:), allocatable :: g asymmetry parameter (ncol, nlay, ngpt) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:), allocatable :: ssa single-scattering albedo (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_2str => alloc_only_2str, init_and_alloc_2str, copy_and_alloc_2str public function alloc_only_2str (this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function init_and_alloc_2str (this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function copy_and_alloc_2str (this, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: delta_scale => delta_scale_2str public function delta_scale_2str (this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Forward scattering fraction; g**2 if not provided Return Value character(len=128) procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: finalize_2str public function finalize_2str (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this Return Value character(len=128) procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol public pure function get_ncol (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay public pure function get_nlay (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_subset => subset_2str_range public function subset_2str_range (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: increment Increment another set of values public function increment (op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure, public :: validate => validate_2stream public function validate_2stream (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(in) :: this Return Value character(len=128)","tags":"","loc":"type/ty_optical_props_2str.html"},{"title":"ty_optical_props_arry – rte-rrtmgp ","text":"type, public, abstract, extends( ty_optical_props ) :: ty_optical_props_arry Optical properties as arrays, normally dimensioned ncol, nlay, ngpt/nbnd\n   The abstract base class for arrays defines what procedures will be available\n   The optical depth field is also part of the abstract base class, since\n    any representation of values as arrays needs an optical depth field Inherits type~~ty_optical_props_arry~~InheritsGraph type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props ty_optical_props type~ty_optical_props_arry->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~ty_optical_props_arry~~InheritedByGraph type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_nstr ty_optical_props_nstr type~ty_optical_props_nstr->type~ty_optical_props_arry type~ty_optical_props_2str ty_optical_props_2str type~ty_optical_props_2str->type~ty_optical_props_arry type~ty_optical_props_1scl ty_optical_props_1scl type~ty_optical_props_1scl->type~ty_optical_props_arry Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name tau Type-Bound Procedures bands_are_equal convert_band2gpt convert_gpt2band delta_scale expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_subset gpoints_are_equal increment init is_initialized set_name validate Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure( delta_scale_abstract ), public, deferred :: delta_scale function delta_scale_abstract(this, for) result(err_message) Prototype Delta-scaling Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) Forward scattering fraction; g**2 if not provided procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol public pure function get_ncol (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay public pure function get_nlay (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure( subset_range_abstract ), public, deferred :: get_subset function subset_range_abstract(full, start, n, subset) result(err_message) Prototype Subsetting -- currently there are only routines with start col and count Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: increment Increment another set of values public function increment (op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure( validate_abstract ), public, deferred :: validate Deferred procedures -- each must be implemented in each child class with\n  arguments following the abstract interface (defined below) function validate_abstract(this) result(err_message) Prototype Validation function looks only at internal data Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value character(len=128)","tags":"","loc":"type/ty_optical_props_arry.html"},{"title":"ty_optical_props_nstr – rte-rrtmgp ","text":"type, public, extends( ty_optical_props_arry ) :: ty_optical_props_nstr Inherits type~~ty_optical_props_nstr~~InheritsGraph type~ty_optical_props_nstr ty_optical_props_nstr type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_nstr->type~ty_optical_props_arry type~ty_optical_props ty_optical_props type~ty_optical_props_arry->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name p ssa tau Type-Bound Procedures alloc_nstr bands_are_equal convert_band2gpt convert_gpt2band delta_scale expand finalize finalize_nstr get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_nmom get_subset gpoints_are_equal increment init is_initialized set_name validate Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:,:), allocatable :: p phase-function moments (nmom, ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: ssa single-scattering albedo (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_nstr => alloc_only_nstr, init_and_alloc_nstr, copy_and_alloc_nstr public function alloc_only_nstr (this, nmom, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function init_and_alloc_nstr (this, nmom, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function copy_and_alloc_nstr (this, nmom, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: delta_scale => delta_scale_nstr public function delta_scale_nstr (this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: finalize_nstr public function finalize_nstr (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this Return Value character(len=128) procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol public pure function get_ncol (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay public pure function get_nlay (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_nmom public pure function get_nmom (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value integer procedure, public :: get_subset => subset_nstr_range public function subset_nstr_range (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: increment Increment another set of values public function increment (op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure, public :: validate => validate_nstream public function validate_nstream (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value character(len=128)","tags":"","loc":"type/ty_optical_props_nstr.html"},{"title":"ty_source_func_lw – rte-rrtmgp ","text":"type, public, extends( ty_optical_props ) :: ty_source_func_lw Inherits type~~ty_source_func_lw~~InheritsGraph type~ty_source_func_lw ty_source_func_lw type~ty_optical_props ty_optical_props type~ty_source_func_lw->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band lay_source lev_source_dec lev_source_inc name sfc_source sfc_source_Jac Type-Bound Procedures alloc bands_are_equal convert_band2gpt convert_gpt2band expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_subset gpoints_are_equal init is_allocated is_initialized set_name Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) real(kind=wp), public, allocatable, dimension(:,:,:) :: lay_source real(kind=wp), public, allocatable, dimension(:,:,:) :: lev_source_dec real(kind=wp), public, allocatable, dimension(:,:,:) :: lev_source_inc character(len=name_len), public :: name = \"\" real(kind=wp), public, allocatable, dimension(:,:  ) :: sfc_source real(kind=wp), public, allocatable, dimension(:,:  ) :: sfc_source_Jac Type-Bound Procedures generic, public :: alloc => alloc_lw, copy_and_alloc_lw public function alloc_lw (this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function copy_and_alloc_lw (this, ncol, nlay, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_lw public subroutine finalize_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol => get_ncol_lw public pure function get_ncol_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay => get_nlay_lw public pure function get_nlay_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer procedure, public :: get_subset => get_subset_range_lw public function get_subset_range_lw (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_lw ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_allocated => is_allocated_lw public pure function is_allocated_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value logical procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name","tags":"","loc":"type/ty_source_func_lw.html"},{"title":"ty_source_func_sw – rte-rrtmgp ","text":"type, public, extends( ty_optical_props ) :: ty_source_func_sw Inherits type~~ty_source_func_sw~~InheritsGraph type~ty_source_func_sw ty_source_func_sw type~ty_optical_props ty_optical_props type~ty_source_func_sw->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name toa_source Type-Bound Procedures alloc bands_are_equal convert_band2gpt convert_gpt2band expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_subset gpoints_are_equal init is_allocated is_initialized set_name Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, allocatable, dimension(:,:  ) :: toa_source Type-Bound Procedures generic, public :: alloc => alloc_sw, copy_and_alloc_sw public function alloc_sw (this, ncol) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol Return Value character(len=128) public function copy_and_alloc_sw (this, ncol, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_sw public subroutine finalize_sw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol => get_ncol_sw public pure function get_ncol_sw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_subset => get_subset_range_sw public function get_subset_range_sw (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_sw ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_allocated => is_allocated_sw public pure function is_allocated_sw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value logical procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name","tags":"","loc":"type/ty_source_func_sw.html"},{"title":"ty_fluxes_1lev – rte-rrtmgp ","text":"type, public, extends( ty_fluxes ) :: ty_fluxes_1lev Inherits type~~ty_fluxes_1lev~~InheritsGraph type~ty_fluxes_1lev ty_fluxes_1lev type~ty_fluxes ty_fluxes type~ty_fluxes_1lev->type~ty_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures are_desired reduce Type-Bound Procedures procedure, public :: are_desired => are_desired_1lev private function are_desired_1lev(this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_1lev ), intent(in) :: this Return Value logical procedure, public :: reduce => reduce_1lev private function reduce_1lev(this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_1lev ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"type/ty_fluxes_1lev.html"},{"title":"ty_fluxes_byband – rte-rrtmgp ","text":"type, public, extends( ty_fluxes_broadband ) :: ty_fluxes_byband Inherits type~~ty_fluxes_byband~~InheritsGraph type~ty_fluxes_byband ty_fluxes_byband type~ty_fluxes_broadband ty_fluxes_broadband type~ty_fluxes_byband->type~ty_fluxes_broadband type~ty_fluxes ty_fluxes type~ty_fluxes_broadband->type~ty_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables bnd_flux_dn bnd_flux_dn_dir bnd_flux_net bnd_flux_up Type-Bound Procedures are_desired reduce Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_dn => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_dn_dir => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_net => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_up => NULL() Type-Bound Procedures procedure, public :: are_desired => are_desired_byband public function are_desired_byband (this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_byband ), intent(in) :: this Return Value logical procedure, public :: reduce => reduce_byband public function reduce_byband (this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_byband ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"type/ty_fluxes_byband.html"},{"title":"ty_fluxes_bygpoint – rte-rrtmgp ","text":"type, public, extends( ty_fluxes ) :: ty_fluxes_bygpoint Inherits type~~ty_fluxes_bygpoint~~InheritsGraph type~ty_fluxes_bygpoint ty_fluxes_bygpoint type~ty_fluxes ty_fluxes type~ty_fluxes_bygpoint->type~ty_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables gpt_flux_dn gpt_flux_dn_dir gpt_flux_net gpt_flux_up Type-Bound Procedures are_desired reduce Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_dn => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_dn_dir => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_net => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_up => NULL() Type-Bound Procedures procedure, public :: are_desired => are_desired_bygpoint public function are_desired_bygpoint (this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_bygpoint ), intent(in) :: this Return Value logical procedure, public :: reduce => reduce_bygpoint public function reduce_bygpoint (this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_bygpoint ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"type/ty_fluxes_bygpoint.html"},{"title":"ty_solar_var – rte-rrtmgp ","text":"type, public :: ty_solar_var Contents Type-Bound Procedures finalize load solar_var_ind_interp Type-Bound Procedures procedure, public :: finalize private subroutine finalize(this) Arguments Type Intent Optional Attributes Name class( ty_solar_var ), intent(inout) :: this procedure, public :: load private function load(this, avgcyc_ind) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_solar_var ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: avgcyc_ind Return Value character(len=128) procedure, public :: solar_var_ind_interp private function solar_var_ind_interp(this, solcycfrac, mg_index, sb_index) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_solar_var ), intent(in) :: this real(kind=wp), intent(in) :: solcycfrac real(kind=wp), intent(out) :: mg_index real(kind=wp), intent(out) :: sb_index Return Value character(len=128)","tags":"","loc":"type/ty_solar_var.html"},{"title":"ty_cloud_optics – rte-rrtmgp ","text":"type, public, extends( ty_optical_props ) :: ty_cloud_optics Inherits type~~ty_cloud_optics~~InheritsGraph type~ty_cloud_optics ty_cloud_optics type~ty_optical_props ty_optical_props type~ty_cloud_optics->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name Type-Bound Procedures bands_are_equal cloud_optics convert_band2gpt convert_gpt2band expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_max_radius_ice get_max_radius_liq get_min_radius_ice get_min_radius_liq get_name get_nband get_ngpt get_num_ice_roughness_types gpoints_are_equal init is_initialized load set_ice_roughness set_name Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: cloud_optics private function cloud_optics(this, clwp, ciwp, reliq, reice, optical_props) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(in) :: this real(kind=wp), intent(in) :: clwp (:,:) real(kind=wp), intent(in) :: ciwp (:,:) real(kind=wp), intent(in) :: reliq (:,:) real(kind=wp), intent(in) :: reice (:,:) class( ty_optical_props_arry ), intent(inout) :: optical_props Return Value character(len=128) procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize private subroutine finalize(this) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(inout) :: this procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_max_radius_ice private function get_max_radius_ice(this) result(r) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_max_radius_liq private function get_max_radius_liq(this) result(r) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_min_radius_ice private function get_min_radius_ice(this) result(r) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_min_radius_liq private function get_min_radius_liq(this) result(r) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_num_ice_roughness_types private function get_num_ice_roughness_types(this) result(i) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(in) :: this Return Value integer procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical generic, public :: load => load_lut, load_pade private function load_lut(this, band_lims_wvn, radliq_lwr, radliq_upr, radliq_fac, radice_lwr, radice_upr, radice_fac, lut_extliq, lut_ssaliq, lut_asyliq, lut_extice, lut_ssaice, lut_asyice) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn real(kind=wp), intent(in) :: radliq_lwr real(kind=wp), intent(in) :: radliq_upr real(kind=wp), intent(in) :: radliq_fac real(kind=wp), intent(in) :: radice_lwr real(kind=wp), intent(in) :: radice_upr real(kind=wp), intent(in) :: radice_fac real(kind=wp), intent(in), dimension(:,:) :: lut_extliq real(kind=wp), intent(in), dimension(:,:) :: lut_ssaliq real(kind=wp), intent(in), dimension(:,:) :: lut_asyliq real(kind=wp), intent(in), dimension(:,:,:) :: lut_extice real(kind=wp), intent(in), dimension(:,:,:) :: lut_ssaice real(kind=wp), intent(in), dimension(:,:,:) :: lut_asyice Return Value character(len=128) private function load_pade(this, band_lims_wvn, pade_extliq, pade_ssaliq, pade_asyliq, pade_extice, pade_ssaice, pade_asyice, pade_sizreg_extliq, pade_sizreg_ssaliq, pade_sizreg_asyliq, pade_sizreg_extice, pade_sizreg_ssaice, pade_sizreg_asyice) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn real(kind=wp), intent(in), dimension(:,:,:) :: pade_extliq real(kind=wp), intent(in), dimension(:,:,:) :: pade_ssaliq real(kind=wp), intent(in), dimension(:,:,:) :: pade_asyliq real(kind=wp), intent(in), dimension(:,:,:,:) :: pade_extice real(kind=wp), intent(in), dimension(:,:,:,:) :: pade_ssaice real(kind=wp), intent(in), dimension(:,:,:,:) :: pade_asyice real(kind=wp), intent(in), dimension(:) :: pade_sizreg_extliq real(kind=wp), intent(in), dimension(:) :: pade_sizreg_ssaliq real(kind=wp), intent(in), dimension(:) :: pade_sizreg_asyliq real(kind=wp), intent(in), dimension(:) :: pade_sizreg_extice real(kind=wp), intent(in), dimension(:) :: pade_sizreg_ssaice real(kind=wp), intent(in), dimension(:) :: pade_sizreg_asyice Return Value character(len=128) procedure, public :: set_ice_roughness private function set_ice_roughness(this, icergh) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(inout) :: this integer, intent(in) :: icergh Return Value character(len=128) procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name","tags":"","loc":"type/ty_cloud_optics.html"},{"title":"gas_optics_ext_abstract – rte-rrtmgp","text":"abstract interface public function gas_optics_ext_abstract(this, play, plev, tlay, gas_desc, optical_props, toa_src, col_dry) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: toa_src real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry Return Value character(len=128)","tags":"","loc":"interface/gas_optics_ext_abstract.html"},{"title":"gas_optics_int_abstract – rte-rrtmgp","text":"abstract interface public function gas_optics_int_abstract(this, play, plev, tlay, tsfc, gas_desc, optical_props, sources, col_dry, tlev) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay real(kind=wp), intent(in), dimension(:) :: tsfc type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props class( ty_source_func_lw ), intent(inout) :: sources real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: tlev Return Value character(len=128)","tags":"","loc":"interface/gas_optics_int_abstract.html"},{"title":"logical_abstract – rte-rrtmgp","text":"abstract interface public function logical_abstract(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value logical","tags":"","loc":"interface/logical_abstract.html"},{"title":"real_abstract – rte-rrtmgp","text":"abstract interface public function real_abstract(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value real(kind=wp)","tags":"","loc":"interface/real_abstract.html"},{"title":"delta_scale_abstract – rte-rrtmgp","text":"abstract interface Interfaces for the methods to be implemented public function delta_scale_abstract(this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) Forward scattering fraction; g**2 if not provided Description Delta-scaling","tags":"","loc":"interface/delta_scale_abstract.html"},{"title":"subset_range_abstract – rte-rrtmgp","text":"abstract interface Interfaces for the methods to be implemented public function subset_range_abstract(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) Description Subsetting -- currently there are only routines with start col and count","tags":"","loc":"interface/subset_range_abstract.html"},{"title":"validate_abstract – rte-rrtmgp","text":"abstract interface Interfaces for the methods to be implemented public function validate_abstract(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value character(len=128) Description Validation function looks only at internal data","tags":"","loc":"interface/validate_abstract.html"},{"title":"lower_case – rte-rrtmgp","text":"public pure function lower_case(input_string) result(output_string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_string Return Value character(len=len) Called by proc~~lower_case~~CalledByGraph proc~lower_case lower_case proc~string_in_array string_in_array proc~string_in_array->proc~lower_case proc~find_gas find_gas proc~find_gas->proc~lower_case proc~init init proc~init->proc~lower_case proc~string_loc_in_array string_loc_in_array proc~string_loc_in_array->proc~lower_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lower_case.html"},{"title":"string_in_array – rte-rrtmgp","text":"public pure function string_in_array(string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), dimension(:) :: array Return Value logical Calls proc~~string_in_array~~CallsGraph proc~string_in_array string_in_array proc~lower_case lower_case proc~string_in_array->proc~lower_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/string_in_array.html"},{"title":"string_loc_in_array – rte-rrtmgp","text":"public pure function string_loc_in_array(string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), dimension(:) :: array Return Value integer Calls proc~~string_loc_in_array~~CallsGraph proc~string_loc_in_array string_loc_in_array proc~lower_case lower_case proc~string_loc_in_array->proc~lower_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/string_loc_in_array.html"},{"title":"reorder123x321 – rte-rrtmgp","text":"public subroutine reorder123x321(array, array_out) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(out), dimension(:,:,:) :: array_out Calls proc~~reorder123x321~~CallsGraph proc~reorder123x321 reorder123x321 reorder_123x321_kernel reorder_123x321_kernel proc~reorder123x321->reorder_123x321_kernel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/reorder123x321.html"},{"title":"find_gas – rte-rrtmgp","text":"public function find_gas(this, gas) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this character(len=*), intent(in) :: gas Return Value integer Calls proc~~find_gas~~CallsGraph proc~find_gas find_gas proc~lower_case lower_case proc~find_gas->proc~lower_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_gas.html"},{"title":"get_gas_names – rte-rrtmgp","text":"public pure function get_gas_names(this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this Return Value character(len=32),\n  dimension(this%get_num_gases()) Contents None","tags":"","loc":"proc/get_gas_names.html"},{"title":"get_num_gases – rte-rrtmgp","text":"public pure function get_num_gases(this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_num_gases.html"},{"title":"get_subset_range – rte-rrtmgp","text":"public function get_subset_range(this, start, n, subset) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this integer, intent(in) :: start integer, intent(in) :: n class( ty_gas_concs ), intent(inout) :: subset Return Value character(len=128) Contents None","tags":"","loc":"proc/get_subset_range.html"},{"title":"get_vmr_1d – rte-rrtmgp","text":"public function get_vmr_1d(this, gas, array) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(out), dimension(:) :: array Return Value character(len=128) Contents None","tags":"","loc":"proc/get_vmr_1d.html"},{"title":"get_vmr_2d – rte-rrtmgp","text":"public function get_vmr_2d(this, gas, array) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(out), dimension(:,:) :: array Return Value character(len=128) Contents None","tags":"","loc":"proc/get_vmr_2d.html"},{"title":"init – rte-rrtmgp","text":"public function init(this, gas_names) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: gas_names Return Value character(len=128) Calls proc~~init~~CallsGraph proc~init init proc~lower_case lower_case proc~init->proc~lower_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init.html"},{"title":"set_vmr_1d – rte-rrtmgp","text":"public function set_vmr_1d(this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in), dimension(:) :: w Return Value character(len=128) Calls proc~~set_vmr_1d~~CallsGraph proc~set_vmr_1d set_vmr_1d interface~any_vals_outside any_vals_outside proc~set_vmr_1d->interface~any_vals_outside Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_vmr_1d.html"},{"title":"set_vmr_2d – rte-rrtmgp","text":"public function set_vmr_2d(this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in), dimension(:,:) :: w Return Value character(len=128) Calls proc~~set_vmr_2d~~CallsGraph proc~set_vmr_2d set_vmr_2d interface~any_vals_outside any_vals_outside proc~set_vmr_2d->interface~any_vals_outside Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_vmr_2d.html"},{"title":"set_vmr_scalar – rte-rrtmgp","text":"public function set_vmr_scalar(this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in) :: w Return Value character(len=128) Contents None","tags":"","loc":"proc/set_vmr_scalar.html"},{"title":"del – rte-rrtmgp","text":"public subroutine del(this) Arguments Type Intent Optional Attributes Name type( ty_gas_concs ), intent(inout) :: this Contents None","tags":"","loc":"proc/del.html"},{"title":"reset – rte-rrtmgp","text":"public subroutine reset(this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this Contents None","tags":"","loc":"proc/reset.html"},{"title":"get_col_dry – rte-rrtmgp","text":"public function get_col_dry(vmr_h2o, plev, latitude) result(col_dry) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: vmr_h2o real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), optional dimension(:) :: latitude Return Value real(kind=wp),\n  dimension(size(plev,dim=1),size(plev,dim=2)-1) Contents None","tags":"","loc":"proc/get_col_dry.html"},{"title":"init_constants – rte-rrtmgp","text":"public subroutine init_constants(gravity, mol_weight_dry_air, heat_capacity_dry_air) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), optional :: gravity real(kind=wp), intent(in), optional :: mol_weight_dry_air real(kind=wp), intent(in), optional :: heat_capacity_dry_air Contents None","tags":"","loc":"proc/init_constants.html"},{"title":"rte_config_checks – rte-rrtmgp","text":"public interface rte_config_checks Contents Module Procedures rte_config_checks_each rte_config_checks_all Module Procedures private subroutine rte_config_checks_each(extents, values) Arguments Type Intent Optional Attributes Name logical(kind=wl), intent(in) :: extents logical(kind=wl), intent(in) :: values private subroutine rte_config_checks_all(do_checks) Arguments Type Intent Optional Attributes Name logical(kind=wl), intent(in) :: do_checks","tags":"","loc":"interface/rte_config_checks.html"},{"title":"rte_lw – rte-rrtmgp","text":"public function rte_lw(optical_props, top_at_1, sources, sfc_emis, fluxes, inc_flux, n_gauss_angles, use_2stream, lw_Ds, flux_up_Jac) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: optical_props logical, intent(in) :: top_at_1 type( ty_source_func_lw ), intent(in) :: sources real(kind=wp), intent(in), dimension(:,:) :: sfc_emis class( ty_fluxes ), intent(inout) :: fluxes real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux integer, intent(in), optional :: n_gauss_angles logical, intent(in), optional :: use_2stream real(kind=wp), intent(in), optional dimension(:,:) :: lw_Ds real(kind=wp), intent(inout), optional dimension(:,:), target :: flux_up_Jac Return Value character(len=128) Calls proc~~rte_lw~~CallsGraph proc~rte_lw rte_lw interface~any_vals_outside any_vals_outside proc~rte_lw->interface~any_vals_outside interface~extents_are extents_are proc~rte_lw->interface~extents_are interface~zero_array zero_array proc~rte_lw->interface~zero_array lw_solver_noscat_gaussquad lw_solver_noscat_gaussquad proc~rte_lw->lw_solver_noscat_gaussquad lw_solver_2stream lw_solver_2stream proc~rte_lw->lw_solver_2stream interface~any_vals_less_than any_vals_less_than proc~rte_lw->interface~any_vals_less_than Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rte_lw~~CalledByGraph proc~rte_lw rte_lw proc~compute_bc compute_bc proc~compute_bc->proc~rte_lw proc~rte_lw~2 rte_lw proc~rte_lw~2->proc~rte_lw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rte_lw.html"},{"title":"rte_sw – rte-rrtmgp","text":"public function rte_sw(atmos, top_at_1, mu0, inc_flux, sfc_alb_dir, sfc_alb_dif, fluxes, inc_flux_dif) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: atmos logical, intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(:) :: mu0 real(kind=wp), intent(in), dimension(:,:) :: inc_flux real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dir real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dif class( ty_fluxes ), intent(inout) :: fluxes real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux_dif Return Value character(len=128) Calls proc~~rte_sw~~CallsGraph proc~rte_sw rte_sw sw_solver_noscat sw_solver_noscat proc~rte_sw->sw_solver_noscat interface~any_vals_outside any_vals_outside proc~rte_sw->interface~any_vals_outside interface~extents_are extents_are proc~rte_sw->interface~extents_are interface~zero_array zero_array proc~rte_sw->interface~zero_array sw_solver_2stream sw_solver_2stream proc~rte_sw->sw_solver_2stream interface~any_vals_less_than any_vals_less_than proc~rte_sw->interface~any_vals_less_than Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rte_sw~~CalledByGraph proc~rte_sw rte_sw proc~rte_sw~2 rte_sw proc~rte_sw~2->proc~rte_sw proc~compute_bc compute_bc proc~compute_bc->proc~rte_sw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rte_sw.html"},{"title":"alloc_only_1scl – rte-rrtmgp","text":"public function alloc_only_1scl(this, ncol, nlay) result(err_message) Straight allocation routines --- 1 scalar ------------------------------------------------------------------------ Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) Contents None","tags":"","loc":"proc/alloc_only_1scl.html"},{"title":"alloc_only_2str – rte-rrtmgp","text":"public function alloc_only_2str(this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) Contents None","tags":"","loc":"proc/alloc_only_2str.html"},{"title":"alloc_only_nstr – rte-rrtmgp","text":"public function alloc_only_nstr(this, nmom, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) Contents None","tags":"","loc":"proc/alloc_only_nstr.html"},{"title":"bands_are_equal – rte-rrtmgp","text":"public pure function bands_are_equal(this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical Contents None","tags":"","loc":"proc/bands_are_equal.html"},{"title":"convert_band2gpt – rte-rrtmgp","text":"public pure function convert_band2gpt(this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) Contents None","tags":"","loc":"proc/convert_band2gpt.html"},{"title":"convert_gpt2band – rte-rrtmgp","text":"public pure function convert_gpt2band(this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer Contents None","tags":"","loc":"proc/convert_gpt2band.html"},{"title":"copy_and_alloc_1scl – rte-rrtmgp","text":"public function copy_and_alloc_1scl(this, ncol, nlay, spectral_desc, name) result(err_message) Initialization from an existing spectral discretization/ty_optical_props Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) Contents None","tags":"","loc":"proc/copy_and_alloc_1scl.html"},{"title":"copy_and_alloc_2str – rte-rrtmgp","text":"public function copy_and_alloc_2str(this, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) Contents None","tags":"","loc":"proc/copy_and_alloc_2str.html"},{"title":"copy_and_alloc_nstr – rte-rrtmgp","text":"public function copy_and_alloc_nstr(this, nmom, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) Contents None","tags":"","loc":"proc/copy_and_alloc_nstr.html"},{"title":"delta_scale_1scl – rte-rrtmgp","text":"public function delta_scale_1scl(this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) Contents None","tags":"","loc":"proc/delta_scale_1scl.html"},{"title":"delta_scale_2str – rte-rrtmgp","text":"public function delta_scale_2str(this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Forward scattering fraction; g**2 if not provided Return Value character(len=128) Calls proc~~delta_scale_2str~~CallsGraph proc~delta_scale_2str delta_scale_2str delta_scale_2str_kernel delta_scale_2str_kernel proc~delta_scale_2str->delta_scale_2str_kernel interface~any_vals_outside any_vals_outside proc~delta_scale_2str->interface~any_vals_outside interface~extents_are extents_are proc~delta_scale_2str->interface~extents_are Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/delta_scale_2str.html"},{"title":"delta_scale_nstr – rte-rrtmgp","text":"public function delta_scale_nstr(this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) Contents None","tags":"","loc":"proc/delta_scale_nstr.html"},{"title":"expand – rte-rrtmgp","text":"public pure function expand(this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) Contents None","tags":"","loc":"proc/expand.html"},{"title":"finalize_1scl – rte-rrtmgp","text":"public function finalize_1scl(this) result(err_message) Finalize routines Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this Return Value character(len=128) Contents None","tags":"","loc":"proc/finalize_1scl.html"},{"title":"finalize_2str – rte-rrtmgp","text":"public function finalize_2str(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this Return Value character(len=128) Contents None","tags":"","loc":"proc/finalize_2str.html"},{"title":"finalize_nstr – rte-rrtmgp","text":"public function finalize_nstr(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this Return Value character(len=128) Contents None","tags":"","loc":"proc/finalize_nstr.html"},{"title":"get_arry_extent – rte-rrtmgp","text":"public pure function get_arry_extent(this, dim) Routines for array classes: problem sizes Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this integer, intent(in) :: dim Return Value integer Called by proc~~get_arry_extent~~CalledByGraph proc~get_arry_extent get_arry_extent proc~get_ncol get_ncol proc~get_ncol->proc~get_arry_extent proc~get_nlay get_nlay proc~get_nlay->proc~get_arry_extent Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_arry_extent.html"},{"title":"get_band_lims_gpoint – rte-rrtmgp","text":"public pure function get_band_lims_gpoint(this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) Contents None","tags":"","loc":"proc/get_band_lims_gpoint.html"},{"title":"get_band_lims_wavelength – rte-rrtmgp","text":"public pure function get_band_lims_wavelength(this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) Contents None","tags":"","loc":"proc/get_band_lims_wavelength.html"},{"title":"get_band_lims_wavenumber – rte-rrtmgp","text":"public pure function get_band_lims_wavenumber(this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) Contents None","tags":"","loc":"proc/get_band_lims_wavenumber.html"},{"title":"get_gpoint_bands – rte-rrtmgp","text":"public pure function get_gpoint_bands(this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) Contents None","tags":"","loc":"proc/get_gpoint_bands.html"},{"title":"get_name – rte-rrtmgp","text":"public function get_name(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) Contents None","tags":"","loc":"proc/get_name.html"},{"title":"get_nband – rte-rrtmgp","text":"public pure function get_nband(this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_nband.html"},{"title":"get_ncol – rte-rrtmgp","text":"public pure function get_ncol(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer Calls proc~~get_ncol~~CallsGraph proc~get_ncol get_ncol proc~get_arry_extent get_arry_extent proc~get_ncol->proc~get_arry_extent Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_ncol.html"},{"title":"get_ngpt – rte-rrtmgp","text":"public pure function get_ngpt(this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_ngpt.html"},{"title":"get_nlay – rte-rrtmgp","text":"public pure function get_nlay(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer Calls proc~~get_nlay~~CallsGraph proc~get_nlay get_nlay proc~get_arry_extent get_arry_extent proc~get_nlay->proc~get_arry_extent Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_nlay.html"},{"title":"get_nmom – rte-rrtmgp","text":"public pure function get_nmom(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_nmom.html"},{"title":"gpoints_are_equal – rte-rrtmgp","text":"public pure function gpoints_are_equal(this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical Contents None","tags":"","loc":"proc/gpoints_are_equal.html"},{"title":"increment – rte-rrtmgp","text":"public function increment(op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) Calls proc~~increment~~CallsGraph proc~increment increment inc_2stream_by_nstream_bybnd inc_2stream_by_nstream_bybnd proc~increment->inc_2stream_by_nstream_bybnd increment_1scalar_by_1scalar increment_1scalar_by_1scalar proc~increment->increment_1scalar_by_1scalar inc_1scalar_by_2stream_bybnd inc_1scalar_by_2stream_bybnd proc~increment->inc_1scalar_by_2stream_bybnd inc_2stream_by_1scalar_bybnd inc_2stream_by_1scalar_bybnd proc~increment->inc_2stream_by_1scalar_bybnd increment_nstream_by_nstream increment_nstream_by_nstream proc~increment->increment_nstream_by_nstream increment_2stream_by_nstream increment_2stream_by_nstream proc~increment->increment_2stream_by_nstream increment_2stream_by_2stream increment_2stream_by_2stream proc~increment->increment_2stream_by_2stream increment_2stream_by_1scalar increment_2stream_by_1scalar proc~increment->increment_2stream_by_1scalar increment_nstream_by_2stream increment_nstream_by_2stream proc~increment->increment_nstream_by_2stream increment_1scalar_by_2stream increment_1scalar_by_2stream proc~increment->increment_1scalar_by_2stream increment_nstream_by_1scalar increment_nstream_by_1scalar proc~increment->increment_nstream_by_1scalar inc_nstream_by_2stream_bybnd inc_nstream_by_2stream_bybnd proc~increment->inc_nstream_by_2stream_bybnd inc_1scalar_by_nstream_bybnd inc_1scalar_by_nstream_bybnd proc~increment->inc_1scalar_by_nstream_bybnd increment_1scalar_by_nstream increment_1scalar_by_nstream proc~increment->increment_1scalar_by_nstream inc_nstream_by_nstream_bybnd inc_nstream_by_nstream_bybnd proc~increment->inc_nstream_by_nstream_bybnd inc_2stream_by_2stream_bybnd inc_2stream_by_2stream_bybnd proc~increment->inc_2stream_by_2stream_bybnd inc_nstream_by_1scalar_bybnd inc_nstream_by_1scalar_bybnd proc~increment->inc_nstream_by_1scalar_bybnd inc_1scalar_by_1scalar_bybnd inc_1scalar_by_1scalar_bybnd proc~increment->inc_1scalar_by_1scalar_bybnd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/increment.html"},{"title":"init_and_alloc_1scl – rte-rrtmgp","text":"public function init_and_alloc_1scl(this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Initialization by specifying band limits and possibly g-point/band mapping Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) Contents None","tags":"","loc":"proc/init_and_alloc_1scl.html"},{"title":"init_and_alloc_2str – rte-rrtmgp","text":"public function init_and_alloc_2str(this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) Contents None","tags":"","loc":"proc/init_and_alloc_2str.html"},{"title":"init_and_alloc_nstr – rte-rrtmgp","text":"public function init_and_alloc_nstr(this, nmom, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) Contents None","tags":"","loc":"proc/init_and_alloc_nstr.html"},{"title":"init_base – rte-rrtmgp","text":"public function init_base(this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) Calls proc~~init_base~~CallsGraph proc~init_base init_base interface~any_vals_less_than any_vals_less_than proc~init_base->interface~any_vals_less_than interface~extents_are extents_are proc~init_base->interface~extents_are Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_base.html"},{"title":"init_base_from_copy – rte-rrtmgp","text":"public function init_base_from_copy(this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) Contents None","tags":"","loc":"proc/init_base_from_copy.html"},{"title":"is_initialized_base – rte-rrtmgp","text":"public pure function is_initialized_base(this) Base class: return true if initialized, false otherwise Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/is_initialized_base.html"},{"title":"subset_1scl_range – rte-rrtmgp","text":"public function subset_1scl_range(full, start, n, subset) result(err_message) Routines for array classes: subsetting of optical properties arrays along x (col) direction Allocate class, then arrays; copy. Could probably be more efficient if\n  classes used pointers internally. This set takes start position and number as scalars Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) Calls proc~~subset_1scl_range~~CallsGraph proc~subset_1scl_range subset_1scl_range extract_subset extract_subset proc~subset_1scl_range->extract_subset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subset_1scl_range.html"},{"title":"subset_2str_range – rte-rrtmgp","text":"public function subset_2str_range(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) Calls proc~~subset_2str_range~~CallsGraph proc~subset_2str_range subset_2str_range extract_subset extract_subset proc~subset_2str_range->extract_subset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subset_2str_range.html"},{"title":"subset_nstr_range – rte-rrtmgp","text":"public function subset_nstr_range(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) Calls proc~~subset_nstr_range~~CallsGraph proc~subset_nstr_range subset_nstr_range extract_subset extract_subset proc~subset_nstr_range->extract_subset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subset_nstr_range.html"},{"title":"validate_1scalar – rte-rrtmgp","text":"public function validate_1scalar(this) result(err_message) --- Validation Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(in) :: this Return Value character(len=128) Calls proc~~validate_1scalar~~CallsGraph proc~validate_1scalar validate_1scalar interface~any_vals_less_than any_vals_less_than proc~validate_1scalar->interface~any_vals_less_than Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/validate_1scalar.html"},{"title":"validate_2stream – rte-rrtmgp","text":"public function validate_2stream(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(in) :: this Return Value character(len=128) Calls proc~~validate_2stream~~CallsGraph proc~validate_2stream validate_2stream interface~extents_are extents_are proc~validate_2stream->interface~extents_are interface~any_vals_outside any_vals_outside proc~validate_2stream->interface~any_vals_outside interface~any_vals_less_than any_vals_less_than proc~validate_2stream->interface~any_vals_less_than Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/validate_2stream.html"},{"title":"validate_nstream – rte-rrtmgp","text":"public function validate_nstream(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value character(len=128) Calls proc~~validate_nstream~~CallsGraph proc~validate_nstream validate_nstream interface~extents_are extents_are proc~validate_nstream->interface~extents_are interface~any_vals_outside any_vals_outside proc~validate_nstream->interface~any_vals_outside interface~any_vals_less_than any_vals_less_than proc~validate_nstream->interface~any_vals_less_than Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/validate_nstream.html"},{"title":"finalize_base – rte-rrtmgp","text":"public subroutine finalize_base(this) Base class: finalize (deallocate memory) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this Contents None","tags":"","loc":"proc/finalize_base.html"},{"title":"set_name – rte-rrtmgp","text":"public subroutine set_name(this, name) --- Setting/getting the name Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name Contents None","tags":"","loc":"proc/set_name.html"},{"title":"alloc_lw – rte-rrtmgp","text":"public function alloc_lw(this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) Contents None","tags":"","loc":"proc/alloc_lw.html"},{"title":"alloc_sw – rte-rrtmgp","text":"public function alloc_sw(this, ncol) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol Return Value character(len=128) Contents None","tags":"","loc":"proc/alloc_sw.html"},{"title":"copy_and_alloc_lw – rte-rrtmgp","text":"public function copy_and_alloc_lw(this, ncol, nlay, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) Contents None","tags":"","loc":"proc/copy_and_alloc_lw.html"},{"title":"copy_and_alloc_sw – rte-rrtmgp","text":"public function copy_and_alloc_sw(this, ncol, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) Contents None","tags":"","loc":"proc/copy_and_alloc_sw.html"},{"title":"get_ncol_lw – rte-rrtmgp","text":"public pure function get_ncol_lw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_ncol_lw.html"},{"title":"get_ncol_sw – rte-rrtmgp","text":"public pure function get_ncol_sw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_ncol_sw.html"},{"title":"get_nlay_lw – rte-rrtmgp","text":"public pure function get_nlay_lw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_nlay_lw.html"},{"title":"get_subset_range_lw – rte-rrtmgp","text":"public function get_subset_range_lw(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_lw ), intent(inout) :: subset Return Value character(len=128) Contents None","tags":"","loc":"proc/get_subset_range_lw.html"},{"title":"get_subset_range_sw – rte-rrtmgp","text":"public function get_subset_range_sw(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_sw ), intent(inout) :: subset Return Value character(len=128) Contents None","tags":"","loc":"proc/get_subset_range_sw.html"},{"title":"is_allocated_lw – rte-rrtmgp","text":"public pure function is_allocated_lw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/is_allocated_lw.html"},{"title":"is_allocated_sw – rte-rrtmgp","text":"public pure function is_allocated_sw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/is_allocated_sw.html"},{"title":"finalize_lw – rte-rrtmgp","text":"public subroutine finalize_lw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this Contents None","tags":"","loc":"proc/finalize_lw.html"},{"title":"finalize_sw – rte-rrtmgp","text":"public subroutine finalize_sw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this Contents None","tags":"","loc":"proc/finalize_sw.html"},{"title":"any_vals_less_than – rte-rrtmgp","text":"public interface any_vals_less_than Called by interface~~any_vals_less_than~~CalledByGraph interface~any_vals_less_than any_vals_less_than proc~validate_nstream validate_nstream proc~validate_nstream->interface~any_vals_less_than proc~validate_1scalar validate_1scalar proc~validate_1scalar->interface~any_vals_less_than proc~rte_lw rte_lw proc~rte_lw->interface~any_vals_less_than proc~validate_2stream validate_2stream proc~validate_2stream->interface~any_vals_less_than proc~rte_sw rte_sw proc~rte_sw->interface~any_vals_less_than proc~init_base init_base proc~init_base->interface~any_vals_less_than proc~rte_sw~2 rte_sw proc~rte_sw~2->proc~rte_sw proc~compute_bc compute_bc proc~compute_bc->proc~rte_lw proc~compute_bc->proc~rte_sw proc~rte_lw~2 rte_lw proc~rte_lw~2->proc~rte_lw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures any_vals_less_than_1D any_vals_less_than_2D any_vals_less_than_3D any_vals_less_than_1D_masked any_vals_less_than_2D_masked any_vals_less_than_3D_masked Module Procedures private function any_vals_less_than_1D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_2D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_3D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_1D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array logical(kind=wl), intent(in), dimension(:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_2D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array logical(kind=wl), intent(in), dimension(:,:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_3D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array logical(kind=wl), intent(in), dimension(:,:,:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical","tags":"","loc":"interface/any_vals_less_than.html"},{"title":"any_vals_outside – rte-rrtmgp","text":"public interface any_vals_outside Called by interface~~any_vals_outside~~CalledByGraph interface~any_vals_outside any_vals_outside proc~validate_nstream validate_nstream proc~validate_nstream->interface~any_vals_outside proc~rte_lw rte_lw proc~rte_lw->interface~any_vals_outside proc~set_vmr_2d set_vmr_2d proc~set_vmr_2d->interface~any_vals_outside proc~validate_2stream validate_2stream proc~validate_2stream->interface~any_vals_outside proc~set_vmr_1d set_vmr_1d proc~set_vmr_1d->interface~any_vals_outside proc~delta_scale_2str delta_scale_2str proc~delta_scale_2str->interface~any_vals_outside proc~rte_sw rte_sw proc~rte_sw->interface~any_vals_outside proc~rte_sw~2 rte_sw proc~rte_sw~2->proc~rte_sw proc~compute_bc compute_bc proc~compute_bc->proc~rte_lw proc~compute_bc->proc~rte_sw proc~rte_lw~2 rte_lw proc~rte_lw~2->proc~rte_lw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures any_vals_outside_1D any_vals_outside_2D any_vals_outside_3D any_vals_outside_1D_masked any_vals_outside_2D_masked any_vals_outside_3D_masked Module Procedures private function any_vals_outside_1D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_2D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_3D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_1D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array logical(kind=wl), intent(in), dimension(:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_2D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array logical(kind=wl), intent(in), dimension(:,:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_3D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array logical(kind=wl), intent(in), dimension(:,:,:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical","tags":"","loc":"interface/any_vals_outside.html"},{"title":"extents_are – rte-rrtmgp","text":"public interface extents_are Called by interface~~extents_are~~CalledByGraph interface~extents_are extents_are proc~validate_nstream validate_nstream proc~validate_nstream->interface~extents_are proc~reduce_bygpoint reduce_bygpoint proc~reduce_bygpoint->interface~extents_are proc~rte_lw rte_lw proc~rte_lw->interface~extents_are proc~compute_heating_rate compute_heating_rate proc~compute_heating_rate->interface~extents_are proc~validate_2stream validate_2stream proc~validate_2stream->interface~extents_are proc~reduce_byband reduce_byband proc~reduce_byband->interface~extents_are proc~delta_scale_2str delta_scale_2str proc~delta_scale_2str->interface~extents_are proc~rte_sw rte_sw proc~rte_sw->interface~extents_are proc~init_base init_base proc~init_base->interface~extents_are proc~compute_bc compute_bc proc~compute_bc->interface~extents_are proc~compute_bc->proc~rte_lw proc~compute_bc->proc~rte_sw proc~rte_sw~2 rte_sw proc~rte_sw~2->proc~rte_sw proc~rte_lw~2 rte_lw proc~rte_lw~2->proc~rte_lw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures extents_are_1D extents_are_2D extents_are_3D extents_are_4D extents_are_5D extents_are_6D extents_are_2d_int Module Procedures private function extents_are_1d(array, n1) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:          ) :: array integer, intent(in) :: n1 Return Value logical(kind=wl) private function extents_are_2d(array, n1, n2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:        ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 Return Value logical(kind=wl) private function extents_are_3d(array, n1, n2, n3) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:      ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 Return Value logical(kind=wl) private function extents_are_4d(array, n1, n2, n3, n4) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:    ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 Return Value logical(kind=wl) private function extents_are_5d(array, n1, n2, n3, n4, n5) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:,:  ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 integer, intent(in) :: n5 Return Value logical(kind=wl) private function extents_are_6d(array, n1, n2, n3, n4, n5, n6) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 integer, intent(in) :: n5 integer, intent(in) :: n6 Return Value logical(kind=wl) private function extents_are_2d_int(array, n1, n2) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:        ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 Return Value logical(kind=wl)","tags":"","loc":"interface/extents_are.html"},{"title":"zero_array – rte-rrtmgp","text":"public interface zero_array Called by interface~~zero_array~~CalledByGraph interface~zero_array zero_array proc~rte_sw rte_sw proc~rte_sw->interface~zero_array proc~rte_lw rte_lw proc~rte_lw->interface~zero_array proc~rte_sw~2 rte_sw proc~rte_sw~2->proc~rte_sw proc~compute_bc compute_bc proc~compute_bc->proc~rte_sw proc~compute_bc->proc~rte_lw proc~rte_lw~2 rte_lw proc~rte_lw~2->proc~rte_lw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures zero_array_1D zero_array_2D zero_array_3D zero_array_4D Module Procedures private subroutine zero_array_1D(ni, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni real(kind=wp), intent(out), dimension(ni) :: array private subroutine zero_array_2D(ni, nj, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni integer, intent(in) :: nj real(kind=wp), intent(out), dimension(ni, nj) :: array private subroutine zero_array_3D(ni, nj, nk, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni integer, intent(in) :: nj integer, intent(in) :: nk real(kind=wp), intent(out), dimension(ni, nj, nk) :: array private subroutine zero_array_4D(ni, nj, nk, nl, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni integer, intent(in) :: nj integer, intent(in) :: nk integer, intent(in) :: nl real(kind=wp), intent(out), dimension(ni, nj, nk, nl) :: array","tags":"","loc":"interface/zero_array.html"},{"title":"compute_heating_rate – rte-rrtmgp","text":"public function compute_heating_rate(flux_up, flux_dn, plev, heating_rate) result(error_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: flux_up real(kind=wp), intent(in), dimension(:,:) :: flux_dn real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(out), dimension(:,:) :: heating_rate Return Value character(len=128) Calls proc~~compute_heating_rate~~CallsGraph proc~compute_heating_rate compute_heating_rate interface~extents_are extents_are proc~compute_heating_rate->interface~extents_are Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/compute_heating_rate.html"},{"title":"compute_bc – rte-rrtmgp","text":"public function compute_bc(k_dist, play, plev, tlay, gas_concs, flux_bc, mu0) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: k_dist real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_concs real(kind=wp), intent(out), dimension(:,:), target :: flux_bc real(kind=wp), intent(in), optional dimension(:) :: mu0 Return Value character(len=128) Calls proc~~compute_bc~~CallsGraph proc~compute_bc compute_bc interface~extents_are extents_are proc~compute_bc->interface~extents_are proc~rte_sw rte_sw proc~compute_bc->proc~rte_sw proc~rte_lw rte_lw proc~compute_bc->proc~rte_lw proc~rte_sw->interface~extents_are sw_solver_noscat sw_solver_noscat proc~rte_sw->sw_solver_noscat interface~any_vals_outside any_vals_outside proc~rte_sw->interface~any_vals_outside interface~zero_array zero_array proc~rte_sw->interface~zero_array sw_solver_2stream sw_solver_2stream proc~rte_sw->sw_solver_2stream interface~any_vals_less_than any_vals_less_than proc~rte_sw->interface~any_vals_less_than proc~rte_lw->interface~extents_are proc~rte_lw->interface~any_vals_outside proc~rte_lw->interface~zero_array lw_solver_noscat_gaussquad lw_solver_noscat_gaussquad proc~rte_lw->lw_solver_noscat_gaussquad lw_solver_2stream lw_solver_2stream proc~rte_lw->lw_solver_2stream proc~rte_lw->interface~any_vals_less_than Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/compute_bc.html"},{"title":"rte_lw – rte-rrtmgp","text":"public function rte_lw(k_dist, gas_concs, p_lay, t_lay, p_lev, t_sfc, sfc_emis, cloud_props, allsky_fluxes, clrsky_fluxes, aer_props, col_dry, t_lev, inc_flux, n_gauss_angles) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: k_dist type( ty_gas_concs ), intent(in) :: gas_concs real(kind=wp), intent(in), dimension(:,:) :: p_lay real(kind=wp), intent(in), dimension(:,:) :: t_lay real(kind=wp), intent(in), dimension(:,:) :: p_lev real(kind=wp), intent(in), dimension(:) :: t_sfc real(kind=wp), intent(in), dimension(:,:) :: sfc_emis class( ty_optical_props_arry ), intent(in) :: cloud_props class( ty_fluxes ), intent(inout) :: allsky_fluxes class( ty_fluxes ), intent(inout) :: clrsky_fluxes class( ty_optical_props_arry ), intent(in), optional :: aer_props real(kind=wp), intent(in), optional dimension(:,:) :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: t_lev real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux integer, intent(in), optional :: n_gauss_angles Return Value character(len=128) Calls proc~~rte_lw~2~~CallsGraph proc~rte_lw~2 rte_lw proc~rte_lw rte_lw proc~rte_lw~2->proc~rte_lw interface~any_vals_outside any_vals_outside proc~rte_lw->interface~any_vals_outside interface~extents_are extents_are proc~rte_lw->interface~extents_are interface~zero_array zero_array proc~rte_lw->interface~zero_array lw_solver_noscat_gaussquad lw_solver_noscat_gaussquad proc~rte_lw->lw_solver_noscat_gaussquad lw_solver_2stream lw_solver_2stream proc~rte_lw->lw_solver_2stream interface~any_vals_less_than any_vals_less_than proc~rte_lw->interface~any_vals_less_than Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rte_lw~2.html"},{"title":"rte_sw – rte-rrtmgp","text":"public function rte_sw(k_dist, gas_concs, p_lay, t_lay, p_lev, mu0, sfc_alb_dir, sfc_alb_dif, cloud_props, allsky_fluxes, clrsky_fluxes, aer_props, col_dry, inc_flux) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: k_dist type( ty_gas_concs ), intent(in) :: gas_concs real(kind=wp), intent(in), dimension(:,:) :: p_lay real(kind=wp), intent(in), dimension(:,:) :: t_lay real(kind=wp), intent(in), dimension(:,:) :: p_lev real(kind=wp), intent(in), dimension(:  ) :: mu0 real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dir real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dif class( ty_optical_props_arry ), intent(in) :: cloud_props class( ty_fluxes ), intent(inout) :: allsky_fluxes class( ty_fluxes ), intent(inout) :: clrsky_fluxes class( ty_optical_props_arry ), intent(in), optional target :: aer_props real(kind=wp), intent(in), optional dimension(:,:) :: col_dry real(kind=wp), intent(in), optional dimension(:,:) :: inc_flux Return Value character(len=128) Calls proc~~rte_sw~2~~CallsGraph proc~rte_sw~2 rte_sw proc~rte_sw rte_sw proc~rte_sw~2->proc~rte_sw sw_solver_noscat sw_solver_noscat proc~rte_sw->sw_solver_noscat interface~any_vals_outside any_vals_outside proc~rte_sw->interface~any_vals_outside interface~extents_are extents_are proc~rte_sw->interface~extents_are interface~zero_array zero_array proc~rte_sw->interface~zero_array sw_solver_2stream sw_solver_2stream proc~rte_sw->sw_solver_2stream interface~any_vals_less_than any_vals_less_than proc~rte_sw->interface~any_vals_less_than Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rte_sw~2.html"},{"title":"are_desired_byband – rte-rrtmgp","text":"public function are_desired_byband(this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_byband ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/are_desired_byband.html"},{"title":"reduce_byband – rte-rrtmgp","text":"public function reduce_byband(this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_byband ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128) Calls proc~~reduce_byband~~CallsGraph proc~reduce_byband reduce_byband proc~sum_byband sum_byband proc~reduce_byband->proc~sum_byband interface~net_byband net_byband proc~reduce_byband->interface~net_byband interface~extents_are extents_are proc~reduce_byband->interface~extents_are proc~net_byband_full net_byband_full interface~net_byband->proc~net_byband_full proc~net_byband_precalc net_byband_precalc interface~net_byband->proc~net_byband_precalc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/reduce_byband.html"},{"title":"net_byband_full – rte-rrtmgp","text":"public subroutine net_byband_full(ncol, nlev, ngpt, nbnd, band_lims, spectral_flux_dn, spectral_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt integer, intent(in) :: nbnd integer, intent(in), dimension(2,          nbnd) :: band_lims real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net Called by proc~~net_byband_full~~CalledByGraph proc~net_byband_full net_byband_full interface~net_byband net_byband interface~net_byband->proc~net_byband_full proc~reduce_byband reduce_byband proc~reduce_byband->interface~net_byband Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/net_byband_full.html"},{"title":"net_byband_precalc – rte-rrtmgp","text":"public subroutine net_byband_precalc(ncol, nlev, nbnd, byband_flux_dn, byband_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: nbnd real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net Called by proc~~net_byband_precalc~~CalledByGraph proc~net_byband_precalc net_byband_precalc interface~net_byband net_byband interface~net_byband->proc~net_byband_precalc proc~reduce_byband reduce_byband proc~reduce_byband->interface~net_byband Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/net_byband_precalc.html"},{"title":"sum_byband – rte-rrtmgp","text":"public subroutine sum_byband(ncol, nlev, ngpt, nbnd, band_lims, spectral_flux, byband_flux) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt integer, intent(in) :: nbnd integer, intent(in), dimension(2,          nbnd) :: band_lims real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux Called by proc~~sum_byband~~CalledByGraph proc~sum_byband sum_byband proc~reduce_byband reduce_byband proc~reduce_byband->proc~sum_byband Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sum_byband.html"},{"title":"net_byband – rte-rrtmgp","text":"public interface net_byband Calls interface~~net_byband~~CallsGraph interface~net_byband net_byband proc~net_byband_full net_byband_full interface~net_byband->proc~net_byband_full proc~net_byband_precalc net_byband_precalc interface~net_byband->proc~net_byband_precalc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~net_byband~~CalledByGraph interface~net_byband net_byband proc~reduce_byband reduce_byband proc~reduce_byband->interface~net_byband Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures net_byband_full net_byband_precalc Module Procedures public subroutine net_byband_full (ncol, nlev, ngpt, nbnd, band_lims, spectral_flux_dn, spectral_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt integer, intent(in) :: nbnd integer, intent(in), dimension(2,          nbnd) :: band_lims real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net public subroutine net_byband_precalc (ncol, nlev, nbnd, byband_flux_dn, byband_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: nbnd real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net","tags":"","loc":"interface/net_byband.html"},{"title":"are_desired_bygpoint – rte-rrtmgp","text":"public function are_desired_bygpoint(this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_bygpoint ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/are_desired_bygpoint.html"},{"title":"reduce_bygpoint – rte-rrtmgp","text":"public function reduce_bygpoint(this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_bygpoint ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128) Calls proc~~reduce_bygpoint~~CallsGraph proc~reduce_bygpoint reduce_bygpoint interface~extents_are extents_are proc~reduce_bygpoint->interface~extents_are Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/reduce_bygpoint.html"},{"title":"draw_samples – rte-rrtmgp","text":"public function draw_samples(cloud_mask, clouds, clouds_sampled) result(error_msg) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:,:) :: cloud_mask class( ty_optical_props_arry ), intent(in) :: clouds class( ty_optical_props_arry ), intent(inout) :: clouds_sampled Return Value character(len=128) Contents None","tags":"","loc":"proc/draw_samples.html"},{"title":"sampled_mask_exp_ran – rte-rrtmgp","text":"public function sampled_mask_exp_ran(randoms, cloud_frac, overlap_param, cloud_mask) result(error_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: randoms real(kind=wp), intent(in), dimension(:,:) :: cloud_frac real(kind=wp), intent(in), dimension(:,:) :: overlap_param logical, intent(out), dimension(:,:,:) :: cloud_mask Return Value character(len=128) Contents None","tags":"","loc":"proc/sampled_mask_exp_ran.html"},{"title":"sampled_mask_max_ran – rte-rrtmgp","text":"public function sampled_mask_max_ran(randoms, cloud_frac, cloud_mask) result(error_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: randoms real(kind=wp), intent(in), dimension(:,:) :: cloud_frac logical, intent(out), dimension(:,:,:) :: cloud_mask Return Value character(len=128) Contents None","tags":"","loc":"proc/sampled_mask_max_ran.html"},{"title":"pade_eval – rte-rrtmgp","text":"public interface pade_eval Contents Module Procedures pade_eval_nbnd pade_eval_1 Module Procedures private function pade_eval_nbnd(nbnd, nrads, m, n, irad, re, pade_coeffs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nbnd integer, intent(in) :: nrads integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: irad real(kind=wp), intent(in) :: re real(kind=wp), intent(in), dimension(nbnd, nrads, 0:m+n) :: pade_coeffs Return Value real(kind=wp),\n  dimension(nbnd) private function pade_eval_1(iband, nbnd, nrads, m, n, irad, re, pade_coeffs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iband integer, intent(in) :: nbnd integer, intent(in) :: nrads integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: irad real(kind=wp), intent(in) :: re real(kind=wp), intent(in), dimension(nbnd, nrads, 0:m+n) :: pade_coeffs Return Value real(kind=wp)","tags":"","loc":"interface/pade_eval.html"},{"title":"mo_rrtmgp_util_string – rte-rrtmgp","text":"Used by module~~mo_rrtmgp_util_string~~UsedByGraph module~mo_rrtmgp_util_string mo_rrtmgp_util_string module~mo_gas_concentrations mo_gas_concentrations module~mo_gas_concentrations->module~mo_rrtmgp_util_string module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_util_string module~mo_gas_optics_rrtmgp->module~mo_gas_concentrations module~mo_gas_optics mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_gas_concentrations module~mo_compute_bc->module~mo_gas_optics module~mo_gas_optics->module~mo_gas_concentrations module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_gas_concentrations module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions lower_case string_in_array string_loc_in_array Functions public pure function lower_case (input_string) result(output_string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_string Return Value character(len=len) public pure function string_in_array (string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), dimension(:) :: array Return Value logical public pure function string_loc_in_array (string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), dimension(:) :: array Return Value integer","tags":"","loc":"module/mo_rrtmgp_util_string.html"},{"title":"mo_rrtmgp_util_reorder – rte-rrtmgp","text":"Uses mo_rte_kind mo_rrtmgp_util_reorder_kernels module~~mo_rrtmgp_util_reorder~~UsesGraph module~mo_rrtmgp_util_reorder mo_rrtmgp_util_reorder module~mo_rte_kind mo_rte_kind module~mo_rrtmgp_util_reorder->module~mo_rte_kind mo_rrtmgp_util_reorder_kernels mo_rrtmgp_util_reorder_kernels module~mo_rrtmgp_util_reorder->mo_rrtmgp_util_reorder_kernels iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rrtmgp_util_reorder~~UsedByGraph module~mo_rrtmgp_util_reorder mo_rrtmgp_util_reorder module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_util_reorder Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines reorder123x321 Subroutines public subroutine reorder123x321 (array, array_out) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(out), dimension(:,:,:) :: array_out","tags":"","loc":"module/mo_rrtmgp_util_reorder.html"},{"title":"mo_gas_concentrations – rte-rrtmgp","text":"Uses mo_rrtmgp_util_string mo_rte_kind mo_rte_config mo_rte_util_array module~~mo_gas_concentrations~~UsesGraph module~mo_gas_concentrations mo_gas_concentrations module~mo_rte_config mo_rte_config module~mo_gas_concentrations->module~mo_rte_config module~mo_rte_kind mo_rte_kind module~mo_gas_concentrations->module~mo_rte_kind module~mo_rte_util_array mo_rte_util_array module~mo_gas_concentrations->module~mo_rte_util_array module~mo_rrtmgp_util_string mo_rrtmgp_util_string module~mo_gas_concentrations->module~mo_rrtmgp_util_string module~mo_rte_config->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_gas_concentrations~~UsedByGraph module~mo_gas_concentrations mo_gas_concentrations module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_gas_concentrations module~mo_gas_optics mo_gas_optics module~mo_compute_bc->module~mo_gas_optics module~mo_gas_optics->module~mo_gas_concentrations module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_gas_concentrations module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_gas_concentrations module~mo_gas_optics_rrtmgp->module~mo_gas_optics Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables GAS_NOT_IN_LIST Derived Types conc_field ty_gas_concs Functions find_gas get_gas_names get_num_gases get_subset_range get_vmr_1d get_vmr_2d init set_vmr_1d set_vmr_2d set_vmr_scalar Subroutines del reset Variables Type Visibility Attributes Name Initial integer, public, parameter :: GAS_NOT_IN_LIST = -1 Derived Types type, public :: conc_field Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:), pointer :: conc => NULL() type, public :: ty_gas_concs Components Type Visibility Attributes Name Initial type( conc_field ), public, dimension(:), allocatable :: concs character(len=32), public, dimension(:), allocatable :: gas_name integer, public :: ncol = 0 integer, public :: nlay = 0 Finalizations Procedures final :: del Type-Bound Procedures procedure, public :: get_gas_names procedure, public :: get_num_gases generic, public :: get_subset => get_subset_range generic, public :: get_vmr => get_vmr_1d, get_vmr_2d procedure, public :: init procedure, public :: reset generic, public :: set_vmr => set_vmr_scalar, set_vmr_1d, set_vmr_2d Functions public function find_gas (this, gas) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this character(len=*), intent(in) :: gas Return Value integer public pure function get_gas_names (this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this Return Value character(len=32),\n  dimension(this%get_num_gases()) public pure function get_num_gases (this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this Return Value integer public function get_subset_range (this, start, n, subset) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this integer, intent(in) :: start integer, intent(in) :: n class( ty_gas_concs ), intent(inout) :: subset Return Value character(len=128) public function get_vmr_1d (this, gas, array) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(out), dimension(:) :: array Return Value character(len=128) public function get_vmr_2d (this, gas, array) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(out), dimension(:,:) :: array Return Value character(len=128) public function init (this, gas_names) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: gas_names Return Value character(len=128) public function set_vmr_1d (this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in), dimension(:) :: w Return Value character(len=128) public function set_vmr_2d (this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in), dimension(:,:) :: w Return Value character(len=128) public function set_vmr_scalar (this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in) :: w Return Value character(len=128) Subroutines public subroutine del (this) Arguments Type Intent Optional Attributes Name type( ty_gas_concs ), intent(inout) :: this public subroutine reset (this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this","tags":"","loc":"module/mo_gas_concentrations.html"},{"title":"mo_gas_optics – rte-rrtmgp","text":"Uses mo_source_functions mo_rte_kind mo_optical_props mo_gas_concentrations module~~mo_gas_optics~~UsesGraph module~mo_gas_optics mo_gas_optics module~mo_gas_concentrations mo_gas_concentrations module~mo_gas_optics->module~mo_gas_concentrations module~mo_rte_kind mo_rte_kind module~mo_gas_optics->module~mo_rte_kind module~mo_source_functions mo_source_functions module~mo_gas_optics->module~mo_source_functions module~mo_optical_props mo_optical_props module~mo_gas_optics->module~mo_optical_props module~mo_gas_concentrations->module~mo_rte_kind module~mo_rte_util_array mo_rte_util_array module~mo_gas_concentrations->module~mo_rte_util_array module~mo_rrtmgp_util_string mo_rrtmgp_util_string module~mo_gas_concentrations->module~mo_rrtmgp_util_string module~mo_rte_config mo_rte_config module~mo_gas_concentrations->module~mo_rte_config iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_source_functions->module~mo_rte_kind module~mo_source_functions->module~mo_optical_props module~mo_optical_props->module~mo_rte_kind mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_config module~mo_rte_util_array->module~mo_rte_kind module~mo_rte_config->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_gas_optics~~UsedByGraph module~mo_gas_optics mo_gas_optics module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_gas_optics module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_gas_optics Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces gas_optics_ext_abstract gas_optics_int_abstract logical_abstract real_abstract Derived Types ty_gas_optics Abstract Interfaces abstract interface public function gas_optics_ext_abstract(this, play, plev, tlay, gas_desc, optical_props, toa_src, col_dry) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: toa_src real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry Return Value character(len=128) abstract interface public function gas_optics_int_abstract(this, play, plev, tlay, tsfc, gas_desc, optical_props, sources, col_dry, tlev) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay real(kind=wp), intent(in), dimension(:) :: tsfc type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props class( ty_source_func_lw ), intent(inout) :: sources real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: tlev Return Value character(len=128) abstract interface public function logical_abstract(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value logical abstract interface public function real_abstract(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value real(kind=wp) Derived Types type, public, abstract, extends( ty_optical_props ) :: ty_gas_optics Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize => finalize_base generic, public :: gas_optics => gas_optics_int, gas_optics_ext procedure(gas_optics_ext_abstract), public :: gas_optics_ext procedure(gas_optics_int_abstract), public :: gas_optics_int procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ngpt procedure(real_abstract), public :: get_press_max procedure(real_abstract), public :: get_press_min procedure(real_abstract), public :: get_temp_max procedure(real_abstract), public :: get_temp_min procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure(logical_abstract), public :: source_is_external procedure(logical_abstract), public :: source_is_internal","tags":"","loc":"module/mo_gas_optics.html"},{"title":"mo_gas_optics_rrtmgp – rte-rrtmgp","text":"Uses mo_source_functions mo_rrtmgp_constants mo_gas_optics mo_rrtmgp_util_string mo_optical_props mo_rte_config mo_rte_util_array mo_rte_kind mo_rrtmgp_util_reorder mo_gas_concentrations mo_gas_optics_kernels module~~mo_gas_optics_rrtmgp~~UsesGraph module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_gas_concentrations mo_gas_concentrations module~mo_gas_optics_rrtmgp->module~mo_gas_concentrations module~mo_rrtmgp_constants mo_rrtmgp_constants module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_constants module~mo_rte_util_array mo_rte_util_array module~mo_gas_optics_rrtmgp->module~mo_rte_util_array module~mo_rrtmgp_util_string mo_rrtmgp_util_string module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_util_string module~mo_source_functions mo_source_functions module~mo_gas_optics_rrtmgp->module~mo_source_functions module~mo_optical_props mo_optical_props module~mo_gas_optics_rrtmgp->module~mo_optical_props mo_gas_optics_kernels mo_gas_optics_kernels module~mo_gas_optics_rrtmgp->mo_gas_optics_kernels module~mo_rte_config mo_rte_config module~mo_gas_optics_rrtmgp->module~mo_rte_config module~mo_rte_kind mo_rte_kind module~mo_gas_optics_rrtmgp->module~mo_rte_kind module~mo_rrtmgp_util_reorder mo_rrtmgp_util_reorder module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_util_reorder module~mo_gas_optics->module~mo_gas_concentrations module~mo_gas_optics->module~mo_source_functions module~mo_gas_optics->module~mo_optical_props module~mo_gas_optics->module~mo_rte_kind module~mo_gas_concentrations->module~mo_rte_util_array module~mo_gas_concentrations->module~mo_rrtmgp_util_string module~mo_gas_concentrations->module~mo_rte_config module~mo_gas_concentrations->module~mo_rte_kind module~mo_rrtmgp_constants->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind module~mo_source_functions->module~mo_optical_props module~mo_source_functions->module~mo_rte_kind module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_kind mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_rte_config->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_rrtmgp_util_reorder->module~mo_rte_kind mo_rrtmgp_util_reorder_kernels mo_rrtmgp_util_reorder_kernels module~mo_rrtmgp_util_reorder->mo_rrtmgp_util_reorder_kernels Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_gas_optics_rrtmgp Functions get_col_dry Derived Types type, public, extends( ty_gas_optics ) :: ty_gas_optics_rrtmgp Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal procedure, public :: compute_optimal_angles procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize => finalize_base generic, public :: gas_optics => gas_optics_int, gas_optics_ext procedure, public :: gas_optics_ext procedure, public :: gas_optics_int procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gases procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ngas procedure, public :: get_ngpt procedure, public :: get_press_max procedure, public :: get_press_min procedure, public :: get_temp_max procedure, public :: get_temp_min procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base generic, public :: load => load_int, load_ext procedure, public :: set_name procedure, public :: set_solar_variability procedure, public :: set_tsi procedure, public :: source_is_external procedure, public :: source_is_internal Functions public function get_col_dry (vmr_h2o, plev, latitude) result(col_dry) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: vmr_h2o real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), optional dimension(:) :: latitude Return Value real(kind=wp),\n  dimension(size(plev,dim=1),size(plev,dim=2)-1)","tags":"","loc":"module/mo_gas_optics_rrtmgp.html"},{"title":"mo_rrtmgp_constants – rte-rrtmgp","text":"Uses mo_rte_kind module~~mo_rrtmgp_constants~~UsesGraph module~mo_rrtmgp_constants mo_rrtmgp_constants module~mo_rte_kind mo_rte_kind module~mo_rrtmgp_constants->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rrtmgp_constants~~UsedByGraph module~mo_rrtmgp_constants mo_rrtmgp_constants module~mo_heating_rates mo_heating_rates module~mo_heating_rates->module~mo_rrtmgp_constants module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables R_univ_gconst avogad k_boltz m_h2o Subroutines init_constants Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: R_univ_gconst = avogad*k_boltz real(kind=wp), public, parameter :: avogad = 6.02214076e23_wp real(kind=wp), public, parameter :: k_boltz = 1.380649e-23_wp real(kind=wp), public, parameter :: m_h2o = 0.018016_wp Subroutines public subroutine init_constants (gravity, mol_weight_dry_air, heat_capacity_dry_air) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), optional :: gravity real(kind=wp), intent(in), optional :: mol_weight_dry_air real(kind=wp), intent(in), optional :: heat_capacity_dry_air","tags":"","loc":"module/mo_rrtmgp_constants.html"},{"title":"mo_rte_config – rte-rrtmgp","text":"Control over input sanitization in Fortan front-end\n  Module variables can be changed only by calling one of the included subroutine Uses mo_rte_kind module~~mo_rte_config~~UsesGraph module~mo_rte_config mo_rte_config module~mo_rte_kind mo_rte_kind module~mo_rte_config->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rte_config~~UsedByGraph module~mo_rte_config mo_rte_config module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_rte_config module~mo_fluxes mo_fluxes module~mo_rte_lw->module~mo_fluxes module~mo_optical_props mo_optical_props module~mo_rte_lw->module~mo_optical_props module~mo_source_functions mo_source_functions module~mo_rte_lw->module~mo_source_functions module~mo_fluxes_byband mo_fluxes_byband module~mo_fluxes_byband->module~mo_rte_config module~mo_fluxes_byband->module~mo_fluxes module~mo_fluxes_byband->module~mo_optical_props module~mo_gas_concentrations mo_gas_concentrations module~mo_gas_concentrations->module~mo_rte_config module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_rte_config module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_gas_concentrations module~mo_compute_bc->module~mo_fluxes module~mo_rte_sw mo_rte_sw module~mo_compute_bc->module~mo_rte_sw module~mo_compute_bc->module~mo_optical_props module~mo_compute_bc->module~mo_source_functions module~mo_gas_optics mo_gas_optics module~mo_compute_bc->module~mo_gas_optics module~mo_fluxes->module~mo_rte_config module~mo_fluxes->module~mo_optical_props module~mo_rte_sw->module~mo_rte_config module~mo_rte_sw->module~mo_fluxes module~mo_rte_sw->module~mo_optical_props module~mo_optical_props->module~mo_rte_config module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_rte_config module~mo_gas_optics_rrtmgp->module~mo_gas_concentrations module~mo_gas_optics_rrtmgp->module~mo_optical_props module~mo_gas_optics_rrtmgp->module~mo_source_functions module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_heating_rates mo_heating_rates module~mo_heating_rates->module~mo_rte_config module~mo_cloud_optics mo_cloud_optics module~mo_cloud_optics->module~mo_rte_config module~mo_cloud_optics->module~mo_optical_props module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_gas_concentrations module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw module~mo_rrtmgp_clr_all_sky->module~mo_optical_props module~mo_rrtmgp_clr_all_sky->module~mo_source_functions module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_source_functions->module~mo_optical_props module~mo_cloud_sampling mo_cloud_sampling module~mo_cloud_sampling->module~mo_optical_props module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_fluxes_bygpoint->module~mo_fluxes module~mo_fluxes_bygpoint->module~mo_optical_props module~mo_gas_optics->module~mo_gas_concentrations module~mo_gas_optics->module~mo_optical_props module~mo_gas_optics->module~mo_source_functions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables check_extents check_values Interfaces rte_config_checks Variables Type Visibility Attributes Name Initial logical(kind=wl), public :: check_extents = .true. logical(kind=wl), public :: check_values = .true. Interfaces public interface rte_config_checks private subroutine rte_config_checks_each(extents, values) Arguments Type Intent Optional Attributes Name logical(kind=wl), intent(in) :: extents logical(kind=wl), intent(in) :: values private subroutine rte_config_checks_all(do_checks) Arguments Type Intent Optional Attributes Name logical(kind=wl), intent(in) :: do_checks","tags":"","loc":"module/mo_rte_config.html"},{"title":"mo_rte_kind – rte-rrtmgp","text":"Uses iso_c_binding module~~mo_rte_kind~~UsesGraph module~mo_rte_kind mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rte_kind~~UsedByGraph module~mo_rte_kind mo_rte_kind module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_rte_kind module~mo_rte_lw mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_gas_concentrations mo_gas_concentrations module~mo_rrtmgp_clr_all_sky->module~mo_gas_concentrations module~mo_fluxes mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_source_functions mo_source_functions module~mo_rrtmgp_clr_all_sky->module~mo_source_functions module~mo_gas_optics mo_gas_optics module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_rte_sw mo_rte_sw module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw module~mo_optical_props mo_optical_props module~mo_rrtmgp_clr_all_sky->module~mo_optical_props module~mo_cloud_optics mo_cloud_optics module~mo_cloud_optics->module~mo_rte_kind module~mo_rte_util_array mo_rte_util_array module~mo_cloud_optics->module~mo_rte_util_array module~mo_rte_config mo_rte_config module~mo_cloud_optics->module~mo_rte_config module~mo_cloud_optics->module~mo_optical_props module~mo_heating_rates mo_heating_rates module~mo_heating_rates->module~mo_rte_kind module~mo_rrtmgp_constants mo_rrtmgp_constants module~mo_heating_rates->module~mo_rrtmgp_constants module~mo_heating_rates->module~mo_rte_util_array module~mo_heating_rates->module~mo_rte_config module~mo_cloud_sampling mo_cloud_sampling module~mo_cloud_sampling->module~mo_rte_kind module~mo_cloud_sampling->module~mo_optical_props module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_fluxes_bygpoint->module~mo_rte_kind module~mo_fluxes_bygpoint->module~mo_rte_util_array module~mo_fluxes_bygpoint->module~mo_fluxes module~mo_fluxes_bygpoint->module~mo_optical_props module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_rte_kind module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_gas_concentrations module~mo_compute_bc->module~mo_rte_util_array module~mo_compute_bc->module~mo_fluxes module~mo_compute_bc->module~mo_source_functions module~mo_compute_bc->module~mo_rte_config module~mo_compute_bc->module~mo_gas_optics module~mo_compute_bc->module~mo_rte_sw module~mo_compute_bc->module~mo_optical_props module~mo_rrtmgp_util_reorder mo_rrtmgp_util_reorder module~mo_rrtmgp_util_reorder->module~mo_rte_kind module~mo_rte_lw->module~mo_rte_kind module~mo_rte_lw->module~mo_rte_util_array module~mo_rte_lw->module~mo_fluxes module~mo_rte_lw->module~mo_source_functions module~mo_rte_lw->module~mo_rte_config module~mo_rte_lw->module~mo_optical_props module~mo_gas_concentrations->module~mo_rte_kind module~mo_gas_concentrations->module~mo_rte_util_array module~mo_gas_concentrations->module~mo_rte_config module~mo_rrtmgp_constants->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind module~mo_fluxes->module~mo_rte_kind module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes->module~mo_rte_config module~mo_fluxes->module~mo_optical_props module~mo_source_functions->module~mo_rte_kind module~mo_source_functions->module~mo_optical_props module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_rte_kind module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_util_reorder module~mo_gas_optics_rrtmgp->module~mo_gas_concentrations module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_constants module~mo_gas_optics_rrtmgp->module~mo_rte_util_array module~mo_gas_optics_rrtmgp->module~mo_source_functions module~mo_gas_optics_rrtmgp->module~mo_rte_config module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_optical_props module~mo_rte_config->module~mo_rte_kind module~mo_gas_optics->module~mo_rte_kind module~mo_gas_optics->module~mo_gas_concentrations module~mo_gas_optics->module~mo_source_functions module~mo_gas_optics->module~mo_optical_props module~mo_fluxes_byband mo_fluxes_byband module~mo_fluxes_byband->module~mo_rte_kind module~mo_fluxes_byband->module~mo_rte_util_array module~mo_fluxes_byband->module~mo_fluxes module~mo_fluxes_byband->module~mo_rte_config module~mo_fluxes_byband->module~mo_optical_props module~mo_solar_variability mo_solar_variability module~mo_solar_variability->module~mo_rte_kind module~mo_rte_sw->module~mo_rte_kind module~mo_rte_sw->module~mo_rte_util_array module~mo_rte_sw->module~mo_fluxes module~mo_rte_sw->module~mo_rte_config module~mo_rte_sw->module~mo_optical_props module~mo_optical_props->module~mo_rte_kind module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_config Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables dp i4 i8 sp wl wp Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = c_double integer, public, parameter :: i4 = c_int integer, public, parameter :: i8 = c_long integer, public, parameter :: sp = c_float integer, public, parameter :: wl = kind(.true.) integer, public, parameter :: wp = dp","tags":"","loc":"module/mo_rte_kind.html"},{"title":"mo_fluxes – rte-rrtmgp","text":"Uses mo_fluxes_broadband_kernels mo_optical_props mo_rte_config mo_rte_util_array mo_rte_kind module~~mo_fluxes~~UsesGraph module~mo_fluxes mo_fluxes mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->mo_fluxes_broadband_kernels module~mo_rte_util_array mo_rte_util_array module~mo_fluxes->module~mo_rte_util_array module~mo_optical_props mo_optical_props module~mo_fluxes->module~mo_optical_props module~mo_rte_config mo_rte_config module~mo_fluxes->module~mo_rte_config module~mo_rte_kind mo_rte_kind module~mo_fluxes->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_kind mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_rte_config->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_fluxes~~UsedByGraph module~mo_fluxes mo_fluxes module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_fluxes module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_rte_sw mo_rte_sw module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw module~mo_fluxes_byband mo_fluxes_byband module~mo_fluxes_byband->module~mo_fluxes module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_fluxes module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_rte_sw module~mo_rte_sw->module~mo_fluxes module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_fluxes_bygpoint->module~mo_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_fluxes ty_fluxes_broadband Derived Types type, public, abstract :: ty_fluxes Type-Bound Procedures procedure(are_desired_abstract), public :: are_desired procedure(reduce_abstract), public :: reduce type, public, extends( ty_fluxes ) :: ty_fluxes_broadband Type-Bound Procedures procedure, public :: are_desired => are_desired_broadband procedure, public :: reduce => reduce_broadband","tags":"","loc":"module/mo_fluxes.html"},{"title":"mo_rte_lw – rte-rrtmgp","text":"Uses mo_source_functions mo_rte_solver_kernels mo_optical_props mo_rte_config mo_rte_util_array mo_rte_kind mo_fluxes module~~mo_rte_lw~~UsesGraph module~mo_rte_lw mo_rte_lw mo_rte_solver_kernels mo_rte_solver_kernels module~mo_rte_lw->mo_rte_solver_kernels module~mo_rte_util_array mo_rte_util_array module~mo_rte_lw->module~mo_rte_util_array module~mo_fluxes mo_fluxes module~mo_rte_lw->module~mo_fluxes module~mo_source_functions mo_source_functions module~mo_rte_lw->module~mo_source_functions module~mo_optical_props mo_optical_props module~mo_rte_lw->module~mo_optical_props module~mo_rte_config mo_rte_config module~mo_rte_lw->module~mo_rte_config module~mo_rte_kind mo_rte_kind module~mo_rte_lw->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_config module~mo_fluxes->module~mo_rte_kind mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->mo_fluxes_broadband_kernels module~mo_source_functions->module~mo_optical_props module~mo_source_functions->module~mo_rte_kind module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_kind mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_rte_config->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rte_lw~~UsedByGraph module~mo_rte_lw mo_rte_lw module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_rte_lw module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions rte_lw Functions public function rte_lw (optical_props, top_at_1, sources, sfc_emis, fluxes, inc_flux, n_gauss_angles, use_2stream, lw_Ds, flux_up_Jac) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: optical_props logical, intent(in) :: top_at_1 type( ty_source_func_lw ), intent(in) :: sources real(kind=wp), intent(in), dimension(:,:) :: sfc_emis class( ty_fluxes ), intent(inout) :: fluxes real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux integer, intent(in), optional :: n_gauss_angles logical, intent(in), optional :: use_2stream real(kind=wp), intent(in), optional dimension(:,:) :: lw_Ds real(kind=wp), intent(inout), optional dimension(:,:), target :: flux_up_Jac Return Value character(len=128)","tags":"","loc":"module/mo_rte_lw.html"},{"title":"mo_rte_sw – rte-rrtmgp","text":"Uses mo_rte_solver_kernels mo_optical_props mo_rte_config mo_rte_util_array mo_rte_kind mo_fluxes module~~mo_rte_sw~~UsesGraph module~mo_rte_sw mo_rte_sw mo_rte_solver_kernels mo_rte_solver_kernels module~mo_rte_sw->mo_rte_solver_kernels module~mo_rte_util_array mo_rte_util_array module~mo_rte_sw->module~mo_rte_util_array module~mo_fluxes mo_fluxes module~mo_rte_sw->module~mo_fluxes module~mo_optical_props mo_optical_props module~mo_rte_sw->module~mo_optical_props module~mo_rte_config mo_rte_config module~mo_rte_sw->module~mo_rte_config module~mo_rte_kind mo_rte_kind module~mo_rte_sw->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_config module~mo_fluxes->module~mo_rte_kind mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->mo_fluxes_broadband_kernels module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_kind mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_rte_config->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rte_sw~~UsedByGraph module~mo_rte_sw mo_rte_sw module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_rte_sw module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions rte_sw Functions public function rte_sw (atmos, top_at_1, mu0, inc_flux, sfc_alb_dir, sfc_alb_dif, fluxes, inc_flux_dif) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: atmos logical, intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(:) :: mu0 real(kind=wp), intent(in), dimension(:,:) :: inc_flux real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dir real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dif class( ty_fluxes ), intent(inout) :: fluxes real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux_dif Return Value character(len=128)","tags":"","loc":"module/mo_rte_sw.html"},{"title":"mo_optical_props – rte-rrtmgp","text":"Encapsulate optical properties defined on a spectral grid of N bands.\n   The bands are described by their limiting wavenumbers. They need not be contiguous or complete.\n   A band may contain more than one spectral sub-point (g-point) in which case a mapping must be supplied.\n   A name may be provided and will be prepended to error messages.\n   The base class (ty_optical_props) encapsulates only this spectral discretization and must be initialized\n      with the spectral information before use. Optical properties may be represented as arrays with dimensions ncol, nlay, ngpt\n   (abstract class ty_optical_props_arry).\n   The type holds arrays depending on how much information is needed\n   There are three possibilites\n      ty_optical_props_1scl holds absorption optical depth tau, used in calculations accounting for extinction and emission\n      ty_optical_props_2str holds extincion optical depth tau, single-scattering albedo ssa, and\n        asymmetry parameter g. These fields are what's needed for two-stream calculations.\n      ty_optical_props_nstr holds extincion optical depth tau, single-scattering albedo ssa, and\n        phase function moments p with leading dimension nmom. These fields are what's needed for multi-stream calculations.\n   These classes must be allocated before use. Initialization and allocation can be combined.\n   The classes have a validate() function that checks all arrays for valid values (e.g. tau > 0.) Optical properties can be delta-scaled (though this is currently implemented only for two-stream arrays) Optical properties can increment or \"add themselves to\" a set of properties represented with arrays\n   as long as both sets have the same underlying band structure. Properties defined by band\n   may be added to properties defined by g-point; the same value is assumed for all g-points with each band. Subsets of optical properties held as arrays may be extracted along the column dimension. Note example of a note with links to other modules and variables check_extents in module mo_rte_config Uses mo_rte_kind mo_rte_config mo_rte_util_array mo_optical_props_kernels module~~mo_optical_props~~UsesGraph module~mo_optical_props mo_optical_props mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_rte_config mo_rte_config module~mo_optical_props->module~mo_rte_config module~mo_rte_kind mo_rte_kind module~mo_optical_props->module~mo_rte_kind module~mo_rte_util_array mo_rte_util_array module~mo_optical_props->module~mo_rte_util_array module~mo_rte_config->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_optical_props~~UsedByGraph module~mo_optical_props mo_optical_props module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_optical_props module~mo_fluxes mo_fluxes module~mo_rte_lw->module~mo_fluxes module~mo_source_functions mo_source_functions module~mo_rte_lw->module~mo_source_functions module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_optical_props module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_source_functions module~mo_rte_sw mo_rte_sw module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw module~mo_gas_optics mo_gas_optics module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_fluxes_byband mo_fluxes_byband module~mo_fluxes_byband->module~mo_optical_props module~mo_fluxes_byband->module~mo_fluxes module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_optical_props module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_fluxes module~mo_compute_bc->module~mo_source_functions module~mo_compute_bc->module~mo_rte_sw module~mo_compute_bc->module~mo_gas_optics module~mo_fluxes->module~mo_optical_props module~mo_source_functions->module~mo_optical_props module~mo_rte_sw->module~mo_optical_props module~mo_rte_sw->module~mo_fluxes module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_optical_props module~mo_gas_optics_rrtmgp->module~mo_source_functions module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_cloud_sampling mo_cloud_sampling module~mo_cloud_sampling->module~mo_optical_props module~mo_cloud_optics mo_cloud_optics module~mo_cloud_optics->module~mo_optical_props module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_fluxes_bygpoint->module~mo_optical_props module~mo_fluxes_bygpoint->module~mo_fluxes module~mo_gas_optics->module~mo_optical_props module~mo_gas_optics->module~mo_source_functions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables name_len Abstract Interfaces delta_scale_abstract subset_range_abstract validate_abstract Derived Types ty_optical_props ty_optical_props_1scl ty_optical_props_2str ty_optical_props_arry ty_optical_props_nstr Functions alloc_only_1scl alloc_only_2str alloc_only_nstr bands_are_equal convert_band2gpt convert_gpt2band copy_and_alloc_1scl copy_and_alloc_2str copy_and_alloc_nstr delta_scale_1scl delta_scale_2str delta_scale_nstr expand finalize_1scl finalize_2str finalize_nstr get_arry_extent get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_nmom gpoints_are_equal increment init_and_alloc_1scl init_and_alloc_2str init_and_alloc_nstr init_base init_base_from_copy is_initialized_base subset_1scl_range subset_2str_range subset_nstr_range validate_1scalar validate_2stream validate_nstream Subroutines finalize_base set_name Variables Type Visibility Attributes Name Initial integer, public, parameter :: name_len = 32 Abstract Interfaces abstract interface Interfaces for the methods to be implemented public function delta_scale_abstract(this, for) result(err_message) Delta-scaling Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) Forward scattering fraction; g**2 if not provided abstract interface Interfaces for the methods to be implemented public function subset_range_abstract(full, start, n, subset) result(err_message) Subsetting -- currently there are only routines with start col and count Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) abstract interface Interfaces for the methods to be implemented public function validate_abstract(this) result(err_message) Validation function looks only at internal data Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value character(len=128) Derived Types type, public :: ty_optical_props Base class for optical properties\n  Describes the spectral discretization including the wavenumber limits\n  of each band (spectral region) and the mapping between g-points and bands Read more… Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ngpt procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name type, public, extends( ty_optical_props_arry ) :: ty_optical_props_1scl ty_optical_props_arry  includes only (extinction) optical depth\n   Class two-stream adds arrays for single scattering albedo ssa and\n     asymmetry parameter needed in two-stream methods\n   Class n-stream adds arrays for single scattering albedo ssa and\n     phase function moments (index 1 = g) for use with discrete ordinate methods Read more… Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_1scl => alloc_only_1scl, init_and_alloc_1scl, copy_and_alloc_1scl procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: delta_scale => delta_scale_1scl procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: finalize_1scl procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol procedure, public :: get_ngpt procedure, public :: get_nlay procedure, public :: get_subset => subset_1scl_range procedure, public :: gpoints_are_equal procedure, public :: increment Increment another set of values generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure, public :: validate => validate_1scalar type, public, extends( ty_optical_props_arry ) :: ty_optical_props_2str Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) real(kind=wp), public, dimension(:,:,:), allocatable :: g asymmetry parameter (ncol, nlay, ngpt) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:), allocatable :: ssa single-scattering albedo (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_2str => alloc_only_2str, init_and_alloc_2str, copy_and_alloc_2str procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: delta_scale => delta_scale_2str procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: finalize_2str procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol procedure, public :: get_ngpt procedure, public :: get_nlay procedure, public :: get_subset => subset_2str_range procedure, public :: gpoints_are_equal procedure, public :: increment Increment another set of values generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure, public :: validate => validate_2stream type, public, abstract, extends( ty_optical_props ) :: ty_optical_props_arry Optical properties as arrays, normally dimensioned ncol, nlay, ngpt/nbnd\n   The abstract base class for arrays defines what procedures will be available\n   The optical depth field is also part of the abstract base class, since\n    any representation of values as arrays needs an optical depth field Read more… Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure(delta_scale_abstract), public :: delta_scale procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol procedure, public :: get_ngpt procedure, public :: get_nlay procedure(subset_range_abstract), public :: get_subset procedure, public :: gpoints_are_equal procedure, public :: increment Increment another set of values generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure(validate_abstract), public :: validate Deferred procedures -- each must be implemented in each child class with\n  arguments following the abstract interface (defined below) type, public, extends( ty_optical_props_arry ) :: ty_optical_props_nstr Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:,:), allocatable :: p phase-function moments (nmom, ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: ssa single-scattering albedo (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_nstr => alloc_only_nstr, init_and_alloc_nstr, copy_and_alloc_nstr procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: delta_scale => delta_scale_nstr procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: finalize_nstr procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol procedure, public :: get_ngpt procedure, public :: get_nlay procedure, public :: get_nmom procedure, public :: get_subset => subset_nstr_range procedure, public :: gpoints_are_equal procedure, public :: increment Increment another set of values generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure, public :: validate => validate_nstream Functions public function alloc_only_1scl (this, ncol, nlay) result(err_message) Straight allocation routines Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function alloc_only_2str (this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function alloc_only_nstr (this, nmom, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer public function copy_and_alloc_1scl (this, ncol, nlay, spectral_desc, name) result(err_message) Initialization from an existing spectral discretization/ty_optical_props Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) public function copy_and_alloc_2str (this, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) public function copy_and_alloc_nstr (this, nmom, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) public function delta_scale_1scl (this, for) result(err_message) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) public function delta_scale_2str (this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Forward scattering fraction; g**2 if not provided Return Value character(len=128) public function delta_scale_nstr (this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) public function finalize_1scl (this) result(err_message) Finalize routines Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this Return Value character(len=128) public function finalize_2str (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this Return Value character(len=128) public function finalize_nstr (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this Return Value character(len=128) public pure function get_arry_extent (this, dim) Routines for array classes: problem sizes Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this integer, intent(in) :: dim Return Value integer public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer public pure function get_ncol (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer public pure function get_nlay (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer public pure function get_nmom (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value integer public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical public function increment (op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) public function init_and_alloc_1scl (this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Initialization by specifying band limits and possibly g-point/band mapping Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_and_alloc_2str (this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_and_alloc_nstr (this, nmom, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical public function subset_1scl_range (full, start, n, subset) result(err_message) Routines for array classes: subsetting of optical properties arrays along x (col) direction Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) public function subset_2str_range (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) public function subset_nstr_range (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) public function validate_1scalar (this) result(err_message) --- Validation Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(in) :: this Return Value character(len=128) public function validate_2stream (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(in) :: this Return Value character(len=128) public function validate_nstream (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value character(len=128) Subroutines public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name","tags":"","loc":"module/mo_optical_props.html"},{"title":"mo_source_functions – rte-rrtmgp","text":"Uses mo_rte_kind mo_optical_props module~~mo_source_functions~~UsesGraph module~mo_source_functions mo_source_functions module~mo_rte_kind mo_rte_kind module~mo_source_functions->module~mo_rte_kind module~mo_optical_props mo_optical_props module~mo_source_functions->module~mo_optical_props iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_optical_props->module~mo_rte_kind mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_rte_config mo_rte_config module~mo_optical_props->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_optical_props->module~mo_rte_util_array module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_source_functions~~UsedByGraph module~mo_source_functions mo_source_functions module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_source_functions module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_source_functions module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_gas_optics mo_gas_optics module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_source_functions module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_gas_optics module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_source_functions module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_gas_optics->module~mo_source_functions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_source_func_lw ty_source_func_sw Functions alloc_lw alloc_sw copy_and_alloc_lw copy_and_alloc_sw get_ncol_lw get_ncol_sw get_nlay_lw get_subset_range_lw get_subset_range_sw is_allocated_lw is_allocated_sw Subroutines finalize_lw finalize_sw Derived Types type, public, extends( ty_optical_props ) :: ty_source_func_lw Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) real(kind=wp), public, allocatable, dimension(:,:,:) :: lay_source real(kind=wp), public, allocatable, dimension(:,:,:) :: lev_source_dec real(kind=wp), public, allocatable, dimension(:,:,:) :: lev_source_inc character(len=name_len), public :: name = \"\" real(kind=wp), public, allocatable, dimension(:,:  ) :: sfc_source real(kind=wp), public, allocatable, dimension(:,:  ) :: sfc_source_Jac Type-Bound Procedures generic, public :: alloc => alloc_lw, copy_and_alloc_lw procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize => finalize_lw procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol => get_ncol_lw procedure, public :: get_ngpt procedure, public :: get_nlay => get_nlay_lw procedure, public :: get_subset => get_subset_range_lw procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_allocated => is_allocated_lw procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name type, public, extends( ty_optical_props ) :: ty_source_func_sw Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, allocatable, dimension(:,:  ) :: toa_source Type-Bound Procedures generic, public :: alloc => alloc_sw, copy_and_alloc_sw procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize => finalize_sw procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol => get_ncol_sw procedure, public :: get_ngpt procedure, public :: get_subset => get_subset_range_sw procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_allocated => is_allocated_sw procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name Functions public function alloc_lw (this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function alloc_sw (this, ncol) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol Return Value character(len=128) public function copy_and_alloc_lw (this, ncol, nlay, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) public function copy_and_alloc_sw (this, ncol, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) public pure function get_ncol_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer public pure function get_ncol_sw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value integer public pure function get_nlay_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer public function get_subset_range_lw (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_lw ), intent(inout) :: subset Return Value character(len=128) public function get_subset_range_sw (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_sw ), intent(inout) :: subset Return Value character(len=128) public pure function is_allocated_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value logical public pure function is_allocated_sw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value logical Subroutines public subroutine finalize_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this public subroutine finalize_sw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this","tags":"","loc":"module/mo_source_functions.html"},{"title":"mo_rte_util_array – rte-rrtmgp","text":"Uses mo_rte_kind module~~mo_rte_util_array~~UsesGraph module~mo_rte_util_array mo_rte_util_array module~mo_rte_kind mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rte_util_array~~UsedByGraph module~mo_rte_util_array mo_rte_util_array module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_rte_util_array module~mo_fluxes mo_fluxes module~mo_rte_lw->module~mo_fluxes module~mo_optical_props mo_optical_props module~mo_rte_lw->module~mo_optical_props module~mo_source_functions mo_source_functions module~mo_rte_lw->module~mo_source_functions module~mo_fluxes_byband mo_fluxes_byband module~mo_fluxes_byband->module~mo_rte_util_array module~mo_fluxes_byband->module~mo_fluxes module~mo_fluxes_byband->module~mo_optical_props module~mo_gas_concentrations mo_gas_concentrations module~mo_gas_concentrations->module~mo_rte_util_array module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_rte_util_array module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_gas_concentrations module~mo_compute_bc->module~mo_fluxes module~mo_rte_sw mo_rte_sw module~mo_compute_bc->module~mo_rte_sw module~mo_compute_bc->module~mo_optical_props module~mo_gas_optics mo_gas_optics module~mo_compute_bc->module~mo_gas_optics module~mo_compute_bc->module~mo_source_functions module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes->module~mo_optical_props module~mo_rte_sw->module~mo_rte_util_array module~mo_rte_sw->module~mo_fluxes module~mo_rte_sw->module~mo_optical_props module~mo_optical_props->module~mo_rte_util_array module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_rte_util_array module~mo_gas_optics_rrtmgp->module~mo_gas_concentrations module~mo_gas_optics_rrtmgp->module~mo_optical_props module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_source_functions module~mo_heating_rates mo_heating_rates module~mo_heating_rates->module~mo_rte_util_array module~mo_cloud_optics mo_cloud_optics module~mo_cloud_optics->module~mo_rte_util_array module~mo_cloud_optics->module~mo_optical_props module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_fluxes_bygpoint->module~mo_rte_util_array module~mo_fluxes_bygpoint->module~mo_fluxes module~mo_fluxes_bygpoint->module~mo_optical_props module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_gas_concentrations module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw module~mo_rrtmgp_clr_all_sky->module~mo_optical_props module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_rrtmgp_clr_all_sky->module~mo_source_functions module~mo_cloud_sampling mo_cloud_sampling module~mo_cloud_sampling->module~mo_optical_props module~mo_gas_optics->module~mo_gas_concentrations module~mo_gas_optics->module~mo_optical_props module~mo_gas_optics->module~mo_source_functions module~mo_source_functions->module~mo_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces any_vals_less_than any_vals_outside extents_are zero_array Interfaces public interface any_vals_less_than private function any_vals_less_than_1D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_2D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_3D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_1D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array logical(kind=wl), intent(in), dimension(:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_2D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array logical(kind=wl), intent(in), dimension(:,:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_3D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array logical(kind=wl), intent(in), dimension(:,:,:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical public interface any_vals_outside private function any_vals_outside_1D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_2D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_3D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_1D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array logical(kind=wl), intent(in), dimension(:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_2D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array logical(kind=wl), intent(in), dimension(:,:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_3D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array logical(kind=wl), intent(in), dimension(:,:,:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical public interface extents_are private function extents_are_1d(array, n1) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:          ) :: array integer, intent(in) :: n1 Return Value logical(kind=wl) private function extents_are_2d(array, n1, n2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:        ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 Return Value logical(kind=wl) private function extents_are_3d(array, n1, n2, n3) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:      ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 Return Value logical(kind=wl) private function extents_are_4d(array, n1, n2, n3, n4) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:    ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 Return Value logical(kind=wl) private function extents_are_5d(array, n1, n2, n3, n4, n5) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:,:  ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 integer, intent(in) :: n5 Return Value logical(kind=wl) private function extents_are_6d(array, n1, n2, n3, n4, n5, n6) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 integer, intent(in) :: n5 integer, intent(in) :: n6 Return Value logical(kind=wl) private function extents_are_2d_int(array, n1, n2) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:        ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 Return Value logical(kind=wl) public interface zero_array private subroutine zero_array_1D(ni, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni real(kind=wp), intent(out), dimension(ni) :: array private subroutine zero_array_2D(ni, nj, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni integer, intent(in) :: nj real(kind=wp), intent(out), dimension(ni, nj) :: array private subroutine zero_array_3D(ni, nj, nk, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni integer, intent(in) :: nj integer, intent(in) :: nk real(kind=wp), intent(out), dimension(ni, nj, nk) :: array private subroutine zero_array_4D(ni, nj, nk, nl, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni integer, intent(in) :: nj integer, intent(in) :: nk integer, intent(in) :: nl real(kind=wp), intent(out), dimension(ni, nj, nk, nl) :: array","tags":"","loc":"module/mo_rte_util_array.html"},{"title":"mo_heating_rates – rte-rrtmgp","text":"Uses mo_rte_kind mo_rte_config mo_rte_util_array mo_rrtmgp_constants module~~mo_heating_rates~~UsesGraph module~mo_heating_rates mo_heating_rates module~mo_rte_config mo_rte_config module~mo_heating_rates->module~mo_rte_config module~mo_rrtmgp_constants mo_rrtmgp_constants module~mo_heating_rates->module~mo_rrtmgp_constants module~mo_rte_util_array mo_rte_util_array module~mo_heating_rates->module~mo_rte_util_array module~mo_rte_kind mo_rte_kind module~mo_heating_rates->module~mo_rte_kind module~mo_rte_config->module~mo_rte_kind module~mo_rrtmgp_constants->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions compute_heating_rate Functions public function compute_heating_rate (flux_up, flux_dn, plev, heating_rate) result(error_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: flux_up real(kind=wp), intent(in), dimension(:,:) :: flux_dn real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(out), dimension(:,:) :: heating_rate Return Value character(len=128)","tags":"","loc":"module/mo_heating_rates.html"},{"title":"mo_compute_bc – rte-rrtmgp","text":"Uses mo_source_functions mo_gas_optics mo_optical_props mo_rte_config mo_rte_util_array mo_fluxes mo_rte_kind mo_rte_lw mo_rte_sw mo_gas_concentrations module~~mo_compute_bc~~UsesGraph module~mo_compute_bc mo_compute_bc module~mo_rte_lw mo_rte_lw module~mo_compute_bc->module~mo_rte_lw module~mo_gas_optics mo_gas_optics module~mo_compute_bc->module~mo_gas_optics module~mo_gas_concentrations mo_gas_concentrations module~mo_compute_bc->module~mo_gas_concentrations module~mo_rte_util_array mo_rte_util_array module~mo_compute_bc->module~mo_rte_util_array module~mo_fluxes mo_fluxes module~mo_compute_bc->module~mo_fluxes module~mo_source_functions mo_source_functions module~mo_compute_bc->module~mo_source_functions module~mo_optical_props mo_optical_props module~mo_compute_bc->module~mo_optical_props module~mo_rte_sw mo_rte_sw module~mo_compute_bc->module~mo_rte_sw module~mo_rte_config mo_rte_config module~mo_compute_bc->module~mo_rte_config module~mo_rte_kind mo_rte_kind module~mo_compute_bc->module~mo_rte_kind module~mo_rte_lw->module~mo_rte_util_array module~mo_rte_lw->module~mo_fluxes module~mo_rte_lw->module~mo_source_functions module~mo_rte_lw->module~mo_optical_props module~mo_rte_lw->module~mo_rte_config module~mo_rte_lw->module~mo_rte_kind mo_rte_solver_kernels mo_rte_solver_kernels module~mo_rte_lw->mo_rte_solver_kernels module~mo_gas_optics->module~mo_gas_concentrations module~mo_gas_optics->module~mo_source_functions module~mo_gas_optics->module~mo_optical_props module~mo_gas_optics->module~mo_rte_kind module~mo_gas_concentrations->module~mo_rte_util_array module~mo_gas_concentrations->module~mo_rte_config module~mo_gas_concentrations->module~mo_rte_kind module~mo_rrtmgp_util_string mo_rrtmgp_util_string module~mo_gas_concentrations->module~mo_rrtmgp_util_string module~mo_rte_util_array->module~mo_rte_kind module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_config module~mo_fluxes->module~mo_rte_kind mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->mo_fluxes_broadband_kernels module~mo_source_functions->module~mo_optical_props module~mo_source_functions->module~mo_rte_kind module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_kind mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_rte_sw->module~mo_rte_util_array module~mo_rte_sw->module~mo_fluxes module~mo_rte_sw->module~mo_optical_props module~mo_rte_sw->module~mo_rte_config module~mo_rte_sw->module~mo_rte_kind module~mo_rte_sw->mo_rte_solver_kernels module~mo_rte_config->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_fluxes_1lev Functions compute_bc Derived Types type, public, extends( ty_fluxes ) :: ty_fluxes_1lev Type-Bound Procedures procedure, public :: are_desired => are_desired_1lev procedure, public :: reduce => reduce_1lev Functions public function compute_bc (k_dist, play, plev, tlay, gas_concs, flux_bc, mu0) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: k_dist real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_concs real(kind=wp), intent(out), dimension(:,:), target :: flux_bc real(kind=wp), intent(in), optional dimension(:) :: mu0 Return Value character(len=128)","tags":"","loc":"module/mo_compute_bc.html"},{"title":"mo_rrtmgp_clr_all_sky – rte-rrtmgp","text":"Uses mo_source_functions mo_gas_optics mo_optical_props mo_fluxes mo_rte_kind mo_rte_lw mo_rte_sw mo_gas_concentrations module~~mo_rrtmgp_clr_all_sky~~UsesGraph module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rte_lw mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_gas_concentrations mo_gas_concentrations module~mo_rrtmgp_clr_all_sky->module~mo_gas_concentrations module~mo_rte_kind mo_rte_kind module~mo_rrtmgp_clr_all_sky->module~mo_rte_kind module~mo_fluxes mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_source_functions mo_source_functions module~mo_rrtmgp_clr_all_sky->module~mo_source_functions module~mo_optical_props mo_optical_props module~mo_rrtmgp_clr_all_sky->module~mo_optical_props module~mo_rte_sw mo_rte_sw module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw module~mo_gas_optics mo_gas_optics module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_rte_lw->module~mo_rte_kind module~mo_rte_lw->module~mo_fluxes module~mo_rte_lw->module~mo_source_functions module~mo_rte_lw->module~mo_optical_props mo_rte_solver_kernels mo_rte_solver_kernels module~mo_rte_lw->mo_rte_solver_kernels module~mo_rte_util_array mo_rte_util_array module~mo_rte_lw->module~mo_rte_util_array module~mo_rte_config mo_rte_config module~mo_rte_lw->module~mo_rte_config module~mo_gas_concentrations->module~mo_rte_kind module~mo_gas_concentrations->module~mo_rte_util_array module~mo_gas_concentrations->module~mo_rte_config module~mo_rrtmgp_util_string mo_rrtmgp_util_string module~mo_gas_concentrations->module~mo_rrtmgp_util_string iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_fluxes->module~mo_rte_kind module~mo_fluxes->module~mo_optical_props mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->mo_fluxes_broadband_kernels module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes->module~mo_rte_config module~mo_source_functions->module~mo_rte_kind module~mo_source_functions->module~mo_optical_props module~mo_optical_props->module~mo_rte_kind mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_config module~mo_rte_sw->module~mo_rte_kind module~mo_rte_sw->module~mo_fluxes module~mo_rte_sw->module~mo_optical_props module~mo_rte_sw->mo_rte_solver_kernels module~mo_rte_sw->module~mo_rte_util_array module~mo_rte_sw->module~mo_rte_config module~mo_gas_optics->module~mo_gas_concentrations module~mo_gas_optics->module~mo_rte_kind module~mo_gas_optics->module~mo_source_functions module~mo_gas_optics->module~mo_optical_props module~mo_rte_util_array->module~mo_rte_kind module~mo_rte_config->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions rte_lw rte_sw Functions public function rte_lw (k_dist, gas_concs, p_lay, t_lay, p_lev, t_sfc, sfc_emis, cloud_props, allsky_fluxes, clrsky_fluxes, aer_props, col_dry, t_lev, inc_flux, n_gauss_angles) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: k_dist type( ty_gas_concs ), intent(in) :: gas_concs real(kind=wp), intent(in), dimension(:,:) :: p_lay real(kind=wp), intent(in), dimension(:,:) :: t_lay real(kind=wp), intent(in), dimension(:,:) :: p_lev real(kind=wp), intent(in), dimension(:) :: t_sfc real(kind=wp), intent(in), dimension(:,:) :: sfc_emis class( ty_optical_props_arry ), intent(in) :: cloud_props class( ty_fluxes ), intent(inout) :: allsky_fluxes class( ty_fluxes ), intent(inout) :: clrsky_fluxes class( ty_optical_props_arry ), intent(in), optional :: aer_props real(kind=wp), intent(in), optional dimension(:,:) :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: t_lev real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux integer, intent(in), optional :: n_gauss_angles Return Value character(len=128) public function rte_sw (k_dist, gas_concs, p_lay, t_lay, p_lev, mu0, sfc_alb_dir, sfc_alb_dif, cloud_props, allsky_fluxes, clrsky_fluxes, aer_props, col_dry, inc_flux) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: k_dist type( ty_gas_concs ), intent(in) :: gas_concs real(kind=wp), intent(in), dimension(:,:) :: p_lay real(kind=wp), intent(in), dimension(:,:) :: t_lay real(kind=wp), intent(in), dimension(:,:) :: p_lev real(kind=wp), intent(in), dimension(:  ) :: mu0 real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dir real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dif class( ty_optical_props_arry ), intent(in) :: cloud_props class( ty_fluxes ), intent(inout) :: allsky_fluxes class( ty_fluxes ), intent(inout) :: clrsky_fluxes class( ty_optical_props_arry ), intent(in), optional target :: aer_props real(kind=wp), intent(in), optional dimension(:,:) :: col_dry real(kind=wp), intent(in), optional dimension(:,:) :: inc_flux Return Value character(len=128)","tags":"","loc":"module/mo_rrtmgp_clr_all_sky.html"},{"title":"mo_fluxes_byband – rte-rrtmgp","text":"Uses mo_optical_props mo_rte_config mo_rte_util_array mo_rte_kind mo_fluxes module~~mo_fluxes_byband~~UsesGraph module~mo_fluxes_byband mo_fluxes_byband module~mo_rte_util_array mo_rte_util_array module~mo_fluxes_byband->module~mo_rte_util_array module~mo_fluxes mo_fluxes module~mo_fluxes_byband->module~mo_fluxes module~mo_optical_props mo_optical_props module~mo_fluxes_byband->module~mo_optical_props module~mo_rte_config mo_rte_config module~mo_fluxes_byband->module~mo_rte_config module~mo_rte_kind mo_rte_kind module~mo_fluxes_byband->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_config module~mo_fluxes->module~mo_rte_kind mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->mo_fluxes_broadband_kernels module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_kind mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_rte_config->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces net_byband Derived Types ty_fluxes_byband Functions are_desired_byband reduce_byband Subroutines net_byband_full net_byband_precalc sum_byband Interfaces public interface net_byband public subroutine net_byband_full (ncol, nlev, ngpt, nbnd, band_lims, spectral_flux_dn, spectral_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt integer, intent(in) :: nbnd integer, intent(in), dimension(2,          nbnd) :: band_lims real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net public subroutine net_byband_precalc (ncol, nlev, nbnd, byband_flux_dn, byband_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: nbnd real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net Derived Types type, public, extends( ty_fluxes_broadband ) :: ty_fluxes_byband Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_dn => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_dn_dir => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_net => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_up => NULL() Type-Bound Procedures procedure, public :: are_desired => are_desired_byband procedure, public :: reduce => reduce_byband Functions public function are_desired_byband (this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_byband ), intent(in) :: this Return Value logical public function reduce_byband (this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_byband ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128) Subroutines public subroutine net_byband_full (ncol, nlev, ngpt, nbnd, band_lims, spectral_flux_dn, spectral_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt integer, intent(in) :: nbnd integer, intent(in), dimension(2,          nbnd) :: band_lims real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net public subroutine net_byband_precalc (ncol, nlev, nbnd, byband_flux_dn, byband_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: nbnd real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net public subroutine sum_byband (ncol, nlev, ngpt, nbnd, band_lims, spectral_flux, byband_flux) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt integer, intent(in) :: nbnd integer, intent(in), dimension(2,          nbnd) :: band_lims real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux","tags":"","loc":"module/mo_fluxes_byband.html"},{"title":"mo_fluxes_bygpoint – rte-rrtmgp","text":"Uses mo_rte_kind mo_rte_util_array mo_optical_props mo_fluxes module~~mo_fluxes_bygpoint~~UsesGraph module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_rte_kind mo_rte_kind module~mo_fluxes_bygpoint->module~mo_rte_kind module~mo_rte_util_array mo_rte_util_array module~mo_fluxes_bygpoint->module~mo_rte_util_array module~mo_optical_props mo_optical_props module~mo_fluxes_bygpoint->module~mo_optical_props module~mo_fluxes mo_fluxes module~mo_fluxes_bygpoint->module~mo_fluxes iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_rte_util_array->module~mo_rte_kind module~mo_optical_props->module~mo_rte_kind module~mo_optical_props->module~mo_rte_util_array mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_rte_config mo_rte_config module~mo_optical_props->module~mo_rte_config module~mo_fluxes->module~mo_rte_kind module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_config mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->mo_fluxes_broadband_kernels module~mo_rte_config->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_fluxes_bygpoint Functions are_desired_bygpoint reduce_bygpoint Derived Types type, public, extends( ty_fluxes ) :: ty_fluxes_bygpoint Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_dn => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_dn_dir => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_net => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_up => NULL() Type-Bound Procedures procedure, public :: are_desired => are_desired_bygpoint procedure, public :: reduce => reduce_bygpoint Functions public function are_desired_bygpoint (this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_bygpoint ), intent(in) :: this Return Value logical public function reduce_bygpoint (this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_bygpoint ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"module/mo_fluxes_bygpoint.html"},{"title":"mo_solar_variability – rte-rrtmgp","text":"Uses mo_rte_kind module~~mo_solar_variability~~UsesGraph module~mo_solar_variability mo_solar_variability module~mo_rte_kind mo_rte_kind module~mo_solar_variability->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_solar_var Derived Types type, public :: ty_solar_var Type-Bound Procedures procedure, public :: finalize procedure, public :: load procedure, public :: solar_var_ind_interp","tags":"","loc":"module/mo_solar_variability.html"},{"title":"mo_cloud_sampling – rte-rrtmgp","text":"Uses mo_rte_kind mo_optical_props module~~mo_cloud_sampling~~UsesGraph module~mo_cloud_sampling mo_cloud_sampling module~mo_rte_kind mo_rte_kind module~mo_cloud_sampling->module~mo_rte_kind module~mo_optical_props mo_optical_props module~mo_cloud_sampling->module~mo_optical_props iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_optical_props->module~mo_rte_kind mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_rte_config mo_rte_config module~mo_optical_props->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_optical_props->module~mo_rte_util_array module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions draw_samples sampled_mask_exp_ran sampled_mask_max_ran Functions public function draw_samples (cloud_mask, clouds, clouds_sampled) result(error_msg) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:,:) :: cloud_mask class( ty_optical_props_arry ), intent(in) :: clouds class( ty_optical_props_arry ), intent(inout) :: clouds_sampled Return Value character(len=128) public function sampled_mask_exp_ran (randoms, cloud_frac, overlap_param, cloud_mask) result(error_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: randoms real(kind=wp), intent(in), dimension(:,:) :: cloud_frac real(kind=wp), intent(in), dimension(:,:) :: overlap_param logical, intent(out), dimension(:,:,:) :: cloud_mask Return Value character(len=128) public function sampled_mask_max_ran (randoms, cloud_frac, cloud_mask) result(error_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: randoms real(kind=wp), intent(in), dimension(:,:) :: cloud_frac logical, intent(out), dimension(:,:,:) :: cloud_mask Return Value character(len=128)","tags":"","loc":"module/mo_cloud_sampling.html"},{"title":"mo_cloud_optics – rte-rrtmgp","text":"Uses mo_rte_kind mo_rte_config mo_rte_util_array mo_optical_props module~~mo_cloud_optics~~UsesGraph module~mo_cloud_optics mo_cloud_optics module~mo_rte_config mo_rte_config module~mo_cloud_optics->module~mo_rte_config module~mo_rte_kind mo_rte_kind module~mo_cloud_optics->module~mo_rte_kind module~mo_rte_util_array mo_rte_util_array module~mo_cloud_optics->module~mo_rte_util_array module~mo_optical_props mo_optical_props module~mo_cloud_optics->module~mo_optical_props module~mo_rte_config->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_rte_util_array->module~mo_rte_kind module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_kind module~mo_optical_props->module~mo_rte_util_array mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pade_eval Derived Types ty_cloud_optics Interfaces public interface pade_eval private function pade_eval_nbnd(nbnd, nrads, m, n, irad, re, pade_coeffs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nbnd integer, intent(in) :: nrads integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: irad real(kind=wp), intent(in) :: re real(kind=wp), intent(in), dimension(nbnd, nrads, 0:m+n) :: pade_coeffs Return Value real(kind=wp),\n  dimension(nbnd) private function pade_eval_1(iband, nbnd, nrads, m, n, irad, re, pade_coeffs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iband integer, intent(in) :: nbnd integer, intent(in) :: nrads integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: irad real(kind=wp), intent(in) :: re real(kind=wp), intent(in), dimension(nbnd, nrads, 0:m+n) :: pade_coeffs Return Value real(kind=wp) Derived Types type, public, extends( ty_optical_props ) :: ty_cloud_optics Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal procedure, public :: cloud_optics procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_max_radius_ice procedure, public :: get_max_radius_liq procedure, public :: get_min_radius_ice procedure, public :: get_min_radius_liq procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ngpt procedure, public :: get_num_ice_roughness_types procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base generic, public :: load => load_lut, load_pade procedure, public :: set_ice_roughness procedure, public :: set_name","tags":"","loc":"module/mo_cloud_optics.html"},{"title":"Additional Documentation – rte-rrtmgp","text":"This and subsequent pages contain documentation to help new users of Vegetables get started and understand how to use this documentation.\nIt contains a Tutorial , and a more [organized_listing] of the functionality of the framework.","tags":"","loc":"page//index.html"},{"title":"Organized Listing – rte-rrtmgp","text":"Describing and providing links to specific items Describing and providing links to specific items The most involved class structure is in mo_optical_props.F90 . Here we have an  base class ( ty_optical_props ) that defines ~20 type-bound procedures, an abstract sub-class ( ty_optical_props_arry ) that defines three more deferred interfaces, and three sub-classes of ty_optical_props_arry ( ty_optical_props_1scl , ty_optical_props_2str , ty_optical_props_nstr that add new procedures (e.g. init_and_alloc_2str )","tags":"","loc":"page/./Organized_Listing.html"},{"title":"Tutorial – rte-rrtmgp","text":"Prerequisites Getting Started With rte-rrtmgp More Documentation Prerequisites This tutorial assumes that you have working knowledge of, and are comfortable using the following tools: Getting Started With rte-rrtmgp If this is your first encounter with rte-rrtmgp,\nthe following resources might be useful.... With those installed and configured, you should be able to open a terminal and issue the following commands. *Command line example git clone https://github.com/earth-system-radiation/rte-rrtmgp.git\ncd rte-rrtmgp More Documentation You should also read through the organized listing of capabilities to get a more comprehensive view of the available functionality. The organized listing contains a more comprehensive view of the available capabilities an functionality of the code.","tags":"","loc":"page/./Tutorial.html"}]}