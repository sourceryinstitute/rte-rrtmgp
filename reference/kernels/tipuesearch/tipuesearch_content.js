var tipuesearch = {"pages":[{"title":" rte-rrtmgp ","text":"rte-rrtmgp Welcome to the rte-rrtmgp developer documentation. How to Read This Documentation Start with the README and the Tutorial .\nAdditionally, there is a page that provides a higher level organizational overview that you can find here . The listings below are not exhaustive.\nTo see the full listings use the links at the top of the page.\nAlso, if you know what you're looking for, there is a search bar in the top right. Take me back to the User Documentation .","tags":"home","loc":"index.html"},{"title":"mo_rrtmgp_util_reorder_kernels.F90 – rte-rrtmgp","text":"Contents Modules mo_rrtmgp_util_reorder_kernels Source Code mo_rrtmgp_util_reorder_kernels.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! Description: Kernels to permute arrays module mo_rrtmgp_util_reorder_kernels use mo_rte_kind , only : wp implicit none public contains ! ---------------------------------------------------------------------------- subroutine reorder_123x321_kernel ( d1 , d2 , d3 , array_in , array_out ) & bind ( C , name = \"reorder_123x321_kernel\" ) integer , intent ( in ) :: d1 , d2 , d3 real ( wp ), dimension ( d1 , d2 , d3 ), intent ( in ) :: array_in real ( wp ), dimension ( d3 , d2 , d1 ), intent ( out ) :: array_out integer :: i1 , i2 , i3 , i10 , i30 , i1diff , i3diff integer , parameter :: tile = 32 ! This kernel uses blocking to speed-up the transposition ! We read the data block by block (three outer loops) !  such that a block fits into fastest cache and the memory reads !  are resolved in the cache. The writes are contiguous here, so !  shouldn't be a problem. !  Tile size of 32x32 is empirical: big enough to read from the whole !  cache line, and small enough to fit into cache. Other numbers !  may give slightly better performance on different hardware. ! !$acc parallel vector_length(tile*tile) & !$acc&     copyout(array_out) & !$acc&     copyin(array_in) !$acc loop gang collapse(3) ! private(cache(:,:)) !$omp target teams distribute parallel do simd collapse(3) map(to:array_in) map(from:array_out) do i2 = 1 , d2 do i10 = 1 , d1 , tile do i30 = 1 , d3 , tile !$acc loop vector collapse(2) do i1diff = 0 , tile - 1 do i3diff = 0 , tile - 1 i1 = i10 + i1diff i3 = i30 + i3diff if ( i1 > d1 . or . i3 > d3 ) cycle array_out ( i3 , i2 , i1 ) = array_in ( i1 , i2 , i3 ) end do end do end do end do end do !$acc end parallel end subroutine reorder_123x321_kernel ! ---------------------------------------------------------------------------- end module mo_rrtmgp_util_reorder_kernels","tags":"","loc":"sourcefile/mo_rrtmgp_util_reorder_kernels.f90.html"},{"title":"mo_gas_optics_kernels.F90 – rte-rrtmgp","text":"Contents Modules mo_gas_optics_kernels Source Code mo_gas_optics_kernels.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2015,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! Description: Numeric calculations for gas optics. Absorption and Rayleigh optical depths, !   source functions. module mo_gas_optics_kernels use mo_rte_kind , only : wp , wl use mo_rte_util_array , only : zero_array implicit none public contains ! -------------------------------------------------------------------------------------- ! Compute interpolation coefficients ! for calculations of major optical depths, minor optical depths, Rayleigh, ! and Planck fractions subroutine interpolation ( & ncol , nlay , ngas , nflav , neta , npres , ntemp , & flavor , & press_ref_log , temp_ref , press_ref_log_delta , & temp_ref_min , temp_ref_delta , press_ref_trop_log , & vmr_ref , & play , tlay , col_gas , & jtemp , fmajor , fminor , col_mix , tropo , jeta , jpress ) bind ( C , name = \"interpolation\" ) ! input dimensions integer , intent ( in ) :: ncol , nlay integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , dimension ( 2 , nflav ), intent ( in ) :: flavor real ( wp ), dimension ( npres ), intent ( in ) :: press_ref_log real ( wp ), dimension ( ntemp ), intent ( in ) :: temp_ref real ( wp ), intent ( in ) :: press_ref_log_delta , & temp_ref_min , temp_ref_delta , & press_ref_trop_log real ( wp ), dimension ( 2 , 0 : ngas , ntemp ), intent ( in ) :: vmr_ref ! inputs from profile or parent function real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas ! outputs integer , dimension ( ncol , nlay ), intent ( out ) :: jtemp , jpress logical ( wl ), dimension ( ncol , nlay ), intent ( out ) :: tropo integer , dimension ( 2 , ncol , nlay , nflav ), intent ( out ) :: jeta real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( out ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( out ) :: fmajor real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( out ) :: fminor ! ----------------- ! local real ( wp ), dimension ( ncol , nlay ) :: ftemp , fpress ! interpolation fraction for temperature, pressure real ( wp ) :: locpress ! needed to find location in pressure grid real ( wp ) :: ratio_eta_half ! ratio of vmrs of major species that defines eta=0.5 ! for given flavor and reference temperature level real ( wp ) :: eta , feta ! binary_species_parameter, interpolation variable for eta real ( wp ) :: loceta ! needed to find location in eta grid real ( wp ) :: ftemp_term ! ----------------- ! local indexes integer :: icol , ilay , iflav , igases ( 2 ), itropo , itemp do ilay = 1 , nlay do icol = 1 , ncol ! index and factor for temperature interpolation jtemp ( icol , ilay ) = int (( tlay ( icol , ilay ) - ( temp_ref_min - temp_ref_delta )) / temp_ref_delta ) jtemp ( icol , ilay ) = min ( ntemp - 1 , max ( 1 , jtemp ( icol , ilay ))) ! limit the index range ftemp ( icol , ilay ) = ( tlay ( icol , ilay ) - temp_ref ( jtemp ( icol , ilay ))) / temp_ref_delta ! index and factor for pressure interpolation locpress = 1._wp + ( log ( play ( icol , ilay )) - press_ref_log ( 1 )) / press_ref_log_delta jpress ( icol , ilay ) = min ( npres - 1 , max ( 1 , int ( locpress ))) fpress ( icol , ilay ) = locpress - float ( jpress ( icol , ilay )) ! determine if in lower or upper part of atmosphere tropo ( icol , ilay ) = log ( play ( icol , ilay )) > press_ref_trop_log end do end do do iflav = 1 , nflav igases (:) = flavor (:, iflav ) do ilay = 1 , nlay do icol = 1 , ncol ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! loop over implemented combinations of major species do itemp = 1 , 2 ! compute interpolation fractions needed for lower, then upper reference temperature level ! compute binary species parameter (eta) for flavor and temperature and !  associated interpolation index and factors ratio_eta_half = vmr_ref ( itropo , igases ( 1 ),( jtemp ( icol , ilay ) + itemp - 1 )) / & vmr_ref ( itropo , igases ( 2 ),( jtemp ( icol , ilay ) + itemp - 1 )) col_mix ( itemp , icol , ilay , iflav ) = col_gas ( icol , ilay , igases ( 1 )) + ratio_eta_half * col_gas ( icol , ilay , igases ( 2 )) eta = merge ( col_gas ( icol , ilay , igases ( 1 )) / col_mix ( itemp , icol , ilay , iflav ), 0.5_wp , & col_mix ( itemp , icol , ilay , iflav ) > 2._wp * tiny ( col_mix )) loceta = eta * float ( neta - 1 ) jeta ( itemp , icol , ilay , iflav ) = min ( int ( loceta ) + 1 , neta - 1 ) feta = mod ( loceta , 1.0_wp ) ! compute interpolation fractions needed for minor species ! ftemp_term = (1._wp-ftemp(icol,ilay)) for itemp = 1, ftemp(icol,ilay) for itemp=2 ftemp_term = ( real ( 2 - itemp , wp ) + real ( 2 * itemp - 3 , wp ) * ftemp ( icol , ilay )) fminor ( 1 , itemp , icol , ilay , iflav ) = ( 1._wp - feta ) * ftemp_term fminor ( 2 , itemp , icol , ilay , iflav ) = feta * ftemp_term ! compute interpolation fractions needed for major species fmajor ( 1 , 1 , itemp , icol , ilay , iflav ) = ( 1._wp - fpress ( icol , ilay )) * fminor ( 1 , itemp , icol , ilay , iflav ) fmajor ( 2 , 1 , itemp , icol , ilay , iflav ) = ( 1._wp - fpress ( icol , ilay )) * fminor ( 2 , itemp , icol , ilay , iflav ) fmajor ( 1 , 2 , itemp , icol , ilay , iflav ) = fpress ( icol , ilay ) * fminor ( 1 , itemp , icol , ilay , iflav ) fmajor ( 2 , 2 , itemp , icol , ilay , iflav ) = fpress ( icol , ilay ) * fminor ( 2 , itemp , icol , ilay , iflav ) end do ! reference temperatures end do ! icol end do ! ilay end do ! iflav end subroutine interpolation ! -------------------------------------------------------------------------------------- ! ! Compute minor and major species opitcal depth from pre-computed interpolation coefficients !   (jeta,jtemp,jpress) ! subroutine compute_tau_absorption ( & ncol , nlay , nbnd , ngpt , & ! dimensions ngas , nflav , neta , npres , ntemp , & nminorlower , nminorklower , & ! number of minor contributors, total num absorption coeffs nminorupper , nminorkupper , & idx_h2o , & gpoint_flavor , & band_lims_gpt , & kmajor , & kminor_lower , & kminor_upper , & minor_limits_gpt_lower , & minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scale_by_complement_lower , & scale_by_complement_upper , & idx_minor_lower , & idx_minor_upper , & idx_minor_scaling_lower , & idx_minor_scaling_upper , & kminor_start_lower , & kminor_start_upper , & tropo , & col_mix , fmajor , fminor , & play , tlay , col_gas , & jeta , jtemp , jpress , & tau ) bind ( C , name = \"compute_tau_absorption\" ) ! --------------------- ! input dimensions integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , intent ( in ) :: nminorlower , nminorklower , nminorupper , nminorkupper integer , intent ( in ) :: idx_h2o ! --------------------- ! inputs from object integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: kmajor real ( wp ), dimension ( ntemp , neta , nminorklower ), intent ( in ) :: kminor_lower real ( wp ), dimension ( ntemp , neta , nminorkupper ), intent ( in ) :: kminor_upper integer , dimension ( 2 , nminorlower ), intent ( in ) :: minor_limits_gpt_lower integer , dimension ( 2 , nminorupper ), intent ( in ) :: minor_limits_gpt_upper logical ( wl ), dimension ( nminorlower ), intent ( in ) :: minor_scales_with_density_lower logical ( wl ), dimension ( nminorupper ), intent ( in ) :: minor_scales_with_density_upper logical ( wl ), dimension ( nminorlower ), intent ( in ) :: scale_by_complement_lower logical ( wl ), dimension ( nminorupper ), intent ( in ) :: scale_by_complement_upper integer , dimension ( nminorlower ), intent ( in ) :: idx_minor_lower integer , dimension ( nminorupper ), intent ( in ) :: idx_minor_upper integer , dimension ( nminorlower ), intent ( in ) :: idx_minor_scaling_lower integer , dimension ( nminorupper ), intent ( in ) :: idx_minor_scaling_upper integer , dimension ( nminorlower ), intent ( in ) :: kminor_start_lower integer , dimension ( nminorupper ), intent ( in ) :: kminor_start_upper logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo ! --------------------- ! inputs from profile or parent function real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay ! pressure and temperature real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp integer , dimension ( ncol , nlay ), intent ( in ) :: jpress ! --------------------- ! output - optical depth real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! --------------------- ! Local variables ! logical :: top_at_1 integer , dimension ( ncol , 2 ) :: itropo_lower , itropo_upper ! ---------------------------------------------------------------- ! --------------------- ! Layer limits of upper, lower atmospheres ! --------------------- top_at_1 = play ( 1 , 1 ) < play ( 1 , nlay ) if ( top_at_1 ) then itropo_lower (:, 1 ) = minloc ( play , dim = 2 , mask = tropo ) itropo_lower (:, 2 ) = nlay itropo_upper (:, 1 ) = 1 itropo_upper (:, 2 ) = maxloc ( play , dim = 2 , mask = (. not . tropo )) else itropo_lower (:, 1 ) = 1 itropo_lower (:, 2 ) = minloc ( play , dim = 2 , mask = tropo ) itropo_upper (:, 1 ) = maxloc ( play , dim = 2 , mask = (. not . tropo )) itropo_upper (:, 2 ) = nlay end if ! --------------------- ! Major Species ! --------------------- call gas_optical_depths_major ( & ncol , nlay , nbnd , ngpt , & ! dimensions nflav , neta , npres , ntemp , & gpoint_flavor , & band_lims_gpt , & kmajor , & col_mix , fmajor , & jeta , tropo , jtemp , jpress , & tau ) ! --------------------- ! Minor Species - lower ! --------------------- call gas_optical_depths_minor ( & ncol , nlay , ngpt , & ! dimensions ngas , nflav , ntemp , neta , & nminorlower , nminorklower , & idx_h2o , & gpoint_flavor ( 1 ,:), & kminor_lower , & minor_limits_gpt_lower , & minor_scales_with_density_lower , & scale_by_complement_lower , & idx_minor_lower , & idx_minor_scaling_lower , & kminor_start_lower , & play , tlay , & col_gas , fminor , jeta , & itropo_lower , jtemp , & tau ) ! --------------------- ! Minor Species - upper ! --------------------- call gas_optical_depths_minor ( & ncol , nlay , ngpt , & ! dimensions ngas , nflav , ntemp , neta , & nminorupper , nminorkupper , & idx_h2o , & gpoint_flavor ( 2 ,:), & kminor_upper , & minor_limits_gpt_upper , & minor_scales_with_density_upper , & scale_by_complement_upper , & idx_minor_upper , & idx_minor_scaling_upper , & kminor_start_upper , & play , tlay , & col_gas , fminor , jeta , & itropo_upper , jtemp , & tau ) end subroutine compute_tau_absorption ! -------------------------------------------------------------------------------------- ! -------------------------------------------------------------------------------------- ! ! compute minor species optical depths ! subroutine gas_optical_depths_major ( ncol , nlay , nbnd , ngpt ,& nflav , neta , npres , ntemp , & ! dimensions gpoint_flavor , band_lims_gpt , & ! inputs from object kmajor , & col_mix , fmajor , & jeta , tropo , jtemp , jpress , & ! local input tau ) bind ( C , name = \"gas_optical_depths_major\" ) ! input dimensions integer , intent ( in ) :: ncol , nlay , nbnd , ngpt , nflav , neta , npres , ntemp ! dimensions ! inputs from object integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: kmajor ! inputs from profile or parent function real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress ! outputs real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! ----------------- ! local variables real ( wp ) :: tau_major ( ngpt ) ! major species optical depth ! local index integer :: icol , ilay , iflav , ibnd , itropo integer :: gptS , gptE ! optical depth calculation for major species do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) iflav = gpoint_flavor ( itropo , gptS ) !eta interpolation depends on band's flavor tau_major ( gptS : gptE ) = & ! interpolation in temperature, pressure, and eta interpolate3D_byflav ( col_mix (:, icol , ilay , iflav ), & fmajor (:,:,:, icol , ilay , iflav ), kmajor , & band_lims_gpt ( 1 , ibnd ), band_lims_gpt ( 2 , ibnd ), & jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay ), jpress ( icol , ilay ) + itropo ) tau ( icol , ilay , gptS : gptE ) = tau ( icol , ilay , gptS : gptE ) + tau_major ( gptS : gptE ) end do end do end do end subroutine gas_optical_depths_major ! ---------------------------------------------------------- ! ! compute minor species optical depths ! subroutine gas_optical_depths_minor ( ncol , nlay , ngpt , & ngas , nflav , ntemp , neta , & nminor , nminork , & idx_h2o , & gpt_flv , & kminor , & minor_limits_gpt , & minor_scales_with_density , & scale_by_complement , & idx_minor , idx_minor_scaling , & kminor_start , & play , tlay , & col_gas , fminor , jeta , & layer_limits , jtemp , & tau ) bind ( C , name = \"gas_optical_depths_minor\" ) integer , intent ( in ) :: ncol , nlay , ngpt integer , intent ( in ) :: ngas , nflav integer , intent ( in ) :: ntemp , neta , nminor , nminork integer , intent ( in ) :: idx_h2o integer , dimension ( ngpt ), intent ( in ) :: gpt_flv real ( wp ), dimension ( ntemp , neta , nminork ), intent ( in ) :: kminor integer , dimension ( 2 , nminor ), intent ( in ) :: minor_limits_gpt logical ( wl ), dimension ( nminor ), intent ( in ) :: minor_scales_with_density logical ( wl ), dimension ( nminor ), intent ( in ) :: scale_by_complement integer , dimension ( nminor ), intent ( in ) :: kminor_start integer , dimension ( nminor ), intent ( in ) :: idx_minor , idx_minor_scaling real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta integer , dimension ( ncol , 2 ), intent ( in ) :: layer_limits integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! ----------------- ! local variables real ( wp ), parameter :: PaTohPa = 0.01_wp real ( wp ) :: vmr_fact , dry_fact ! conversion from column abundance to dry vol. mixing ratio; real ( wp ) :: scaling ! optical depth integer :: icol , ilay , iflav , imnr integer :: gptS , gptE real ( wp ), dimension ( ngpt ) :: tau_minor ! ----------------- ! ! Guard against layer limits being 0 -- that means don't do anything i.e. there are no !   layers with pressures in the upper or lower atmosphere respectively ! First check skips the routine entirely if all columns are out of bounds... ! if ( any ( layer_limits (:, 1 ) > 0 )) then do imnr = 1 , size ( scale_by_complement , dim = 1 ) ! loop over minor absorbers in each band do icol = 1 , ncol ! ! This check skips individual columns with no pressures in range ! if ( layer_limits ( icol , 1 ) > 0 ) then do ilay = layer_limits ( icol , 1 ), layer_limits ( icol , 2 ) ! ! Scaling of minor gas absortion coefficient begins with column amount of minor gas ! scaling = col_gas ( icol , ilay , idx_minor ( imnr )) ! ! Density scaling (e.g. for h2o continuum, collision-induced absorption) ! if ( minor_scales_with_density ( imnr )) then ! ! NOTE: P needed in hPa to properly handle density scaling. ! scaling = scaling * ( PaTohPa * play ( icol , ilay ) / tlay ( icol , ilay )) if ( idx_minor_scaling ( imnr ) > 0 ) then ! there is a second gas that affects this gas's absorption vmr_fact = 1._wp / col_gas ( icol , ilay , 0 ) dry_fact = 1._wp / ( 1._wp + col_gas ( icol , ilay , idx_h2o ) * vmr_fact ) ! scale by density of special gas if ( scale_by_complement ( imnr )) then ! scale by densities of all gases but the special one scaling = scaling * ( 1._wp - col_gas ( icol , ilay , idx_minor_scaling ( imnr )) * vmr_fact * dry_fact ) else scaling = scaling * ( col_gas ( icol , ilay , idx_minor_scaling ( imnr )) * vmr_fact * dry_fact ) endif endif endif ! ! Interpolation of absorption coefficient and calculation of optical depth ! ! Which gpoint range does this minor gas affect? gptS = minor_limits_gpt ( 1 , imnr ) gptE = minor_limits_gpt ( 2 , imnr ) iflav = gpt_flv ( gptS ) tau_minor ( gptS : gptE ) = scaling * & interpolate2D_byflav ( fminor (:,:, icol , ilay , iflav ), & kminor , & kminor_start ( imnr ), kminor_start ( imnr ) + ( gptE - gptS ), & jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay )) tau ( icol , ilay , gptS : gptE ) = tau ( icol , ilay , gptS : gptE ) + tau_minor ( gptS : gptE ) enddo end if enddo enddo end if end subroutine gas_optical_depths_minor ! ---------------------------------------------------------- ! ! compute Rayleigh scattering optical depths ! subroutine compute_tau_rayleigh ( ncol , nlay , nbnd , ngpt , & ngas , nflav , neta , npres , ntemp , & gpoint_flavor , band_lims_gpt , & krayl , & idx_h2o , col_dry , col_gas , & fminor , jeta , tropo , jtemp , & tau_rayleigh ) bind ( C , name = \"compute_tau_rayleigh\" ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), dimension ( ntemp , neta , ngpt , 2 ), intent ( in ) :: krayl integer , intent ( in ) :: idx_h2o real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: col_dry real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp ! outputs real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: tau_rayleigh ! ----------------- ! local variables real ( wp ) :: k ( ngpt ) ! rayleigh scattering coefficient integer :: icol , ilay , iflav , ibnd , gptS , gptE integer :: itropo ! ----------------- do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! itropo = 1 lower atmosphere;itropo = 2 upper atmosphere iflav = gpoint_flavor ( itropo , gptS ) !eta interpolation depends on band's flavor k ( gptS : gptE ) = interpolate2D_byflav ( fminor (:,:, icol , ilay , iflav ), & krayl (:,:,:, itropo ), & gptS , gptE , jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay )) tau_rayleigh ( icol , ilay , gptS : gptE ) = k ( gptS : gptE ) * & ( col_gas ( icol , ilay , idx_h2o ) + col_dry ( icol , ilay )) end do end do end do end subroutine compute_tau_rayleigh ! ---------------------------------------------------------- subroutine compute_Planck_source ( & ncol , nlay , nbnd , ngpt , & nflav , neta , npres , ntemp , nPlanckTemp ,& tlay , tlev , tsfc , sfc_lay , & fmajor , jeta , tropo , jtemp , jpress , & gpoint_bands , band_lims_gpt , & pfracin , temp_ref_min , totplnk_delta , totplnk , gpoint_flavor , & sfc_src , lay_src , lev_src_inc , lev_src_dec , sfc_source_Jac ) bind ( C , name = \"compute_Planck_source\" ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: nflav , neta , npres , ntemp , nPlanckTemp real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: tlay real ( wp ), dimension ( ncol , nlay + 1 ), intent ( in ) :: tlev real ( wp ), dimension ( ncol ), intent ( in ) :: tsfc integer , intent ( in ) :: sfc_lay ! Interpolation variables real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress ! Table-specific integer , dimension ( ngpt ), intent ( in ) :: gpoint_bands ! start and end g-point for each band integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), intent ( in ) :: temp_ref_min , totplnk_delta real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: pfracin real ( wp ), dimension ( nPlanckTemp , nbnd ), intent ( in ) :: totplnk integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: sfc_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: lay_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: lev_src_inc , lev_src_dec real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: sfc_source_Jac ! ----------------- ! local real ( wp ), parameter :: delta_Tsurf = 1.0_wp integer :: ilay , icol , igpt , ibnd , itropo , iflav integer :: gptS , gptE real ( wp ), dimension ( 2 ), parameter :: one = [ 1._wp , 1._wp ] real ( wp ) :: pfrac ( ncol , nlay , ngpt ) real ( wp ) :: planck_function ( ncol , nlay + 1 , nbnd ) ! ----------------- ! Calculation of fraction of band's Planck irradiance associated with each g-point do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) iflav = gpoint_flavor ( itropo , gptS ) !eta interpolation depends on band's flavor pfrac ( icol , ilay , gptS : gptE ) = & ! interpolation in temperature, pressure, and eta interpolate3D_byflav ( one , fmajor (:,:,:, icol , ilay , iflav ), pfracin , & band_lims_gpt ( 1 , ibnd ), band_lims_gpt ( 2 , ibnd ), & jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay ), jpress ( icol , ilay ) + itropo ) end do ! column end do ! layer end do ! band ! ! Planck function by band for the surface ! Compute surface source irradiance for g-point, equals band irradiance x fraction for g-point ! do icol = 1 , ncol planck_function ( icol , 1 , 1 : nbnd ) = interpolate1D ( tsfc ( icol ), temp_ref_min , totplnk_delta , totplnk ) planck_function ( icol , 2 , 1 : nbnd ) = interpolate1D ( tsfc ( icol ) + delta_Tsurf , temp_ref_min , totplnk_delta , totplnk ) ! ! Map to g-points ! do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do igpt = gptS , gptE sfc_src ( icol , igpt ) = pfrac ( icol , sfc_lay , igpt ) * planck_function ( icol , 1 , ibnd ) sfc_source_Jac ( icol , igpt ) = pfrac ( icol , sfc_lay , igpt ) * & ( planck_function ( icol , 2 , ibnd ) - planck_function ( icol , 1 , ibnd )) end do end do end do !icol do ilay = 1 , nlay do icol = 1 , ncol ! Compute layer source irradiance for g-point, equals band irradiance x fraction for g-point planck_function ( icol , ilay , 1 : nbnd ) = interpolate1D ( tlay ( icol , ilay ), temp_ref_min , totplnk_delta , totplnk ) end do end do ! ! Map to g-points ! do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do igpt = gptS , gptE do ilay = 1 , nlay do icol = 1 , ncol lay_src ( icol , ilay , igpt ) = pfrac ( icol , ilay , igpt ) * planck_function ( icol , ilay , ibnd ) end do end do end do end do ! compute level source irradiances for each g-point, one each for upward and downward paths do ilay = 1 , nlay do icol = 1 , ncol planck_function ( icol , 1 , 1 : nbnd ) = interpolate1D ( tlev ( icol , 1 ), temp_ref_min , totplnk_delta , totplnk ) planck_function ( icol , ilay + 1 , 1 : nbnd ) = interpolate1D ( tlev ( icol , ilay + 1 ), temp_ref_min , totplnk_delta , totplnk ) end do end do ! ! Map to g-points ! do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do igpt = gptS , gptE do ilay = 1 , nlay do icol = 1 , ncol lev_src_inc ( icol , ilay , igpt ) = pfrac ( icol , ilay , igpt ) * planck_function ( icol , ilay + 1 , ibnd ) lev_src_dec ( icol , ilay , igpt ) = pfrac ( icol , ilay , igpt ) * planck_function ( icol , ilay , ibnd ) end do end do end do end do end subroutine compute_Planck_source ! ---------------------------------------------------------- ! ! One dimensional interpolation -- return all values along second table dimension ! pure function interpolate1D ( val , offset , delta , table ) result ( res ) ! input real ( wp ), intent ( in ) :: val , & ! axis value at which to evaluate table offset , & ! minimum of table axis delta ! step size of table axis real ( wp ), dimension (:,:), & intent ( in ) :: table ! dimensions (axis, values) ! output real ( wp ), dimension ( size ( table , dim = 2 )) :: res ! local real ( wp ) :: val0 ! fraction index adjusted by offset and delta integer :: index ! index term real ( wp ) :: frac ! fractional term ! ------------------------------------- val0 = ( val - offset ) / delta frac = val0 - int ( val0 ) ! get fractional part index = min ( size ( table , dim = 1 ) - 1 , max ( 1 , int ( val0 ) + 1 )) ! limit the index range res (:) = table ( index ,:) + frac * ( table ( index + 1 ,:) - table ( index ,:)) end function interpolate1D ! ---------------------------------------------------------------------------------------- !   This function returns a single value from a subset (in gpoint) of the k table ! pure function interpolate2D ( fminor , k , igpt , jeta , jtemp ) result ( res ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: fminor ! interpolation fractions for minor species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference temperature level real ( wp ), dimension (:,:,:), intent ( in ) :: k ! (g-point, eta, temp) integer , intent ( in ) :: igpt , jtemp ! interpolation index for temperature integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) real ( wp ) :: res ! the result res = & fminor ( 1 , 1 ) * k ( jtemp , jeta ( 1 ) , igpt ) + & fminor ( 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , igpt ) + & fminor ( 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , igpt ) + & fminor ( 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , igpt ) end function interpolate2D ! ---------------------------------------------------------- !   This function returns a range of values from a subset (in gpoint) of the k table ! pure function interpolate2D_byflav ( fminor , k , gptS , gptE , jeta , jtemp ) result ( res ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: fminor ! interpolation fractions for minor species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference temperature level real ( wp ), dimension (:,:,:), intent ( in ) :: k ! (g-point, eta, temp) integer , intent ( in ) :: gptS , gptE , jtemp ! interpolation index for temperature integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) real ( wp ), dimension ( gptE - gptS + 1 ) :: res ! the result ! Local variable integer :: igpt ! each code block is for a different reference temperature do igpt = 1 , gptE - gptS + 1 res ( igpt ) = fminor ( 1 , 1 ) * k ( jtemp , jeta ( 1 ) , gptS + igpt - 1 ) + & fminor ( 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , gptS + igpt - 1 ) + & fminor ( 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , gptS + igpt - 1 ) + & fminor ( 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , gptS + igpt - 1 ) end do end function interpolate2D_byflav ! ---------------------------------------------------------- ! interpolation in temperature, pressure, and eta pure function interpolate3D ( scaling , fmajor , k , igpt , jeta , jtemp , jpress ) result ( res ) real ( wp ), dimension ( 2 ), intent ( in ) :: scaling real ( wp ), dimension ( 2 , 2 , 2 ), intent ( in ) :: fmajor ! interpolation fractions for major species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference pressure level ! index(3) : reference temperature level real ( wp ), dimension (:,:,:,:), intent ( in ) :: k ! (gpt, eta,temp,press) integer , intent ( in ) :: igpt integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) integer , intent ( in ) :: jtemp ! interpolation index for temperature integer , intent ( in ) :: jpress ! interpolation index for pressure real ( wp ) :: res ! the result ! each code block is for a different reference temperature res = & scaling ( 1 ) * & ( fmajor ( 1 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress , igpt ) ) + & scaling ( 2 ) * & ( fmajor ( 1 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress , igpt ) ) end function interpolate3D ! ---------------------------------------------------------- pure function interpolate3D_byflav ( scaling , fmajor , k , gptS , gptE , jeta , jtemp , jpress ) result ( res ) real ( wp ), dimension ( 2 ), intent ( in ) :: scaling real ( wp ), dimension ( 2 , 2 , 2 ), intent ( in ) :: fmajor ! interpolation fractions for major species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference pressure level ! index(3) : reference temperature level real ( wp ), dimension (:,:,:,:), intent ( in ) :: k ! (temp,eta,press,gpt) integer , intent ( in ) :: gptS , gptE integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) integer , intent ( in ) :: jtemp ! interpolation index for temperature integer , intent ( in ) :: jpress ! interpolation index for pressure real ( wp ), dimension ( gptS : gptE ) :: res ! the result ! Local variable integer :: igpt ! each code block is for a different reference temperature do igpt = gptS , gptE res ( igpt ) = & scaling ( 1 ) * & ( fmajor ( 1 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress , igpt ) ) + & scaling ( 2 ) * & ( fmajor ( 1 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress , igpt ) ) end do end function interpolate3D_byflav end module mo_gas_optics_kernels","tags":"","loc":"sourcefile/mo_gas_optics_kernels.f90.html"},{"title":"mo_fluxes_broadband_kernels.F90 – rte-rrtmgp","text":"Contents Modules mo_fluxes_broadband_kernels Source Code mo_fluxes_broadband_kernels.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Kernels for computing broadband fluxes by summing over all elements in the spectral dimension ! ! ------------------------------------------------------------------------------------------------- module mo_fluxes_broadband_kernels use , intrinsic :: iso_c_binding use mo_rte_kind , only : wp implicit none private public :: sum_broadband , net_broadband interface net_broadband module procedure net_broadband_full , net_broadband_precalc end interface net_broadband contains ! ---------------------------------------------------------------------------- ! ! Spectral reduction over all points ! subroutine sum_broadband ( ncol , nlev , ngpt , spectral_flux , broadband_flux ) bind ( C , name = \"sum_broadband\" ) integer , intent ( in ) :: ncol , nlev , ngpt real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( in ) :: spectral_flux real ( wp ), dimension ( ncol , nlev ), intent ( out ) :: broadband_flux integer :: icol , ilev , igpt real ( wp ) :: bb_flux_s ! local scalar version !$acc enter data copyin(spectral_flux) create(broadband_flux) !$omp target enter data map(to:spectral_flux) map(alloc:broadband_flux) !$acc parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilev = 1 , nlev do icol = 1 , ncol bb_flux_s = 0.0_wp do igpt = 1 , ngpt bb_flux_s = bb_flux_s + spectral_flux ( icol , ilev , igpt ) end do broadband_flux ( icol , ilev ) = bb_flux_s end do end do !$acc exit data delete(spectral_flux) copyout(broadband_flux) !$omp target exit data map(release:spectral_flux) map(from:broadband_flux) end subroutine sum_broadband ! ---------------------------------------------------------------------------- ! ! Net flux: Spectral reduction over all points ! subroutine net_broadband_full ( ncol , nlev , ngpt , spectral_flux_dn , spectral_flux_up , broadband_flux_net ) & bind ( C , name = \"net_broadband_full\" ) integer , intent ( in ) :: ncol , nlev , ngpt real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( in ) :: spectral_flux_dn , spectral_flux_up real ( wp ), dimension ( ncol , nlev ), intent ( out ) :: broadband_flux_net integer :: icol , ilev , igpt real ( wp ) :: diff !$acc enter data copyin(spectral_flux_dn, spectral_flux_up) create(broadband_flux_net) !$omp target enter data map(to:spectral_flux_dn, spectral_flux_up) map(alloc:broadband_flux_net) !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilev = 1 , nlev do icol = 1 , ncol diff = spectral_flux_dn ( icol , ilev , 1 ) - spectral_flux_up ( icol , ilev , 1 ) broadband_flux_net ( icol , ilev ) = diff end do end do !$acc parallel loop collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 2 , ngpt do ilev = 1 , nlev do icol = 1 , ncol diff = spectral_flux_dn ( icol , ilev , igpt ) - spectral_flux_up ( icol , ilev , igpt ) !$acc atomic update !$omp atomic update broadband_flux_net ( icol , ilev ) = broadband_flux_net ( icol , ilev ) + diff end do end do end do !$acc exit data delete(spectral_flux_dn, spectral_flux_up) copyout(broadband_flux_net) !$omp target exit data map(release:spectral_flux_dn, spectral_flux_up) map(from:broadband_flux_net) end subroutine net_broadband_full ! ---------------------------------------------------------------------------- ! ! Net flux when bradband flux up and down are already available ! subroutine net_broadband_precalc ( ncol , nlev , flux_dn , flux_up , broadband_flux_net ) & bind ( C , name = \"net_broadband_precalc\" ) integer , intent ( in ) :: ncol , nlev real ( wp ), dimension ( ncol , nlev ), intent ( in ) :: flux_dn , flux_up real ( wp ), dimension ( ncol , nlev ), intent ( out ) :: broadband_flux_net integer :: icol , ilev !$acc enter data copyin(flux_dn, flux_up) create(broadband_flux_net) !$omp target enter data map(to:flux_dn, flux_up) map(alloc:broadband_flux_net) !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilev = 1 , nlev do icol = 1 , ncol broadband_flux_net ( icol , ilev ) = flux_dn ( icol , ilev ) - flux_up ( icol , ilev ) end do end do !$acc exit data delete(flux_dn, flux_up) copyout(broadband_flux_net) !$omp target exit data map(release:flux_dn, flux_up) map(from:broadband_flux_net) end subroutine net_broadband_precalc ! ---------------------------------------------------------------------------- end module mo_fluxes_broadband_kernels","tags":"","loc":"sourcefile/mo_fluxes_broadband_kernels.f90.html"},{"title":"mo_optical_props_kernels.F90 – rte-rrtmgp","text":"Contents Modules mo_optical_props_kernels Source Code mo_optical_props_kernels.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Kernels for arrays of optical properties: !   delta-scaling !   adding two sets of properties !   extracting subsets !   validity checking ! ! ------------------------------------------------------------------------------------------------- module mo_optical_props_kernels use , intrinsic :: iso_c_binding use mo_rte_kind , only : wp , wl implicit none public interface delta_scale_2str_kernel module procedure delta_scale_2str_f_k , delta_scale_2str_k end interface interface extract_subset module procedure extract_subset_dim1_3d , extract_subset_dim2_4d module procedure extract_subset_absorption_tau end interface extract_subset real ( wp ), parameter , private :: eps = 3.0_wp * tiny ( 1.0_wp ) contains ! ------------------------------------------------------------------------------------------------- ! ! Delta-scaling, provided only for two-stream properties at present ! ! ------------------------------------------------------------------------------------------------- ! Delta-scale two-stream optical properties !   user-provided value of f (forward scattering) ! pure subroutine delta_scale_2str_f_k ( ncol , nlay , ngpt , tau , ssa , g , f ) & bind ( C , name = \"delta_scale_2str_f_k\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau , ssa , g real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: f real ( wp ) :: wf integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol wf = ssa ( icol , ilay , igpt ) * f ( icol , ilay , igpt ) tau ( icol , ilay , igpt ) = ( 1._wp - wf ) * tau ( icol , ilay , igpt ) ssa ( icol , ilay , igpt ) = ( ssa ( icol , ilay , igpt ) - wf ) / max ( eps ,( 1.0_wp - wf )) g ( icol , ilay , igpt ) = ( g ( icol , ilay , igpt ) - f ( icol , ilay , igpt )) / & max ( eps ,( 1._wp - f ( icol , ilay , igpt ))) end do end do end do end subroutine delta_scale_2str_f_k ! --------------------------------- ! Delta-scale !   f = g*g ! pure subroutine delta_scale_2str_k ( ncol , nlay , ngpt , tau , ssa , g ) & bind ( C , name = \"delta_scale_2str_k\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau , ssa , g real ( wp ) :: f , wf integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol f = g ( icol , ilay , igpt ) * g ( icol , ilay , igpt ) wf = ssa ( icol , ilay , igpt ) * f tau ( icol , ilay , igpt ) = ( 1._wp - wf ) * tau ( icol , ilay , igpt ) ssa ( icol , ilay , igpt ) = ( ssa ( icol , ilay , igpt ) - wf ) / max ( eps ,( 1.0_wp - wf )) g ( icol , ilay , igpt ) = ( g ( icol , ilay , igpt ) - f ) / max ( eps ,( 1.0_wp - f )) end do end do end do end subroutine delta_scale_2str_k ! ------------------------------------------------------------------------------------------------- ! ! Addition of optical properties: the first set are incremented by the second set. ! !   There are three possible representations of optical properties (scalar = optical depth only; !   two-stream = tau, single-scattering albedo, and asymmetry factor g, and !   n-stream = tau, ssa, and phase function moments p.) Thus we need nine routines, three for !   each choice of representation on the left hand side times three representations of the !   optical properties to be added. ! !   There are two sets of these nine routines. In the first the two sets of optical !   properties are defined at the same spectral resolution. There is also a set of routines !   to add properties defined at lower spectral resolution to a set defined at higher spectral !   resolution (adding properties defined by band to those defined by g-point) ! ! ------------------------------------------------------------------------------------------------- pure subroutine increment_1scalar_by_1scalar ( ncol , nlay , ngpt , & tau1 , & tau2 ) bind ( C , name = \"increment_1scalar_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) end do end do end do end subroutine increment_1scalar_by_1scalar ! --------------------------------- ! increment 1scalar by 2stream pure subroutine increment_1scalar_by_2stream ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 ) bind ( C , name = \"increment_1scalar_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ( 1._wp - ssa2 ( icol , ilay , igpt )) end do end do end do end subroutine increment_1scalar_by_2stream ! --------------------------------- ! increment 1scalar by nstream pure subroutine increment_1scalar_by_nstream ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 ) bind ( C , name = \"increment_1scalar_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ( 1._wp - ssa2 ( icol , ilay , igpt )) end do end do end do end subroutine increment_1scalar_by_nstream ! --------------------------------- ! --------------------------------- ! increment 2stream by 1scalar pure subroutine increment_2stream_by_1scalar ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 ) bind ( C , name = \"increment_2stream_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt real ( wp ) :: tau12 do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! g is unchanged end do end do end do end subroutine increment_2stream_by_1scalar ! --------------------------------- ! increment 2stream by 2stream pure subroutine increment_2stream_by_2stream ( ncol , nlay , ngpt , & tau1 , ssa1 , g1 , & tau2 , ssa2 , g2 ) bind ( C , name = \"increment_2stream_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 , g2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * g2 ( icol , ilay , igpt )) & / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end subroutine increment_2stream_by_2stream ! --------------------------------- ! increment 2stream by nstream pure subroutine increment_2stream_by_nstream ( ncol , nlay , ngpt , nmom2 , & tau1 , ssa1 , g1 , & tau2 , ssa2 , p2 ) bind ( C , name = \"increment_2stream_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom2 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , ngpt ), intent ( in ) :: p2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * p2 ( 1 , icol , ilay , igpt )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end subroutine increment_2stream_by_nstream ! --------------------------------- ! --------------------------------- ! increment nstream by 1scalar pure subroutine increment_nstream_by_1scalar ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 ) bind ( C , name = \"increment_nstream_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt real ( wp ) :: tau12 do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! p is unchanged end do end do end do end subroutine increment_nstream_by_1scalar ! --------------------------------- ! increment nstream by 2stream pure subroutine increment_nstream_by_2stream ( ncol , nlay , ngpt , nmom1 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , g2 ) bind ( C , name = \"increment_nstream_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 , g2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 real ( wp ), dimension ( nmom1 ) :: temp_moms ! TK integer :: imom !TK do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) ! ! Here assume Henyey-Greenstein ! temp_moms ( 1 ) = g2 ( icol , ilay , igpt ) do imom = 2 , nmom1 temp_moms ( imom ) = temp_moms ( imom - 1 ) * g2 ( icol , ilay , igpt ) end do p1 ( 1 : nmom1 , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : nmom1 , icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * temp_moms ( 1 : nmom1 ) ) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end subroutine increment_nstream_by_2stream ! --------------------------------- ! increment nstream by nstream pure subroutine increment_nstream_by_nstream ( ncol , nlay , ngpt , nmom1 , nmom2 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , p2 ) bind ( C , name = \"increment_nstream_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nmom2 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , ngpt ), intent ( in ) :: p2 integer :: icol , ilay , igpt , mom_lim real ( wp ) :: tau12 , tauscat12 mom_lim = min ( nmom1 , nmom2 ) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) ! ! If op2 has more moments than op1 these are ignored; !   if it has fewer moments the higher orders are assumed to be 0 ! p1 ( 1 : mom_lim , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : mom_lim , icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * p2 ( 1 : mom_lim , icol , ilay , igpt )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end subroutine increment_nstream_by_nstream ! ------------------------------------------------------------------------------------------------- ! ! Incrementing when the second set of optical properties is defined at lower spectral resolution !   (e.g. by band instead of by gpoint) ! ! ------------------------------------------------------------------------------------------------- pure subroutine inc_1scalar_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) tau1 (:,:, igpt ) = tau1 (:,:, igpt ) + tau2 (:,:, ibnd ) end do end do end subroutine inc_1scalar_by_1scalar_bybnd ! --------------------------------- ! increment 1scalar by 2stream pure subroutine inc_1scalar_by_2stream_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) tau1 (:,:, igpt ) = tau1 (:,:, igpt ) + tau2 (:,:, ibnd ) * ( 1._wp - ssa2 (:,:, ibnd )) end do end do end subroutine inc_1scalar_by_2stream_bybnd ! --------------------------------- ! increment 1scalar by nstream pure subroutine inc_1scalar_by_nstream_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) tau1 (:,:, igpt ) = tau1 (:,:, igpt ) + tau2 (:,:, ibnd ) * ( 1._wp - ssa2 (:,:, ibnd )) end do end do end subroutine inc_1scalar_by_nstream_bybnd ! --------------------------------- ! increment 2stream by 1scalar pure subroutine inc_2stream_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! g is unchanged end do end do end do end do end subroutine inc_2stream_by_1scalar_bybnd ! --------------------------------- ! increment 2stream by 2stream pure subroutine inc_2stream_by_2stream_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , g1 , & tau2 , ssa2 , g2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 , g2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * g2 ( icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end do end subroutine inc_2stream_by_2stream_bybnd ! --------------------------------- ! increment 2stream by nstream pure subroutine inc_2stream_by_nstream_bybnd ( ncol , nlay , ngpt , nmom2 , & tau1 , ssa1 , g1 , & tau2 , ssa2 , p2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom2 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , nbnd ), intent ( in ) :: p2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * p2 ( 1 , icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end do end subroutine inc_2stream_by_nstream_bybnd ! --------------------------------- ! --------------------------------- ! increment nstream by 1scalar pure subroutine inc_nstream_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! p is unchanged end do end do end do end do end subroutine inc_nstream_by_1scalar_bybnd ! --------------------------------- ! increment nstream by 2stream pure subroutine inc_nstream_by_2stream_bybnd ( ncol , nlay , ngpt , nmom1 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , g2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 , g2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 real ( wp ), dimension ( nmom1 ) :: temp_moms ! TK integer :: imom !TK do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) ! ! Here assume Henyey-Greenstein ! temp_moms ( 1 ) = g2 ( icol , ilay , ibnd ) do imom = 2 , nmom1 temp_moms ( imom ) = temp_moms ( imom - 1 ) * g2 ( icol , ilay , ibnd ) end do p1 ( 1 : nmom1 , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : nmom1 , icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * temp_moms ( 1 : nmom1 ) ) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end do end subroutine inc_nstream_by_2stream_bybnd ! --------------------------------- ! increment nstream by nstream pure subroutine inc_nstream_by_nstream_bybnd ( ncol , nlay , ngpt , nmom1 , nmom2 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , p2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nmom2 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , nbnd ), intent ( in ) :: p2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd , mom_lim real ( wp ) :: tau12 , tauscat12 mom_lim = min ( nmom1 , nmom2 ) do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) ! ! If op2 has more moments than op1 these are ignored; !   if it has fewer moments the higher orders are assumed to be 0 ! p1 ( 1 : mom_lim , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : mom_lim , icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * p2 ( 1 : mom_lim , icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end do end subroutine inc_nstream_by_nstream_bybnd ! ------------------------------------------------------------------------------------------------- ! ! Subsetting, meaning extracting some portion of the 3D domain ! ! ------------------------------------------------------------------------------------------------- pure subroutine extract_subset_dim1_3d ( ncol , nlay , ngpt , array_in , colS , colE , array_out ) & bind ( C , name = \"extract_subset_dim1_3d\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: array_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: array_out integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE array_out ( icol - colS + 1 , ilay , igpt ) = array_in ( icol , ilay , igpt ) end do end do end do end subroutine extract_subset_dim1_3d ! --------------------------------- pure subroutine extract_subset_dim2_4d ( nmom , ncol , nlay , ngpt , array_in , colS , colE , array_out ) & bind ( C , name = \"extract_subset_dim2_4d\" ) integer , intent ( in ) :: nmom , ncol , nlay , ngpt real ( wp ), dimension ( nmom , ncol , nlay , ngpt ), intent ( in ) :: array_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( nmom , colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: array_out integer :: icol , ilay , igpt , imom do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE do imom = 1 , nmom array_out ( imom , icol - colS + 1 , ilay , igpt ) = array_in ( imom , icol , ilay , igpt ) end do end do end do end do end subroutine extract_subset_dim2_4d ! --------------------------------- ! ! Extract the absorption optical thickness which requires mulitplying by 1 - ssa ! pure subroutine extract_subset_absorption_tau ( ncol , nlay , ngpt , tau_in , ssa_in , & colS , colE , tau_out ) & bind ( C , name = \"extract_subset_absorption_tau\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau_in , ssa_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: tau_out integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE tau_out ( icol - colS + 1 , ilay , igpt ) = & tau_in ( icol , ilay , igpt ) * ( 1._wp - ssa_in ( icol , ilay , igpt )) end do end do end do end subroutine extract_subset_absorption_tau end module mo_optical_props_kernels","tags":"","loc":"sourcefile/mo_optical_props_kernels.f90.html"},{"title":"mo_rte_solver_kernels.F90 – rte-rrtmgp","text":"Contents Modules mo_rte_solver_kernels Source Code mo_rte_solver_kernels.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2021,  Atmospheric and Environmental Research, ! Regents of the University of Colorado, Trustees of Columbia University.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Numeric calculations for radiative transfer solvers. !   Emission/absorption (no-scattering) calculations !     solver for multi-angle Gaussian quadrature !     solver for a single angle, calling !       source function computation (linear-in-tau) !       transport !   Extinction-only calculation (direct solar beam) !   Two-stream calculations !     solvers for LW and SW with different boundary conditions and source functions !       source function calculation for LW, SW !       two-stream calculations for LW, SW (using different assumtions about phase function) !       transport (adding) !   Application of boundary conditions ! ! ------------------------------------------------------------------------------------------------- module mo_rte_solver_kernels use , intrinsic :: iso_c_binding use mo_rte_kind , only : wp , wl use mo_rte_util_array , only : zero_array implicit none private public :: lw_solver_noscat , lw_solver_noscat_GaussQuad , lw_solver_2stream , & sw_solver_noscat , sw_solver_2stream real ( wp ), parameter :: pi = acos ( - 1._wp ) contains ! ------------------------------------------------------------------------------------------------- ! ! Top-level longwave kernels ! ! ------------------------------------------------------------------------------------------------- ! ! LW fluxes, no scattering, mu (cosine of integration angle) specified by column !   Does radiation calculation at user-supplied angles; converts radiances to flux !   using user-supplied weights ! ! --------------------------------------------------------------- subroutine lw_solver_noscat ( ncol , nlay , ngpt , top_at_1 , D , weight , & tau , lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & incident_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) bind ( C , name = \"lw_solver_noscat\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: D ! secant of propagation angle  [] real ( wp ), intent ( in ) :: weight ! quadrature weight real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] ! Planck source at layer edge for radiation in increasing/decreasing ilay direction ! lev_source_dec applies the mapping in layer i to the Planck function at layer i ! lev_source_inc applies the mapping in layer i to the Planck function at layer i+1 real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( in ) :: lev_source_inc , lev_source_dec real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: incident_flux ! Boundary condition for flux [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & ! Fluxes [W/m2] intent ( out ) :: flux_up , flux_dn ! ! Optional variables - arrays aren't referenced if corresponding logical  == False ! logical ( wl ), intent ( in ) :: do_broadband real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: broadband_up , broadband_dn ! Spectrally-integrated fluxes [W/m2] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_srcJac ! surface temperature Jacobian of surface source function [W/m2/K] real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: flux_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] logical ( wl ), intent ( in ) :: do_rescaling real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: ssa , g ! single-scattering albedo, asymmetry parameter ! ------------------------------------ ! Local variables, no g-point dependency ! integer :: icol , ilay , igpt integer :: top_level , sfc_level real ( wp ), dimension ( ncol , nlay ) :: tau_loc , & ! path length (tau/mu) trans ! transmissivity  = exp(-tau) real ( wp ), dimension ( ncol , nlay ) :: source_dn , source_up real ( wp ), dimension ( ncol ) :: sfc_albedo real ( wp ), dimension (:,:,:), pointer :: lev_source_up , lev_source_dn ! Mapping increasing/decreasing indicies to up/down real ( wp ), parameter :: pi = acos ( - 1._wp ) ! loc_fluxes hold a single g-point flux if fluxes are being integrated instead of returned !   with spectral detail real ( wp ), dimension ( ncol , nlay + 1 ), & target :: loc_flux_up , loc_flux_dn ! gpt_fluxes point to calculations for the current g-point real ( wp ), dimension (:,:), pointer :: gpt_flux_up , gpt_flux_dn ! ------------------------------------------------------------------------------------------------- ! Optionally, use an approximate treatment of scattering using rescaling !   Implemented based on the paper !   Tang G, et al, 2018: https://doi.org/10.1175/JAS-D-18-0014.1 !   a) relies on rescaling of the optical parameters based on asymetry factor and single scattering albedo !       scaling can be computed  by scaling_1rescl !   b) adds adustment term based on cloud properties (lw_transport_1rescl) !      adustment terms is computed based on solution of the Tang equations !      for \"linear-in-tau\" internal source (not in the paper) ! ! Used when approximating scattering ! real ( wp ) :: ssal , wb , scaleTau real ( wp ), dimension ( ncol , nlay ) :: An , Cn real ( wp ), dimension ( ncol , nlay + 1 ) :: gpt_flux_Jac ! ------------------------------------ ! Which way is up? ! Level Planck sources for upward and downward radiation ! When top_at_1, lev_source_up => lev_source_dec !                lev_source_dn => lev_source_inc, and vice-versa if ( top_at_1 ) then top_level = 1 sfc_level = nlay + 1 lev_source_up => lev_source_dec lev_source_dn => lev_source_inc else top_level = nlay + 1 sfc_level = 1 lev_source_up => lev_source_inc lev_source_dn => lev_source_dec end if ! ! Integrated fluxes need zeroing ! if ( do_broadband ) then call zero_array ( ncol , nlay + 1 , broadband_up ) call zero_array ( ncol , nlay + 1 , broadband_dn ) end if if ( do_Jacobians ) & call zero_array ( ncol , nlay + 1 , flux_upJac ) do igpt = 1 , ngpt if ( do_broadband ) then gpt_flux_up => loc_flux_up gpt_flux_dn => loc_flux_dn else gpt_flux_up => flux_up (:,:, igpt ) gpt_flux_dn => flux_dn (:,:, igpt ) end if ! ! Transport is for intensity !   convert flux at top of domain to intensity assuming azimuthal isotropy ! gpt_flux_dn (:, top_level ) = incident_flux (:, igpt ) / ( 2._wp * pi * weight ) ! ! Optical path and transmission, used in source function and transport calculations ! if ( do_rescaling ) then ! ! The scaling and scaleTau terms are independent of propagation !   angle D and could be pre-computed if several values of D are used ! We re-compute them here to keep not have to localize memory use ! do ilay = 1 , nlay do icol = 1 , ncol ssal = ssa ( icol , ilay , igpt ) ! w is the layer single scattering albedo ! b is phase function parameter (Eq.13 of the paper) ! for the similarity principle scaling scheme ! b = (1-g)/2 (where g is phase function avergae cosine) wb = ssal * ( 1._wp - g ( icol , ilay , igpt )) * 0.5_wp ! scaleTau=1-w(1-b) is a scaling factor of the optical thickness representing ! the radiative transfer equation in a nonscattering form Eq(14) of the paper scaleTau = ( 1._wp - ssal + wb ) ! Cn = 0.5*wb/(1-w(1-b)) is parameter of Eq.21-22 of the Tang paper ! Tang paper, p.2222 advises to replace 0.5 with 0.4 based on simulations Cn ( icol , ilay ) = 0.4_wp * wb / scaleTau ! Eqs.15, 18ab and 19 of the paper, ! rescaling of the optical depth multiplied by path length tau_loc ( icol , ilay ) = tau ( icol , ilay , igpt ) * D ( icol , igpt ) * scaleTau end do trans (:, ilay ) = exp ( - tau_loc (:, ilay )) An (:, ilay ) = ( 1._wp - trans (:, ilay ) ** 2 ) end do else do ilay = 1 , nlay tau_loc (:, ilay ) = tau (:, ilay , igpt ) * D (:, igpt ) trans (:, ilay ) = exp ( - tau_loc (:, ilay )) end do end if ! ! Source function for diffuse radiation ! call lw_source_noscat ( ncol , nlay , & lay_source (:,:, igpt ), lev_source_up (:,:, igpt ), lev_source_dn (:,:, igpt ), & tau_loc , trans , source_dn , source_up ) ! ! Transport down ! call lw_transport_noscat_dn ( ncol , nlay , top_at_1 , trans , source_dn , gpt_flux_dn ) ! ! Surface albedo, surface source function, reflection and emission ! sfc_albedo (:) = 1._wp - sfc_emis (:, igpt ) gpt_flux_up (:, sfc_level ) = gpt_flux_dn (:, sfc_level ) * sfc_albedo (:) + & sfc_emis (:, igpt ) * sfc_src (:, igpt ) if ( do_Jacobians ) & gpt_flux_Jac (:, sfc_level ) = sfc_emis (:, igpt ) * sfc_srcJac (:, igpt ) ! ! Transport up, or up and down again if using rescaling ! if ( do_rescaling ) then call lw_transport_1rescl ( ncol , nlay , top_at_1 , trans , & source_dn , source_up , & gpt_flux_up , gpt_flux_dn , An , Cn , & do_Jacobians , gpt_flux_Jac ) ! Standing in for Jacobian, i.e. rad_up_Jac(:,:,igpt), rad_dn_Jac(:,:,igpt)) else call lw_transport_noscat_up ( ncol , nlay , top_at_1 , trans , source_up , gpt_flux_up , & do_Jacobians , gpt_flux_Jac ) end if if ( do_broadband ) then broadband_up (:,:) = broadband_up (:,:) + gpt_flux_up (:,:) broadband_dn (:,:) = broadband_dn (:,:) + gpt_flux_dn (:,:) else ! ! Convert intensity to flux assuming azimuthal isotropy and quadrature weight ! gpt_flux_dn (:,:) = 2._wp * pi * weight * gpt_flux_dn (:,:) gpt_flux_up (:,:) = 2._wp * pi * weight * gpt_flux_up (:,:) end if ! ! Only broadband-integrated Jacobians are provided ! if ( do_Jacobians ) & flux_upJac (:,:) = flux_upJac (:,:) + gpt_flux_Jac (:,:) end do ! g point loop if ( do_broadband ) then broadband_up (:,:) = 2._wp * pi * weight * broadband_up (:,:) broadband_dn (:,:) = 2._wp * pi * weight * broadband_dn (:,:) end if if ( do_Jacobians ) & flux_upJac (:,:) = 2._wp * pi * weight * flux_upJac (:,:) end subroutine lw_solver_noscat ! ------------------------------------------------------------------------------------------------- ! ! LW transport, no scattering, multi-angle quadrature !   Users provide a set of weights and quadrature angles !   Routine sums over single-angle solutions for each sets of angles/weights ! ! --------------------------------------------------------------- subroutine lw_solver_noscat_GaussQuad ( ncol , nlay , ngpt , top_at_1 , & nmus , Ds , weights , & tau , & lay_source , lev_source_inc , lev_source_dec , & sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) bind ( C , name = \"lw_solver_noscat_GaussQuad\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 integer , intent ( in ) :: nmus ! number of quadrature angles real ( wp ), dimension ( ncol , ngpt , & nmus ), intent ( in ) :: Ds real ( wp ), dimension ( nmus ), intent ( in ) :: weights ! quadrature secants, weights real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_source_inc ! Planck source at layer edge for radiation in increasing ilay direction [W/m2] ! Includes spectral weighting that accounts for state-dependent frequency to g-space mapping real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_source_dec ! Planck source at layer edge for radiation in decreasing ilay direction [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux ! Incident diffuse flux, probably 0 [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ! Optional variables - arrays aren't referenced if corresponding logical  == False ! logical ( wl ), intent ( in ) :: do_broadband real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( out ) :: broadband_up , broadband_dn ! Spectrally-integrated fluxes [W/m2] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_srcJac ! surface temperature Jacobian of surface source function [W/m2/K] real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( out ) :: flux_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] logical ( wl ), intent ( in ) :: do_rescaling real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: ssa , g ! single-scattering albedo, asymmetry parameter ! ------------------------------------ ! ! Local variables - used for a single quadrature angle ! real ( wp ), dimension (:,:,:), pointer :: this_flux_up , this_flux_dn real ( wp ), dimension (:,:), pointer :: this_broadband_up , this_broadband_dn , this_flux_upJac integer :: imu ! ------------------------------------ ! ! For the first angle output arrays store total flux ! call lw_solver_noscat ( ncol , nlay , ngpt , & top_at_1 , Ds (:,:, 1 ), weights ( 1 ), tau , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) ! ! For more than one angle use local arrays ! if ( nmus > 1 ) then if ( do_broadband ) then allocate ( this_broadband_up ( ncol , nlay + 1 ), this_broadband_dn ( ncol , nlay + 1 )) ! Spectrally-resolved fluxes won't be filled in so can point to caller-supplied memory this_flux_up => flux_up this_flux_dn => flux_dn else allocate ( this_flux_up ( ncol , nlay + 1 , ngpt ), this_flux_dn ( ncol , nlay + 1 , ngpt )) ! Spectrally-integrated fluxes won't be filled in so can point to caller-supplied memory this_broadband_up => broadband_up this_broadband_dn => broadband_dn end if if ( do_Jacobians ) then allocate ( this_flux_upJac ( ncol , nlay + 1 )) else this_flux_upJac => flux_upJac end if end if do imu = 2 , nmus call lw_solver_noscat ( ncol , nlay , ngpt , & top_at_1 , Ds (:,:, imu ), weights ( imu ), tau , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & this_flux_up , this_flux_dn , & do_broadband , this_broadband_up , this_broadband_dn , & do_Jacobians , sfc_srcJac , this_flux_upJac , & do_rescaling , ssa , g ) if ( do_broadband ) then broadband_up (:,:) = broadband_up (:,:) + this_broadband_up (:,:) broadband_dn (:,:) = broadband_dn (:,:) + this_broadband_dn (:,:) else flux_up (:,:,:) = flux_up (:,:,:) + this_flux_up (:,:,:) flux_dn (:,:,:) = flux_dn (:,:,:) + this_flux_dn (:,:,:) end if if ( do_Jacobians ) & flux_upJac (:,:) = flux_upJac (:,: ) + this_flux_upJac (:,: ) end do if ( nmus > 1 ) then if ( do_broadband ) deallocate ( this_broadband_up , this_broadband_dn ) if (. not . do_broadband ) deallocate ( this_flux_up , this_flux_dn ) if ( do_Jacobians ) deallocate ( this_flux_upJac ) end if end subroutine lw_solver_noscat_GaussQuad ! ------------------------------------------------------------------------------------------------- ! ! Longwave two-stream calculation: !   combine RRTMGP-specific sources at levels !   compute layer reflectance, transmittance !   compute total source function at levels using linear-in-tau !   transport ! ! ------------------------------------------------------------------------------------------------- subroutine lw_solver_2stream ( ncol , nlay , ngpt , top_at_1 , & tau , ssa , g , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn ) bind ( C , name = \"lw_solver_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , & ! Optical thickness, ssa , & ! single-scattering albedo, g ! asymmetry parameter [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( in ) :: lev_source_inc , lev_source_dec ! Planck source at layer edge for radiation in increasing/decreasing ilay direction [W/m2] ! Includes spectral weighting that accounts for state-dependent frequency to g-space mapping real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux ! Incident diffuse flux, probably 0 [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ---------------------------------------------------------------------- integer :: igpt , top_level real ( wp ), dimension ( ncol , nlay ) :: Rdif , Tdif , gamma1 , gamma2 real ( wp ), dimension ( ncol ) :: sfc_albedo real ( wp ), dimension ( ncol , nlay + 1 ) :: lev_source real ( wp ), dimension ( ncol , nlay ) :: source_dn , source_up real ( wp ), dimension ( ncol ) :: source_sfc ! ------------------------------------ top_level = nlay + 1 if ( top_at_1 ) top_level = 1 do igpt = 1 , ngpt ! ! RRTMGP provides source functions at each level using the spectral mapping !   of each adjacent layer. Combine these for two-stream calculations ! call lw_combine_sources ( ncol , nlay , top_at_1 , & lev_source_inc (:,:, igpt ), lev_source_dec (:,:, igpt ), & lev_source ) ! ! Cell properties: reflection, transmission for diffuse radiation !   Coupling coefficients needed for source function ! call lw_two_stream ( ncol , nlay , & tau (:,:, igpt ), ssa (:,:, igpt ), g (:,:, igpt ), & gamma1 , gamma2 , Rdif , Tdif ) ! ! Source function for diffuse radiation ! call lw_source_2str ( ncol , nlay , top_at_1 , & sfc_emis (:, igpt ), sfc_src (:, igpt ), & lay_source (:,:, igpt ), lev_source , & gamma1 , gamma2 , Rdif , Tdif , tau (:,:, igpt ), & source_dn , source_up , source_sfc ) ! ! Transport ! sfc_albedo ( 1 : ncol ) = 1._wp - sfc_emis (:, igpt ) ! ! Boundary condition ! flux_dn (:, top_level , igpt ) = inc_flux (:, igpt ) call adding ( ncol , nlay , top_at_1 , & sfc_albedo , & Rdif , Tdif , & source_dn , source_up , source_sfc , & flux_up (:,:, igpt ), flux_dn (:,:, igpt )) end do end subroutine lw_solver_2stream ! ------------------------------------------------------------------------------------------------- ! !   Top-level shortwave kernels ! ! ------------------------------------------------------------------------------------------------- ! !   Extinction-only i.e. solar direct beam ! ! ------------------------------------------------------------------------------------------------- pure subroutine sw_solver_noscat ( ncol , nlay , ngpt , top_at_1 , & tau , mu0 , inc_flux_dir , flux_dir ) bind ( C , name = \"sw_solver_noscat\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 ! cosine of solar zenith angle real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux_dir ! Direct beam incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_dir ! Direct-beam flux, spectral [W/m2] integer :: ilev , igpt real ( wp ) :: mu0_inv ( ncol ) ! ------------------------------------ mu0_inv ( 1 : ncol ) = 1._wp / mu0 ( 1 : ncol ) ! Indexing into arrays for upward and downward propagation depends on the vertical !   orientation of the arrays (whether the domain top is at the first or last index) ! We write the loops out explicitly so compilers will have no trouble optimizing them. ! Downward propagation if ( top_at_1 ) then ! For the flux at this level, what was the previous level, and which layer has the !   radiation just passed through? ! layer index = level index - 1 ! previous level is up (-1) do igpt = 1 , ngpt flux_dir (:, 1 , igpt ) = inc_flux_dir (:, igpt ) * mu0 (:) do ilev = 2 , nlay + 1 flux_dir (:, ilev , igpt ) = flux_dir (:, ilev - 1 , igpt ) * exp ( - tau (:, ilev - 1 , igpt ) * mu0_inv (:)) end do end do else ! layer index = level index ! previous level is up (+1) do igpt = 1 , ngpt flux_dir (:, nlay + 1 , igpt ) = inc_flux_dir (:, igpt ) * mu0 (:) do ilev = nlay , 1 , - 1 flux_dir (:, ilev , igpt ) = flux_dir (:, ilev + 1 , igpt ) * exp ( - tau (:, ilev , igpt ) * mu0_inv (:)) end do end do end if end subroutine sw_solver_noscat ! ------------------------------------------------------------------------------------------------- ! ! Shortwave two-stream calculation: !   compute layer reflectance, transmittance !   compute solar source function for diffuse radiation !   transport ! ! ------------------------------------------------------------------------------------------------- subroutine sw_solver_2stream ( ncol , nlay , ngpt , top_at_1 , & tau , ssa , g , mu0 , & sfc_alb_dir , sfc_alb_dif , & inc_flux_dir , & flux_up , flux_dn , flux_dir , & has_dif_bc , inc_flux_dif , & do_broadband , broadband_up , & broadband_dn , broadband_dir ) bind ( C , name = \"sw_solver_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , & ! Optical thickness, ssa , & ! single-scattering albedo, g ! asymmetry parameter [] real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 ! cosine of solar zenith angle ! Spectral albedo of surface to direct and diffuse radiation real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_alb_dir , sfc_alb_dif , & inc_flux_dir ! Direct beam incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn , flux_dir ! Fluxes [W/m2] logical ( wl ), intent ( in ) :: has_dif_bc ! Is a boundary condition for diffuse flux supplied? real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux_dif ! Boundary condition for diffuse flux logical ( wl ), intent ( in ) :: do_broadband ! Provide broadband-integrated, not spectrally-resolved, fluxes? real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: broadband_up , broadband_dn , broadband_dir ! -------------------------------------------           ! Broadband integrated fluxes integer :: igpt , top_level real ( wp ), dimension ( ncol , nlay ) :: Rdif , Tdif real ( wp ), dimension ( ncol , nlay ) :: source_up , source_dn real ( wp ), dimension ( ncol ) :: source_srf ! loc_fluxes hold a single g-point flux if fluxes are being integrated instead of returned !   with spectral detail real ( wp ), dimension ( ncol , nlay + 1 ), & target :: loc_flux_up , loc_flux_dn , loc_flux_dir ! gpt_fluxes point to calculations for the current g-point real ( wp ), dimension (:,:), pointer :: gpt_flux_up , gpt_flux_dn , gpt_flux_dir ! ------------------------------------ top_level = nlay + 1 if ( top_at_1 ) top_level = 1 ! ! Integrated fluxes need zeroing ! if ( do_broadband ) then call zero_array ( ncol , nlay + 1 , broadband_up ) call zero_array ( ncol , nlay + 1 , broadband_dn ) call zero_array ( ncol , nlay + 1 , broadband_dir ) end if do igpt = 1 , ngpt if ( do_broadband ) then gpt_flux_up => loc_flux_up gpt_flux_dn => loc_flux_dn gpt_flux_dir => loc_flux_dir else gpt_flux_up => flux_up (:,:, igpt ) gpt_flux_dn => flux_dn (:,:, igpt ) gpt_flux_dir => flux_dir (:,:, igpt ) end if ! ! Boundary conditions direct beam... ! gpt_flux_dir (:, top_level ) = inc_flux_dir (:, igpt ) * mu0 (:) ! ! ... and diffuse field, using 0 if no BC is provided ! if ( has_dif_bc ) then gpt_flux_dn (:, top_level ) = inc_flux_dif (:, igpt ) else gpt_flux_dn (:, top_level ) = 0._wp end if ! ! Cell properties: transmittance and reflectance for diffuse radiation !   Direct-beam and source for diffuse radiation ! call sw_dif_and_source ( ncol , nlay , top_at_1 , mu0 , sfc_alb_dir (:, igpt ), & tau (:,:, igpt ), ssa (:,:, igpt ), g (:,:, igpt ), & Rdif , Tdif , source_dn , source_up , source_srf , & gpt_flux_dir ) ! ! Transport ! call adding ( ncol , nlay , top_at_1 , & sfc_alb_dif (:, igpt ), Rdif , Tdif , & source_dn , source_up , source_srf , gpt_flux_up , gpt_flux_dn ) ! ! adding() computes only diffuse flux; flux_dn is total ! if ( do_broadband ) then broadband_up (:,:) = broadband_up (:,:) + gpt_flux_up (:,:) broadband_dn (:,:) = broadband_dn (:,:) + gpt_flux_dn (:,:) + gpt_flux_dir (:,:) broadband_dir (:,:) = broadband_dir (:,:) + gpt_flux_dir (:,:) else gpt_flux_dn (:,:) = gpt_flux_dn (:,:) + gpt_flux_dir (:,:) end if end do end subroutine sw_solver_2stream ! ------------------------------------------------------------------------------------------------- ! !   Lower-level longwave kernels ! ! ------------------------------------------------------------------------------------------------- ! ! Compute LW source function for upward and downward emission at levels using linear-in-tau assumption ! See Clough et al., 1992, doi: 10.1029/92JD01419, Eq 13 ! ! --------------------------------------------------------------- subroutine lw_source_noscat ( ncol , nlay , lay_source , lev_source_up , lev_source_dn , tau , trans , & source_dn , source_up ) bind ( C , name = \"lw_source_noscat\" ) integer , intent ( in ) :: ncol , nlay real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: lay_source , & ! Planck source at layer center lev_source_up , & ! Planck source at levels (layer edges), lev_source_dn , & !   increasing/decreasing layer index tau , & ! Optical path (tau/mu) trans ! Transmissivity (exp(-tau)) real ( wp ), dimension ( ncol , nlay ), intent ( out ) :: source_dn , source_up ! Source function at layer edges ! Down at the bottom of the layer, up at the top ! -------------------------------- integer :: icol , ilay real ( wp ) :: fact real ( wp ), parameter :: tau_thresh = sqrt ( epsilon ( tau )) ! --------------------------------------------------------------- do ilay = 1 , nlay do icol = 1 , ncol ! ! Weighting factor. Use 2nd order series expansion when rounding error (~tau&#94;2) !   is of order epsilon (smallest difference from 1. in working precision) !   Thanks to Peter Blossey ! if ( tau ( icol , ilay ) > tau_thresh ) then fact = ( 1._wp - trans ( icol , ilay )) / tau ( icol , ilay ) - trans ( icol , ilay ) else fact = tau ( icol , ilay ) * ( 0.5_wp - 1._wp / 3._wp * tau ( icol , ilay )) end if ! ! Equation below is developed in Clough et al., 1992, doi:10.1029/92JD01419, Eq 13 ! source_dn ( icol , ilay ) = ( 1._wp - trans ( icol , ilay )) * lev_source_dn ( icol , ilay ) + & 2._wp * fact * ( lay_source ( icol , ilay ) - lev_source_dn ( icol , ilay )) source_up ( icol , ilay ) = ( 1._wp - trans ( icol , ilay )) * lev_source_up ( icol , ilay ) + & 2._wp * fact * ( lay_source ( icol , ilay ) - lev_source_up ( icol , ilay )) end do end do end subroutine lw_source_noscat ! ------------------------------------------------------------------------------------------------- ! ! Longwave no-scattering transport - separate routines for up and down ! ! ------------------------------------------------------------------------------------------------- subroutine lw_transport_noscat_dn ( ncol , nlay , top_at_1 , & trans , source_dn , radn_dn ) bind ( C , name = \"lw_transport_noscat_dn\" ) integer , intent ( in ) :: ncol , nlay ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 ! real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: trans ! transmissivity = exp(-tau) real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: source_dn ! Diffuse radiation emitted by the layer real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: radn_dn ! Radiances [W/m2-str] Top level must contain incident flux boundary condition ! --------------------------------------------------- ! Local variables integer :: ilev ! --------------------------------------------------- if ( top_at_1 ) then ! ! Top of domain is index 1 ! do ilev = 2 , nlay + 1 radn_dn (:, ilev ) = trans (:, ilev - 1 ) * radn_dn (:, ilev - 1 ) + source_dn (:, ilev - 1 ) end do else ! ! Top of domain is index nlay+1 ! do ilev = nlay , 1 , - 1 radn_dn (:, ilev ) = trans (:, ilev ) * radn_dn (:, ilev + 1 ) + source_dn (:, ilev ) end do end if end subroutine lw_transport_noscat_dn ! ------------------------------------------------------------------------------------------------- subroutine lw_transport_noscat_up ( ncol , nlay , top_at_1 , & trans , source_up , radn_up , do_Jacobians , radn_upJac ) bind ( C , name = \"lw_transport_noscat_up\" ) integer , intent ( in ) :: ncol , nlay ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 ! real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: trans ! transmissivity = exp(-tau) real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: source_up ! Diffuse radiation emitted by the layer real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: radn_up ! Radiances [W/m2-str] Top level must contain incident flux boundary condition logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: radn_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] ! --------------------------------------------------- ! Local variables integer :: ilev ! --------------------------------------------------- if ( top_at_1 ) then ! ! Top of domain is index 1 ! ! Upward propagation do ilev = nlay , 1 , - 1 radn_up (:, ilev ) = trans (:, ilev ) * radn_up (:, ilev + 1 ) + source_up (:, ilev ) if ( do_Jacobians ) & radn_upJac (:, ilev ) = trans (:, ilev ) * radn_upJac (:, ilev + 1 ) end do else ! ! Top of domain is index nlay+1 ! ! Upward propagation do ilev = 2 , nlay + 1 radn_up (:, ilev ) = trans (:, ilev - 1 ) * radn_up (:, ilev - 1 ) + source_up (:, ilev - 1 ) if ( do_Jacobians ) & radn_upJac (:, ilev ) = trans (:, ilev - 1 ) * radn_upJac (:, ilev - 1 ) end do end if end subroutine lw_transport_noscat_up ! ------------------------------------------------------------------------------------------------- ! Upward and (second) downward transport for re-scaled longwave solution !   adds adjustment factor based on cloud properties ! !   implementation notice: !       the adjustmentFactor computation can be skipped where Cn <= epsilon ! ------------------------------------------------------------------------------------------------- subroutine lw_transport_1rescl ( ncol , nlay , top_at_1 , & trans , source_dn , source_up , & radn_up , radn_dn , An , Cn ,& do_Jacobians , radn_up_Jac ) bind ( C , name = \"lw_transport_1rescl\" ) integer , intent ( in ) :: ncol , nlay ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 ! real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: trans ! transmissivity = exp(-tau) real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: source_dn , & source_up ! Diffuse radiation emitted by the layer real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: radn_up ! Radiances [W/m2-str] real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: radn_dn !Top level must contain incident flux boundary condition real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: An , Cn logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: radn_up_Jac ! Surface temperature Jacobians [W/m2-str/K] ! ! We could in principle compute a downwelling Jacobian too, but it's small !   (only a small proportion of LW is scattered) and it complicates code and the API, !   so we will not ! ! Local variables integer :: ilev , icol ! --------------------------------------------------- real ( wp ) :: adjustmentFactor if ( top_at_1 ) then ! ! Top of domain is index 1 ! ! Upward propagation ! adjustment factor is obtained as a solution of 18b of the Tang paper ! eqvivalent to Eq.20 of the Tang paper but for linear-in-tau source do ilev = nlay , 1 , - 1 do icol = 1 , ncol adjustmentFactor = Cn ( icol , ilev ) * ( An ( icol , ilev ) * radn_dn ( icol , ilev ) - & trans ( icol , ilev ) * source_dn ( icol , ilev ) - source_up ( icol , ilev ) ) radn_up ( icol , ilev ) = trans ( icol , ilev ) * radn_up ( icol , ilev + 1 ) + source_up ( icol , ilev ) + & adjustmentFactor end do if ( do_Jacobians ) & radn_up_Jac (:, ilev ) = trans (:, ilev ) * radn_up_Jac (:, ilev + 1 ) end do ! Downward propagation ! radn_dn_Jac(:,1) = 0._wp ! adjustment factor is obtained as a solution of 19 of the Tang paper ! eqvivalent to Eq.21 of the Tang paper but for linear-in-tau source do ilev = 1 , nlay ! radn_dn_Jac(:,ilev+1) = trans(:,ilev)*radn_dn_Jac(:,ilev) do icol = 1 , ncol adjustmentFactor = Cn ( icol , ilev ) * ( An ( icol , ilev ) * radn_up ( icol , ilev ) - & trans ( icol , ilev ) * source_up ( icol , ilev ) - source_dn ( icol , ilev ) ) radn_dn ( icol , ilev + 1 ) = trans ( icol , ilev ) * radn_dn ( icol , ilev ) + source_dn ( icol , ilev ) + & adjustmentFactor ! adjustmentFactor         = Cn(icol,ilev)*An(icol,ilev)*radn_up_Jac(icol,ilev) ! radn_dn_Jac(icol,ilev+1) = radn_dn_Jac(icol,ilev+1) + adjustmentFactor enddo end do else ! ! Top of domain is index nlay+1 ! ! Upward propagation ! adjustment factor is obtained as a solution of 18b of the Tang paper ! eqvivalent to Eq.20 of the Tang paper but for linear-in-tau source do ilev = 1 , nlay radn_up (:, ilev + 1 ) = trans (:, ilev ) * radn_up (:, ilev ) + source_up (:, ilev ) do icol = 1 , ncol adjustmentFactor = Cn ( icol , ilev ) * ( An ( icol , ilev ) * radn_dn ( icol , ilev + 1 ) - & trans ( icol , ilev ) * source_dn ( icol , ilev ) - source_up ( icol , ilev ) ) radn_up ( icol , ilev + 1 ) = trans ( icol , ilev ) * radn_up ( icol , ilev ) + source_up ( icol , ilev ) + & adjustmentFactor enddo if ( do_Jacobians ) & radn_up_Jac (:, ilev + 1 ) = trans (:, ilev ) * radn_up_Jac (:, ilev ) end do ! Downward propagation ! adjustment factor is obtained as a solution of 19 of the Tang paper ! eqvivalent to Eq.21 of the Tang paper but for linear-in-tau source ! radn_dn_Jac(:,nlay+1) = 0._wp do ilev = nlay , 1 , - 1 ! radn_dn_Jac(:,ilev) = trans(:,ilev)*radn_dn_Jac(:,ilev+1) do icol = 1 , ncol adjustmentFactor = Cn ( icol , ilev ) * ( An ( icol , ilev ) * radn_up ( icol , ilev ) - & trans ( icol , ilev ) * source_up ( icol , ilev ) - source_dn ( icol , ilev ) ) radn_dn ( icol , ilev ) = trans ( icol , ilev ) * radn_dn ( icol , ilev + 1 ) + source_dn ( icol , ilev ) + & adjustmentFactor ! adjustmentFactor    = Cn(icol,ilev)*An(icol,ilev)*radn_up_Jac(icol,ilev) ! radn_dn_Jac(icol,ilev) = radn_dn_Jac(icol,ilev) + adjustmentFactor enddo end do end if end subroutine lw_transport_1rescl ! ------------------------------------------------------------------------------------------------- ! ! Longwave two-stream solutions to diffuse reflectance and transmittance for a layer !    with optical depth tau, single scattering albedo w0, and asymmetery parameter g. ! ! Equations are developed in Meador and Weaver, 1980, !    doi:10.1175/1520-0469(1980)037<0630:TSATRT>2.0.CO;2 ! ! ------------------------------------------------------------------------------------------------- pure subroutine lw_two_stream ( ncol , nlay , tau , w0 , g , & gamma1 , gamma2 , Rdif , Tdif ) bind ( C , name = \"lw_two_stream\" ) integer , intent ( in ) :: ncol , nlay real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: tau , w0 , g real ( wp ), dimension ( ncol , nlay ), intent ( out ) :: gamma1 , gamma2 , Rdif , Tdif ! ----------------------- integer :: i , j ! Variables used in Meador and Weaver real ( wp ) :: k ( ncol ) ! Ancillary variables real ( wp ) :: RT_term ( ncol ) real ( wp ) :: exp_minusktau ( ncol ), exp_minus2ktau ( ncol ) real ( wp ), parameter :: LW_diff_sec = 1.66 ! 1./cos(diffusivity angle) ! --------------------------------- do j = 1 , nlay do i = 1 , ncol ! ! Coefficients differ from SW implementation because the phase function is more isotropic !   Here we follow Fu et al. 1997, doi:10.1175/1520-0469(1997)054<2799:MSPITI>2.0.CO;2 !   and use a diffusivity sec of 1.66 ! gamma1 ( i , j ) = LW_diff_sec * ( 1._wp - 0.5_wp * w0 ( i , j ) * ( 1._wp + g ( i , j ))) ! Fu et al. Eq 2.9 gamma2 ( i , j ) = LW_diff_sec * 0.5_wp * w0 ( i , j ) * ( 1._wp - g ( i , j )) ! Fu et al. Eq 2.10 ! Eq 18;  k = SQRT(gamma1**2 - gamma2**2), limited below to avoid div by 0. !   k = 0 for isotropic, conservative scattering; this lower limit on k !   gives relative error with respect to conservative solution !   of < 0.1% in Rdif down to tau = 10&#94;-9 k ( i ) = sqrt ( max (( gamma1 ( i , j ) - gamma2 ( i , j )) * ( gamma1 ( i , j ) + gamma2 ( i , j )), 1.e-12_wp )) end do ! Written to encourage vectorization of exponential exp_minusktau ( 1 : ncol ) = exp ( - tau ( 1 : ncol , j ) * k ( 1 : ncol )) ! ! Diffuse reflection and transmission ! do i = 1 , ncol exp_minus2ktau ( i ) = exp_minusktau ( i ) * exp_minusktau ( i ) ! Refactored to avoid rounding errors when k, gamma1 are of very different magnitudes RT_term ( i ) = 1._wp / ( k ( i ) * ( 1._wp + exp_minus2ktau ( i )) + & gamma1 ( i , j ) * ( 1._wp - exp_minus2ktau ( i )) ) ! Equation 25 Rdif ( i , j ) = RT_term ( i ) * gamma2 ( i , j ) * ( 1._wp - exp_minus2ktau ( i )) ! Equation 26 Tdif ( i , j ) = RT_term ( i ) * 2._wp * k ( i ) * exp_minusktau ( i ) end do end do end subroutine lw_two_stream ! ------------------------------------------------------------------------------------------------- ! ! Source function combination ! RRTMGP provides two source functions at each level !   using the spectral mapping from each of the adjascent layers. !   Need to combine these for use in two-stream calculation. ! ! ------------------------------------------------------------------------------------------------- subroutine lw_combine_sources ( ncol , nlay , top_at_1 , & lev_src_inc , lev_src_dec , lev_source ) bind ( C , name = \"lw_combine_sources\" ) integer , intent ( in ) :: ncol , nlay logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: lev_src_inc , lev_src_dec real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: lev_source integer :: icol , ilay ! --------------------------------------------------------------- ilay = 1 do icol = 1 , ncol lev_source ( icol , ilay ) = lev_src_dec ( icol , ilay ) end do do ilay = 2 , nlay do icol = 1 , ncol lev_source ( icol , ilay ) = sqrt ( lev_src_dec ( icol , ilay ) * & lev_src_inc ( icol , ilay - 1 )) end do end do ilay = nlay + 1 do icol = 1 , ncol lev_source ( icol , ilay ) = lev_src_inc ( icol , ilay - 1 ) end do end subroutine lw_combine_sources ! --------------------------------------------------------------- ! ! Compute LW source function for upward and downward emission at levels using linear-in-tau assumption !   This version straight from ECRAD !   Source is provided as W/m2-str; factor of pi converts to flux units ! ! --------------------------------------------------------------- subroutine lw_source_2str ( ncol , nlay , top_at_1 , & sfc_emis , sfc_src , & lay_source , lev_source , & gamma1 , gamma2 , rdif , tdif , tau , source_dn , source_up , source_sfc ) & bind ( C , name = \"lw_source_2str\" ) integer , intent ( in ) :: ncol , nlay logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol ), intent ( in ) :: sfc_emis , sfc_src real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: lay_source , & ! Planck source at layer center tau , & ! Optical depth (tau) gamma1 , gamma2 ,& ! Coupling coefficients rdif , tdif ! Layer reflectance and transmittance real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( in ) :: lev_source ! Planck source at layer edges real ( wp ), dimension ( ncol , nlay ), intent ( out ) :: source_dn , source_up real ( wp ), dimension ( ncol ), intent ( out ) :: source_sfc ! Source function for upward radation at surface integer :: icol , ilay real ( wp ) :: Z , Zup_top , Zup_bottom , Zdn_top , Zdn_bottom real ( wp ), dimension (:), pointer :: lev_source_bot , lev_source_top ! --------------------------------------------------------------- do ilay = 1 , nlay if ( top_at_1 ) then lev_source_top => lev_source (:, ilay ) lev_source_bot => lev_source (:, ilay + 1 ) else lev_source_top => lev_source (:, ilay + 1 ) lev_source_bot => lev_source (:, ilay ) end if do icol = 1 , ncol if ( tau ( icol , ilay ) > 1.0e-8_wp ) then ! ! Toon et al. (JGR 1989) Eqs 26-27 ! Z = ( lev_source_bot ( icol ) - lev_source_top ( icol )) / ( tau ( icol , ilay ) * ( gamma1 ( icol , ilay ) + gamma2 ( icol , ilay ))) Zup_top = Z + lev_source_top ( icol ) Zup_bottom = Z + lev_source_bot ( icol ) Zdn_top = - Z + lev_source_top ( icol ) Zdn_bottom = - Z + lev_source_bot ( icol ) source_up ( icol , ilay ) = pi * ( Zup_top - rdif ( icol , ilay ) * Zdn_top - tdif ( icol , ilay ) * Zup_bottom ) source_dn ( icol , ilay ) = pi * ( Zdn_bottom - rdif ( icol , ilay ) * Zup_bottom - tdif ( icol , ilay ) * Zdn_top ) else source_up ( icol , ilay ) = 0._wp source_dn ( icol , ilay ) = 0._wp end if end do end do do icol = 1 , ncol source_sfc ( icol ) = pi * sfc_emis ( icol ) * sfc_src ( icol ) end do end subroutine lw_source_2str ! ------------------------------------------------------------------------------------------------- ! !   Lower-level shortwave kernels ! ! ------------------------------------------------------------------------------------------------- ! ! Two-stream solutions to diffuse reflectance and transmittance for a layer !    with optical depth tau, single scattering albedo w0, and asymmetery parameter g. ! Direct reflectance and transmittance used to compute direct beam source for diffuse radiation !   in layers and at surface; report direct beam as a byproduct ! Computing the direct-beam source for diffuse radiation at the same time as R and T for !   direct radiation reduces memory traffic and use. ! ! Equations are developed in Meador and Weaver, 1980, !    doi:10.1175/1520-0469(1980)037<0630:TSATRT>2.0.CO;2 ! ! ------------------------------------------------------------------------------------------------- pure subroutine sw_dif_and_source ( ncol , nlay , top_at_1 , mu0 , sfc_albedo , & tau , w0 , g , & Rdif , Tdif , source_dn , source_up , source_sfc , flux_dn_dir ) bind ( C , name = \"sw_source_dir\" ) integer , intent ( in ) :: ncol , nlay logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 , sfc_albedo ! surface albedo for direct radiation real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: tau , w0 , g real ( wp ), dimension ( ncol , nlay ), intent ( out ) :: Rdif , Tdif , source_dn , source_up real ( wp ), dimension ( ncol ), intent ( out ) :: source_sfc ! Source function for upward radation at surface real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( inout ) :: flux_dn_dir ! Direct beam flux ! ----------------------- integer :: i , j ! Variables used in Meador and Weaver real ( wp ) :: gamma1 , gamma2 , gamma3 , gamma4 , alpha1 , alpha2 ! Ancillary variables real ( wp ) :: k , exp_minusktau , k_mu , k_gamma3 , k_gamma4 real ( wp ) :: RT_term , exp_minus2ktau real ( wp ) :: Rdir , Tdir , Tnoscat real ( wp ), pointer , dimension (:) :: dir_flux_inc , dir_flux_trans integer :: lay_index real ( wp ) :: tau_s , w0_s , g_s , mu0_s ! --------------------------------- do j = 1 , nlay if ( top_at_1 ) then lay_index = j dir_flux_inc => flux_dn_dir (:, lay_index ) dir_flux_trans => flux_dn_dir (:, lay_index + 1 ) else lay_index = nlay - j + 1 dir_flux_inc => flux_dn_dir (:, lay_index + 1 ) dir_flux_trans => flux_dn_dir (:, lay_index ) end if do i = 1 , ncol ! ! Scalars ! tau_s = tau ( i , lay_index ) w0_s = w0 ( i , lay_index ) g_s = g ( i , lay_index ) mu0_s = mu0 ( i ) ! ! Zdunkowski Practical Improved Flux Method \"PIFM\" !  (Zdunkowski et al., 1980;  Contributions to Atmospheric Physics 53, 147-66) ! gamma1 = ( 8._wp - w0_s * ( 5._wp + 3._wp * g_s )) * . 25_wp gamma2 = 3._wp * ( w0_s * ( 1._wp - g_s )) * . 25_wp gamma3 = ( 2._wp - 3._wp * mu0_s * g_s ) * . 25_wp gamma4 = 1._wp - gamma3 alpha1 = gamma1 * gamma4 + gamma2 * gamma3 ! Eq. 16 alpha2 = gamma1 * gamma3 + gamma2 * gamma4 ! Eq. 17 ! ! Direct reflect and transmission ! ! Eq 18;  k = SQRT(gamma1**2 - gamma2**2), limited below to avoid div by 0. !   k = 0 for isotropic, conservative scattering; this lower limit on k !   gives relative error with respect to conservative solution !   of < 0.1% in Rdif down to tau = 10&#94;-9 k = sqrt ( max (( gamma1 - gamma2 ) * ( gamma1 + gamma2 ), 1.e-12_wp )) k_mu = k * mu0_s k_gamma3 = k * gamma3 k_gamma4 = k * gamma4 exp_minusktau = exp ( - tau_s * k ) exp_minus2ktau = exp_minusktau * exp_minusktau ! Refactored to avoid rounding errors when k, gamma1 are of very different magnitudes RT_term = 1._wp / ( k * ( 1._wp + exp_minus2ktau ) + & gamma1 * ( 1._wp - exp_minus2ktau ) ) ! Equation 25 Rdif ( i , lay_index ) = RT_term * gamma2 * ( 1._wp - exp_minus2ktau ) ! Equation 26 Tdif ( i , lay_index ) = RT_term * 2._wp * k * exp_minusktau ! ! Equation 14, multiplying top and bottom by exp(-k*tau) !   and rearranging to avoid div by 0. ! RT_term = w0_s * RT_term / merge ( 1._wp - k_mu * k_mu , & epsilon ( 1._wp ), & abs ( 1._wp - k_mu * k_mu ) >= epsilon ( 1._wp )) ! ! Transmittance of direct, unscattered beam. ! Tnoscat = exp ( - tau_s / mu0_s ) Rdir = RT_term * & (( 1._wp - k_mu ) * ( alpha2 + k_gamma3 ) - & ( 1._wp + k_mu ) * ( alpha2 - k_gamma3 ) * exp_minus2ktau - & 2.0_wp * ( k_gamma3 - alpha2 * k_mu ) * exp_minusktau * Tnoscat ) ! ! Equation 15, multiplying top and bottom by exp(-k*tau), !   multiplying through by exp(-tau/mu0) to !   prefer underflow to overflow ! Omitting direct transmittance ! Tdir = - RT_term * & (( 1._wp + k_mu ) * ( alpha1 + k_gamma4 ) * Tnoscat - & ( 1._wp - k_mu ) * ( alpha1 - k_gamma4 ) * exp_minus2ktau * Tnoscat - & 2.0_wp * ( k_gamma4 + alpha1 * k_mu ) * exp_minusktau ) source_up ( i , lay_index ) = Rdir * dir_flux_inc ( i ) source_dn ( i , lay_index ) = Tdir * dir_flux_inc ( i ) dir_flux_trans ( i ) = Tnoscat * dir_flux_inc ( i ) end do end do source_sfc (:) = dir_flux_trans (:) * sfc_albedo (:) end subroutine sw_dif_and_source ! --------------------------------------------------------------- ! ! Transport of diffuse radiation through a vertically layered atmosphere. !   Equations are after Shonk and Hogan 2008, doi:10.1175/2007JCLI1940.1 (SH08) !   This routine is shared by longwave and shortwave ! ! ------------------------------------------------------------------------------------------------- subroutine adding ( ncol , nlay , top_at_1 , & albedo_sfc , & rdif , tdif , & src_dn , src_up , src_sfc , & flux_up , flux_dn ) bind ( C , name = \"adding\" ) integer , intent ( in ) :: ncol , nlay logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol ), intent ( in ) :: albedo_sfc real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: rdif , tdif real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: src_dn , src_up real ( wp ), dimension ( ncol ), intent ( in ) :: src_sfc real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: flux_up ! intent(inout) because top layer includes incident flux real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: flux_dn ! ------------------ integer :: ilev real ( wp ), dimension ( ncol , nlay + 1 ) :: albedo , & ! reflectivity to diffuse radiation below this level ! alpha in SH08 src ! source of diffuse upwelling radiation from emission or ! scattering of direct beam ! G in SH08 real ( wp ), dimension ( ncol , nlay ) :: denom ! beta in SH08 ! ------------------ ! ! Indexing into arrays for upward and downward propagation depends on the vertical !   orientation of the arrays (whether the domain top is at the first or last index) ! We write the loops out explicitly so compilers will have no trouble optimizing them. ! if ( top_at_1 ) then ilev = nlay + 1 ! Albedo of lowest level is the surface albedo... albedo (:, ilev ) = albedo_sfc (:) ! ... and source of diffuse radiation is surface emission src (:, ilev ) = src_sfc (:) ! ! From bottom to top of atmosphere -- !   compute albedo and source of upward radiation ! do ilev = nlay , 1 , - 1 denom (:, ilev ) = 1._wp / ( 1._wp - rdif (:, ilev ) * albedo (:, ilev + 1 )) ! Eq 10 albedo (:, ilev ) = rdif (:, ilev ) + & tdif (:, ilev ) * tdif (:, ilev ) * albedo (:, ilev + 1 ) * denom (:, ilev ) ! Equation 9 ! ! Equation 11 -- source is emitted upward radiation at top of layer plus !   radiation emitted at bottom of layer, !   transmitted through the layer and reflected from layers below (tdiff*src*albedo) ! src (:, ilev ) = src_up (:, ilev ) + & tdif (:, ilev ) * denom (:, ilev ) * & ( src (:, ilev + 1 ) + albedo (:, ilev + 1 ) * src_dn (:, ilev )) end do ! Eq 12, at the top of the domain upwelling diffuse is due to ... ilev = 1 flux_up (:, ilev ) = flux_dn (:, ilev ) * albedo (:, ilev ) + & ! ... reflection of incident diffuse and src (:, ilev ) ! emission from below ! ! From the top of the atmosphere downward -- compute fluxes ! do ilev = 2 , nlay + 1 flux_dn (:, ilev ) = ( tdif (:, ilev - 1 ) * flux_dn (:, ilev - 1 ) + & ! Equation 13 rdif (:, ilev - 1 ) * src (:, ilev ) + & src_dn (:, ilev - 1 )) * denom (:, ilev - 1 ) flux_up (:, ilev ) = flux_dn (:, ilev ) * albedo (:, ilev ) + & ! Equation 12 src (:, ilev ) end do else ilev = 1 ! Albedo of lowest level is the surface albedo... albedo (:, ilev ) = albedo_sfc (:) ! ... and source of diffuse radiation is surface emission src (:, ilev ) = src_sfc (:) ! ! From bottom to top of atmosphere -- !   compute albedo and source of upward radiation ! do ilev = 1 , nlay denom (:, ilev ) = 1._wp / ( 1._wp - rdif (:, ilev ) * albedo (:, ilev )) ! Eq 10 albedo (:, ilev + 1 ) = rdif (:, ilev ) + & tdif (:, ilev ) * tdif (:, ilev ) * albedo (:, ilev ) * denom (:, ilev ) ! Equation 9 ! ! Equation 11 -- source is emitted upward radiation at top of layer plus !   radiation emitted at bottom of layer, !   transmitted through the layer and reflected from layers below (tdiff*src*albedo) ! src (:, ilev + 1 ) = src_up (:, ilev ) + & tdif (:, ilev ) * denom (:, ilev ) * & ( src (:, ilev ) + albedo (:, ilev ) * src_dn (:, ilev )) end do ! Eq 12, at the top of the domain upwelling diffuse is due to ... ilev = nlay + 1 flux_up (:, ilev ) = flux_dn (:, ilev ) * albedo (:, ilev ) + & ! ... reflection of incident diffuse and src (:, ilev ) ! scattering by the direct beam below ! ! From the top of the atmosphere downward -- compute fluxes ! do ilev = nlay , 1 , - 1 flux_dn (:, ilev ) = ( tdif (:, ilev ) * flux_dn (:, ilev + 1 ) + & ! Equation 13 rdif (:, ilev ) * src (:, ilev ) + & src_dn (:, ilev )) * denom (:, ilev ) flux_up (:, ilev ) = flux_dn (:, ilev ) * albedo (:, ilev ) + & ! Equation 12 src (:, ilev ) end do end if end subroutine adding end module mo_rte_solver_kernels","tags":"","loc":"sourcefile/mo_rte_solver_kernels.f90.html"},{"title":"mo_gas_optics_kernels.F90 – rte-rrtmgp","text":"Contents Modules mo_gas_optics_kernels Source Code mo_gas_optics_kernels.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2015,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! Description: Numeric calculations for gas optics. Absorption and Rayleigh optical depths, !   source functions. module mo_gas_optics_kernels use mo_rte_kind , only : wp , wl use mo_rte_util_array , only : zero_array implicit none public contains ! -------------------------------------------------------------------------------------- ! Compute interpolation coefficients ! for calculations of major optical depths, minor optical depths, Rayleigh, ! and Planck fractions subroutine interpolation ( & ncol , nlay , ngas , nflav , neta , npres , ntemp , & flavor , & press_ref_log , temp_ref , press_ref_log_delta , & temp_ref_min , temp_ref_delta , press_ref_trop_log , & vmr_ref , & play , tlay , col_gas , & jtemp , fmajor , fminor , col_mix , tropo , jeta , jpress ) bind ( C , name = \"interpolation\" ) ! input dimensions integer , intent ( in ) :: ncol , nlay integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , dimension ( 2 , nflav ), intent ( in ) :: flavor real ( wp ), dimension ( npres ), intent ( in ) :: press_ref_log real ( wp ), dimension ( ntemp ), intent ( in ) :: temp_ref real ( wp ), intent ( in ) :: press_ref_log_delta , & temp_ref_min , temp_ref_delta , & press_ref_trop_log real ( wp ), dimension ( 2 , 0 : ngas , ntemp ), intent ( in ) :: vmr_ref ! inputs from profile or parent function real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas ! outputs integer , dimension ( ncol , nlay ), intent ( out ) :: jtemp , jpress logical ( wl ), dimension ( ncol , nlay ), intent ( out ) :: tropo integer , dimension ( 2 , ncol , nlay , nflav ), intent ( out ) :: jeta real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( out ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( out ) :: fmajor real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( out ) :: fminor ! ----------------- ! local real ( wp ), dimension ( ncol , nlay ) :: ftemp , fpress ! interpolation fraction for temperature, pressure real ( wp ) :: locpress ! needed to find location in pressure grid real ( wp ) :: ratio_eta_half ! ratio of vmrs of major species that defines eta=0.5 ! for given flavor and reference temperature level real ( wp ) :: eta , feta ! binary_species_parameter, interpolation variable for eta real ( wp ) :: loceta ! needed to find location in eta grid real ( wp ) :: ftemp_term ! ----------------- ! local indexes integer :: icol , ilay , iflav , igases ( 2 ), itropo , itemp !$acc data copyin(flavor,press_ref_log,temp_ref,vmr_ref,play,tlay,col_gas) & !$acc      copyout(jtemp,jpress,tropo,jeta,col_mix,fmajor,fminor) & !$acc      create(ftemp,fpress) !$omp target data map(to:flavor, press_ref_log, temp_ref, vmr_ref, play, tlay, col_gas) & !$omp             map(alloc:jtemp, jpress, tropo, jeta, col_mix, fmajor, fminor) & !$omp             map(alloc:ftemp, fpress) !$acc parallel loop gang vector collapse(2) default(none) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol ! index and factor for temperature interpolation jtemp ( icol , ilay ) = int (( tlay ( icol , ilay ) - ( temp_ref_min - temp_ref_delta )) / temp_ref_delta ) jtemp ( icol , ilay ) = min ( ntemp - 1 , max ( 1 , jtemp ( icol , ilay ))) ! limit the index range ftemp ( icol , ilay ) = ( tlay ( icol , ilay ) - temp_ref ( jtemp ( icol , ilay ))) / temp_ref_delta ! index and factor for pressure interpolation locpress = 1._wp + ( log ( play ( icol , ilay )) - press_ref_log ( 1 )) / press_ref_log_delta jpress ( icol , ilay ) = min ( npres - 1 , max ( 1 , int ( locpress ))) fpress ( icol , ilay ) = locpress - float ( jpress ( icol , ilay )) ! determine if in lower or upper part of atmosphere tropo ( icol , ilay ) = log ( play ( icol , ilay )) > press_ref_trop_log end do end do ! loop over implemented combinations of major species ! PGI BUG WORKAROUND: if present(vmr_ref) isn't there, OpenACC runtime ! thinks it isn't present. !$acc parallel loop gang vector collapse(4) default(none) private(igases) present(vmr_ref) !$omp target teams distribute parallel do simd collapse(4) private(igases) do iflav = 1 , nflav do ilay = 1 , nlay ! loop over implemented combinations of major species do icol = 1 , ncol do itemp = 1 , 2 igases (:) = flavor (:, iflav ) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! compute interpolation fractions needed for lower, then upper reference temperature level ! compute binary species parameter (eta) for flavor and temperature and !  associated interpolation index and factors ratio_eta_half = vmr_ref ( itropo , igases ( 1 ),( jtemp ( icol , ilay ) + itemp - 1 )) / & vmr_ref ( itropo , igases ( 2 ),( jtemp ( icol , ilay ) + itemp - 1 )) col_mix ( itemp , icol , ilay , iflav ) = col_gas ( icol , ilay , igases ( 1 )) + ratio_eta_half * col_gas ( icol , ilay , igases ( 2 )) eta = merge ( col_gas ( icol , ilay , igases ( 1 )) / col_mix ( itemp , icol , ilay , iflav ), 0.5_wp , & col_mix ( itemp , icol , ilay , iflav ) > 2._wp * tiny ( col_mix )) loceta = eta * float ( neta - 1 ) jeta ( itemp , icol , ilay , iflav ) = min ( int ( loceta ) + 1 , neta - 1 ) feta = mod ( loceta , 1.0_wp ) ! compute interpolation fractions needed for minor species ! ftemp_term = (1._wp-ftemp(icol,ilay)) for itemp = 1, ftemp(icol,ilay) for itemp=2 ftemp_term = ( real ( 2 - itemp , wp ) + real ( 2 * itemp - 3 , wp ) * ftemp ( icol , ilay )) fminor ( 1 , itemp , icol , ilay , iflav ) = ( 1._wp - feta ) * ftemp_term fminor ( 2 , itemp , icol , ilay , iflav ) = feta * ftemp_term ! compute interpolation fractions needed for major species fmajor ( 1 , 1 , itemp , icol , ilay , iflav ) = ( 1._wp - fpress ( icol , ilay )) * fminor ( 1 , itemp , icol , ilay , iflav ) fmajor ( 2 , 1 , itemp , icol , ilay , iflav ) = ( 1._wp - fpress ( icol , ilay )) * fminor ( 2 , itemp , icol , ilay , iflav ) fmajor ( 1 , 2 , itemp , icol , ilay , iflav ) = fpress ( icol , ilay ) * fminor ( 1 , itemp , icol , ilay , iflav ) fmajor ( 2 , 2 , itemp , icol , ilay , iflav ) = fpress ( icol , ilay ) * fminor ( 2 , itemp , icol , ilay , iflav ) end do ! reference temperatures end do ! icol end do ! ilay end do ! iflav !$acc end data !$omp end target data end subroutine interpolation ! -------------------------------------------------------------------------------------- ! ! Compute minor and major species opitcal depth from pre-computed interpolation coefficients !   (jeta,jtemp,jpress) ! subroutine compute_tau_absorption ( & ncol , nlay , nbnd , ngpt , & ! dimensions ngas , nflav , neta , npres , ntemp , & nminorlower , nminorklower , & ! number of minor contributors, total num absorption coeffs nminorupper , nminorkupper , & idx_h2o , & gpoint_flavor , & band_lims_gpt , & kmajor , & kminor_lower , & kminor_upper , & minor_limits_gpt_lower , & minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scale_by_complement_lower , & scale_by_complement_upper , & idx_minor_lower , & idx_minor_upper , & idx_minor_scaling_lower , & idx_minor_scaling_upper , & kminor_start_lower , & kminor_start_upper , & tropo , & col_mix , fmajor , fminor , & play , tlay , col_gas , & jeta , jtemp , jpress , & tau ) bind ( C , name = \"compute_tau_absorption\" ) ! --------------------- ! input dimensions integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , intent ( in ) :: nminorlower , nminorklower , nminorupper , nminorkupper integer , intent ( in ) :: idx_h2o ! --------------------- ! inputs from object integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: kmajor real ( wp ), dimension ( ntemp , neta , nminorklower ), intent ( in ) :: kminor_lower real ( wp ), dimension ( ntemp , neta , nminorkupper ), intent ( in ) :: kminor_upper integer , dimension ( 2 , nminorlower ), intent ( in ) :: minor_limits_gpt_lower integer , dimension ( 2 , nminorupper ), intent ( in ) :: minor_limits_gpt_upper logical ( wl ), dimension ( nminorlower ), intent ( in ) :: minor_scales_with_density_lower logical ( wl ), dimension ( nminorupper ), intent ( in ) :: minor_scales_with_density_upper logical ( wl ), dimension ( nminorlower ), intent ( in ) :: scale_by_complement_lower logical ( wl ), dimension ( nminorupper ), intent ( in ) :: scale_by_complement_upper integer , dimension ( nminorlower ), intent ( in ) :: idx_minor_lower integer , dimension ( nminorupper ), intent ( in ) :: idx_minor_upper integer , dimension ( nminorlower ), intent ( in ) :: idx_minor_scaling_lower integer , dimension ( nminorupper ), intent ( in ) :: idx_minor_scaling_upper integer , dimension ( nminorlower ), intent ( in ) :: kminor_start_lower integer , dimension ( nminorupper ), intent ( in ) :: kminor_start_upper logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo ! --------------------- ! inputs from profile or parent function real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay ! pressure and temperature real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp integer , dimension ( ncol , nlay ), intent ( in ) :: jpress ! --------------------- ! output - optical depth real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! --------------------- ! Local variables ! logical ( wl ) :: top_at_1 integer , dimension ( ncol , 2 ) :: itropo_lower , itropo_upper integer :: icol , idx_tropo ! ---------------------------------------------------------------- !$acc enter data create(itropo_lower, itropo_upper) !$omp target enter data map(alloc:itropo_lower, itropo_upper) !$acc enter data copyin(play, tlay, tropo, gpoint_flavor, jeta, jtemp, col_gas, fminor, tau) !$omp target enter data map(to:play, tlay, tropo, gpoint_flavor, jeta, jtemp, col_gas, fminor, tau) ! --------------------- ! Layer limits of upper, lower atmospheres ! --------------------- !$acc kernels copyout(top_at_1) !$omp target map(from:top_at_1) top_at_1 = play ( 1 , 1 ) < play ( 1 , nlay ) !$acc end kernels !$omp end target if ( top_at_1 ) then !$acc parallel loop !$omp target teams distribute parallel do simd do icol = 1 , ncol itropo_lower ( icol , 2 ) = nlay #if defined(_CRAYFTN) || defined(__NVCOMPILER) itropo_upper ( icol , 1 ) = 1 call minmaxloc ( icol , tropo , play , itropo_lower ( icol , 1 ), itropo_upper ( icol , 2 )) #else itropo_lower ( icol , 1 ) = minloc ( play ( icol ,:), dim = 1 , mask = tropo ( icol ,:)) itropo_upper ( icol , 1 ) = 1 itropo_upper ( icol , 2 ) = maxloc ( play ( icol ,:), dim = 1 , mask = (. not . tropo ( icol ,:))) #endif end do else !$acc parallel loop !$omp target teams distribute parallel do simd do icol = 1 , ncol itropo_lower ( icol , 1 ) = 1 #if defined(_CRAYFTN) || defined(__NVCOMPILER) itropo_upper ( icol , 2 ) = nlay call minmaxloc ( icol , tropo , play , itropo_lower ( icol , 2 ), itropo_upper ( icol , 1 )) #else itropo_lower ( icol , 2 ) = minloc ( play ( icol ,:), dim = 1 , mask = tropo ( icol ,:)) itropo_upper ( icol , 2 ) = nlay itropo_upper ( icol , 1 ) = maxloc ( play ( icol ,:), dim = 1 , mask = (. not . tropo ( icol ,:))) #endif end do end if ! --------------------- ! Major Species ! --------------------- call gas_optical_depths_major ( & ncol , nlay , nbnd , ngpt , & ! dimensions nflav , neta , npres , ntemp , & gpoint_flavor , & band_lims_gpt , & kmajor , & col_mix , fmajor , & jeta , tropo , jtemp , jpress , & tau ) ! --------------------- ! Minor Species - lower ! --------------------- idx_tropo = 1 call gas_optical_depths_minor ( & ncol , nlay , ngpt , & ! dimensions ngas , nflav , ntemp , neta , & nminorlower , nminorklower , & idx_h2o , idx_tropo , & gpoint_flavor , & kminor_lower , & minor_limits_gpt_lower , & minor_scales_with_density_lower , & scale_by_complement_lower , & idx_minor_lower , & idx_minor_scaling_lower , & kminor_start_lower , & play , tlay , & col_gas , fminor , jeta , & itropo_lower , jtemp , & tau ) ! --------------------- ! Minor Species - upper ! --------------------- idx_tropo = 2 call gas_optical_depths_minor ( & ncol , nlay , ngpt , & ! dimensions ngas , nflav , ntemp , neta , & nminorupper , nminorkupper , & idx_h2o , idx_tropo , & gpoint_flavor , & kminor_upper , & minor_limits_gpt_upper , & minor_scales_with_density_upper , & scale_by_complement_upper , & idx_minor_upper , & idx_minor_scaling_upper , & kminor_start_upper , & play , tlay , & col_gas , fminor , jeta , & itropo_upper , jtemp , & tau ) !$acc exit data delete(itropo_lower,itropo_upper) !$omp target exit data map(release:itropo_lower, itropo_upper) !$acc exit data delete(play, tlay, tropo, gpoint_flavor, jeta, jtemp, col_gas, fminor) !$omp target exit data map(release:play, tlay, tropo, gpoint_flavor, jeta, jtemp, col_gas, fminor) !$acc exit data copyout(tau) !$omp target exit data map(from:tau) end subroutine compute_tau_absorption ! -------------------------------------------------------------------------------------- ! -------------------------------------------------------------------------------------- ! ! compute minor species optical depths ! subroutine gas_optical_depths_major ( ncol , nlay , nbnd , ngpt ,& nflav , neta , npres , ntemp , & ! dimensions gpoint_flavor , band_lims_gpt , & ! inputs from object kmajor , & col_mix , fmajor , & jeta , tropo , jtemp , jpress , & ! local input tau ) bind ( C , name = \"gas_optical_depths_major\" ) ! input dimensions integer , intent ( in ) :: ncol , nlay , nbnd , ngpt , nflav , neta , npres , ntemp ! dimensions ! inputs from object integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: kmajor ! inputs from profile or parent function real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress ! outputs real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! ----------------- ! local variables real ( wp ) :: tau_major ! major species optical depth ! local index integer :: icol , ilay , iflav , igpt , itropo ! ----------------- ! ----------------- ! optical depth calculation for major species !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol !$acc loop seq do igpt = 1 , ngpt ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! WS: moved inside innermost loop ! binary species parameter (eta) and col_mix depend on band flavor iflav = gpoint_flavor ( itropo , igpt ) tau_major = & ! interpolation in temperature, pressure, and eta interpolate3D ( col_mix (:, icol , ilay , iflav ), & fmajor (:,:,:, icol , ilay , iflav ), kmajor , & igpt , jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay ), jpress ( icol , ilay ) + itropo ) tau ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) + tau_major end do ! igpt end do end do ! ilay end subroutine gas_optical_depths_major ! ---------------------------------------------------------- ! ! compute minor species optical depths ! subroutine gas_optical_depths_minor ( ncol , nlay , ngpt , & ngas , nflav , ntemp , neta , & nminor , nminork , & idx_h2o , idx_tropo , & gpt_flv , & kminor , & minor_limits_gpt , & minor_scales_with_density , & scale_by_complement , & idx_minor , idx_minor_scaling , & kminor_start , & play , tlay , & col_gas , fminor , jeta , & layer_limits , jtemp , & tau ) bind ( C , name = \"gas_optical_depths_minor\" ) integer , intent ( in ) :: ncol , nlay , ngpt integer , intent ( in ) :: ngas , nflav integer , intent ( in ) :: ntemp , neta , nminor , nminork integer , intent ( in ) :: idx_h2o , idx_tropo integer , dimension ( 2 , ngpt ), intent ( in ) :: gpt_flv real ( wp ), dimension ( ntemp , neta , nminork ), intent ( in ) :: kminor integer , dimension ( 2 , nminor ), intent ( in ) :: minor_limits_gpt logical ( wl ), dimension ( nminor ), intent ( in ) :: minor_scales_with_density logical ( wl ), dimension ( nminor ), intent ( in ) :: scale_by_complement integer , dimension ( nminor ), intent ( in ) :: kminor_start integer , dimension ( nminor ), intent ( in ) :: idx_minor , idx_minor_scaling real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta integer , dimension ( ncol , 2 ), intent ( in ) :: layer_limits integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! ----------------- ! local variables real ( wp ), parameter :: PaTohPa = 0.01_wp real ( wp ) :: vmr_fact , dry_fact ! conversion from column abundance to dry vol. mixing ratio; real ( wp ) :: scaling , kminor_loc , tau_minor ! minor species absorption coefficient, optical depth integer :: icol , ilay , iflav , igpt , imnr integer :: minor_start , minor_loc , extent real ( wp ) :: myplay , mytlay , mycol_gas_h2o , mycol_gas_imnr , mycol_gas_0 real ( wp ) :: myfminor ( 2 , 2 ) integer :: myjtemp , myjeta ( 2 ) ! ----------------- extent = size ( scale_by_complement , dim = 1 ) !$acc parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol ! ! This check skips individual columns with no pressures in range ! if ( layer_limits ( icol , 1 ) <= 0 . or . ilay < layer_limits ( icol , 1 ) . or . ilay > layer_limits ( icol , 2 ) ) cycle myplay = play ( icol , ilay ) mytlay = tlay ( icol , ilay ) myjtemp = jtemp ( icol , ilay ) mycol_gas_h2o = col_gas ( icol , ilay , idx_h2o ) mycol_gas_0 = col_gas ( icol , ilay , 0 ) !$acc loop seq do imnr = 1 , extent ! What is the starting point in the stored array of minor absorption coefficients? minor_start = kminor_start ( imnr ) !$acc loop seq do igpt = minor_limits_gpt ( 1 , imnr ), minor_limits_gpt ( 2 , imnr ) scaling = col_gas ( icol , ilay , idx_minor ( imnr )) if ( minor_scales_with_density ( imnr )) then ! ! NOTE: P needed in hPa to properly handle density scaling. ! scaling = scaling * ( PaTohPa * myplay / mytlay ) if ( idx_minor_scaling ( imnr ) > 0 ) then ! there is a second gas that affects this gas's absorption mycol_gas_imnr = col_gas ( icol , ilay , idx_minor_scaling ( imnr )) vmr_fact = 1._wp / mycol_gas_0 dry_fact = 1._wp / ( 1._wp + mycol_gas_h2o * vmr_fact ) ! scale by density of special gas if ( scale_by_complement ( imnr )) then ! scale by densities of all gases but the special one scaling = scaling * ( 1._wp - mycol_gas_imnr * vmr_fact * dry_fact ) else scaling = scaling * ( mycol_gas_imnr * vmr_fact * dry_fact ) endif endif endif ! ! Interpolation of absorption coefficient and calculation of optical depth ! tau_minor = 0._wp iflav = gpt_flv ( idx_tropo , igpt ) ! eta interpolation depends on flavor minor_loc = minor_start + ( igpt - minor_limits_gpt ( 1 , imnr )) ! add offset to starting point kminor_loc = interpolate2D ( fminor (:,:, icol , ilay , iflav ), kminor , minor_loc , & jeta (:, icol , ilay , iflav ), myjtemp ) tau_minor = kminor_loc * scaling tau ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) + tau_minor enddo enddo enddo enddo end subroutine gas_optical_depths_minor ! ---------------------------------------------------------- ! ! compute Rayleigh scattering optical depths ! subroutine compute_tau_rayleigh ( ncol , nlay , nbnd , ngpt , & ngas , nflav , neta , npres , ntemp , & gpoint_flavor , band_lims_gpt , & krayl , & idx_h2o , col_dry , col_gas , & fminor , jeta , tropo , jtemp , & tau_rayleigh ) bind ( C , name = \"compute_tau_rayleigh\" ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), dimension ( ntemp , neta , ngpt , 2 ), intent ( in ) :: krayl integer , intent ( in ) :: idx_h2o real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: col_dry real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp ! outputs real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: tau_rayleigh ! ----------------- ! local variables real ( wp ) :: k ! rayleigh scattering coefficient integer :: icol , ilay , iflav , igpt integer :: itropo ! ----------------- !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol !$acc loop seq do igpt = 1 , ngpt itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere iflav = gpoint_flavor ( itropo , igpt ) k = interpolate2D ( fminor (:,:, icol , ilay , iflav ), & krayl (:,:,:, itropo ), & igpt , jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay )) tau_rayleigh ( icol , ilay , igpt ) = k * ( col_gas ( icol , ilay , idx_h2o ) + col_dry ( icol , ilay )) end do end do end do end subroutine compute_tau_rayleigh ! ---------------------------------------------------------- subroutine compute_Planck_source ( & ncol , nlay , nbnd , ngpt , & nflav , neta , npres , ntemp , nPlanckTemp ,& tlay , tlev , tsfc , sfc_lay , & fmajor , jeta , tropo , jtemp , jpress , & gpoint_bands , band_lims_gpt , & pfracin , temp_ref_min , totplnk_delta , totplnk , gpoint_flavor , & sfc_src , lay_src , lev_src_inc , lev_src_dec , sfc_source_Jac ) bind ( C , name = \"compute_Planck_source\" ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: nflav , neta , npres , ntemp , nPlanckTemp real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: tlay real ( wp ), dimension ( ncol , nlay + 1 ), intent ( in ) :: tlev real ( wp ), dimension ( ncol ), intent ( in ) :: tsfc integer , intent ( in ) :: sfc_lay ! Interpolation variables real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress ! Table-specific integer , dimension ( ngpt ), intent ( in ) :: gpoint_bands ! start and end g-point for each band integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), intent ( in ) :: temp_ref_min , totplnk_delta real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: pfracin real ( wp ), dimension ( nPlanckTemp , nbnd ), intent ( in ) :: totplnk integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: sfc_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: lay_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: lev_src_inc , lev_src_dec real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: sfc_source_Jac ! ----------------- ! local real ( wp ), parameter :: delta_Tsurf = 1.0_wp integer :: ilay , icol , igpt , ibnd , itropo , iflav integer :: gptS , gptE real ( wp ), dimension ( 2 ), parameter :: one = [ 1._wp , 1._wp ] real ( wp ) :: pfrac real ( wp ) :: planck_function_1 , planck_function_2 ! ----------------- !$acc        data copyin(   tlay,tlev,tsfc,fmajor,jeta,tropo,jtemp,jpress,gpoint_bands,pfracin,totplnk,gpoint_flavor) & !$acc             copyout(  sfc_src,lay_src,lev_src_inc,lev_src_dec,sfc_source_Jac) !$omp target data map(   to:tlay,tlev,tsfc,fmajor,jeta,tropo,jtemp,jpress,gpoint_bands,pfracin,totplnk,gpoint_flavor) & !$omp             map(from: sfc_src,lay_src,lev_src_inc,lev_src_dec,sfc_source_Jac) ! Calculation of fraction of band's Planck irradiance associated with each g-point !$acc parallel loop tile(128,2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol !$acc loop seq do igpt = 1 , ngpt ibnd = gpoint_bands ( igpt ) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) !WS moved itropo inside loop for GPU iflav = gpoint_flavor ( itropo , igpt ) !eta interpolation depends on band's flavor pfrac = & ! interpolation in temperature, pressure, and eta interpolate3D ( one , fmajor (:,:,:, icol , ilay , iflav ), pfracin , & igpt , jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay ), jpress ( icol , ilay ) + itropo ) ! Compute layer source irradiance for g-point, equals band irradiance x fraction for g-point planck_function_1 = interpolate1D ( tlay ( icol , ilay ), temp_ref_min , totplnk_delta , totplnk (:, ibnd )) lay_src ( icol , ilay , igpt ) = pfrac * planck_function_1 ! Compute layer source irradiance for g-point, equals band irradiance x fraction for g-point planck_function_1 = interpolate1D ( tlev ( icol , ilay ), temp_ref_min , totplnk_delta , totplnk (:, ibnd )) planck_function_2 = interpolate1D ( tlev ( icol , ilay + 1 ), temp_ref_min , totplnk_delta , totplnk (:, ibnd )) lev_src_dec ( icol , ilay , igpt ) = pfrac * planck_function_1 lev_src_inc ( icol , ilay , igpt ) = pfrac * planck_function_2 if ( ilay == sfc_lay ) then planck_function_1 = interpolate1D ( tsfc ( icol ) , temp_ref_min , totplnk_delta , totplnk (:, ibnd )) planck_function_2 = interpolate1D ( tsfc ( icol ) + delta_Tsurf , temp_ref_min , totplnk_delta , totplnk (:, ibnd )) sfc_src ( icol , igpt ) = pfrac * planck_function_1 sfc_source_Jac ( icol , igpt ) = pfrac * ( planck_function_2 - planck_function_1 ) end if end do ! igpt end do ! icol end do ! ilay !$acc end        data !$omp end target data end subroutine compute_Planck_source ! ---------------------------------------------------------- ! ! One dimensional interpolation ! function interpolate1D ( val , offset , delta , table ) result ( res ) !$acc routine seq !$omp declare target ! input real ( wp ), intent ( in ) :: val , & ! axis value at which to evaluate table offset , & ! minimum of table axis delta ! step size of table axis real ( wp ), dimension (:), & intent ( in ) :: table ! dimensions (axis, values) ! output real ( wp ) :: res ! local real ( wp ) :: val0 ! fraction index adjusted by offset and delta integer :: index ! index term real ( wp ) :: frac ! fractional term ! ------------------------------------- val0 = ( val - offset ) / delta frac = val0 - int ( val0 ) ! get fractional part index = min ( size ( table , dim = 1 ) - 1 , max ( 1 , int ( val0 ) + 1 )) ! limit the index range res = table ( index ) + frac * ( table ( index + 1 ) - table ( index )) end function interpolate1D ! ------------ !   This function returns a single value from a subset (in gpoint) of the k table ! function interpolate2D ( fminor , k , igpt , jeta , jtemp ) result ( res ) !$acc routine seq !$omp declare target real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: fminor ! interpolation fractions for minor species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference temperature level real ( wp ), dimension (:,:,:), intent ( in ) :: k ! (g-point, eta, temp) integer , intent ( in ) :: igpt , jtemp ! interpolation index for temperature integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) real ( wp ) :: res ! the result res = & fminor ( 1 , 1 ) * k ( jtemp , jeta ( 1 ) , igpt ) + & fminor ( 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , igpt ) + & fminor ( 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , igpt ) + & fminor ( 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , igpt ) end function interpolate2D ! ---------------------------------------------------------- ! interpolation in temperature, pressure, and eta function interpolate3D ( scaling , fmajor , k , igpt , jeta , jtemp , jpress ) result ( res ) !$acc routine seq !$omp declare target real ( wp ), dimension ( 2 ), intent ( in ) :: scaling real ( wp ), dimension ( 2 , 2 , 2 ), intent ( in ) :: fmajor ! interpolation fractions for major species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference pressure level ! index(3) : reference temperature level real ( wp ), dimension (:,:,:,:), intent ( in ) :: k ! (gpt, eta,temp,press) integer , intent ( in ) :: igpt integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) integer , intent ( in ) :: jtemp ! interpolation index for temperature integer , intent ( in ) :: jpress ! interpolation index for pressure real ( wp ) :: res ! the result ! each code block is for a different reference temperature res = & scaling ( 1 ) * & ( fmajor ( 1 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress , igpt ) ) + & scaling ( 2 ) * & ( fmajor ( 1 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress , igpt ) ) end function interpolate3D ! ---------------------------------------------------------- ! ! In-house subroutine for handling minloc and maxloc for ! compilers which do not support GPU versions ! subroutine minmaxloc ( i , mask , a , minl , maxl ) implicit none !$acc routine seq !$omp declare target integer :: i , minl , maxl logical ( wl ) :: mask (:,:) real ( wp ) :: a (:,:) integer :: j , n real ( wp ) :: aij , amax , amin n = size ( a , 2 ) amax = - huge ( amax ) amin = huge ( amin ) do j = 1 , n aij = a ( i , j ) if ( mask ( i , j )) then if ( aij . lt . amin ) then amin = aij minl = j end if else if ( aij . gt . amax ) then amax = aij maxl = j end if end if end do end subroutine ! ---------------------------------------------------------- end module mo_gas_optics_kernels","tags":"","loc":"sourcefile/mo_gas_optics_kernels.f90~2.html"},{"title":"mo_optical_props_kernels.F90 – rte-rrtmgp","text":"Contents Modules mo_optical_props_kernels Source Code mo_optical_props_kernels.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2015-2016,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Description:  Addition of optical properties -- the first set are incremented by the second set. !   There are three possible representations of optical properties (scalar = optical depth only; !   two-stream = tau, single-scattering albedo, and asymmetry factor g, and !   n-stream = tau, ssa, and phase function moments p.) Thus we need nine routines, three for !   each choice of representation on the left hand side times three representations of the !   optical properties to be added. !   There are two sets of these nine routines. In the first the two sets of optical !   properties are defined at the same spectral resolution. There is also a set of routines !   to add properties defined at lower spectral resolution to a set defined at higher spectral !   resolution (adding properties defined by band to those defined by g-point) module mo_optical_props_kernels use , intrinsic :: iso_c_binding use mo_rte_kind , only : wp , wl implicit none public interface delta_scale_2str_kernel module procedure delta_scale_2str_f_k , delta_scale_2str_k end interface interface extract_subset module procedure extract_subset_dim1_3d , extract_subset_dim2_4d module procedure extract_subset_absorption_tau end interface extract_subset real ( wp ), parameter , private :: eps = 3.0_wp * tiny ( 1.0_wp ) contains ! ------------------------------------------------------------------------------------------------- ! ! Delta-scaling, provided only for two-stream properties at present ! ! ------------------------------------------------------------------------------------------------- ! Delta-scale !   user-provided value of f (forward scattering) ! subroutine delta_scale_2str_f_k ( ncol , nlay , ngpt , tau , ssa , g , f ) & bind ( C , name = \"delta_scale_2str_f_k\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau , ssa , g real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: f real ( wp ) :: wf integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copy(ssa(:ncol,:nlay,:ngpt),tau(:ncol,:nlay,:ngpt)) & !$acc&     copyin(f(:ncol,:nlay,:ngpt)) & !$acc&     copy(g(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:ssa, tau) & !$omp& map(to:f) & !$omp& map(tofrom:g) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol if ( tau ( icol , ilay , igpt ) > eps ) then wf = ssa ( icol , ilay , igpt ) * f ( icol , ilay , igpt ) tau ( icol , ilay , igpt ) = ( 1._wp - wf ) * tau ( icol , ilay , igpt ) ssa ( icol , ilay , igpt ) = ( ssa ( icol , ilay , igpt ) - wf ) / ( 1.0_wp - wf ) g ( icol , ilay , igpt ) = ( g ( icol , ilay , igpt ) - f ( icol , ilay , igpt )) / ( 1._wp - f ( icol , ilay , igpt )) end if end do end do end do end subroutine delta_scale_2str_f_k ! --------------------------------- ! Delta-scale !   f = g*g ! subroutine delta_scale_2str_k ( ncol , nlay , ngpt , tau , ssa , g ) & bind ( C , name = \"delta_scale_2str_k\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau , ssa , g real ( wp ) :: f , wf integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copy(tau(:ncol,:nlay,:ngpt),ssa(:ncol,:nlay,:ngpt),g(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau, ssa, g) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol if ( tau ( icol , ilay , igpt ) > eps ) then f = g ( icol , ilay , igpt ) * g ( icol , ilay , igpt ) wf = ssa ( icol , ilay , igpt ) * f tau ( icol , ilay , igpt ) = ( 1._wp - wf ) * tau ( icol , ilay , igpt ) ssa ( icol , ilay , igpt ) = ( ssa ( icol , ilay , igpt ) - wf ) / ( 1.0_wp - wf ) g ( icol , ilay , igpt ) = ( g ( icol , ilay , igpt ) - f ) / ( 1.0_wp - f ) end if end do end do end do end subroutine delta_scale_2str_k ! ------------------------------------------------------------------------------------------------- ! ! Addition of optical properties: the first set are incremented by the second set. ! !   There are three possible representations of optical properties (scalar = optical depth only; !   two-stream = tau, single-scattering albedo, and asymmetry factor g, and !   n-stream = tau, ssa, and phase function moments p.) Thus we need nine routines, three for !   each choice of representation on the left hand side times three representations of the !   optical properties to be added. ! !   There are two sets of these nine routines. In the first the two sets of optical !   properties are defined at the same spectral resolution. There is also a set of routines !   to add properties defined at lower spectral resolution to a set defined at higher spectral !   resolution (adding properties defined by band to those defined by g-point) ! ! ------------------------------------------------------------------------------------------------- subroutine increment_1scalar_by_1scalar ( ncol , nlay , ngpt , & tau1 , & tau2 ) bind ( C , name = \"increment_1scalar_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) end do end do end do end subroutine increment_1scalar_by_1scalar ! --------------------------------- ! increment 1scalar by 2stream subroutine increment_1scalar_by_2stream ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 ) bind ( C , name = \"increment_1scalar_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) & !$omp& map(to:ssa2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ( 1._wp - ssa2 ( icol , ilay , igpt )) end do end do end do end subroutine increment_1scalar_by_2stream ! --------------------------------- ! increment 1scalar by nstream subroutine increment_1scalar_by_nstream ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 ) bind ( C , name = \"increment_1scalar_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) & !$omp& map(to:ssa2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ( 1._wp - ssa2 ( icol , ilay , igpt )) end do end do end do end subroutine increment_1scalar_by_nstream ! --------------------------------- ! --------------------------------- ! increment 2stream by 1scalar subroutine increment_2stream_by_1scalar ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 ) bind ( C , name = \"increment_2stream_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt real ( wp ) :: tau12 ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:ssa1) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) if ( tau12 > eps ) then ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / tau12 tau1 ( icol , ilay , igpt ) = tau12 ! g is unchanged end if end do end do end do end subroutine increment_2stream_by_1scalar ! --------------------------------- ! increment 2stream by 2stream subroutine increment_2stream_by_2stream ( ncol , nlay , ngpt , & tau1 , ssa1 , g1 , & tau2 , ssa2 , g2 ) bind ( C , name = \"increment_2stream_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 , g2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(g2(:ncol,:nlay,:ngpt)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt),tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt),g1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:g2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:ssa2, tau2) & !$omp& map(tofrom:tau1, g1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) if ( tauscat12 > eps ) then g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * g2 ( icol , ilay , igpt )) & / tauscat12 ssa1 ( icol , ilay , igpt ) = tauscat12 / tau12 tau1 ( icol , ilay , igpt ) = tau12 end if end do end do end do end subroutine increment_2stream_by_2stream ! --------------------------------- ! increment 2stream by nstream subroutine increment_2stream_by_nstream ( ncol , nlay , ngpt , nmom2 , & tau1 , ssa1 , g1 , & tau2 , ssa2 , p2 ) bind ( C , name = \"increment_2stream_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom2 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , ngpt ), intent ( in ) :: p2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(p2(:1,:ncol,:nlay,:ngpt)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt),tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt),g1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:p2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:ssa2, tau2) & !$omp& map(tofrom:tau1, g1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) if ( tauscat12 > eps ) then g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * p2 ( 1 , icol , ilay , igpt )) / tauscat12 ssa1 ( icol , ilay , igpt ) = tauscat12 / tau12 tau1 ( icol , ilay , igpt ) = tau12 end if end do end do end do end subroutine increment_2stream_by_nstream ! --------------------------------- ! --------------------------------- ! increment nstream by 1scalar subroutine increment_nstream_by_1scalar ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 ) bind ( C , name = \"increment_nstream_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt real ( wp ) :: tau12 ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:ssa1) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) if ( tau12 > eps ) then ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / tau12 tau1 ( icol , ilay , igpt ) = tau12 ! p is unchanged end if end do end do end do end subroutine increment_nstream_by_1scalar ! --------------------------------- ! increment nstream by 2stream subroutine increment_nstream_by_2stream ( ncol , nlay , ngpt , nmom1 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , g2 ) bind ( C , name = \"increment_nstream_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 , g2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 real ( wp ) :: temp_mom ! TK integer :: imom !TK ! -------------- ! -------------- !$acc parallel loop collapse(3) & !$acc&     copy(p1(:nmom1,:ncol,:nlay,:ngpt),ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(g2(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:p1, ssa1) & !$omp& map(to:ssa2) & !$omp& map(tofrom:tau1) & !$omp& map(to:g2) & !$omp& map(to:tau2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) ! ! Here assume Henyey-Greenstein ! if ( tauscat12 > eps ) then temp_mom = g2 ( icol , ilay , igpt ) do imom = 1 , nmom1 p1 ( imom , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( imom , icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * temp_mom ) / tauscat12 temp_mom = temp_mom * g2 ( icol , ilay , igpt ) end do ssa1 ( icol , ilay , igpt ) = tauscat12 / tau12 tau1 ( icol , ilay , igpt ) = tau12 end if end do end do end do end subroutine increment_nstream_by_2stream ! --------------------------------- ! increment nstream by nstream subroutine increment_nstream_by_nstream ( ncol , nlay , ngpt , nmom1 , nmom2 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , p2 ) bind ( C , name = \"increment_nstream_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nmom2 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , ngpt ), intent ( in ) :: p2 integer :: icol , ilay , igpt , mom_lim real ( wp ) :: tau12 , tauscat12 ! -------------- ! -------------- mom_lim = min ( nmom1 , nmom2 ) !$acc  parallel loop collapse(3) & !$acc&     copyin(p2(:mom_lim,:ncol,:nlay,:ngpt)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt),tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt),p1(:mom_lim,:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:p2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:ssa2, tau2) & !$omp& map(tofrom:tau1, p1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) if ( tauscat12 > eps ) then ! ! If op2 has more moments than op1 these are ignored; !   if it has fewer moments the higher orders are assumed to be 0 ! p1 ( 1 : mom_lim , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : mom_lim , icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * p2 ( 1 : mom_lim , icol , ilay , igpt )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end if end do end do end do end subroutine increment_nstream_by_nstream ! --------------------------------- ! ! Incrementing when the second set of optical properties is defined at lower spectral resolution !   (e.g. by band instead of by gpoint) ! ! --------------------------------- subroutine inc_1scalar_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt , icol , ilay !$acc parallel loop collapse(3) & !$acc& copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc& copy(tau1(:ncol,:nlay,:ngpt)) & !$acc& copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) endif end do end do end do end do end subroutine inc_1scalar_by_1scalar_bybnd ! --------------------------------- ! increment 1scalar by 2stream subroutine inc_1scalar_by_2stream_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt , icol , ilay !$acc parallel loop collapse(3) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd),ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2, ssa2) & !$omp& map(tofrom:tau1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) * ( 1._wp - ssa2 ( icol , ilay , ibnd )) endif end do end do end do end do end subroutine inc_1scalar_by_2stream_bybnd ! --------------------------------- ! increment 1scalar by nstream subroutine inc_1scalar_by_nstream_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt , icol , ilay !$acc parallel loop collapse(3) & !$acc&     copyin(gpt_lims(:,:nbnd),tau2(:ncol,:nlay,:nbnd)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:gpt_lims, tau2) & !$omp& map(tofrom:tau1) & !$omp& map(to:ssa2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) * ( 1._wp - ssa2 ( icol , ilay , ibnd )) endif end do end do end do end do end subroutine inc_1scalar_by_nstream_bybnd ! --------------------------------- ! increment 2stream by 1scalar subroutine inc_2stream_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! g is unchanged endif end do end do end do end do end subroutine inc_2stream_by_1scalar_bybnd ! --------------------------------- ! increment 2stream by 2stream subroutine inc_2stream_by_2stream_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , g1 , & tau2 , ssa2 , g2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 , g2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd),ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) & !$acc&     copy(g1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(g2(:ncol,:nlay,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2, ssa2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:gpt_lims) & !$omp& map(tofrom:g1) & !$omp& map(to:g2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * g2 ( icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 endif end do end do end do end do end subroutine inc_2stream_by_2stream_bybnd ! --------------------------------- ! increment 2stream by nstream subroutine inc_2stream_by_nstream_bybnd ( ncol , nlay , ngpt , nmom2 , & tau1 , ssa1 , g1 , & tau2 , ssa2 , p2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom2 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , nbnd ), intent ( in ) :: p2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd),ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(p2(:1,:ncol,:nlay,:nbnd),gpt_lims(:,:nbnd)) & !$acc&     copy(g1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2, ssa2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:p2, gpt_lims) & !$omp& map(tofrom:g1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * p2 ( 1 , icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 endif end do end do end do end do end subroutine inc_2stream_by_nstream_bybnd ! --------------------------------- ! --------------------------------- ! increment nstream by 1scalar subroutine inc_nstream_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! p is unchanged endif end do end do end do end do end subroutine inc_nstream_by_1scalar_bybnd ! --------------------------------- ! increment nstream by 2stream subroutine inc_nstream_by_2stream_bybnd ( ncol , nlay , ngpt , nmom1 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , g2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 , g2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 real ( wp ) :: temp_mom ! TK integer :: imom !TK !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt),p1(:nmom1,:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc&     copyin(gpt_lims(:,:nbnd),g2(:ncol,:nlay,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:ssa2) & !$omp& map(tofrom:ssa1, p1) & !$omp& map(to:tau2) & !$omp& map(to:gpt_lims, g2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) ! ! Here assume Henyey-Greenstein ! temp_mom = g2 ( icol , ilay , ibnd ) do imom = 1 , nmom1 p1 ( imom , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( imom , icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * temp_mom ) / max ( eps , tauscat12 ) temp_mom = temp_mom * g2 ( icol , ilay , igpt ) end do ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 endif end do end do end do end do end subroutine inc_nstream_by_2stream_bybnd ! --------------------------------- ! increment nstream by nstream subroutine inc_nstream_by_nstream_bybnd ( ncol , nlay , ngpt , nmom1 , nmom2 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , p2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nmom2 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , nbnd ), intent ( in ) :: p2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd , mom_lim real ( wp ) :: tau12 , tauscat12 mom_lim = min ( nmom1 , nmom2 ) !$acc parallel loop collapse(3) & !$acc&     copyin(p2(:mom_lim,:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc&     copy(p1(:mom_lim,:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:p2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:ssa2) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2) & !$omp& map(tofrom:p1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) ! ! If op2 has more moments than op1 these are ignored; !   if it has fewer moments the higher orders are assumed to be 0 ! p1 ( 1 : mom_lim , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : mom_lim , icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * p2 ( 1 : mom_lim , icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 endif end do end do end do end do end subroutine inc_nstream_by_nstream_bybnd ! --------------------------------- ! ------------------------------------------------------------------------------------------------- ! ! Subsetting, meaning extracting some portion of the 3D domain ! ! ------------------------------------------------------------------------------------------------- subroutine extract_subset_dim1_3d ( ncol , nlay , ngpt , array_in , colS , colE , array_out ) & bind ( C , name = \"extract_subset_dim1_3d\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: array_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: array_out integer :: icol , ilay , igpt !$acc parallel loop collapse(3) & !$acc&     copyout(array_out(:cole-cols+1,:nlay,:ngpt)) & !$acc&     copyin(array_in(cols:cole,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(from:array_out) & !$omp& map(to:array_in) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE array_out ( icol - colS + 1 , ilay , igpt ) = array_in ( icol , ilay , igpt ) end do end do end do end subroutine extract_subset_dim1_3d ! --------------------------------- subroutine extract_subset_dim2_4d ( nmom , ncol , nlay , ngpt , array_in , colS , colE , array_out ) & bind ( C , name = \"extract_subset_dim2_4d\" ) integer , intent ( in ) :: nmom , ncol , nlay , ngpt real ( wp ), dimension ( nmom , ncol , nlay , ngpt ), intent ( in ) :: array_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( nmom , colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: array_out integer :: icol , ilay , igpt , imom !$acc parallel loop collapse(4) & !$acc&     copyout(array_out(:nmom,:cole-cols+1,:nlay,:ngpt)) & !$acc&     copyin(array_in(:nmom,cols:cole,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(4) & !$omp& map(from:array_out) & !$omp& map(to:array_in) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE do imom = 1 , nmom array_out ( imom , icol - colS + 1 , ilay , igpt ) = array_in ( imom , icol , ilay , igpt ) end do end do end do end do end subroutine extract_subset_dim2_4d ! --------------------------------- ! ! Extract the absorption optical thickness which requires mulitplying by 1 - ssa ! subroutine extract_subset_absorption_tau ( ncol , nlay , ngpt , tau_in , ssa_in , & colS , colE , tau_out ) & bind ( C , name = \"extract_subset_absorption_tau\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau_in , ssa_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: tau_out integer :: icol , ilay , igpt !$acc parallel loop collapse(3) & !$acc&     copyin(ssa_in(cols:cole,:nlay,:ngpt)) & !$acc&     copyout(tau_out(:cole-cols+1,:nlay,:ngpt)) & !$acc&     copyin(tau_in(cols:cole,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:ssa_in) & !$omp& map(from:tau_out) & !$omp& map(to:tau_in) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE tau_out ( icol - colS + 1 , ilay , igpt ) = & tau_in ( icol , ilay , igpt ) * ( 1._wp - ssa_in ( icol , ilay , igpt )) end do end do end do end subroutine extract_subset_absorption_tau end module mo_optical_props_kernels","tags":"","loc":"sourcefile/mo_optical_props_kernels.f90~2.html"},{"title":"mo_rte_solver_kernels.F90 – rte-rrtmgp","text":"Contents Modules mo_rte_solver_kernels Source Code mo_rte_solver_kernels.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2021,  Atmospheric and Environmental Research, ! Regents of the University of Colorado, Trustees of Columbia University.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Numeric calculations for radiative transfer solvers. !   Emission/absorption (no-scattering) calculations !     solver for multi-angle Gaussian quadrature !     solver for a single angle, calling !       source function computation (linear-in-tau) !       transport !   Extinction-only calculation (direct solar beam) !   Two-stream calculations !     solvers for LW and SW with different boundary conditions and source functions !       source function calculation for LW, SW !       two-stream calculations for LW, SW (using different assumtions about phase function) !       transport (adding) !   Application of boundary conditions ! ! ------------------------------------------------------------------------------------------------- module mo_rte_solver_kernels use , intrinsic :: iso_c_binding use mo_rte_kind , only : wp , wl use mo_rte_util_array , only : zero_array implicit none private public :: lw_solver_noscat , lw_solver_noscat_GaussQuad , lw_solver_2stream , & sw_solver_noscat , sw_solver_2stream interface add_arrays module procedure add_arrays_2D , add_arrays_3D end interface real ( wp ), parameter :: pi = acos ( - 1._wp ) contains ! ------------------------------------------------------------------------------------------------- ! ! Top-level longwave kernels ! ! ------------------------------------------------------------------------------------------------- ! ! LW fluxes, no scattering, mu (cosine of integration angle) specified by column !   Does radiation calculation at user-supplied angles; converts radiances to flux !   using user-supplied weights ! ! --------------------------------------------------------------- subroutine lw_solver_noscat ( ncol , nlay , ngpt , top_at_1 , D , weight , & tau , lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & incident_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) bind ( C , name = \"lw_solver_noscat\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: D ! secant of propagation angle  [] real ( wp ), intent ( in ) :: weight ! quadrature weight real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] ! Planck source at layer edge for radiation in increasing/decreasing ilay direction ! lev_source_dec applies the mapping in layer i to the Planck function at layer i ! lev_source_inc applies the mapping in layer i to the Planck function at layer i+1 real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( in ) :: lev_source_inc , lev_source_dec real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: incident_flux ! Boundary condition for flux [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ! Optional variables - arrays aren't referenced if corresponding logical  == False ! logical ( wl ), intent ( in ) :: do_broadband real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: broadband_up , broadband_dn ! Spectrally-integrated fluxes [W/m2] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_srcJac ! surface temperature Jacobian of surface source function [W/m2/K] real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: flux_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] logical ( wl ), intent ( in ) :: do_rescaling real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: ssa , g ! single-scattering albedo, asymmetry parameter ! ------------------------------------------------------------------------------------------------- ! Local variables integer :: icol , ilay , ilev , igpt integer :: top_level , sfc_level real ( wp ), dimension ( ncol , nlay , ngpt ) :: tau_loc , & ! path length (tau/mu) trans ! transmissivity  = exp(-tau) real ( wp ), dimension ( ncol , nlay , ngpt ) :: source_dn , source_up real ( wp ), dimension (:,:,:), pointer :: lev_source_up , lev_source_dn ! Mapping increasing/decreasing indicies to up/down real ( wp ), parameter :: pi = acos ( - 1._wp ) ! ! For Jacobians ! real ( wp ), dimension ( ncol , nlay + 1 , ngpt ) :: gpt_Jac ! ! Used when approximating scattering ! real ( wp ) :: ssal , wb , scaleTau , scaling real ( wp ), dimension ( ncol , nlay , ngpt ) :: An , Cn ! ------------------------------------ ! Which way is up? ! Level Planck sources for upward and downward radiation ! When top_at_1, lev_source_up => lev_source_dec !                lev_source_dn => lev_source_inc, and vice-versa if ( top_at_1 ) then top_level = 1 sfc_level = nlay + 1 lev_source_up => lev_source_dec lev_source_dn => lev_source_inc else top_level = nlay + 1 sfc_level = 1 lev_source_up => lev_source_inc lev_source_dn => lev_source_dec end if !$acc        data create(   tau_loc,trans,source_dn,source_up ) & !$acc             copyin(   D, tau,lev_source_up,lev_source_dn) !$omp target data map(alloc:tau_loc,trans,source_dn,source_up ) & !$omp             map(to:   D, tau,lev_source_up,lev_source_dn) !$acc        enter data create(   flux_dn,flux_up) !$omp target enter data map(alloc:flux_dn,flux_up) !$acc                         parallel loop    collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ! ! Transport is for intensity !   convert flux at top of domain to intensity assuming azimuthal isotropy ! flux_dn ( icol , top_level , igpt ) = incident_flux ( icol , igpt ) / ( 2._wp * pi * weight ) end do end do !$acc        data create(   An, Cn)  copyin(g)          if(do_rescaling) !$omp target data map(alloc:An, Cn)  map(to:g)          if(do_rescaling) !$acc        data copyin(sfc_srcJac) create(   gpt_Jac) if(do_Jacobians) !$omp target data map(to:sfc_srcJac) map(alloc:gpt_Jac) if(do_Jacobians) !$acc parallel loop no_create(An, Cn, gpt_Jac, g) collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! ! The wb and scaleTau terms are independent of propagation !   angle D and could be pre-computed if several values of D are used ! We re-compute them here to keep not have to localize memory use ! if ( do_rescaling ) then ssal = ssa ( icol , ilay , igpt ) wb = ssal * ( 1._wp - g ( icol , ilay , igpt )) * 0.5_wp scaleTau = ( 1._wp - ssal + wb ) ! here wb/scaleTau is parameter wb/(1-w(1-b)) of Eq.21 of the Tang paper ! actually it is in line of parameter rescaling defined in Eq.7 ! potentialy if g=ssa=1  then  wb/scaleTau = NaN ! it should not happen because g is never 1 in atmospheres ! explanation of factor 0.4 note A of Table Cn ( icol , ilay , igpt ) = 0.4_wp * wb / scaleTau ! Eq.15 of the paper, multiplied by path length tau_loc ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) * D ( icol , igpt ) * scaleTau trans ( icol , ilay , igpt ) = exp ( - tau_loc ( icol , ilay , igpt )) An ( icol , ilay , igpt ) = ( 1._wp - trans ( icol , ilay , igpt ) ** 2 ) else ! ! Optical path and transmission, used in source function and transport calculations ! tau_loc ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) * D ( icol , igpt ) trans ( icol , ilay , igpt ) = exp ( - tau_loc ( icol , ilay , igpt )) end if call lw_source_noscat ( lay_source ( icol , ilay , igpt ), & lev_source_up ( icol , ilay , igpt ), lev_source_dn ( icol , ilay , igpt ), & tau_loc ( icol , ilay , igpt ), trans ( icol , ilay , igpt ), & source_dn ( icol , ilay , igpt ), source_up ( icol , ilay , igpt )) end do end do end do ! ! Transport down ! call lw_transport_noscat_dn ( ncol , nlay , ngpt , top_at_1 , trans , source_dn , flux_dn ) ! ! Surface reflection and emission ! !$acc                         parallel loop    collapse(2) no_create(gpt_Jac, sfc_srcJac) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ! ! Surface albedo, surface source function ! flux_up ( icol , sfc_level , igpt ) = flux_dn ( icol , sfc_level , igpt ) * ( 1._wp - sfc_emis ( icol , igpt )) + & sfc_src ( icol , igpt ) * sfc_emis ( icol , igpt ) if ( do_Jacobians ) & gpt_Jac ( icol , sfc_level , igpt ) = sfc_srcJac ( icol , igpt ) * sfc_emis ( icol , igpt ) end do end do ! ! Transport up, or up and down again if using rescaling ! if ( do_rescaling ) then call lw_transport_1rescl ( ncol , nlay , ngpt , top_at_1 , trans , & source_dn , source_up , & flux_up , flux_dn , An , Cn , & do_Jacobians , gpt_Jac ) else call lw_transport_noscat_up ( ncol , nlay , ngpt , top_at_1 , trans , source_up , flux_up , & do_Jacobians , gpt_Jac ) end if if ( do_broadband ) then ! ! Broadband reduction including !   conversion from intensity to flux assuming azimuthal isotropy and quadrature weight ! call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , flux_dn , broadband_dn ) call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , flux_up , broadband_up ) !$acc        exit data delete(     flux_dn,flux_up) !$omp target exit data map(release:flux_dn,flux_up) else ! ! Convert intensity to flux assuming azimuthal isotropy and quadrature weight ! call apply_factor_3D ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , flux_dn ) call apply_factor_3D ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , flux_up ) !$acc        exit data copyout( flux_dn,flux_up) !$omp target exit data map(from:flux_dn,flux_up) end if ! ! Only broadband-integrated Jacobians are provided ! if ( do_Jacobians ) then call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , gpt_Jac , flux_upJac ) end if !$acc        end data !$omp end target data !$acc        end data !$omp end target data !$acc        end data !$omp end target data end subroutine lw_solver_noscat ! --------------------------------------------------------------- ! ! LW transport, no scattering, multi-angle quadrature !   Users provide a set of weights and quadrature angles !   Routine sums over single-angle solutions for each sets of angles/weights ! ! --------------------------------------------------------------- subroutine lw_solver_noscat_GaussQuad ( ncol , nlay , ngpt , top_at_1 , & nmus , Ds , weights , & tau , & lay_source , lev_source_inc , lev_source_dec , & sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) bind ( C , name = \"lw_solver_noscat_GaussQuad\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 integer , intent ( in ) :: nmus ! number of quadrature angles real ( wp ), dimension ( ncol , ngpt , & nmus ), intent ( in ) :: Ds real ( wp ), dimension ( nmus ), intent ( in ) :: weights ! quadrature secants, weights real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_source_inc ! Planck source at layer edge for radiation in increasing ilay direction [W/m2] ! Includes spectral weighting that accounts for state-dependent frequency to g-space mapping real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_source_dec ! Planck source at layer edge for radiation in decreasing ilay direction [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux ! Incident diffuse flux, probably 0 [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ! Optional variables - arrays aren't referenced if corresponding logical  == False ! logical ( wl ), intent ( in ) :: do_broadband real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( inout ) :: broadband_up , broadband_dn ! Spectrally-integrated fluxes [W/m2] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_srcJac ! surface temperature Jacobian of surface source function [W/m2/K] real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( out ) :: flux_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] logical ( wl ), intent ( in ) :: do_rescaling real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: ssa , g ! single-scattering albedo, asymmetry parameter ! ------------------------------------ ! ! Local variables ! real ( wp ), dimension (:,:,:), pointer :: this_flux_up , this_flux_dn real ( wp ), dimension (:,:), pointer :: this_broadband_up , this_broadband_dn , this_flux_upJac integer :: icol , ilev , igpt , imu ! ------------------------------------ !$acc        data copyin(Ds, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src) !$omp target data map(to:Ds, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src) !$acc        data copyout( flux_up, flux_dn)             if (.not. do_broadband) !$omp target data map(from:flux_up, flux_dn)             if (.not. do_broadband) !$acc        data copyout( broadband_up, broadband_dn)   if (      do_broadband) !$omp target data map(from:broadband_up, broadband_dn)   if (      do_broadband) !$acc        data copyin(sfc_srcJac)   copyout(flux_upJac) if (do_Jacobians) !$omp target data map(to:sfc_srcJac), map(from:flux_upJac) if (do_Jacobians) if ( do_broadband ) then this_broadband_up => broadband_up this_broadband_dn => broadband_dn allocate ( this_flux_up ( ncol , nlay + 1 , ngpt ), this_flux_dn ( ncol , nlay + 1 , ngpt )) else this_flux_up => flux_up this_flux_dn => flux_dn ! Spectrally-integrated fluxes won't be filled in allocate ( this_broadband_up ( ncol , nlay + 1 ), this_broadband_dn ( ncol , nlay + 1 )) end if !$acc        data create(   this_broadband_up, this_broadband_dn, this_flux_up, this_flux_dn) !$omp target data map(alloc:this_broadband_up, this_broadband_dn, this_flux_up, this_flux_dn) call lw_solver_noscat ( ncol , nlay , ngpt , & top_at_1 , Ds (:,:, 1 ), weights ( 1 ), tau , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & this_flux_up , this_flux_dn , & do_broadband , this_broadband_up , this_broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) !$acc end data !$omp end target data if ( nmus > 1 ) then ! ! For more than one angle use local arrays ! if ( do_broadband ) then nullify ( this_broadband_up , this_broadband_dn ) allocate ( this_broadband_up ( ncol , nlay + 1 ), this_broadband_dn ( ncol , nlay + 1 )) else nullify ( this_flux_up , this_flux_dn ) allocate ( this_flux_up ( ncol , nlay + 1 , ngpt ), this_flux_dn ( ncol , nlay + 1 , ngpt )) end if if ( do_Jacobians ) then allocate ( this_flux_upJac ( ncol , nlay + 1 )) else this_flux_upJac => flux_upJac end if ! ! For more than one angle use local arrays ! !$acc        data create(   this_broadband_up, this_broadband_dn, this_flux_up, this_flux_dn) !$omp target data map(alloc:this_broadband_up, this_broadband_dn, this_flux_up, this_flux_dn) do imu = 2 , nmus call lw_solver_noscat ( ncol , nlay , ngpt , & top_at_1 , Ds (:,:, imu ), weights ( imu ), tau , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & this_flux_up , this_flux_dn , & do_broadband , this_broadband_up , this_broadband_dn , & do_Jacobians , sfc_srcJac , this_flux_upJac , & do_rescaling , ssa , g ) if ( do_broadband ) then call add_arrays ( ncol , nlay + 1 , this_broadband_up , broadband_up ) call add_arrays ( ncol , nlay + 1 , this_broadband_dn , broadband_dn ) else call add_arrays ( ncol , nlay + 1 , ngpt , flux_up , this_flux_up ) call add_arrays ( ncol , nlay + 1 , ngpt , flux_dn , this_flux_dn ) end if if ( do_Jacobians ) then call add_arrays ( ncol , nlay + 1 , this_flux_upJac , flux_upJac ) end if end do !$acc end data !$omp end target data end if !$acc end data !$omp end target data !$acc end data !$omp end target data !$acc end data !$omp end target data !$acc end data !$omp end target data ! Cleanup if (. not . associated ( this_broadband_up , broadband_up )) then deallocate ( this_broadband_up , this_broadband_dn ) end if if (. not . associated ( this_flux_up , flux_up )) then deallocate ( this_flux_up , this_flux_dn ) end if if ( nmus > 1 . and . do_Jacobians ) then deallocate ( this_flux_upJac ) end if end subroutine lw_solver_noscat_GaussQuad ! ------------------------------------------------------------------------------------------------- ! ! Longwave two-stream calculation: !   combine RRTMGP-specific sources at levels !   compute layer reflectance, transmittance !   compute total source function at levels using linear-in-tau !   transport ! ! ------------------------------------------------------------------------------------------------- subroutine lw_solver_2stream ( ncol , nlay , ngpt , top_at_1 , & tau , ssa , g , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn ) bind ( C , name = \"lw_solver_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , & ! Optical thickness, ssa , & ! single-scattering albedo, g ! asymmetry parameter [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( in ) :: lev_source_inc , lev_source_dec ! Planck source at layer edge for radiation in increasing/decreasing ilay direction [W/m2] ! Includes spectral weighting that accounts for state-dependent frequency to g-space mapping real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux ! Incident diffuse flux, probably 0 [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ---------------------------------------------------------------------- integer :: icol , igpt , top_level real ( wp ), dimension ( ncol , nlay , ngpt ) :: Rdif , Tdif , gamma1 , gamma2 real ( wp ), dimension ( ncol , ngpt ) :: sfc_albedo real ( wp ), dimension ( ncol , nlay + 1 , ngpt ) :: lev_source real ( wp ), dimension ( ncol , nlay , ngpt ) :: source_dn , source_up real ( wp ), dimension ( ncol , ngpt ) :: source_sfc ! ------------------------------------ ! ------------------------------------ !$acc enter data copyin(tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, flux_dn) !$omp target enter data map(to:tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, flux_dn) !$acc enter data create(flux_up, Rdif, Tdif, gamma1, gamma2, sfc_albedo, lev_source, source_dn, source_up, source_sfc) !$omp target enter data map(alloc:flux_up, Rdif, Tdif, gamma1, gamma2, sfc_albedo, lev_source, source_dn, source_up, source_sfc) ! ! RRTMGP provides source functions at each level using the spectral mapping !   of each adjacent layer. Combine these for two-stream calculations ! top_level = nlay + 1 if ( top_at_1 ) top_level = 1 call lw_combine_sources ( ncol , nlay , ngpt , top_at_1 , & lev_source_inc , lev_source_dec , & lev_source ) ! ! Cell properties: reflection, transmission for diffuse radiation !   Coupling coefficients needed for source function ! call lw_two_stream ( ncol , nlay , ngpt , & tau , ssa , g , & gamma1 , gamma2 , Rdif , Tdif ) ! ! Source function for diffuse radiation ! call lw_source_2str ( ncol , nlay , ngpt , top_at_1 , & sfc_emis , sfc_src , & lay_source , lev_source , & gamma1 , gamma2 , Rdif , Tdif , tau , & source_dn , source_up , source_sfc ) !$acc                         parallel loop    collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol sfc_albedo ( icol , igpt ) = 1._wp - sfc_emis ( icol , igpt ) flux_dn ( icol , top_level , igpt ) = inc_flux ( icol , igpt ) end do end do ! ! Transport ! call adding ( ncol , nlay , ngpt , top_at_1 , & sfc_albedo , & Rdif , Tdif , & source_dn , source_up , source_sfc , & flux_up , flux_dn ) !$acc exit data delete(tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src) !$omp target exit data map(release:tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src) !$acc exit data delete(Rdif, Tdif, gamma1, gamma2, sfc_albedo, lev_source, source_dn, source_up, source_sfc) !$omp target exit data map(release:Rdif, Tdif, gamma1, gamma2, sfc_albedo, lev_source, source_dn, source_up, source_sfc) !$acc exit data copyout(flux_up, flux_dn) !$omp target exit data map(from:flux_up, flux_dn) end subroutine lw_solver_2stream ! ------------------------------------------------------------------------------------------------- ! !   Top-level shortwave kernels ! ! ------------------------------------------------------------------------------------------------- ! !   Extinction-only i.e. solar direct beam ! ! ------------------------------------------------------------------------------------------------- subroutine sw_solver_noscat ( ncol , nlay , ngpt , top_at_1 , & tau , mu0 , inc_flux_dir , flux_dir ) bind ( C , name = \"sw_solver_noscat\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 ! cosine of solar zenith angle real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux_dir ! Direct beam incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_dir ! Direct-beam flux, spectral [W/m2] integer :: icol , ilev , igpt real ( wp ) :: mu0_inv ( ncol ) ! ------------------------------------ ! ------------------------------------ !$acc enter data copyin(tau, mu0) create(mu0_inv, flux_dir) !$omp target enter data map(to:tau, mu0) map(alloc:mu0_inv, flux_dir) !$acc parallel loop !$omp target teams distribute parallel do simd do icol = 1 , ncol mu0_inv ( icol ) = 1._wp / mu0 ( icol ) enddo ! Indexing into arrays for upward and downward propagation depends on the vertical !   orientation of the arrays (whether the domain top is at the first or last index) ! We write the loops out explicitly so compilers will have no trouble optimizing them. ! Downward propagation if ( top_at_1 ) then ! For the flux at this level, what was the previous level, and which layer has the !   radiation just passed through? ! layer index = level index - 1 ! previous level is up (-1) !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol flux_dir ( icol , 1 , igpt ) = inc_flux_dir ( icol , igpt ) * mu0 ( icol ) do ilev = 2 , nlay + 1 flux_dir ( icol , ilev , igpt ) = flux_dir ( icol , ilev - 1 , igpt ) * exp ( - tau ( icol , ilev , igpt ) * mu0_inv ( icol )) end do end do end do else ! layer index = level index ! previous level is up (+1) !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol flux_dir ( icol , nlay + 1 , igpt ) = inc_flux_dir ( icol , igpt ) * mu0 ( icol ) do ilev = nlay , 1 , - 1 flux_dir ( icol , ilev , igpt ) = flux_dir ( icol , ilev + 1 , igpt ) * exp ( - tau ( icol , ilev , igpt ) * mu0_inv ( icol )) end do end do end do end if !$acc exit data delete(tau, mu0, mu0_inv) copyout(flux_dir) !$omp target exit data map(release:tau, mu0, mu0_inv) map(from:flux_dir) end subroutine sw_solver_noscat ! ------------------------------------------------------------------------------------------------- ! ! Shortwave two-stream calculation: !   compute layer reflectance, transmittance !   compute solar source function for diffuse radiation !   transport ! ! ------------------------------------------------------------------------------------------------- subroutine sw_solver_2stream ( ncol , nlay , ngpt , top_at_1 , & tau , ssa , g , mu0 , & sfc_alb_dir , sfc_alb_dif , & inc_flux_dir , & flux_up , flux_dn , flux_dir , & has_dif_bc , inc_flux_dif , & do_broadband , broadband_up , & broadband_dn , broadband_dir ) bind ( C , name = \"sw_solver_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , & ! Optical thickness, ssa , & ! single-scattering albedo, g ! asymmetry parameter [] real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 ! cosine of solar zenith angle ! Spectral albedo of surface to direct and diffuse radiation real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_alb_dir , sfc_alb_dif , & inc_flux_dir ! Direct beam incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn , flux_dir ! Fluxes [W/m2] logical ( wl ), intent ( in ) :: has_dif_bc ! Is a boundary condition for diffuse flux supplied? real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux_dif ! Boundary condition for diffuse flux logical ( wl ), intent ( in ) :: do_broadband ! Provide broadband-integrated, not spectrally-resolved, fluxes? real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: broadband_up , broadband_dn , broadband_dir ! ------------------------------------------- integer :: icol , ilay , igpt , top_level real ( wp ) :: bb_flux_s , bb_dir_s real ( wp ), dimension ( ncol , nlay , ngpt ) :: Rdif , Tdif real ( wp ), dimension ( ncol , nlay , ngpt ) :: source_up , source_dn real ( wp ), dimension ( ncol , ngpt ) :: source_srf real ( wp ), dimension (:,:,:), pointer :: gpt_flux_up , gpt_flux_dn , gpt_flux_dir ! ------------------------------------ if ( do_broadband ) then allocate ( gpt_flux_up ( ncol , nlay + 1 , ngpt ), & gpt_flux_dn ( ncol , nlay + 1 , ngpt ), & gpt_flux_dir ( ncol , nlay + 1 , ngpt )) else gpt_flux_up => flux_up gpt_flux_dn => flux_dn gpt_flux_dir => flux_dir end if top_level = nlay + 1 if ( top_at_1 ) top_level = 1 ! ! Boundary conditions direct beam... ! !$acc        data create(   gpt_flux_up, gpt_flux_dn, gpt_flux_dir) & !$acc             copyin(   mu0) !$omp target data map(alloc:gpt_flux_up, gpt_flux_dn, gpt_flux_dir) & !$omp             map(to:   mu0) !$acc        data copyout(flux_up, flux_dn, flux_dir) if (.not. do_broadband) !$omp target data map(to: flux_up, flux_dn, flux_dir) if (.not. do_broadband) !$acc  parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol gpt_flux_dir ( icol , top_level , igpt ) = inc_flux_dir ( icol , igpt ) * mu0 ( icol ) end do end do ! ! ... and diffuse field, using 0 if no BC is provided ! if ( has_dif_bc ) then !$acc                         parallel loop    collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol gpt_flux_dn ( icol , top_level , igpt ) = inc_flux_dif ( icol , igpt ) end do end do else !$acc                         parallel loop    collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol gpt_flux_dn ( icol , top_level , igpt ) = 0._wp end do end do end if ! ! Cell properties: transmittance and reflectance for diffuse radiation ! Direct-beam radiation and source for diffuse radiation ! !$acc        data create(   Rdif, Tdif, source_up, source_dn, source_srf) !$omp target data map(alloc:Rdif, Tdif, source_up, source_dn, source_srf) call sw_dif_and_source ( ncol , nlay , ngpt , top_at_1 , mu0 , sfc_alb_dif , & tau , ssa , g , & Rdif , Tdif , source_dn , source_up , source_srf , gpt_flux_dir ) call adding ( ncol , nlay , ngpt , top_at_1 , & sfc_alb_dif , Rdif , Tdif , & source_dn , source_up , source_srf , gpt_flux_up , gpt_flux_dn ) !$acc        end data !$omp end target data if ( do_broadband ) then ! ! Broadband integration ! !$acc        data copyout( broadband_up, broadband_dn, broadband_dir) !$omp target data map(from:broadband_up, broadband_dn, broadband_dir) call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 1._wp , gpt_flux_up , broadband_up ) call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 1._wp , gpt_flux_dn , broadband_dn ) call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 1._wp , gpt_flux_dir , broadband_dir ) ! ! adding computes only diffuse flux; flux_dn is total ! call add_arrays ( ncol , nlay + 1 , broadband_dir , broadband_dn ) !$acc        end data !$omp end target data else ! ! adding computes only diffuse flux; flux_dn is total ! call add_arrays ( ncol , nlay + 1 , ngpt , flux_dir , flux_dn ) end if !$acc        end data !$omp end target data !$acc        end data !$omp end target data if ( do_broadband ) then deallocate ( gpt_flux_up , gpt_flux_dn , gpt_flux_dir ) end if end subroutine sw_solver_2stream ! ------------------------------------------------------------------------------------------------- ! !   Lower-level longwave kernels ! ! --------------------------------------------------------------- ! ! Compute LW source function for upward and downward emission at levels using linear-in-tau assumption ! See Clough et al., 1992, doi: 10.1029/92JD01419, Eq 13 ! This routine implements point-wise stencil, and has to be called in a loop ! ! --------------------------------------------------------------- subroutine lw_source_noscat ( lay_source , lev_source_up , lev_source_dn , tau , trans , & source_dn , source_up ) !$acc routine seq !$omp declare target ! real ( wp ), intent ( in ) :: lay_source , & ! Planck source at layer center lev_source_up , & ! Planck source at levels (layer edges), lev_source_dn , & !   increasing/decreasing layer index tau , & ! Optical path (tau/mu) trans ! Transmissivity (exp(-tau)) real ( wp ), intent ( inout ) :: source_dn , source_up ! Source function at layer edges ! Down at the bottom of the layer, up at the top ! -------------------------------- real ( wp ), parameter :: tau_thresh = sqrt ( epsilon ( tau )) real ( wp ) :: fact ! --------------------------------------------------------------- ! ! Weighting factor. Use 2nd order series expansion when rounding error (~tau&#94;2) !   is of order epsilon (smallest difference from 1. in working precision) !   Thanks to Peter Blossey ! if ( tau > tau_thresh ) then fact = ( 1._wp - trans ) / tau - trans else fact = tau * ( 0.5_wp - 1._wp / 3._wp * tau ) end if ! ! Equation below is developed in Clough et al., 1992, doi:10.1029/92JD01419, Eq 13 ! source_dn = ( 1._wp - trans ) * lev_source_dn + & 2._wp * fact * ( lay_source - lev_source_dn ) source_up = ( 1._wp - trans ) * lev_source_up + & 2._wp * fact * ( lay_source - lev_source_up ) end subroutine lw_source_noscat ! --------------------------------------------------------------- ! ! Longwave no-scattering transport ! ! --------------------------------------------------------------- subroutine lw_transport_noscat_dn ( ncol , nlay , ngpt , top_at_1 , & trans , source_dn , radn_dn ) bind ( C , name = \"lw_transport_noscat_dn\" ) !dir$ optimize(-O0) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 ! real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: trans ! transmissivity = exp(-tau) real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: source_dn ! Diffuse radiation emitted by the layer real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( inout ) :: radn_dn ! Radiances [W/m2-str] ! Top level must contain incident flux boundary condition ! Local variables integer :: igpt , ilev , icol ! --------------------------------------------------- ! --------------------------------------------------- if ( top_at_1 ) then ! ! Top of domain is index 1 ! !$acc  parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol do ilev = 2 , nlay + 1 radn_dn ( icol , ilev , igpt ) = trans ( icol , ilev - 1 , igpt ) * radn_dn ( icol , ilev - 1 , igpt ) + source_dn ( icol , ilev - 1 , igpt ) end do end do end do else ! ! Top of domain is index nlay+1 ! !$acc  parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol do ilev = nlay , 1 , - 1 radn_dn ( icol , ilev , igpt ) = trans ( icol , ilev , igpt ) * radn_dn ( icol , ilev + 1 , igpt ) + source_dn ( icol , ilev , igpt ) end do end do end do end if end subroutine lw_transport_noscat_dn ! ------------------------------------------------------------------------------------------------- subroutine lw_transport_noscat_up ( ncol , nlay , ngpt , & top_at_1 , trans , source_up , radn_up , do_Jacobians , radn_upJac ) bind ( C , name = \"lw_transport_noscat_up\" ) !dir$ optimize(-O0) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 ! real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: trans ! transmissivity = exp(-tau) real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: source_up ! Diffuse radiation emitted by the layer real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: radn_up ! Radiances [W/m2-str] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( inout ) :: radn_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] ! Local variables integer :: igpt , ilev , icol ! --------------------------------------------------- ! --------------------------------------------------- if ( top_at_1 ) then ! ! Top of domain is index 1 ! !$acc  parallel loop collapse(2) no_create(radn_upJac) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol do ilev = nlay , 1 , - 1 radn_up ( icol , ilev , igpt ) = trans ( icol , ilev , igpt ) * radn_up ( icol , ilev + 1 , igpt ) + source_up ( icol , ilev , igpt ) end do if ( do_Jacobians ) then do ilev = nlay , 1 , - 1 radn_upJac ( icol , ilev , igpt ) = trans ( icol , ilev , igpt ) * radn_upJac ( icol , ilev + 1 , igpt ) end do end if end do end do else ! ! Top of domain is index nlay+1 ! !$acc  parallel loop collapse(2) no_create(radn_upJac) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol do ilev = 2 , nlay + 1 radn_up ( icol , ilev , igpt ) = trans ( icol , ilev - 1 , igpt ) * radn_up ( icol , ilev - 1 , igpt ) + source_up ( icol , ilev - 1 , igpt ) end do if ( do_Jacobians ) then do ilev = nlay , 1 , - 1 radn_upJac ( icol , ilev , igpt ) = trans ( icol , ilev - 1 , igpt ) * radn_upJac ( icol , ilev - 1 , igpt ) end do end if end do end do end if end subroutine lw_transport_noscat_up ! ------------------------------------------------------------------------------------------------- ! ! Longwave two-stream solutions to diffuse reflectance and transmittance for a layer !    with optical depth tau, single scattering albedo w0, and asymmetery parameter g. ! ! Equations are developed in Meador and Weaver, 1980, !    doi:10.1175/1520-0469(1980)037<0630:TSATRT>2.0.CO;2 ! subroutine lw_two_stream ( ncol , nlay , ngpt , tau , w0 , g , & gamma1 , gamma2 , Rdif , Tdif ) bind ( C , name = \"lw_two_stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , w0 , g real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: gamma1 , gamma2 , Rdif , Tdif ! ----------------------- integer :: icol , ilay , igpt ! Variables used in Meador and Weaver real ( wp ) :: k ! Ancillary variables real ( wp ) :: RT_term real ( wp ) :: exp_minusktau , exp_minus2ktau real ( wp ), parameter :: LW_diff_sec = 1.66 ! 1./cos(diffusivity angle) ! --------------------------------- ! --------------------------------- !$acc enter data copyin(tau, w0, g) !$omp target enter data map(to:tau, w0, g) !$acc enter data create(gamma1, gamma2, Rdif, Tdif) !$omp target enter data map(alloc:gamma1, gamma2, Rdif, Tdif) !$acc  parallel loop collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! ! Coefficients differ from SW implementation because the phase function is more isotropic !   Here we follow Fu et al. 1997, doi:10.1175/1520-0469(1997)054<2799:MSPITI>2.0.CO;2 !   and use a diffusivity sec of 1.66 ! gamma1 ( icol , ilay , igpt ) = LW_diff_sec * ( 1._wp - 0.5_wp * w0 ( icol , ilay , igpt ) * ( 1._wp + g ( icol , ilay , igpt ))) ! Fu et al. Eq 2.9 gamma2 ( icol , ilay , igpt ) = LW_diff_sec * 0.5_wp * w0 ( icol , ilay , igpt ) * ( 1._wp - g ( icol , ilay , igpt )) ! Fu et al. Eq 2.10 ! Written to encourage vectorization of exponential, square root ! Eq 18;  k = SQRT(gamma1**2 - gamma2**2), limited below to avoid div by 0. !   k = 0 for isotropic, conservative scattering; this lower limit on k !   gives relative error with respect to conservative solution !   of < 0.1% in Rdif down to tau = 10&#94;-9 k = sqrt ( max (( gamma1 ( icol , ilay , igpt ) - gamma2 ( icol , ilay , igpt )) * & ( gamma1 ( icol , ilay , igpt ) + gamma2 ( icol , ilay , igpt )), & 1.e-12_wp )) exp_minusktau = exp ( - tau ( icol , ilay , igpt ) * k ) ! ! Diffuse reflection and transmission ! exp_minus2ktau = exp_minusktau * exp_minusktau ! Refactored to avoid rounding errors when k, gamma1 are of very different magnitudes RT_term = 1._wp / ( k * ( 1._wp + exp_minus2ktau ) + & gamma1 ( icol , ilay , igpt ) * ( 1._wp - exp_minus2ktau ) ) ! Equation 25 Rdif ( icol , ilay , igpt ) = RT_term * gamma2 ( icol , ilay , igpt ) * ( 1._wp - exp_minus2ktau ) ! Equation 26 Tdif ( icol , ilay , igpt ) = RT_term * 2._wp * k * exp_minusktau end do end do end do !$acc exit data delete (tau, w0, g) !$omp target exit data map(release:tau, w0, g) !$acc exit data copyout(gamma1, gamma2, Rdif, Tdif) !$omp target exit data map(from:gamma1, gamma2, Rdif, Tdif) end subroutine lw_two_stream ! ------------------------------------------------------------------------------------------------- ! ! Source function combination ! RRTMGP provides two source functions at each level !   using the spectral mapping from each of the adjascent layers. !   Need to combine these for use in two-stream calculation. ! ! ------------------------------------------------------------------------------------------------- subroutine lw_combine_sources ( ncol , nlay , ngpt , top_at_1 , & lev_src_inc , lev_src_dec , lev_source ) bind ( C , name = \"lw_combine_sources\" ) integer , intent ( in ) :: ncol , nlay , ngpt logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_src_inc , lev_src_dec real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: lev_source integer :: icol , ilay , igpt ! --------------------------------------------------------------- ! --------------------------------- !$acc enter data copyin(lev_src_inc, lev_src_dec) !$omp target enter data map(to:lev_src_inc, lev_src_dec) !$acc enter data create(lev_source) !$omp target enter data map(alloc:lev_source) !$acc  parallel loop collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay + 1 do icol = 1 , ncol if ( ilay == 1 ) then lev_source ( icol , ilay , igpt ) = lev_src_dec ( icol , ilay , igpt ) else if ( ilay == nlay + 1 ) then lev_source ( icol , ilay , igpt ) = lev_src_inc ( icol , ilay - 1 , igpt ) else lev_source ( icol , ilay , igpt ) = sqrt ( lev_src_dec ( icol , ilay , igpt ) * & lev_src_inc ( icol , ilay - 1 , igpt )) end if end do end do end do !$acc exit data delete (lev_src_inc, lev_src_dec) !$omp target exit data map(release:lev_src_inc, lev_src_dec) !$acc exit data copyout(lev_source) !$omp target exit data map(from:lev_source) end subroutine lw_combine_sources ! --------------------------------------------------------------- ! ! Compute LW source function for upward and downward emission at levels using linear-in-tau assumption !   This version straight from ECRAD !   Source is provided as W/m2-str; factor of pi converts to flux units ! ! --------------------------------------------------------------- subroutine lw_source_2str ( ncol , nlay , ngpt , top_at_1 , & sfc_emis , sfc_src , & lay_source , lev_source , & gamma1 , gamma2 , rdif , tdif , tau , source_dn , source_up , source_sfc ) & bind ( C , name = \"lw_source_2str\" ) integer , intent ( in ) :: ncol , nlay , ngpt logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis , sfc_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source , & ! Planck source at layer center tau , & ! Optical depth (tau) gamma1 , gamma2 ,& ! Coupling coefficients rdif , tdif ! Layer reflectance and transmittance real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( in ) :: lev_source ! Planck source at layer edges real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: source_dn , source_up real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: source_sfc ! Source function for upward radation at surface integer :: icol , ilay , igpt real ( wp ) :: Z , Zup_top , Zup_bottom , Zdn_top , Zdn_bottom real ( wp ) :: lev_source_bot , lev_source_top ! --------------------------------------------------------------- ! --------------------------------- !$acc enter data copyin(sfc_emis, sfc_src, lay_source, tau, gamma1, gamma2, rdif, tdif, lev_source) !$omp target enter data map(to:sfc_emis, sfc_src, lay_source, tau, gamma1, gamma2, rdif, tdif, lev_source) !$acc enter data create(source_dn, source_up, source_sfc) !$omp target enter data map(alloc:source_dn, source_up, source_sfc) !$acc parallel loop collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol if ( tau ( icol , ilay , igpt ) > 1.0e-8_wp ) then if ( top_at_1 ) then lev_source_top = lev_source ( icol , ilay , igpt ) lev_source_bot = lev_source ( icol , ilay + 1 , igpt ) else lev_source_top = lev_source ( icol , ilay + 1 , igpt ) lev_source_bot = lev_source ( icol , ilay , igpt ) end if ! ! Toon et al. (JGR 1989) Eqs 26-27 ! Z = ( lev_source_bot - lev_source_top ) / ( tau ( icol , ilay , igpt ) * ( gamma1 ( icol , ilay , igpt ) + gamma2 ( icol , ilay , igpt ))) Zup_top = Z + lev_source_top Zup_bottom = Z + lev_source_bot Zdn_top = - Z + lev_source_top Zdn_bottom = - Z + lev_source_bot source_up ( icol , ilay , igpt ) = pi * ( Zup_top - rdif ( icol , ilay , igpt ) * Zdn_top - tdif ( icol , ilay , igpt ) * Zup_bottom ) source_dn ( icol , ilay , igpt ) = pi * ( Zdn_bottom - rdif ( icol , ilay , igpt ) * Zup_bottom - tdif ( icol , ilay , igpt ) * Zdn_top ) else source_up ( icol , ilay , igpt ) = 0._wp source_dn ( icol , ilay , igpt ) = 0._wp end if if ( ilay == 1 ) source_sfc ( icol , igpt ) = pi * sfc_emis ( icol , igpt ) * sfc_src ( icol , igpt ) end do end do end do !$acc exit data delete(sfc_emis, sfc_src, lay_source, tau, gamma1, gamma2, rdif, tdif, lev_source) !$omp target exit data map(release:sfc_emis, sfc_src, lay_source, tau, gamma1, gamma2, rdif, tdif, lev_source) !$acc exit data copyout(source_dn, source_up, source_sfc) !$omp target exit data map(from:source_dn, source_up, source_sfc) end subroutine lw_source_2str ! ------------------------------------------------------------------------------------------------- ! !   Lower-level shortwave kernels ! ! ------------------------------------------------------------------------------------------------- ! ------------------------------------------------------------------------------------------------- ! ! Two-stream solutions to direct and diffuse reflectance and transmittance for a layer !    with optical depth tau, single scattering albedo w0, and asymmetery parameter g. ! ! Equations are developed in Meador and Weaver, 1980, !    doi:10.1175/1520-0469(1980)037<0630:TSATRT>2.0.CO;2 ! ! --------------------------------------------------------------- ! ! Direct beam source for diffuse radiation in layers and at surface; !   report direct beam as a byproduct ! ! ------------------------------------------------------------------------------------------------- subroutine sw_dif_and_source ( ncol , nlay , ngpt , top_at_1 , mu0 , sfc_albedo , & tau , w0 , g , & Rdif , Tdif , source_dn , source_up , source_sfc , & flux_dn_dir ) bind ( C , name = \"sw_source_dir\" ) integer , intent ( in ) :: ncol , nlay , ngpt logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_albedo ! surface albedo for direct radiation real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , w0 , g real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( out ) :: Rdif , Tdif , source_dn , source_up real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: source_sfc ! Source function for upward radation at surface real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( inout ) :: flux_dn_dir ! Direct beam flux ! ----------------------- integer :: icol , ilay , igpt ! Variables used in Meador and Weaver real ( wp ) :: gamma1 , gamma2 , gamma3 , gamma4 , alpha1 , alpha2 ! Ancillary variables real ( wp ) :: k , exp_minusktau , k_mu , k_gamma3 , k_gamma4 real ( wp ) :: RT_term , exp_minus2ktau real ( wp ) :: Rdir , Tdir , Tnoscat , inc_flux integer :: lay_index , inc_index , trans_index real ( wp ) :: tau_s , w0_s , g_s , mu0_s ! --------------------------------- !$acc  parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol do ilay = 1 , nlay if ( top_at_1 ) then lay_index = ilay inc_index = lay_index trans_index = lay_index + 1 else lay_index = nlay - ilay + 1 inc_index = lay_index + 1 trans_index = lay_index end if inc_flux = flux_dn_dir ( icol , inc_index , igpt ) ! ! Scalars ! tau_s = tau ( icol , lay_index , igpt ) w0_s = w0 ( icol , lay_index , igpt ) g_s = g ( icol , lay_index , igpt ) mu0_s = mu0 ( icol ) ! ! Zdunkowski Practical Improved Flux Method \"PIFM\" !  (Zdunkowski et al., 1980;  Contributions to Atmospheric Physics 53, 147-66) ! gamma1 = ( 8._wp - w0_s * ( 5._wp + 3._wp * g_s )) * . 25_wp gamma2 = 3._wp * ( w0_s * ( 1._wp - g_s )) * . 25_wp gamma3 = ( 2._wp - 3._wp * mu0_s * g_s ) * . 25_wp gamma4 = 1._wp - gamma3 alpha1 = gamma1 * gamma4 + gamma2 * gamma3 ! Eq. 16 alpha2 = gamma1 * gamma3 + gamma2 * gamma4 ! Eq. 17 ! ! Direct reflect and transmission ! ! Eq 18;  k = SQRT(gamma1**2 - gamma2**2), limited below to avoid div by 0. !   k = 0 for isotropic, conservative scattering; this lower limit on k !   gives relative error with respect to conservative solution !   of < 0.1% in Rdif down to tau = 10&#94;-9 k = sqrt ( max (( gamma1 - gamma2 ) * ( gamma1 + gamma2 ), 1.e-12_wp )) k_mu = k * mu0_s k_gamma3 = k * gamma3 k_gamma4 = k * gamma4 exp_minusktau = exp ( - tau_s * k ) exp_minus2ktau = exp_minusktau * exp_minusktau ! Refactored to avoid rounding errors when k, gamma1 are of very different magnitudes RT_term = 1._wp / ( k * ( 1._wp + exp_minus2ktau ) + & gamma1 * ( 1._wp - exp_minus2ktau ) ) ! Equation 25 Rdif ( icol , lay_index , igpt ) = RT_term * gamma2 * ( 1._wp - exp_minus2ktau ) ! Equation 26 Tdif ( icol , lay_index , igpt ) = RT_term * 2._wp * k * exp_minusktau ! ! Equation 14, multiplying top and bottom by exp(-k*tau) !   and rearranging to avoid div by 0. ! RT_term = w0_s * RT_term / merge ( 1._wp - k_mu * k_mu , & epsilon ( 1._wp ), & abs ( 1._wp - k_mu * k_mu ) >= epsilon ( 1._wp )) ! ! Transmittance of direct, unscattered beam. ! Tnoscat = exp ( - tau_s / mu0_s ) Rdir = RT_term * & (( 1._wp - k_mu ) * ( alpha2 + k_gamma3 ) - & ( 1._wp + k_mu ) * ( alpha2 - k_gamma3 ) * exp_minus2ktau - & 2.0_wp * ( k_gamma3 - alpha2 * k_mu ) * exp_minusktau * Tnoscat ) ! ! Equation 15, multiplying top and bottom by exp(-k*tau), !   multiplying through by exp(-tau/mu0) to !   prefer underflow to overflow ! Omitting direct transmittance ! Tdir = - RT_term * & (( 1._wp + k_mu ) * ( alpha1 + k_gamma4 ) * Tnoscat - & ( 1._wp - k_mu ) * ( alpha1 - k_gamma4 ) * exp_minus2ktau * Tnoscat - & 2.0_wp * ( k_gamma4 + alpha1 * k_mu ) * exp_minusktau ) source_up ( icol , lay_index , igpt ) = Rdir * inc_flux source_dn ( icol , lay_index , igpt ) = Tdir * inc_flux flux_dn_dir ( icol , trans_index , igpt ) = Tnoscat * inc_flux end do source_sfc ( icol , igpt ) = flux_dn_dir ( icol , trans_index , igpt ) * sfc_albedo ( icol , igpt ) end do end do end subroutine sw_dif_and_source ! --------------------------------------------------------------- ! ! Transport of diffuse radiation through a vertically layered atmosphere. !   Equations are after Shonk and Hogan 2008, doi:10.1175/2007JCLI1940.1 (SH08) !   This routine is shared by longwave and shortwave ! ! ------------------------------------------------------------------------------------------------- subroutine adding ( ncol , nlay , ngpt , top_at_1 , & albedo_sfc , & rdif , tdif , & src_dn , src_up , src_sfc , & flux_up , flux_dn ) bind ( C , name = \"adding\" ) !dir$ optimize(-O0) integer , intent ( in ) :: ncol , nlay , ngpt logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: albedo_sfc real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: rdif , tdif real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: src_dn , src_up real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: src_sfc real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_up ! intent(inout) because top layer includes incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( inout ) :: flux_dn ! ------------------ integer :: icol , ilev , igpt ! These arrays could be private per thread in OpenACC, with 1 dimension of size nlay (or nlay+1) ! However, current PGI (19.4) has a bug preventing it from properly handling such private arrays. ! So we explicitly create the temporary arrays of size nlay(+1) per each of the ncol*ngpt elements ! real ( wp ), dimension ( ncol , nlay + 1 , ngpt ) :: albedo , & ! reflectivity to diffuse radiation below this level ! alpha in SH08 src ! source of diffuse upwelling radiation from emission or ! scattering of direct beam ! G in SH08 real ( wp ), dimension ( ncol , nlay , ngpt ) :: denom ! beta in SH08 ! ------------------ ! --------------------------------- ! ! Indexing into arrays for upward and downward propagation depends on the vertical !   orientation of the arrays (whether the domain top is at the first or last index) ! We write the loops out explicitly so compilers will have no trouble optimizing them. ! !$acc enter data copyin(albedo_sfc, rdif, tdif, src_dn, src_up, src_sfc, flux_dn) !$omp target enter data map(to:albedo_sfc, rdif, tdif, src_dn, src_up, src_sfc, flux_dn) !$acc enter data create(flux_up, albedo, src, denom) !$omp target enter data map(alloc:flux_up, albedo, src, denom) if ( top_at_1 ) then !$acc parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ilev = nlay + 1 ! Albedo of lowest level is the surface albedo... albedo ( icol , ilev , igpt ) = albedo_sfc ( icol , igpt ) ! ... and source of diffuse radiation is surface emission src ( icol , ilev , igpt ) = src_sfc ( icol , igpt ) ! ! From bottom to top of atmosphere -- !   compute albedo and source of upward radiation ! do ilev = nlay , 1 , - 1 denom ( icol , ilev , igpt ) = 1._wp / ( 1._wp - rdif ( icol , ilev , igpt ) * albedo ( icol , ilev + 1 , igpt )) ! Eq 10 albedo ( icol , ilev , igpt ) = rdif ( icol , ilev , igpt ) + & tdif ( icol , ilev , igpt ) * tdif ( icol , ilev , igpt ) * albedo ( icol , ilev + 1 , igpt ) * denom ( icol , ilev , igpt ) ! Equation 9 ! ! Equation 11 -- source is emitted upward radiation at top of layer plus !   radiation emitted at bottom of layer, !   transmitted through the layer and reflected from layers below (tdiff*src*albedo) ! src ( icol , ilev , igpt ) = src_up ( icol , ilev , igpt ) + & tdif ( icol , ilev , igpt ) * denom ( icol , ilev , igpt ) * & ( src ( icol , ilev + 1 , igpt ) + albedo ( icol , ilev + 1 , igpt ) * src_dn ( icol , ilev , igpt )) end do ! Eq 12, at the top of the domain upwelling diffuse is due to ... ilev = 1 flux_up ( icol , ilev , igpt ) = flux_dn ( icol , ilev , igpt ) * albedo ( icol , ilev , igpt ) + & ! ... reflection of incident diffuse and src ( icol , ilev , igpt ) ! emission from below ! ! From the top of the atmosphere downward -- compute fluxes ! do ilev = 2 , nlay + 1 flux_dn ( icol , ilev , igpt ) = ( tdif ( icol , ilev - 1 , igpt ) * flux_dn ( icol , ilev - 1 , igpt ) + & ! Equation 13 rdif ( icol , ilev - 1 , igpt ) * src ( icol , ilev , igpt ) + & src_dn ( icol , ilev - 1 , igpt )) * denom ( icol , ilev - 1 , igpt ) flux_up ( icol , ilev , igpt ) = flux_dn ( icol , ilev , igpt ) * albedo ( icol , ilev , igpt ) + & ! Equation 12 src ( icol , ilev , igpt ) end do end do end do else !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ilev = 1 ! Albedo of lowest level is the surface albedo... albedo ( icol , ilev , igpt ) = albedo_sfc ( icol , igpt ) ! ... and source of diffuse radiation is surface emission src ( icol , ilev , igpt ) = src_sfc ( icol , igpt ) ! ! From bottom to top of atmosphere -- !   compute albedo and source of upward radiation ! do ilev = 1 , nlay denom ( icol , ilev , igpt ) = 1._wp / ( 1._wp - rdif ( icol , ilev , igpt ) * albedo ( icol , ilev , igpt )) ! Eq 10 albedo ( icol , ilev + 1 , igpt ) = rdif ( icol , ilev , igpt ) + & tdif ( icol , ilev , igpt ) * tdif ( icol , ilev , igpt ) * albedo ( icol , ilev , igpt ) * denom ( icol , ilev , igpt ) ! Equation 9 ! ! Equation 11 -- source is emitted upward radiation at top of layer plus !   radiation emitted at bottom of layer, !   transmitted through the layer and reflected from layers below (tdiff*src*albedo) ! src ( icol , ilev + 1 , igpt ) = src_up ( icol , ilev , igpt ) + & tdif ( icol , ilev , igpt ) * denom ( icol , ilev , igpt ) * & ( src ( icol , ilev , igpt ) + albedo ( icol , ilev , igpt ) * src_dn ( icol , ilev , igpt )) end do ! Eq 12, at the top of the domain upwelling diffuse is due to ... ilev = nlay + 1 flux_up ( icol , ilev , igpt ) = flux_dn ( icol , ilev , igpt ) * albedo ( icol , ilev , igpt ) + & ! ... reflection of incident diffuse and src ( icol , ilev , igpt ) ! scattering by the direct beam below ! ! From the top of the atmosphere downward -- compute fluxes ! do ilev = nlay , 1 , - 1 flux_dn ( icol , ilev , igpt ) = ( tdif ( icol , ilev , igpt ) * flux_dn ( icol , ilev + 1 , igpt ) + & ! Equation 13 rdif ( icol , ilev , igpt ) * src ( icol , ilev , igpt ) + & src_dn ( icol , ilev , igpt )) * denom ( icol , ilev , igpt ) flux_up ( icol , ilev , igpt ) = flux_dn ( icol , ilev , igpt ) * albedo ( icol , ilev , igpt ) + & ! Equation 12 src ( icol , ilev , igpt ) end do end do end do end if !$acc exit data delete(albedo_sfc, rdif, tdif, src_dn, src_up, src_sfc, albedo, src, denom) !$omp target exit data map(release:albedo_sfc, rdif, tdif, src_dn, src_up, src_sfc, albedo, src, denom) !$acc exit data copyout(flux_up, flux_dn) !$omp target exit data map(from:flux_up, flux_dn) end subroutine adding ! ------------------------------------------------------------------------------------------------- ! ! Similar to Longwave no-scattering tarnsport  (lw_transport_noscat) !   a) adds adjustment factor based on cloud properties ! !   implementation notice: !       the adjustmentFactor computation can be skipped where Cn <= epsilon ! ! ------------------------------------------------------------------------------------------------- subroutine lw_transport_1rescl ( ncol , nlay , ngpt , top_at_1 , & trans , source_dn , source_up , & radn_up , radn_dn , An , Cn , & do_Jacobians , radn_up_Jac ) bind ( C , name = \"lw_transport_1rescl\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 ! real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: trans ! transmissivity = exp(-tau) real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: source_dn , & source_up ! Diffuse radiation emitted by the layer real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( inout ) :: radn_up ! Radiances [W/m2-str] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( inout ) :: radn_dn !Top level must contain incident flux boundary condition real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: An , Cn logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( inout ) :: radn_up_Jac ! Radiances [W/m2-str] ! --------------------------------------------------- ! Local variables integer :: ilev , icol , igpt real ( wp ) :: adjustmentFactor ! --------------------------------------------------- if ( top_at_1 ) then ! ! Top of domain is index 1 ! ! Downward propagation !$acc                         parallel loop    collapse(2) no_create(radn_up_Jac) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ! Upward propagation do ilev = nlay , 1 , - 1 adjustmentFactor = Cn ( icol , ilev , igpt ) * & ( An ( icol , ilev , igpt ) * radn_dn ( icol , ilev , igpt ) - & source_dn ( icol , ilev , igpt ) * trans ( icol , ilev , igpt ) - & source_up ( icol , ilev , igpt )) radn_up ( icol , ilev , igpt ) = trans ( icol , ilev , igpt ) * radn_up ( icol , ilev + 1 , igpt ) + & source_up ( icol , ilev , igpt ) + adjustmentFactor enddo if ( do_Jacobians ) then do ilev = nlay , 1 , - 1 radn_up_Jac ( icol , ilev , igpt ) = trans ( icol , ilev , igpt ) * radn_up_Jac ( icol , ilev + 1 , igpt ) end do end if ! radn_dn_Jac(icol,1,igpt) = 0._wp ! 2nd Downward propagation do ilev = 1 , nlay ! radn_dn_Jac(icol,ilev+1,igpt) = trans(icol,ilev,igpt)*radn_dn_Jac(icol,ilev,igpt) adjustmentFactor = Cn ( icol , ilev , igpt ) * ( & An ( icol , ilev , igpt ) * radn_up ( icol , ilev , igpt ) - & source_up ( icol , ilev , igpt ) * trans ( icol , ilev , igpt ) - & source_dn ( icol , ilev , igpt ) ) radn_dn ( icol , ilev + 1 , igpt ) = trans ( icol , ilev , igpt ) * radn_dn ( icol , ilev , igpt ) + & source_dn ( icol , ilev , igpt ) + adjustmentFactor ! adjustmentFactor             = Cn(icol,ilev,igpt)*An(icol,ilev,igpt)*radn_up_Jac(icol,ilev,igpt) ! radn_dn_Jac(icol,ilev+1,igpt) = radn_dn_Jac(icol,ilev+1,igpt) + adjustmentFactor enddo enddo enddo else !$acc  parallel loop collapse(2) no_create(radn_up_Jac) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ! Upward propagation do ilev = 1 , nlay adjustmentFactor = Cn ( icol , ilev , igpt ) * & ( An ( icol , ilev , igpt ) * radn_dn ( icol , ilev + 1 , igpt ) - & source_dn ( icol , ilev , igpt ) * trans ( icol , ilev , igpt ) - & source_up ( icol , ilev , igpt )) radn_up ( icol , ilev + 1 , igpt ) = trans ( icol , ilev , igpt ) * radn_up ( icol , ilev , igpt ) + & source_up ( icol , ilev , igpt ) + adjustmentFactor end do if ( do_Jacobians ) then do ilev = 1 , nlay radn_up_Jac ( icol , ilev + 1 , igpt ) = trans ( icol , ilev , igpt ) * radn_up_Jac ( icol , ilev , igpt ) end do end if ! 2st Downward propagation ! radn_dn_Jac(icol,nlay+1,igpt) = 0._wp do ilev = nlay , 1 , - 1 ! radn_dn_Jac(icol,ilev,igpt) = trans(icol,ilev,igpt)*radn_dn_Jac(icol,ilev+1,igpt) adjustmentFactor = Cn ( icol , ilev , igpt ) * ( & An ( icol , ilev , igpt ) * radn_up ( icol , ilev , igpt ) - & source_up ( icol , ilev , igpt ) * trans ( icol , ilev , igpt ) - & source_dn ( icol , ilev , igpt ) ) radn_dn ( icol , ilev , igpt ) = trans ( icol , ilev , igpt ) * radn_dn ( icol , ilev + 1 , igpt ) + & source_dn ( icol , ilev , igpt ) + adjustmentFactor ! adjustmentFactor           = Cn(icol,ilev,igpt)*An(icol,ilev,igpt)*radn_up_Jac(icol,ilev,igpt) ! radn_dn_Jac(icol,ilev,igpt) = radn_dn_Jac(icol,ilev,igpt) + adjustmentFactor end do enddo enddo end if end subroutine lw_transport_1rescl ! ------------------------------------------------------------------------------------------------- ! ! Spectral reduction over all points ! subroutine sum_broadband_factor ( ncol , nlev , ngpt , factor , spectral_flux , broadband_flux ) integer , intent ( in ) :: ncol , nlev , ngpt real ( wp ), intent ( in ) :: factor real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( in ) :: spectral_flux real ( wp ), dimension ( ncol , nlev ), intent ( out ) :: broadband_flux integer :: icol , ilev , igpt real ( wp ) :: scalar ! local scalar version !$acc                         parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd          collapse(2) do ilev = 1 , nlev do icol = 1 , ncol scalar = 0.0_wp do igpt = 1 , ngpt scalar = scalar + spectral_flux ( icol , ilev , igpt ) end do broadband_flux ( icol , ilev ) = factor * scalar end do end do end subroutine sum_broadband_factor ! ------------------------------------------------------------------------------------------------- ! ! Apply a scalar weight to every element of an array ! subroutine apply_factor_3D ( ncol , nlev , ngpt , factor , array ) integer , intent ( in ) :: ncol , nlev , ngpt real ( wp ), intent ( in ) :: factor real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( inout ) :: array integer :: icol , ilev , igpt !$acc                         parallel loop gang vector collapse(3) !$omp target teams distribute parallel do simd          collapse(3) do igpt = 1 , ngpt do ilev = 1 , nlev do icol = 1 , ncol array ( icol , ilev , igpt ) = factor * array ( icol , ilev , igpt ) end do end do end do end subroutine apply_factor_3D ! ------------------------------------------------------------------------------------------------- ! ! Add an array to an existing array ! subroutine add_arrays_3D ( ncol , nlev , ngpt , increment , array ) integer , intent ( in ) :: ncol , nlev , ngpt real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( in ) :: increment real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( inout ) :: array integer :: icol , ilev , igpt !$acc                         parallel loop gang vector collapse(3) !$omp target teams distribute parallel do simd          collapse(3) do igpt = 1 , ngpt do ilev = 1 , nlev do icol = 1 , ncol array ( icol , ilev , igpt ) = array ( icol , ilev , igpt ) + increment ( icol , ilev , igpt ) end do end do end do end subroutine add_arrays_3D ! ------------------------------------------------------------------------------------------------- subroutine add_arrays_2D ( ncol , nlev , increment , array ) integer , intent ( in ) :: ncol , nlev real ( wp ), dimension ( ncol , nlev ), intent ( in ) :: increment real ( wp ), dimension ( ncol , nlev ), intent ( inout ) :: array integer :: icol , ilev !$acc                         parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd          collapse(2) do ilev = 1 , nlev do icol = 1 , ncol array ( icol , ilev ) = array ( icol , ilev ) + increment ( icol , ilev ) end do end do end subroutine add_arrays_2D ! ------------------------------------------------------------------------------------------------- end module mo_rte_solver_kernels","tags":"","loc":"sourcefile/mo_rte_solver_kernels.f90~2.html"},{"title":"reorder_123x321_kernel – rte-rrtmgp","text":"public subroutine reorder_123x321_kernel(d1, d2, d3, array_in, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: d1 integer, intent(in) :: d2 integer, intent(in) :: d3 real(kind=wp), intent(in), dimension(d1, d2, d3) :: array_in real(kind=wp), intent(out), dimension(d3, d2, d1) :: array_out Contents Source Code reorder_123x321_kernel Source Code subroutine reorder_123x321_kernel ( d1 , d2 , d3 , array_in , array_out ) & bind ( C , name = \"reorder_123x321_kernel\" ) integer , intent ( in ) :: d1 , d2 , d3 real ( wp ), dimension ( d1 , d2 , d3 ), intent ( in ) :: array_in real ( wp ), dimension ( d3 , d2 , d1 ), intent ( out ) :: array_out integer :: i1 , i2 , i3 , i10 , i30 , i1diff , i3diff integer , parameter :: tile = 32 ! This kernel uses blocking to speed-up the transposition ! We read the data block by block (three outer loops) !  such that a block fits into fastest cache and the memory reads !  are resolved in the cache. The writes are contiguous here, so !  shouldn't be a problem. !  Tile size of 32x32 is empirical: big enough to read from the whole !  cache line, and small enough to fit into cache. Other numbers !  may give slightly better performance on different hardware. ! !$acc parallel vector_length(tile*tile) & !$acc&     copyout(array_out) & !$acc&     copyin(array_in) !$acc loop gang collapse(3) ! private(cache(:,:)) !$omp target teams distribute parallel do simd collapse(3) map(to:array_in) map(from:array_out) do i2 = 1 , d2 do i10 = 1 , d1 , tile do i30 = 1 , d3 , tile !$acc loop vector collapse(2) do i1diff = 0 , tile - 1 do i3diff = 0 , tile - 1 i1 = i10 + i1diff i3 = i30 + i3diff if ( i1 > d1 . or . i3 > d3 ) cycle array_out ( i3 , i2 , i1 ) = array_in ( i1 , i2 , i3 ) end do end do end do end do end do !$acc end parallel end subroutine reorder_123x321_kernel","tags":"","loc":"proc/reorder_123x321_kernel.html"},{"title":"interpolate1D – rte-rrtmgp","text":"public pure function interpolate1D(val, offset, delta, table) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: val real(kind=wp), intent(in) :: offset real(kind=wp), intent(in) :: delta real(kind=wp), intent(in), dimension(:,:) :: table Return Value real(kind=wp),dimension(size(table,dim=2)) Called by proc~~interpolate1d~~CalledByGraph proc~interpolate1d interpolate1D proc~compute_planck_source compute_Planck_source proc~compute_planck_source->proc~interpolate1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpolate1D Source Code pure function interpolate1D ( val , offset , delta , table ) result ( res ) ! input real ( wp ), intent ( in ) :: val , & ! axis value at which to evaluate table offset , & ! minimum of table axis delta ! step size of table axis real ( wp ), dimension (:,:), & intent ( in ) :: table ! dimensions (axis, values) ! output real ( wp ), dimension ( size ( table , dim = 2 )) :: res ! local real ( wp ) :: val0 ! fraction index adjusted by offset and delta integer :: index ! index term real ( wp ) :: frac ! fractional term ! ------------------------------------- val0 = ( val - offset ) / delta frac = val0 - int ( val0 ) ! get fractional part index = min ( size ( table , dim = 1 ) - 1 , max ( 1 , int ( val0 ) + 1 )) ! limit the index range res (:) = table ( index ,:) + frac * ( table ( index + 1 ,:) - table ( index ,:)) end function interpolate1D","tags":"","loc":"proc/interpolate1d.html"},{"title":"interpolate2D – rte-rrtmgp","text":"public pure function interpolate2D(fminor, k, igpt, jeta, jtemp) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: fminor real(kind=wp), intent(in), dimension(:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp Return Value real(kind=wp) Contents Source Code interpolate2D Source Code pure function interpolate2D ( fminor , k , igpt , jeta , jtemp ) result ( res ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: fminor ! interpolation fractions for minor species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference temperature level real ( wp ), dimension (:,:,:), intent ( in ) :: k ! (g-point, eta, temp) integer , intent ( in ) :: igpt , jtemp ! interpolation index for temperature integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) real ( wp ) :: res ! the result res = & fminor ( 1 , 1 ) * k ( jtemp , jeta ( 1 ) , igpt ) + & fminor ( 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , igpt ) + & fminor ( 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , igpt ) + & fminor ( 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , igpt ) end function interpolate2D","tags":"","loc":"proc/interpolate2d.html"},{"title":"interpolate2D_byflav – rte-rrtmgp","text":"public pure function interpolate2D_byflav(fminor, k, gptS, gptE, jeta, jtemp) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: fminor real(kind=wp), intent(in), dimension(:,:,:) :: k integer, intent(in) :: gptS integer, intent(in) :: gptE integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp Return Value real(kind=wp),dimension(gptE-gptS+1) Called by proc~~interpolate2d_byflav~~CalledByGraph proc~interpolate2d_byflav interpolate2D_byflav proc~gas_optical_depths_minor gas_optical_depths_minor proc~gas_optical_depths_minor->proc~interpolate2d_byflav proc~compute_tau_rayleigh compute_tau_rayleigh proc~compute_tau_rayleigh->proc~interpolate2d_byflav proc~compute_tau_absorption compute_tau_absorption proc~compute_tau_absorption->proc~gas_optical_depths_minor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpolate2D_byflav Source Code pure function interpolate2D_byflav ( fminor , k , gptS , gptE , jeta , jtemp ) result ( res ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: fminor ! interpolation fractions for minor species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference temperature level real ( wp ), dimension (:,:,:), intent ( in ) :: k ! (g-point, eta, temp) integer , intent ( in ) :: gptS , gptE , jtemp ! interpolation index for temperature integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) real ( wp ), dimension ( gptE - gptS + 1 ) :: res ! the result ! Local variable integer :: igpt ! each code block is for a different reference temperature do igpt = 1 , gptE - gptS + 1 res ( igpt ) = fminor ( 1 , 1 ) * k ( jtemp , jeta ( 1 ) , gptS + igpt - 1 ) + & fminor ( 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , gptS + igpt - 1 ) + & fminor ( 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , gptS + igpt - 1 ) + & fminor ( 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , gptS + igpt - 1 ) end do end function interpolate2D_byflav","tags":"","loc":"proc/interpolate2d_byflav.html"},{"title":"interpolate3D – rte-rrtmgp","text":"public pure function interpolate3D(scaling, fmajor, k, igpt, jeta, jtemp, jpress) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: scaling real(kind=wp), intent(in), dimension(2,2,2) :: fmajor real(kind=wp), intent(in), dimension(:,:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp integer, intent(in) :: jpress Return Value real(kind=wp) Contents Source Code interpolate3D Source Code pure function interpolate3D ( scaling , fmajor , k , igpt , jeta , jtemp , jpress ) result ( res ) real ( wp ), dimension ( 2 ), intent ( in ) :: scaling real ( wp ), dimension ( 2 , 2 , 2 ), intent ( in ) :: fmajor ! interpolation fractions for major species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference pressure level ! index(3) : reference temperature level real ( wp ), dimension (:,:,:,:), intent ( in ) :: k ! (gpt, eta,temp,press) integer , intent ( in ) :: igpt integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) integer , intent ( in ) :: jtemp ! interpolation index for temperature integer , intent ( in ) :: jpress ! interpolation index for pressure real ( wp ) :: res ! the result ! each code block is for a different reference temperature res = & scaling ( 1 ) * & ( fmajor ( 1 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress , igpt ) ) + & scaling ( 2 ) * & ( fmajor ( 1 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress , igpt ) ) end function interpolate3D","tags":"","loc":"proc/interpolate3d.html"},{"title":"interpolate3D_byflav – rte-rrtmgp","text":"public pure function interpolate3D_byflav(scaling, fmajor, k, gptS, gptE, jeta, jtemp, jpress) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: scaling real(kind=wp), intent(in), dimension(2,2,2) :: fmajor real(kind=wp), intent(in), dimension(:,:,:,:) :: k integer, intent(in) :: gptS integer, intent(in) :: gptE integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp integer, intent(in) :: jpress Return Value real(kind=wp),dimension(gptS:gptE) Called by proc~~interpolate3d_byflav~~CalledByGraph proc~interpolate3d_byflav interpolate3D_byflav proc~compute_planck_source compute_Planck_source proc~compute_planck_source->proc~interpolate3d_byflav proc~gas_optical_depths_major gas_optical_depths_major proc~gas_optical_depths_major->proc~interpolate3d_byflav proc~compute_tau_absorption compute_tau_absorption proc~compute_tau_absorption->proc~gas_optical_depths_major Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpolate3D_byflav Source Code pure function interpolate3D_byflav ( scaling , fmajor , k , gptS , gptE , jeta , jtemp , jpress ) result ( res ) real ( wp ), dimension ( 2 ), intent ( in ) :: scaling real ( wp ), dimension ( 2 , 2 , 2 ), intent ( in ) :: fmajor ! interpolation fractions for major species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference pressure level ! index(3) : reference temperature level real ( wp ), dimension (:,:,:,:), intent ( in ) :: k ! (temp,eta,press,gpt) integer , intent ( in ) :: gptS , gptE integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) integer , intent ( in ) :: jtemp ! interpolation index for temperature integer , intent ( in ) :: jpress ! interpolation index for pressure real ( wp ), dimension ( gptS : gptE ) :: res ! the result ! Local variable integer :: igpt ! each code block is for a different reference temperature do igpt = gptS , gptE res ( igpt ) = & scaling ( 1 ) * & ( fmajor ( 1 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress , igpt ) ) + & scaling ( 2 ) * & ( fmajor ( 1 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress , igpt ) ) end do end function interpolate3D_byflav","tags":"","loc":"proc/interpolate3d_byflav.html"},{"title":"compute_Planck_source – rte-rrtmgp","text":"public subroutine compute_Planck_source(ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, nPlanckTemp, tlay, tlev, tsfc, sfc_lay, fmajor, jeta, tropo, jtemp, jpress, gpoint_bands, band_lims_gpt, pfracin, temp_ref_min, totplnk_delta, totplnk, gpoint_flavor, sfc_src, lay_src, lev_src_inc, lev_src_dec, sfc_source_Jac) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nPlanckTemp real(kind=wp), intent(in), dimension(ncol,nlay  ) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay+1) :: tlev real(kind=wp), intent(in), dimension(ncol       ) :: tsfc integer, intent(in) :: sfc_lay real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(            ncol,nlay) :: tropo integer, intent(in), dimension(            ncol,nlay) :: jtemp integer, intent(in), dimension(            ncol,nlay) :: jpress integer, intent(in), dimension(ngpt) :: gpoint_bands integer, intent(in), dimension(2, nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: pfracin real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: totplnk_delta real(kind=wp), intent(in), dimension(nPlanckTemp,nbnd) :: totplnk integer, intent(in), dimension(2,ngpt) :: gpoint_flavor real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lay_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_inc real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_dec real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_source_Jac Calls proc~~compute_planck_source~~CallsGraph proc~compute_planck_source compute_Planck_source proc~interpolate3d_byflav interpolate3D_byflav proc~compute_planck_source->proc~interpolate3d_byflav proc~interpolate1d interpolate1D proc~compute_planck_source->proc~interpolate1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code compute_Planck_source Source Code subroutine compute_Planck_source ( & ncol , nlay , nbnd , ngpt , & nflav , neta , npres , ntemp , nPlanckTemp ,& tlay , tlev , tsfc , sfc_lay , & fmajor , jeta , tropo , jtemp , jpress , & gpoint_bands , band_lims_gpt , & pfracin , temp_ref_min , totplnk_delta , totplnk , gpoint_flavor , & sfc_src , lay_src , lev_src_inc , lev_src_dec , sfc_source_Jac ) bind ( C , name = \"compute_Planck_source\" ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: nflav , neta , npres , ntemp , nPlanckTemp real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: tlay real ( wp ), dimension ( ncol , nlay + 1 ), intent ( in ) :: tlev real ( wp ), dimension ( ncol ), intent ( in ) :: tsfc integer , intent ( in ) :: sfc_lay ! Interpolation variables real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress ! Table-specific integer , dimension ( ngpt ), intent ( in ) :: gpoint_bands ! start and end g-point for each band integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), intent ( in ) :: temp_ref_min , totplnk_delta real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: pfracin real ( wp ), dimension ( nPlanckTemp , nbnd ), intent ( in ) :: totplnk integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: sfc_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: lay_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: lev_src_inc , lev_src_dec real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: sfc_source_Jac ! ----------------- ! local real ( wp ), parameter :: delta_Tsurf = 1.0_wp integer :: ilay , icol , igpt , ibnd , itropo , iflav integer :: gptS , gptE real ( wp ), dimension ( 2 ), parameter :: one = [ 1._wp , 1._wp ] real ( wp ) :: pfrac ( ncol , nlay , ngpt ) real ( wp ) :: planck_function ( ncol , nlay + 1 , nbnd ) ! ----------------- ! Calculation of fraction of band's Planck irradiance associated with each g-point do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) iflav = gpoint_flavor ( itropo , gptS ) !eta interpolation depends on band's flavor pfrac ( icol , ilay , gptS : gptE ) = & ! interpolation in temperature, pressure, and eta interpolate3D_byflav ( one , fmajor (:,:,:, icol , ilay , iflav ), pfracin , & band_lims_gpt ( 1 , ibnd ), band_lims_gpt ( 2 , ibnd ), & jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay ), jpress ( icol , ilay ) + itropo ) end do ! column end do ! layer end do ! band ! ! Planck function by band for the surface ! Compute surface source irradiance for g-point, equals band irradiance x fraction for g-point ! do icol = 1 , ncol planck_function ( icol , 1 , 1 : nbnd ) = interpolate1D ( tsfc ( icol ), temp_ref_min , totplnk_delta , totplnk ) planck_function ( icol , 2 , 1 : nbnd ) = interpolate1D ( tsfc ( icol ) + delta_Tsurf , temp_ref_min , totplnk_delta , totplnk ) ! ! Map to g-points ! do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do igpt = gptS , gptE sfc_src ( icol , igpt ) = pfrac ( icol , sfc_lay , igpt ) * planck_function ( icol , 1 , ibnd ) sfc_source_Jac ( icol , igpt ) = pfrac ( icol , sfc_lay , igpt ) * & ( planck_function ( icol , 2 , ibnd ) - planck_function ( icol , 1 , ibnd )) end do end do end do !icol do ilay = 1 , nlay do icol = 1 , ncol ! Compute layer source irradiance for g-point, equals band irradiance x fraction for g-point planck_function ( icol , ilay , 1 : nbnd ) = interpolate1D ( tlay ( icol , ilay ), temp_ref_min , totplnk_delta , totplnk ) end do end do ! ! Map to g-points ! do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do igpt = gptS , gptE do ilay = 1 , nlay do icol = 1 , ncol lay_src ( icol , ilay , igpt ) = pfrac ( icol , ilay , igpt ) * planck_function ( icol , ilay , ibnd ) end do end do end do end do ! compute level source irradiances for each g-point, one each for upward and downward paths do ilay = 1 , nlay do icol = 1 , ncol planck_function ( icol , 1 , 1 : nbnd ) = interpolate1D ( tlev ( icol , 1 ), temp_ref_min , totplnk_delta , totplnk ) planck_function ( icol , ilay + 1 , 1 : nbnd ) = interpolate1D ( tlev ( icol , ilay + 1 ), temp_ref_min , totplnk_delta , totplnk ) end do end do ! ! Map to g-points ! do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do igpt = gptS , gptE do ilay = 1 , nlay do icol = 1 , ncol lev_src_inc ( icol , ilay , igpt ) = pfrac ( icol , ilay , igpt ) * planck_function ( icol , ilay + 1 , ibnd ) lev_src_dec ( icol , ilay , igpt ) = pfrac ( icol , ilay , igpt ) * planck_function ( icol , ilay , ibnd ) end do end do end do end do end subroutine compute_Planck_source","tags":"","loc":"proc/compute_planck_source.html"},{"title":"compute_tau_absorption – rte-rrtmgp","text":"public subroutine compute_tau_absorption(ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, nminorlower, nminorklower, nminorupper, nminorkupper, idx_h2o, gpoint_flavor, band_lims_gpt, kmajor, kminor_lower, kminor_upper, minor_limits_gpt_lower, minor_limits_gpt_upper, minor_scales_with_density_lower, minor_scales_with_density_upper, scale_by_complement_lower, scale_by_complement_upper, idx_minor_lower, idx_minor_upper, idx_minor_scaling_lower, idx_minor_scaling_upper, kminor_start_lower, kminor_start_upper, tropo, col_mix, fmajor, fminor, play, tlay, col_gas, jeta, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nminorlower integer, intent(in) :: nminorklower integer, intent(in) :: nminorupper integer, intent(in) :: nminorkupper integer, intent(in) :: idx_h2o integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(ntemp,neta,nminorklower) :: kminor_lower real(kind=wp), intent(in), dimension(ntemp,neta,nminorkupper) :: kminor_upper integer, intent(in), dimension(2,nminorlower) :: minor_limits_gpt_lower integer, intent(in), dimension(2,nminorupper) :: minor_limits_gpt_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: minor_scales_with_density_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: minor_scales_with_density_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: scale_by_complement_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: scale_by_complement_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_scaling_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_scaling_upper integer, intent(in), dimension(  nminorlower) :: kminor_start_lower integer, intent(in), dimension(  nminorupper) :: kminor_start_upper logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav       ) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav       ) :: fmajor real(kind=wp), intent(in), dimension(2,2,  ncol,nlay,nflav       ) :: fminor real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: play real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: tlay real(kind=wp), intent(in), dimension(            ncol,nlay,0:ngas) :: col_gas integer, intent(in), dimension(2,    ncol,nlay,nflav       ) :: jeta integer, intent(in), dimension(            ncol,nlay       ) :: jtemp integer, intent(in), dimension(            ncol,nlay       ) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau Calls proc~~compute_tau_absorption~~CallsGraph proc~compute_tau_absorption compute_tau_absorption proc~gas_optical_depths_minor gas_optical_depths_minor proc~compute_tau_absorption->proc~gas_optical_depths_minor proc~gas_optical_depths_major gas_optical_depths_major proc~compute_tau_absorption->proc~gas_optical_depths_major proc~interpolate2d_byflav interpolate2D_byflav proc~gas_optical_depths_minor->proc~interpolate2d_byflav proc~interpolate3d_byflav interpolate3D_byflav proc~gas_optical_depths_major->proc~interpolate3d_byflav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code compute_tau_absorption Source Code subroutine compute_tau_absorption ( & ncol , nlay , nbnd , ngpt , & ! dimensions ngas , nflav , neta , npres , ntemp , & nminorlower , nminorklower , & ! number of minor contributors, total num absorption coeffs nminorupper , nminorkupper , & idx_h2o , & gpoint_flavor , & band_lims_gpt , & kmajor , & kminor_lower , & kminor_upper , & minor_limits_gpt_lower , & minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scale_by_complement_lower , & scale_by_complement_upper , & idx_minor_lower , & idx_minor_upper , & idx_minor_scaling_lower , & idx_minor_scaling_upper , & kminor_start_lower , & kminor_start_upper , & tropo , & col_mix , fmajor , fminor , & play , tlay , col_gas , & jeta , jtemp , jpress , & tau ) bind ( C , name = \"compute_tau_absorption\" ) ! --------------------- ! input dimensions integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , intent ( in ) :: nminorlower , nminorklower , nminorupper , nminorkupper integer , intent ( in ) :: idx_h2o ! --------------------- ! inputs from object integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: kmajor real ( wp ), dimension ( ntemp , neta , nminorklower ), intent ( in ) :: kminor_lower real ( wp ), dimension ( ntemp , neta , nminorkupper ), intent ( in ) :: kminor_upper integer , dimension ( 2 , nminorlower ), intent ( in ) :: minor_limits_gpt_lower integer , dimension ( 2 , nminorupper ), intent ( in ) :: minor_limits_gpt_upper logical ( wl ), dimension ( nminorlower ), intent ( in ) :: minor_scales_with_density_lower logical ( wl ), dimension ( nminorupper ), intent ( in ) :: minor_scales_with_density_upper logical ( wl ), dimension ( nminorlower ), intent ( in ) :: scale_by_complement_lower logical ( wl ), dimension ( nminorupper ), intent ( in ) :: scale_by_complement_upper integer , dimension ( nminorlower ), intent ( in ) :: idx_minor_lower integer , dimension ( nminorupper ), intent ( in ) :: idx_minor_upper integer , dimension ( nminorlower ), intent ( in ) :: idx_minor_scaling_lower integer , dimension ( nminorupper ), intent ( in ) :: idx_minor_scaling_upper integer , dimension ( nminorlower ), intent ( in ) :: kminor_start_lower integer , dimension ( nminorupper ), intent ( in ) :: kminor_start_upper logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo ! --------------------- ! inputs from profile or parent function real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay ! pressure and temperature real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp integer , dimension ( ncol , nlay ), intent ( in ) :: jpress ! --------------------- ! output - optical depth real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! --------------------- ! Local variables ! logical :: top_at_1 integer , dimension ( ncol , 2 ) :: itropo_lower , itropo_upper ! ---------------------------------------------------------------- ! --------------------- ! Layer limits of upper, lower atmospheres ! --------------------- top_at_1 = play ( 1 , 1 ) < play ( 1 , nlay ) if ( top_at_1 ) then itropo_lower (:, 1 ) = minloc ( play , dim = 2 , mask = tropo ) itropo_lower (:, 2 ) = nlay itropo_upper (:, 1 ) = 1 itropo_upper (:, 2 ) = maxloc ( play , dim = 2 , mask = (. not . tropo )) else itropo_lower (:, 1 ) = 1 itropo_lower (:, 2 ) = minloc ( play , dim = 2 , mask = tropo ) itropo_upper (:, 1 ) = maxloc ( play , dim = 2 , mask = (. not . tropo )) itropo_upper (:, 2 ) = nlay end if ! --------------------- ! Major Species ! --------------------- call gas_optical_depths_major ( & ncol , nlay , nbnd , ngpt , & ! dimensions nflav , neta , npres , ntemp , & gpoint_flavor , & band_lims_gpt , & kmajor , & col_mix , fmajor , & jeta , tropo , jtemp , jpress , & tau ) ! --------------------- ! Minor Species - lower ! --------------------- call gas_optical_depths_minor ( & ncol , nlay , ngpt , & ! dimensions ngas , nflav , ntemp , neta , & nminorlower , nminorklower , & idx_h2o , & gpoint_flavor ( 1 ,:), & kminor_lower , & minor_limits_gpt_lower , & minor_scales_with_density_lower , & scale_by_complement_lower , & idx_minor_lower , & idx_minor_scaling_lower , & kminor_start_lower , & play , tlay , & col_gas , fminor , jeta , & itropo_lower , jtemp , & tau ) ! --------------------- ! Minor Species - upper ! --------------------- call gas_optical_depths_minor ( & ncol , nlay , ngpt , & ! dimensions ngas , nflav , ntemp , neta , & nminorupper , nminorkupper , & idx_h2o , & gpoint_flavor ( 2 ,:), & kminor_upper , & minor_limits_gpt_upper , & minor_scales_with_density_upper , & scale_by_complement_upper , & idx_minor_upper , & idx_minor_scaling_upper , & kminor_start_upper , & play , tlay , & col_gas , fminor , jeta , & itropo_upper , jtemp , & tau ) end subroutine compute_tau_absorption","tags":"","loc":"proc/compute_tau_absorption.html"},{"title":"compute_tau_rayleigh – rte-rrtmgp","text":"public subroutine compute_tau_rayleigh(ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, krayl, idx_h2o, col_dry, col_gas, fminor, jeta, tropo, jtemp, tau_rayleigh) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,ngpt,2) :: krayl integer, intent(in) :: idx_h2o real(kind=wp), intent(in), dimension(ncol,nlay) :: col_dry real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: tau_rayleigh Calls proc~~compute_tau_rayleigh~~CallsGraph proc~compute_tau_rayleigh compute_tau_rayleigh proc~interpolate2d_byflav interpolate2D_byflav proc~compute_tau_rayleigh->proc~interpolate2d_byflav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code compute_tau_rayleigh Source Code subroutine compute_tau_rayleigh ( ncol , nlay , nbnd , ngpt , & ngas , nflav , neta , npres , ntemp , & gpoint_flavor , band_lims_gpt , & krayl , & idx_h2o , col_dry , col_gas , & fminor , jeta , tropo , jtemp , & tau_rayleigh ) bind ( C , name = \"compute_tau_rayleigh\" ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), dimension ( ntemp , neta , ngpt , 2 ), intent ( in ) :: krayl integer , intent ( in ) :: idx_h2o real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: col_dry real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp ! outputs real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: tau_rayleigh ! ----------------- ! local variables real ( wp ) :: k ( ngpt ) ! rayleigh scattering coefficient integer :: icol , ilay , iflav , ibnd , gptS , gptE integer :: itropo ! ----------------- do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! itropo = 1 lower atmosphere;itropo = 2 upper atmosphere iflav = gpoint_flavor ( itropo , gptS ) !eta interpolation depends on band's flavor k ( gptS : gptE ) = interpolate2D_byflav ( fminor (:,:, icol , ilay , iflav ), & krayl (:,:,:, itropo ), & gptS , gptE , jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay )) tau_rayleigh ( icol , ilay , gptS : gptE ) = k ( gptS : gptE ) * & ( col_gas ( icol , ilay , idx_h2o ) + col_dry ( icol , ilay )) end do end do end do end subroutine compute_tau_rayleigh","tags":"","loc":"proc/compute_tau_rayleigh.html"},{"title":"gas_optical_depths_major – rte-rrtmgp","text":"public subroutine gas_optical_depths_major(ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, kmajor, col_mix, fmajor, jeta, tropo, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp integer, intent(in), dimension(ncol,nlay) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau Calls proc~~gas_optical_depths_major~~CallsGraph proc~gas_optical_depths_major gas_optical_depths_major proc~interpolate3d_byflav interpolate3D_byflav proc~gas_optical_depths_major->proc~interpolate3d_byflav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gas_optical_depths_major~~CalledByGraph proc~gas_optical_depths_major gas_optical_depths_major proc~compute_tau_absorption compute_tau_absorption proc~compute_tau_absorption->proc~gas_optical_depths_major Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code gas_optical_depths_major Source Code subroutine gas_optical_depths_major ( ncol , nlay , nbnd , ngpt ,& nflav , neta , npres , ntemp , & ! dimensions gpoint_flavor , band_lims_gpt , & ! inputs from object kmajor , & col_mix , fmajor , & jeta , tropo , jtemp , jpress , & ! local input tau ) bind ( C , name = \"gas_optical_depths_major\" ) ! input dimensions integer , intent ( in ) :: ncol , nlay , nbnd , ngpt , nflav , neta , npres , ntemp ! dimensions ! inputs from object integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: kmajor ! inputs from profile or parent function real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress ! outputs real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! ----------------- ! local variables real ( wp ) :: tau_major ( ngpt ) ! major species optical depth ! local index integer :: icol , ilay , iflav , ibnd , itropo integer :: gptS , gptE ! optical depth calculation for major species do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) iflav = gpoint_flavor ( itropo , gptS ) !eta interpolation depends on band's flavor tau_major ( gptS : gptE ) = & ! interpolation in temperature, pressure, and eta interpolate3D_byflav ( col_mix (:, icol , ilay , iflav ), & fmajor (:,:,:, icol , ilay , iflav ), kmajor , & band_lims_gpt ( 1 , ibnd ), band_lims_gpt ( 2 , ibnd ), & jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay ), jpress ( icol , ilay ) + itropo ) tau ( icol , ilay , gptS : gptE ) = tau ( icol , ilay , gptS : gptE ) + tau_major ( gptS : gptE ) end do end do end do end subroutine gas_optical_depths_major","tags":"","loc":"proc/gas_optical_depths_major.html"},{"title":"gas_optical_depths_minor – rte-rrtmgp","text":"public subroutine gas_optical_depths_minor(ncol, nlay, ngpt, ngas, nflav, ntemp, neta, nminor, nminork, idx_h2o, gpt_flv, kminor, minor_limits_gpt, minor_scales_with_density, scale_by_complement, idx_minor, idx_minor_scaling, kminor_start, play, tlay, col_gas, fminor, jeta, layer_limits, jtemp, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: ntemp integer, intent(in) :: neta integer, intent(in) :: nminor integer, intent(in) :: nminork integer, intent(in) :: idx_h2o integer, intent(in), dimension(ngpt) :: gpt_flv real(kind=wp), intent(in), dimension(ntemp,neta,nminork) :: kminor integer, intent(in), dimension(2,nminor) :: minor_limits_gpt logical(kind=wl), intent(in), dimension(  nminor) :: minor_scales_with_density logical(kind=wl), intent(in), dimension(  nminor) :: scale_by_complement integer, intent(in), dimension(  nminor) :: idx_minor integer, intent(in), dimension(  nminor) :: idx_minor_scaling integer, intent(in), dimension(  nminor) :: kminor_start real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta integer, intent(in), dimension(ncol, 2) :: layer_limits integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau Calls proc~~gas_optical_depths_minor~~CallsGraph proc~gas_optical_depths_minor gas_optical_depths_minor proc~interpolate2d_byflav interpolate2D_byflav proc~gas_optical_depths_minor->proc~interpolate2d_byflav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gas_optical_depths_minor~~CalledByGraph proc~gas_optical_depths_minor gas_optical_depths_minor proc~compute_tau_absorption compute_tau_absorption proc~compute_tau_absorption->proc~gas_optical_depths_minor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code gas_optical_depths_minor Source Code subroutine gas_optical_depths_minor ( ncol , nlay , ngpt , & ngas , nflav , ntemp , neta , & nminor , nminork , & idx_h2o , & gpt_flv , & kminor , & minor_limits_gpt , & minor_scales_with_density , & scale_by_complement , & idx_minor , idx_minor_scaling , & kminor_start , & play , tlay , & col_gas , fminor , jeta , & layer_limits , jtemp , & tau ) bind ( C , name = \"gas_optical_depths_minor\" ) integer , intent ( in ) :: ncol , nlay , ngpt integer , intent ( in ) :: ngas , nflav integer , intent ( in ) :: ntemp , neta , nminor , nminork integer , intent ( in ) :: idx_h2o integer , dimension ( ngpt ), intent ( in ) :: gpt_flv real ( wp ), dimension ( ntemp , neta , nminork ), intent ( in ) :: kminor integer , dimension ( 2 , nminor ), intent ( in ) :: minor_limits_gpt logical ( wl ), dimension ( nminor ), intent ( in ) :: minor_scales_with_density logical ( wl ), dimension ( nminor ), intent ( in ) :: scale_by_complement integer , dimension ( nminor ), intent ( in ) :: kminor_start integer , dimension ( nminor ), intent ( in ) :: idx_minor , idx_minor_scaling real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta integer , dimension ( ncol , 2 ), intent ( in ) :: layer_limits integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! ----------------- ! local variables real ( wp ), parameter :: PaTohPa = 0.01_wp real ( wp ) :: vmr_fact , dry_fact ! conversion from column abundance to dry vol. mixing ratio; real ( wp ) :: scaling ! optical depth integer :: icol , ilay , iflav , imnr integer :: gptS , gptE real ( wp ), dimension ( ngpt ) :: tau_minor ! ----------------- ! ! Guard against layer limits being 0 -- that means don't do anything i.e. there are no !   layers with pressures in the upper or lower atmosphere respectively ! First check skips the routine entirely if all columns are out of bounds... ! if ( any ( layer_limits (:, 1 ) > 0 )) then do imnr = 1 , size ( scale_by_complement , dim = 1 ) ! loop over minor absorbers in each band do icol = 1 , ncol ! ! This check skips individual columns with no pressures in range ! if ( layer_limits ( icol , 1 ) > 0 ) then do ilay = layer_limits ( icol , 1 ), layer_limits ( icol , 2 ) ! ! Scaling of minor gas absortion coefficient begins with column amount of minor gas ! scaling = col_gas ( icol , ilay , idx_minor ( imnr )) ! ! Density scaling (e.g. for h2o continuum, collision-induced absorption) ! if ( minor_scales_with_density ( imnr )) then ! ! NOTE: P needed in hPa to properly handle density scaling. ! scaling = scaling * ( PaTohPa * play ( icol , ilay ) / tlay ( icol , ilay )) if ( idx_minor_scaling ( imnr ) > 0 ) then ! there is a second gas that affects this gas's absorption vmr_fact = 1._wp / col_gas ( icol , ilay , 0 ) dry_fact = 1._wp / ( 1._wp + col_gas ( icol , ilay , idx_h2o ) * vmr_fact ) ! scale by density of special gas if ( scale_by_complement ( imnr )) then ! scale by densities of all gases but the special one scaling = scaling * ( 1._wp - col_gas ( icol , ilay , idx_minor_scaling ( imnr )) * vmr_fact * dry_fact ) else scaling = scaling * ( col_gas ( icol , ilay , idx_minor_scaling ( imnr )) * vmr_fact * dry_fact ) endif endif endif ! ! Interpolation of absorption coefficient and calculation of optical depth ! ! Which gpoint range does this minor gas affect? gptS = minor_limits_gpt ( 1 , imnr ) gptE = minor_limits_gpt ( 2 , imnr ) iflav = gpt_flv ( gptS ) tau_minor ( gptS : gptE ) = scaling * & interpolate2D_byflav ( fminor (:,:, icol , ilay , iflav ), & kminor , & kminor_start ( imnr ), kminor_start ( imnr ) + ( gptE - gptS ), & jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay )) tau ( icol , ilay , gptS : gptE ) = tau ( icol , ilay , gptS : gptE ) + tau_minor ( gptS : gptE ) enddo end if enddo enddo end if end subroutine gas_optical_depths_minor","tags":"","loc":"proc/gas_optical_depths_minor.html"},{"title":"interpolation – rte-rrtmgp","text":"public subroutine interpolation(ncol, nlay, ngas, nflav, neta, npres, ntemp, flavor, press_ref_log, temp_ref, press_ref_log_delta, temp_ref_min, temp_ref_delta, press_ref_trop_log, vmr_ref, play, tlay, col_gas, jtemp, fmajor, fminor, col_mix, tropo, jeta, jpress) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,nflav) :: flavor real(kind=wp), intent(in), dimension(npres) :: press_ref_log real(kind=wp), intent(in), dimension(ntemp) :: temp_ref real(kind=wp), intent(in) :: press_ref_log_delta real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: temp_ref_delta real(kind=wp), intent(in) :: press_ref_trop_log real(kind=wp), intent(in), dimension(2,0:ngas,ntemp) :: vmr_ref real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas integer, intent(out), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(2,2,2,ncol,nlay,nflav) :: fmajor real(kind=wp), intent(out), dimension(2,2,  ncol,nlay,nflav) :: fminor real(kind=wp), intent(out), dimension(2,    ncol,nlay,nflav) :: col_mix logical(kind=wl), intent(out), dimension(ncol,nlay) :: tropo integer, intent(out), dimension(2,    ncol,nlay,nflav) :: jeta integer, intent(out), dimension(ncol,nlay) :: jpress Calls proc~~interpolation~~CallsGraph proc~interpolation interpolation float float proc~interpolation->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpolation Source Code subroutine interpolation ( & ncol , nlay , ngas , nflav , neta , npres , ntemp , & flavor , & press_ref_log , temp_ref , press_ref_log_delta , & temp_ref_min , temp_ref_delta , press_ref_trop_log , & vmr_ref , & play , tlay , col_gas , & jtemp , fmajor , fminor , col_mix , tropo , jeta , jpress ) bind ( C , name = \"interpolation\" ) ! input dimensions integer , intent ( in ) :: ncol , nlay integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , dimension ( 2 , nflav ), intent ( in ) :: flavor real ( wp ), dimension ( npres ), intent ( in ) :: press_ref_log real ( wp ), dimension ( ntemp ), intent ( in ) :: temp_ref real ( wp ), intent ( in ) :: press_ref_log_delta , & temp_ref_min , temp_ref_delta , & press_ref_trop_log real ( wp ), dimension ( 2 , 0 : ngas , ntemp ), intent ( in ) :: vmr_ref ! inputs from profile or parent function real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas ! outputs integer , dimension ( ncol , nlay ), intent ( out ) :: jtemp , jpress logical ( wl ), dimension ( ncol , nlay ), intent ( out ) :: tropo integer , dimension ( 2 , ncol , nlay , nflav ), intent ( out ) :: jeta real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( out ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( out ) :: fmajor real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( out ) :: fminor ! ----------------- ! local real ( wp ), dimension ( ncol , nlay ) :: ftemp , fpress ! interpolation fraction for temperature, pressure real ( wp ) :: locpress ! needed to find location in pressure grid real ( wp ) :: ratio_eta_half ! ratio of vmrs of major species that defines eta=0.5 ! for given flavor and reference temperature level real ( wp ) :: eta , feta ! binary_species_parameter, interpolation variable for eta real ( wp ) :: loceta ! needed to find location in eta grid real ( wp ) :: ftemp_term ! ----------------- ! local indexes integer :: icol , ilay , iflav , igases ( 2 ), itropo , itemp do ilay = 1 , nlay do icol = 1 , ncol ! index and factor for temperature interpolation jtemp ( icol , ilay ) = int (( tlay ( icol , ilay ) - ( temp_ref_min - temp_ref_delta )) / temp_ref_delta ) jtemp ( icol , ilay ) = min ( ntemp - 1 , max ( 1 , jtemp ( icol , ilay ))) ! limit the index range ftemp ( icol , ilay ) = ( tlay ( icol , ilay ) - temp_ref ( jtemp ( icol , ilay ))) / temp_ref_delta ! index and factor for pressure interpolation locpress = 1._wp + ( log ( play ( icol , ilay )) - press_ref_log ( 1 )) / press_ref_log_delta jpress ( icol , ilay ) = min ( npres - 1 , max ( 1 , int ( locpress ))) fpress ( icol , ilay ) = locpress - float ( jpress ( icol , ilay )) ! determine if in lower or upper part of atmosphere tropo ( icol , ilay ) = log ( play ( icol , ilay )) > press_ref_trop_log end do end do do iflav = 1 , nflav igases (:) = flavor (:, iflav ) do ilay = 1 , nlay do icol = 1 , ncol ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! loop over implemented combinations of major species do itemp = 1 , 2 ! compute interpolation fractions needed for lower, then upper reference temperature level ! compute binary species parameter (eta) for flavor and temperature and !  associated interpolation index and factors ratio_eta_half = vmr_ref ( itropo , igases ( 1 ),( jtemp ( icol , ilay ) + itemp - 1 )) / & vmr_ref ( itropo , igases ( 2 ),( jtemp ( icol , ilay ) + itemp - 1 )) col_mix ( itemp , icol , ilay , iflav ) = col_gas ( icol , ilay , igases ( 1 )) + ratio_eta_half * col_gas ( icol , ilay , igases ( 2 )) eta = merge ( col_gas ( icol , ilay , igases ( 1 )) / col_mix ( itemp , icol , ilay , iflav ), 0.5_wp , & col_mix ( itemp , icol , ilay , iflav ) > 2._wp * tiny ( col_mix )) loceta = eta * float ( neta - 1 ) jeta ( itemp , icol , ilay , iflav ) = min ( int ( loceta ) + 1 , neta - 1 ) feta = mod ( loceta , 1.0_wp ) ! compute interpolation fractions needed for minor species ! ftemp_term = (1._wp-ftemp(icol,ilay)) for itemp = 1, ftemp(icol,ilay) for itemp=2 ftemp_term = ( real ( 2 - itemp , wp ) + real ( 2 * itemp - 3 , wp ) * ftemp ( icol , ilay )) fminor ( 1 , itemp , icol , ilay , iflav ) = ( 1._wp - feta ) * ftemp_term fminor ( 2 , itemp , icol , ilay , iflav ) = feta * ftemp_term ! compute interpolation fractions needed for major species fmajor ( 1 , 1 , itemp , icol , ilay , iflav ) = ( 1._wp - fpress ( icol , ilay )) * fminor ( 1 , itemp , icol , ilay , iflav ) fmajor ( 2 , 1 , itemp , icol , ilay , iflav ) = ( 1._wp - fpress ( icol , ilay )) * fminor ( 2 , itemp , icol , ilay , iflav ) fmajor ( 1 , 2 , itemp , icol , ilay , iflav ) = fpress ( icol , ilay ) * fminor ( 1 , itemp , icol , ilay , iflav ) fmajor ( 2 , 2 , itemp , icol , ilay , iflav ) = fpress ( icol , ilay ) * fminor ( 2 , itemp , icol , ilay , iflav ) end do ! reference temperatures end do ! icol end do ! ilay end do ! iflav end subroutine interpolation","tags":"","loc":"proc/interpolation.html"},{"title":"sum_broadband – rte-rrtmgp","text":"public subroutine sum_broadband(ncol, nlev, ngpt, spectral_flux, broadband_flux) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux real(kind=wp), intent(out), dimension(ncol, nlev) :: broadband_flux Contents Source Code sum_broadband Source Code subroutine sum_broadband ( ncol , nlev , ngpt , spectral_flux , broadband_flux ) bind ( C , name = \"sum_broadband\" ) integer , intent ( in ) :: ncol , nlev , ngpt real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( in ) :: spectral_flux real ( wp ), dimension ( ncol , nlev ), intent ( out ) :: broadband_flux integer :: icol , ilev , igpt real ( wp ) :: bb_flux_s ! local scalar version !$acc enter data copyin(spectral_flux) create(broadband_flux) !$omp target enter data map(to:spectral_flux) map(alloc:broadband_flux) !$acc parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilev = 1 , nlev do icol = 1 , ncol bb_flux_s = 0.0_wp do igpt = 1 , ngpt bb_flux_s = bb_flux_s + spectral_flux ( icol , ilev , igpt ) end do broadband_flux ( icol , ilev ) = bb_flux_s end do end do !$acc exit data delete(spectral_flux) copyout(broadband_flux) !$omp target exit data map(release:spectral_flux) map(from:broadband_flux) end subroutine sum_broadband","tags":"","loc":"proc/sum_broadband.html"},{"title":"net_broadband – rte-rrtmgp","text":"public interface net_broadband Contents Module Procedures net_broadband_full net_broadband_precalc Module Procedures private subroutine net_broadband_full(ncol, nlev, ngpt, spectral_flux_dn, spectral_flux_up, broadband_flux_net) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_up real(kind=wp), intent(out), dimension(ncol, nlev) :: broadband_flux_net private subroutine net_broadband_precalc(ncol, nlev, flux_dn, flux_up, broadband_flux_net) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev real(kind=wp), intent(in), dimension(ncol, nlev) :: flux_dn real(kind=wp), intent(in), dimension(ncol, nlev) :: flux_up real(kind=wp), intent(out), dimension(ncol, nlev) :: broadband_flux_net","tags":"","loc":"interface/net_broadband.html"},{"title":"delta_scale_2str_f_k – rte-rrtmgp","text":"public pure subroutine delta_scale_2str_f_k(ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f Called by proc~~delta_scale_2str_f_k~~CalledByGraph proc~delta_scale_2str_f_k delta_scale_2str_f_k interface~delta_scale_2str_kernel delta_scale_2str_kernel interface~delta_scale_2str_kernel->proc~delta_scale_2str_f_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code delta_scale_2str_f_k Source Code pure subroutine delta_scale_2str_f_k ( ncol , nlay , ngpt , tau , ssa , g , f ) & bind ( C , name = \"delta_scale_2str_f_k\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau , ssa , g real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: f real ( wp ) :: wf integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol wf = ssa ( icol , ilay , igpt ) * f ( icol , ilay , igpt ) tau ( icol , ilay , igpt ) = ( 1._wp - wf ) * tau ( icol , ilay , igpt ) ssa ( icol , ilay , igpt ) = ( ssa ( icol , ilay , igpt ) - wf ) / max ( eps ,( 1.0_wp - wf )) g ( icol , ilay , igpt ) = ( g ( icol , ilay , igpt ) - f ( icol , ilay , igpt )) / & max ( eps ,( 1._wp - f ( icol , ilay , igpt ))) end do end do end do end subroutine delta_scale_2str_f_k","tags":"","loc":"proc/delta_scale_2str_f_k.html"},{"title":"delta_scale_2str_k – rte-rrtmgp","text":"public pure subroutine delta_scale_2str_k(ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g Called by proc~~delta_scale_2str_k~~CalledByGraph proc~delta_scale_2str_k delta_scale_2str_k interface~delta_scale_2str_kernel delta_scale_2str_kernel interface~delta_scale_2str_kernel->proc~delta_scale_2str_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code delta_scale_2str_k Source Code pure subroutine delta_scale_2str_k ( ncol , nlay , ngpt , tau , ssa , g ) & bind ( C , name = \"delta_scale_2str_k\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau , ssa , g real ( wp ) :: f , wf integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol f = g ( icol , ilay , igpt ) * g ( icol , ilay , igpt ) wf = ssa ( icol , ilay , igpt ) * f tau ( icol , ilay , igpt ) = ( 1._wp - wf ) * tau ( icol , ilay , igpt ) ssa ( icol , ilay , igpt ) = ( ssa ( icol , ilay , igpt ) - wf ) / max ( eps ,( 1.0_wp - wf )) g ( icol , ilay , igpt ) = ( g ( icol , ilay , igpt ) - f ) / max ( eps ,( 1.0_wp - f )) end do end do end do end subroutine delta_scale_2str_k","tags":"","loc":"proc/delta_scale_2str_k.html"},{"title":"extract_subset_absorption_tau – rte-rrtmgp","text":"public pure subroutine extract_subset_absorption_tau(ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out Called by proc~~extract_subset_absorption_tau~~CalledByGraph proc~extract_subset_absorption_tau extract_subset_absorption_tau interface~extract_subset extract_subset interface~extract_subset->proc~extract_subset_absorption_tau Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code extract_subset_absorption_tau Source Code pure subroutine extract_subset_absorption_tau ( ncol , nlay , ngpt , tau_in , ssa_in , & colS , colE , tau_out ) & bind ( C , name = \"extract_subset_absorption_tau\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau_in , ssa_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: tau_out integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE tau_out ( icol - colS + 1 , ilay , igpt ) = & tau_in ( icol , ilay , igpt ) * ( 1._wp - ssa_in ( icol , ilay , igpt )) end do end do end do end subroutine extract_subset_absorption_tau","tags":"","loc":"proc/extract_subset_absorption_tau.html"},{"title":"extract_subset_dim1_3d – rte-rrtmgp","text":"public pure subroutine extract_subset_dim1_3d(ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out Called by proc~~extract_subset_dim1_3d~~CalledByGraph proc~extract_subset_dim1_3d extract_subset_dim1_3d interface~extract_subset extract_subset interface~extract_subset->proc~extract_subset_dim1_3d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code extract_subset_dim1_3d Source Code pure subroutine extract_subset_dim1_3d ( ncol , nlay , ngpt , array_in , colS , colE , array_out ) & bind ( C , name = \"extract_subset_dim1_3d\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: array_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: array_out integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE array_out ( icol - colS + 1 , ilay , igpt ) = array_in ( icol , ilay , igpt ) end do end do end do end subroutine extract_subset_dim1_3d","tags":"","loc":"proc/extract_subset_dim1_3d.html"},{"title":"extract_subset_dim2_4d – rte-rrtmgp","text":"public pure subroutine extract_subset_dim2_4d(nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out Called by proc~~extract_subset_dim2_4d~~CalledByGraph proc~extract_subset_dim2_4d extract_subset_dim2_4d interface~extract_subset extract_subset interface~extract_subset->proc~extract_subset_dim2_4d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code extract_subset_dim2_4d Source Code pure subroutine extract_subset_dim2_4d ( nmom , ncol , nlay , ngpt , array_in , colS , colE , array_out ) & bind ( C , name = \"extract_subset_dim2_4d\" ) integer , intent ( in ) :: nmom , ncol , nlay , ngpt real ( wp ), dimension ( nmom , ncol , nlay , ngpt ), intent ( in ) :: array_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( nmom , colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: array_out integer :: icol , ilay , igpt , imom do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE do imom = 1 , nmom array_out ( imom , icol - colS + 1 , ilay , igpt ) = array_in ( imom , icol , ilay , igpt ) end do end do end do end do end subroutine extract_subset_dim2_4d","tags":"","loc":"proc/extract_subset_dim2_4d.html"},{"title":"inc_1scalar_by_1scalar_bybnd – rte-rrtmgp","text":"public pure subroutine inc_1scalar_by_1scalar_bybnd(ncol, nlay, ngpt, tau1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_1scalar_by_1scalar_bybnd Source Code pure subroutine inc_1scalar_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) tau1 (:,:, igpt ) = tau1 (:,:, igpt ) + tau2 (:,:, ibnd ) end do end do end subroutine inc_1scalar_by_1scalar_bybnd","tags":"","loc":"proc/inc_1scalar_by_1scalar_bybnd.html"},{"title":"inc_1scalar_by_2stream_bybnd – rte-rrtmgp","text":"public pure subroutine inc_1scalar_by_2stream_bybnd(ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_1scalar_by_2stream_bybnd Source Code pure subroutine inc_1scalar_by_2stream_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) tau1 (:,:, igpt ) = tau1 (:,:, igpt ) + tau2 (:,:, ibnd ) * ( 1._wp - ssa2 (:,:, ibnd )) end do end do end subroutine inc_1scalar_by_2stream_bybnd","tags":"","loc":"proc/inc_1scalar_by_2stream_bybnd.html"},{"title":"inc_1scalar_by_nstream_bybnd – rte-rrtmgp","text":"public pure subroutine inc_1scalar_by_nstream_bybnd(ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_1scalar_by_nstream_bybnd Source Code pure subroutine inc_1scalar_by_nstream_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) tau1 (:,:, igpt ) = tau1 (:,:, igpt ) + tau2 (:,:, ibnd ) * ( 1._wp - ssa2 (:,:, ibnd )) end do end do end subroutine inc_1scalar_by_nstream_bybnd","tags":"","loc":"proc/inc_1scalar_by_nstream_bybnd.html"},{"title":"inc_2stream_by_1scalar_bybnd – rte-rrtmgp","text":"public pure subroutine inc_2stream_by_1scalar_bybnd(ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_2stream_by_1scalar_bybnd Source Code pure subroutine inc_2stream_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! g is unchanged end do end do end do end do end subroutine inc_2stream_by_1scalar_bybnd","tags":"","loc":"proc/inc_2stream_by_1scalar_bybnd.html"},{"title":"inc_2stream_by_2stream_bybnd – rte-rrtmgp","text":"public pure subroutine inc_2stream_by_2stream_bybnd(ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_2stream_by_2stream_bybnd Source Code pure subroutine inc_2stream_by_2stream_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , g1 , & tau2 , ssa2 , g2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 , g2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * g2 ( icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end do end subroutine inc_2stream_by_2stream_bybnd","tags":"","loc":"proc/inc_2stream_by_2stream_bybnd.html"},{"title":"inc_2stream_by_nstream_bybnd – rte-rrtmgp","text":"public pure subroutine inc_2stream_by_nstream_bybnd(ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_2stream_by_nstream_bybnd Source Code pure subroutine inc_2stream_by_nstream_bybnd ( ncol , nlay , ngpt , nmom2 , & tau1 , ssa1 , g1 , & tau2 , ssa2 , p2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom2 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , nbnd ), intent ( in ) :: p2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * p2 ( 1 , icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end do end subroutine inc_2stream_by_nstream_bybnd","tags":"","loc":"proc/inc_2stream_by_nstream_bybnd.html"},{"title":"inc_nstream_by_1scalar_bybnd – rte-rrtmgp","text":"public pure subroutine inc_nstream_by_1scalar_bybnd(ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_nstream_by_1scalar_bybnd Source Code pure subroutine inc_nstream_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! p is unchanged end do end do end do end do end subroutine inc_nstream_by_1scalar_bybnd","tags":"","loc":"proc/inc_nstream_by_1scalar_bybnd.html"},{"title":"inc_nstream_by_2stream_bybnd – rte-rrtmgp","text":"public pure subroutine inc_nstream_by_2stream_bybnd(ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_nstream_by_2stream_bybnd Source Code pure subroutine inc_nstream_by_2stream_bybnd ( ncol , nlay , ngpt , nmom1 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , g2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 , g2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 real ( wp ), dimension ( nmom1 ) :: temp_moms ! TK integer :: imom !TK do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) ! ! Here assume Henyey-Greenstein ! temp_moms ( 1 ) = g2 ( icol , ilay , ibnd ) do imom = 2 , nmom1 temp_moms ( imom ) = temp_moms ( imom - 1 ) * g2 ( icol , ilay , ibnd ) end do p1 ( 1 : nmom1 , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : nmom1 , icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * temp_moms ( 1 : nmom1 ) ) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end do end subroutine inc_nstream_by_2stream_bybnd","tags":"","loc":"proc/inc_nstream_by_2stream_bybnd.html"},{"title":"inc_nstream_by_nstream_bybnd – rte-rrtmgp","text":"public pure subroutine inc_nstream_by_nstream_bybnd(ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_nstream_by_nstream_bybnd Source Code pure subroutine inc_nstream_by_nstream_bybnd ( ncol , nlay , ngpt , nmom1 , nmom2 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , p2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nmom2 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , nbnd ), intent ( in ) :: p2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd , mom_lim real ( wp ) :: tau12 , tauscat12 mom_lim = min ( nmom1 , nmom2 ) do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) ! ! If op2 has more moments than op1 these are ignored; !   if it has fewer moments the higher orders are assumed to be 0 ! p1 ( 1 : mom_lim , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : mom_lim , icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * p2 ( 1 : mom_lim , icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end do end subroutine inc_nstream_by_nstream_bybnd","tags":"","loc":"proc/inc_nstream_by_nstream_bybnd.html"},{"title":"increment_1scalar_by_1scalar – rte-rrtmgp","text":"public pure subroutine increment_1scalar_by_1scalar(ncol, nlay, ngpt, tau1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 Contents Source Code increment_1scalar_by_1scalar Source Code pure subroutine increment_1scalar_by_1scalar ( ncol , nlay , ngpt , & tau1 , & tau2 ) bind ( C , name = \"increment_1scalar_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) end do end do end do end subroutine increment_1scalar_by_1scalar","tags":"","loc":"proc/increment_1scalar_by_1scalar.html"},{"title":"increment_1scalar_by_2stream – rte-rrtmgp","text":"public pure subroutine increment_1scalar_by_2stream(ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 Contents Source Code increment_1scalar_by_2stream Source Code pure subroutine increment_1scalar_by_2stream ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 ) bind ( C , name = \"increment_1scalar_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ( 1._wp - ssa2 ( icol , ilay , igpt )) end do end do end do end subroutine increment_1scalar_by_2stream","tags":"","loc":"proc/increment_1scalar_by_2stream.html"},{"title":"increment_1scalar_by_nstream – rte-rrtmgp","text":"public pure subroutine increment_1scalar_by_nstream(ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 Contents Source Code increment_1scalar_by_nstream Source Code pure subroutine increment_1scalar_by_nstream ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 ) bind ( C , name = \"increment_1scalar_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ( 1._wp - ssa2 ( icol , ilay , igpt )) end do end do end do end subroutine increment_1scalar_by_nstream","tags":"","loc":"proc/increment_1scalar_by_nstream.html"},{"title":"increment_2stream_by_1scalar – rte-rrtmgp","text":"public pure subroutine increment_2stream_by_1scalar(ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 Contents Source Code increment_2stream_by_1scalar Source Code pure subroutine increment_2stream_by_1scalar ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 ) bind ( C , name = \"increment_2stream_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt real ( wp ) :: tau12 do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! g is unchanged end do end do end do end subroutine increment_2stream_by_1scalar","tags":"","loc":"proc/increment_2stream_by_1scalar.html"},{"title":"increment_2stream_by_2stream – rte-rrtmgp","text":"public pure subroutine increment_2stream_by_2stream(ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 Contents Source Code increment_2stream_by_2stream Source Code pure subroutine increment_2stream_by_2stream ( ncol , nlay , ngpt , & tau1 , ssa1 , g1 , & tau2 , ssa2 , g2 ) bind ( C , name = \"increment_2stream_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 , g2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * g2 ( icol , ilay , igpt )) & / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end subroutine increment_2stream_by_2stream","tags":"","loc":"proc/increment_2stream_by_2stream.html"},{"title":"increment_2stream_by_nstream – rte-rrtmgp","text":"public pure subroutine increment_2stream_by_nstream(ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2 Contents Source Code increment_2stream_by_nstream Source Code pure subroutine increment_2stream_by_nstream ( ncol , nlay , ngpt , nmom2 , & tau1 , ssa1 , g1 , & tau2 , ssa2 , p2 ) bind ( C , name = \"increment_2stream_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom2 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , ngpt ), intent ( in ) :: p2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * p2 ( 1 , icol , ilay , igpt )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end subroutine increment_2stream_by_nstream","tags":"","loc":"proc/increment_2stream_by_nstream.html"},{"title":"increment_nstream_by_1scalar – rte-rrtmgp","text":"public pure subroutine increment_nstream_by_1scalar(ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 Contents Source Code increment_nstream_by_1scalar Source Code pure subroutine increment_nstream_by_1scalar ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 ) bind ( C , name = \"increment_nstream_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt real ( wp ) :: tau12 do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! p is unchanged end do end do end do end subroutine increment_nstream_by_1scalar","tags":"","loc":"proc/increment_nstream_by_1scalar.html"},{"title":"increment_nstream_by_2stream – rte-rrtmgp","text":"public pure subroutine increment_nstream_by_2stream(ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 Contents Source Code increment_nstream_by_2stream Source Code pure subroutine increment_nstream_by_2stream ( ncol , nlay , ngpt , nmom1 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , g2 ) bind ( C , name = \"increment_nstream_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 , g2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 real ( wp ), dimension ( nmom1 ) :: temp_moms ! TK integer :: imom !TK do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) ! ! Here assume Henyey-Greenstein ! temp_moms ( 1 ) = g2 ( icol , ilay , igpt ) do imom = 2 , nmom1 temp_moms ( imom ) = temp_moms ( imom - 1 ) * g2 ( icol , ilay , igpt ) end do p1 ( 1 : nmom1 , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : nmom1 , icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * temp_moms ( 1 : nmom1 ) ) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end subroutine increment_nstream_by_2stream","tags":"","loc":"proc/increment_nstream_by_2stream.html"},{"title":"increment_nstream_by_nstream – rte-rrtmgp","text":"public pure subroutine increment_nstream_by_nstream(ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2 Contents Source Code increment_nstream_by_nstream Source Code pure subroutine increment_nstream_by_nstream ( ncol , nlay , ngpt , nmom1 , nmom2 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , p2 ) bind ( C , name = \"increment_nstream_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nmom2 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , ngpt ), intent ( in ) :: p2 integer :: icol , ilay , igpt , mom_lim real ( wp ) :: tau12 , tauscat12 mom_lim = min ( nmom1 , nmom2 ) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) ! ! If op2 has more moments than op1 these are ignored; !   if it has fewer moments the higher orders are assumed to be 0 ! p1 ( 1 : mom_lim , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : mom_lim , icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * p2 ( 1 : mom_lim , icol , ilay , igpt )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end subroutine increment_nstream_by_nstream","tags":"","loc":"proc/increment_nstream_by_nstream.html"},{"title":"delta_scale_2str_kernel – rte-rrtmgp","text":"public interface delta_scale_2str_kernel Calls interface~~delta_scale_2str_kernel~~CallsGraph interface~delta_scale_2str_kernel delta_scale_2str_kernel proc~delta_scale_2str_f_k delta_scale_2str_f_k interface~delta_scale_2str_kernel->proc~delta_scale_2str_f_k proc~delta_scale_2str_k delta_scale_2str_k interface~delta_scale_2str_kernel->proc~delta_scale_2str_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures delta_scale_2str_f_k delta_scale_2str_k Module Procedures public pure subroutine delta_scale_2str_f_k (ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f public pure subroutine delta_scale_2str_k (ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g","tags":"","loc":"interface/delta_scale_2str_kernel.html"},{"title":"extract_subset – rte-rrtmgp","text":"public interface extract_subset Calls interface~~extract_subset~~CallsGraph interface~extract_subset extract_subset proc~extract_subset_absorption_tau extract_subset_absorption_tau interface~extract_subset->proc~extract_subset_absorption_tau proc~extract_subset_dim1_3d extract_subset_dim1_3d interface~extract_subset->proc~extract_subset_dim1_3d proc~extract_subset_dim2_4d extract_subset_dim2_4d interface~extract_subset->proc~extract_subset_dim2_4d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures extract_subset_dim1_3d extract_subset_dim2_4d extract_subset_absorption_tau Module Procedures public pure subroutine extract_subset_dim1_3d (ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out public pure subroutine extract_subset_dim2_4d (nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out public pure subroutine extract_subset_absorption_tau (ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out","tags":"","loc":"interface/extract_subset.html"},{"title":"lw_solver_2stream – rte-rrtmgp","text":"public subroutine lw_solver_2stream(ncol, nlay, ngpt, top_at_1, tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dn Contents Source Code lw_solver_2stream Source Code subroutine lw_solver_2stream ( ncol , nlay , ngpt , top_at_1 , & tau , ssa , g , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn ) bind ( C , name = \"lw_solver_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , & ! Optical thickness, ssa , & ! single-scattering albedo, g ! asymmetry parameter [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( in ) :: lev_source_inc , lev_source_dec ! Planck source at layer edge for radiation in increasing/decreasing ilay direction [W/m2] ! Includes spectral weighting that accounts for state-dependent frequency to g-space mapping real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux ! Incident diffuse flux, probably 0 [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ---------------------------------------------------------------------- integer :: igpt , top_level real ( wp ), dimension ( ncol , nlay ) :: Rdif , Tdif , gamma1 , gamma2 real ( wp ), dimension ( ncol ) :: sfc_albedo real ( wp ), dimension ( ncol , nlay + 1 ) :: lev_source real ( wp ), dimension ( ncol , nlay ) :: source_dn , source_up real ( wp ), dimension ( ncol ) :: source_sfc ! ------------------------------------ top_level = nlay + 1 if ( top_at_1 ) top_level = 1 do igpt = 1 , ngpt ! ! RRTMGP provides source functions at each level using the spectral mapping !   of each adjacent layer. Combine these for two-stream calculations ! call lw_combine_sources ( ncol , nlay , top_at_1 , & lev_source_inc (:,:, igpt ), lev_source_dec (:,:, igpt ), & lev_source ) ! ! Cell properties: reflection, transmission for diffuse radiation !   Coupling coefficients needed for source function ! call lw_two_stream ( ncol , nlay , & tau (:,:, igpt ), ssa (:,:, igpt ), g (:,:, igpt ), & gamma1 , gamma2 , Rdif , Tdif ) ! ! Source function for diffuse radiation ! call lw_source_2str ( ncol , nlay , top_at_1 , & sfc_emis (:, igpt ), sfc_src (:, igpt ), & lay_source (:,:, igpt ), lev_source , & gamma1 , gamma2 , Rdif , Tdif , tau (:,:, igpt ), & source_dn , source_up , source_sfc ) ! ! Transport ! sfc_albedo ( 1 : ncol ) = 1._wp - sfc_emis (:, igpt ) ! ! Boundary condition ! flux_dn (:, top_level , igpt ) = inc_flux (:, igpt ) call adding ( ncol , nlay , top_at_1 , & sfc_albedo , & Rdif , Tdif , & source_dn , source_up , source_sfc , & flux_up (:,:, igpt ), flux_dn (:,:, igpt )) end do end subroutine lw_solver_2stream","tags":"","loc":"proc/lw_solver_2stream.html"},{"title":"lw_solver_noscat – rte-rrtmgp","text":"public subroutine lw_solver_noscat(ncol, nlay, ngpt, top_at_1, D, weight, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, incident_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: D real(kind=wp), intent(in) :: weight real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: incident_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g Calls proc~~lw_solver_noscat~~CallsGraph proc~lw_solver_noscat lw_solver_noscat zero_array zero_array proc~lw_solver_noscat->zero_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lw_solver_noscat~~CalledByGraph proc~lw_solver_noscat lw_solver_noscat proc~lw_solver_noscat_gaussquad lw_solver_noscat_GaussQuad proc~lw_solver_noscat_gaussquad->proc~lw_solver_noscat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lw_solver_noscat Source Code subroutine lw_solver_noscat ( ncol , nlay , ngpt , top_at_1 , D , weight , & tau , lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & incident_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) bind ( C , name = \"lw_solver_noscat\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: D ! secant of propagation angle  [] real ( wp ), intent ( in ) :: weight ! quadrature weight real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] ! Planck source at layer edge for radiation in increasing/decreasing ilay direction ! lev_source_dec applies the mapping in layer i to the Planck function at layer i ! lev_source_inc applies the mapping in layer i to the Planck function at layer i+1 real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( in ) :: lev_source_inc , lev_source_dec real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: incident_flux ! Boundary condition for flux [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & ! Fluxes [W/m2] intent ( out ) :: flux_up , flux_dn ! ! Optional variables - arrays aren't referenced if corresponding logical  == False ! logical ( wl ), intent ( in ) :: do_broadband real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: broadband_up , broadband_dn ! Spectrally-integrated fluxes [W/m2] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_srcJac ! surface temperature Jacobian of surface source function [W/m2/K] real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: flux_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] logical ( wl ), intent ( in ) :: do_rescaling real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: ssa , g ! single-scattering albedo, asymmetry parameter ! ------------------------------------ ! Local variables, no g-point dependency ! integer :: icol , ilay , igpt integer :: top_level , sfc_level real ( wp ), dimension ( ncol , nlay ) :: tau_loc , & ! path length (tau/mu) trans ! transmissivity  = exp(-tau) real ( wp ), dimension ( ncol , nlay ) :: source_dn , source_up real ( wp ), dimension ( ncol ) :: sfc_albedo real ( wp ), dimension (:,:,:), pointer :: lev_source_up , lev_source_dn ! Mapping increasing/decreasing indicies to up/down real ( wp ), parameter :: pi = acos ( - 1._wp ) ! loc_fluxes hold a single g-point flux if fluxes are being integrated instead of returned !   with spectral detail real ( wp ), dimension ( ncol , nlay + 1 ), & target :: loc_flux_up , loc_flux_dn ! gpt_fluxes point to calculations for the current g-point real ( wp ), dimension (:,:), pointer :: gpt_flux_up , gpt_flux_dn ! ------------------------------------------------------------------------------------------------- ! Optionally, use an approximate treatment of scattering using rescaling !   Implemented based on the paper !   Tang G, et al, 2018: https://doi.org/10.1175/JAS-D-18-0014.1 !   a) relies on rescaling of the optical parameters based on asymetry factor and single scattering albedo !       scaling can be computed  by scaling_1rescl !   b) adds adustment term based on cloud properties (lw_transport_1rescl) !      adustment terms is computed based on solution of the Tang equations !      for \"linear-in-tau\" internal source (not in the paper) ! ! Used when approximating scattering ! real ( wp ) :: ssal , wb , scaleTau real ( wp ), dimension ( ncol , nlay ) :: An , Cn real ( wp ), dimension ( ncol , nlay + 1 ) :: gpt_flux_Jac ! ------------------------------------ ! Which way is up? ! Level Planck sources for upward and downward radiation ! When top_at_1, lev_source_up => lev_source_dec !                lev_source_dn => lev_source_inc, and vice-versa if ( top_at_1 ) then top_level = 1 sfc_level = nlay + 1 lev_source_up => lev_source_dec lev_source_dn => lev_source_inc else top_level = nlay + 1 sfc_level = 1 lev_source_up => lev_source_inc lev_source_dn => lev_source_dec end if ! ! Integrated fluxes need zeroing ! if ( do_broadband ) then call zero_array ( ncol , nlay + 1 , broadband_up ) call zero_array ( ncol , nlay + 1 , broadband_dn ) end if if ( do_Jacobians ) & call zero_array ( ncol , nlay + 1 , flux_upJac ) do igpt = 1 , ngpt if ( do_broadband ) then gpt_flux_up => loc_flux_up gpt_flux_dn => loc_flux_dn else gpt_flux_up => flux_up (:,:, igpt ) gpt_flux_dn => flux_dn (:,:, igpt ) end if ! ! Transport is for intensity !   convert flux at top of domain to intensity assuming azimuthal isotropy ! gpt_flux_dn (:, top_level ) = incident_flux (:, igpt ) / ( 2._wp * pi * weight ) ! ! Optical path and transmission, used in source function and transport calculations ! if ( do_rescaling ) then ! ! The scaling and scaleTau terms are independent of propagation !   angle D and could be pre-computed if several values of D are used ! We re-compute them here to keep not have to localize memory use ! do ilay = 1 , nlay do icol = 1 , ncol ssal = ssa ( icol , ilay , igpt ) ! w is the layer single scattering albedo ! b is phase function parameter (Eq.13 of the paper) ! for the similarity principle scaling scheme ! b = (1-g)/2 (where g is phase function avergae cosine) wb = ssal * ( 1._wp - g ( icol , ilay , igpt )) * 0.5_wp ! scaleTau=1-w(1-b) is a scaling factor of the optical thickness representing ! the radiative transfer equation in a nonscattering form Eq(14) of the paper scaleTau = ( 1._wp - ssal + wb ) ! Cn = 0.5*wb/(1-w(1-b)) is parameter of Eq.21-22 of the Tang paper ! Tang paper, p.2222 advises to replace 0.5 with 0.4 based on simulations Cn ( icol , ilay ) = 0.4_wp * wb / scaleTau ! Eqs.15, 18ab and 19 of the paper, ! rescaling of the optical depth multiplied by path length tau_loc ( icol , ilay ) = tau ( icol , ilay , igpt ) * D ( icol , igpt ) * scaleTau end do trans (:, ilay ) = exp ( - tau_loc (:, ilay )) An (:, ilay ) = ( 1._wp - trans (:, ilay ) ** 2 ) end do else do ilay = 1 , nlay tau_loc (:, ilay ) = tau (:, ilay , igpt ) * D (:, igpt ) trans (:, ilay ) = exp ( - tau_loc (:, ilay )) end do end if ! ! Source function for diffuse radiation ! call lw_source_noscat ( ncol , nlay , & lay_source (:,:, igpt ), lev_source_up (:,:, igpt ), lev_source_dn (:,:, igpt ), & tau_loc , trans , source_dn , source_up ) ! ! Transport down ! call lw_transport_noscat_dn ( ncol , nlay , top_at_1 , trans , source_dn , gpt_flux_dn ) ! ! Surface albedo, surface source function, reflection and emission ! sfc_albedo (:) = 1._wp - sfc_emis (:, igpt ) gpt_flux_up (:, sfc_level ) = gpt_flux_dn (:, sfc_level ) * sfc_albedo (:) + & sfc_emis (:, igpt ) * sfc_src (:, igpt ) if ( do_Jacobians ) & gpt_flux_Jac (:, sfc_level ) = sfc_emis (:, igpt ) * sfc_srcJac (:, igpt ) ! ! Transport up, or up and down again if using rescaling ! if ( do_rescaling ) then call lw_transport_1rescl ( ncol , nlay , top_at_1 , trans , & source_dn , source_up , & gpt_flux_up , gpt_flux_dn , An , Cn , & do_Jacobians , gpt_flux_Jac ) ! Standing in for Jacobian, i.e. rad_up_Jac(:,:,igpt), rad_dn_Jac(:,:,igpt)) else call lw_transport_noscat_up ( ncol , nlay , top_at_1 , trans , source_up , gpt_flux_up , & do_Jacobians , gpt_flux_Jac ) end if if ( do_broadband ) then broadband_up (:,:) = broadband_up (:,:) + gpt_flux_up (:,:) broadband_dn (:,:) = broadband_dn (:,:) + gpt_flux_dn (:,:) else ! ! Convert intensity to flux assuming azimuthal isotropy and quadrature weight ! gpt_flux_dn (:,:) = 2._wp * pi * weight * gpt_flux_dn (:,:) gpt_flux_up (:,:) = 2._wp * pi * weight * gpt_flux_up (:,:) end if ! ! Only broadband-integrated Jacobians are provided ! if ( do_Jacobians ) & flux_upJac (:,:) = flux_upJac (:,:) + gpt_flux_Jac (:,:) end do ! g point loop if ( do_broadband ) then broadband_up (:,:) = 2._wp * pi * weight * broadband_up (:,:) broadband_dn (:,:) = 2._wp * pi * weight * broadband_dn (:,:) end if if ( do_Jacobians ) & flux_upJac (:,:) = 2._wp * pi * weight * flux_upJac (:,:) end subroutine lw_solver_noscat","tags":"","loc":"proc/lw_solver_noscat.html"},{"title":"lw_solver_noscat_GaussQuad – rte-rrtmgp","text":"public subroutine lw_solver_noscat_GaussQuad(ncol, nlay, ngpt, top_at_1, nmus, Ds, weights, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 integer, intent(in) :: nmus real(kind=wp), intent(in), dimension (ncol,      ngpt, nmus) :: Ds real(kind=wp), intent(in), dimension(nmus) :: weights real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g Calls proc~~lw_solver_noscat_gaussquad~~CallsGraph proc~lw_solver_noscat_gaussquad lw_solver_noscat_GaussQuad proc~lw_solver_noscat lw_solver_noscat proc~lw_solver_noscat_gaussquad->proc~lw_solver_noscat zero_array zero_array proc~lw_solver_noscat->zero_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lw_solver_noscat_GaussQuad Source Code subroutine lw_solver_noscat_GaussQuad ( ncol , nlay , ngpt , top_at_1 , & nmus , Ds , weights , & tau , & lay_source , lev_source_inc , lev_source_dec , & sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) bind ( C , name = \"lw_solver_noscat_GaussQuad\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 integer , intent ( in ) :: nmus ! number of quadrature angles real ( wp ), dimension ( ncol , ngpt , & nmus ), intent ( in ) :: Ds real ( wp ), dimension ( nmus ), intent ( in ) :: weights ! quadrature secants, weights real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_source_inc ! Planck source at layer edge for radiation in increasing ilay direction [W/m2] ! Includes spectral weighting that accounts for state-dependent frequency to g-space mapping real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_source_dec ! Planck source at layer edge for radiation in decreasing ilay direction [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux ! Incident diffuse flux, probably 0 [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ! Optional variables - arrays aren't referenced if corresponding logical  == False ! logical ( wl ), intent ( in ) :: do_broadband real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( out ) :: broadband_up , broadband_dn ! Spectrally-integrated fluxes [W/m2] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_srcJac ! surface temperature Jacobian of surface source function [W/m2/K] real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( out ) :: flux_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] logical ( wl ), intent ( in ) :: do_rescaling real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: ssa , g ! single-scattering albedo, asymmetry parameter ! ------------------------------------ ! ! Local variables - used for a single quadrature angle ! real ( wp ), dimension (:,:,:), pointer :: this_flux_up , this_flux_dn real ( wp ), dimension (:,:), pointer :: this_broadband_up , this_broadband_dn , this_flux_upJac integer :: imu ! ------------------------------------ ! ! For the first angle output arrays store total flux ! call lw_solver_noscat ( ncol , nlay , ngpt , & top_at_1 , Ds (:,:, 1 ), weights ( 1 ), tau , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) ! ! For more than one angle use local arrays ! if ( nmus > 1 ) then if ( do_broadband ) then allocate ( this_broadband_up ( ncol , nlay + 1 ), this_broadband_dn ( ncol , nlay + 1 )) ! Spectrally-resolved fluxes won't be filled in so can point to caller-supplied memory this_flux_up => flux_up this_flux_dn => flux_dn else allocate ( this_flux_up ( ncol , nlay + 1 , ngpt ), this_flux_dn ( ncol , nlay + 1 , ngpt )) ! Spectrally-integrated fluxes won't be filled in so can point to caller-supplied memory this_broadband_up => broadband_up this_broadband_dn => broadband_dn end if if ( do_Jacobians ) then allocate ( this_flux_upJac ( ncol , nlay + 1 )) else this_flux_upJac => flux_upJac end if end if do imu = 2 , nmus call lw_solver_noscat ( ncol , nlay , ngpt , & top_at_1 , Ds (:,:, imu ), weights ( imu ), tau , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & this_flux_up , this_flux_dn , & do_broadband , this_broadband_up , this_broadband_dn , & do_Jacobians , sfc_srcJac , this_flux_upJac , & do_rescaling , ssa , g ) if ( do_broadband ) then broadband_up (:,:) = broadband_up (:,:) + this_broadband_up (:,:) broadband_dn (:,:) = broadband_dn (:,:) + this_broadband_dn (:,:) else flux_up (:,:,:) = flux_up (:,:,:) + this_flux_up (:,:,:) flux_dn (:,:,:) = flux_dn (:,:,:) + this_flux_dn (:,:,:) end if if ( do_Jacobians ) & flux_upJac (:,:) = flux_upJac (:,: ) + this_flux_upJac (:,: ) end do if ( nmus > 1 ) then if ( do_broadband ) deallocate ( this_broadband_up , this_broadband_dn ) if (. not . do_broadband ) deallocate ( this_flux_up , this_flux_dn ) if ( do_Jacobians ) deallocate ( this_flux_upJac ) end if end subroutine lw_solver_noscat_GaussQuad","tags":"","loc":"proc/lw_solver_noscat_gaussquad.html"},{"title":"sw_solver_2stream – rte-rrtmgp","text":"public subroutine sw_solver_2stream(ncol, nlay, ngpt, top_at_1, tau, ssa, g, mu0, sfc_alb_dir, sfc_alb_dif, inc_flux_dir, flux_up, flux_dn, flux_dir, has_dif_bc, inc_flux_dif, do_broadband, broadband_up, broadband_dn, broadband_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dir real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dif real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dir logical(kind=wl), intent(in) :: has_dif_bc real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dif logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dir Calls proc~~sw_solver_2stream~~CallsGraph proc~sw_solver_2stream sw_solver_2stream zero_array zero_array proc~sw_solver_2stream->zero_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sw_solver_2stream Source Code subroutine sw_solver_2stream ( ncol , nlay , ngpt , top_at_1 , & tau , ssa , g , mu0 , & sfc_alb_dir , sfc_alb_dif , & inc_flux_dir , & flux_up , flux_dn , flux_dir , & has_dif_bc , inc_flux_dif , & do_broadband , broadband_up , & broadband_dn , broadband_dir ) bind ( C , name = \"sw_solver_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , & ! Optical thickness, ssa , & ! single-scattering albedo, g ! asymmetry parameter [] real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 ! cosine of solar zenith angle ! Spectral albedo of surface to direct and diffuse radiation real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_alb_dir , sfc_alb_dif , & inc_flux_dir ! Direct beam incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn , flux_dir ! Fluxes [W/m2] logical ( wl ), intent ( in ) :: has_dif_bc ! Is a boundary condition for diffuse flux supplied? real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux_dif ! Boundary condition for diffuse flux logical ( wl ), intent ( in ) :: do_broadband ! Provide broadband-integrated, not spectrally-resolved, fluxes? real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: broadband_up , broadband_dn , broadband_dir ! -------------------------------------------           ! Broadband integrated fluxes integer :: igpt , top_level real ( wp ), dimension ( ncol , nlay ) :: Rdif , Tdif real ( wp ), dimension ( ncol , nlay ) :: source_up , source_dn real ( wp ), dimension ( ncol ) :: source_srf ! loc_fluxes hold a single g-point flux if fluxes are being integrated instead of returned !   with spectral detail real ( wp ), dimension ( ncol , nlay + 1 ), & target :: loc_flux_up , loc_flux_dn , loc_flux_dir ! gpt_fluxes point to calculations for the current g-point real ( wp ), dimension (:,:), pointer :: gpt_flux_up , gpt_flux_dn , gpt_flux_dir ! ------------------------------------ top_level = nlay + 1 if ( top_at_1 ) top_level = 1 ! ! Integrated fluxes need zeroing ! if ( do_broadband ) then call zero_array ( ncol , nlay + 1 , broadband_up ) call zero_array ( ncol , nlay + 1 , broadband_dn ) call zero_array ( ncol , nlay + 1 , broadband_dir ) end if do igpt = 1 , ngpt if ( do_broadband ) then gpt_flux_up => loc_flux_up gpt_flux_dn => loc_flux_dn gpt_flux_dir => loc_flux_dir else gpt_flux_up => flux_up (:,:, igpt ) gpt_flux_dn => flux_dn (:,:, igpt ) gpt_flux_dir => flux_dir (:,:, igpt ) end if ! ! Boundary conditions direct beam... ! gpt_flux_dir (:, top_level ) = inc_flux_dir (:, igpt ) * mu0 (:) ! ! ... and diffuse field, using 0 if no BC is provided ! if ( has_dif_bc ) then gpt_flux_dn (:, top_level ) = inc_flux_dif (:, igpt ) else gpt_flux_dn (:, top_level ) = 0._wp end if ! ! Cell properties: transmittance and reflectance for diffuse radiation !   Direct-beam and source for diffuse radiation ! call sw_dif_and_source ( ncol , nlay , top_at_1 , mu0 , sfc_alb_dir (:, igpt ), & tau (:,:, igpt ), ssa (:,:, igpt ), g (:,:, igpt ), & Rdif , Tdif , source_dn , source_up , source_srf , & gpt_flux_dir ) ! ! Transport ! call adding ( ncol , nlay , top_at_1 , & sfc_alb_dif (:, igpt ), Rdif , Tdif , & source_dn , source_up , source_srf , gpt_flux_up , gpt_flux_dn ) ! ! adding() computes only diffuse flux; flux_dn is total ! if ( do_broadband ) then broadband_up (:,:) = broadband_up (:,:) + gpt_flux_up (:,:) broadband_dn (:,:) = broadband_dn (:,:) + gpt_flux_dn (:,:) + gpt_flux_dir (:,:) broadband_dir (:,:) = broadband_dir (:,:) + gpt_flux_dir (:,:) else gpt_flux_dn (:,:) = gpt_flux_dn (:,:) + gpt_flux_dir (:,:) end if end do end subroutine sw_solver_2stream","tags":"","loc":"proc/sw_solver_2stream.html"},{"title":"sw_solver_noscat – rte-rrtmgp","text":"public pure subroutine sw_solver_noscat(ncol, nlay, ngpt, top_at_1, tau, mu0, inc_flux_dir, flux_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dir Contents Source Code sw_solver_noscat Source Code pure subroutine sw_solver_noscat ( ncol , nlay , ngpt , top_at_1 , & tau , mu0 , inc_flux_dir , flux_dir ) bind ( C , name = \"sw_solver_noscat\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 ! cosine of solar zenith angle real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux_dir ! Direct beam incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_dir ! Direct-beam flux, spectral [W/m2] integer :: ilev , igpt real ( wp ) :: mu0_inv ( ncol ) ! ------------------------------------ mu0_inv ( 1 : ncol ) = 1._wp / mu0 ( 1 : ncol ) ! Indexing into arrays for upward and downward propagation depends on the vertical !   orientation of the arrays (whether the domain top is at the first or last index) ! We write the loops out explicitly so compilers will have no trouble optimizing them. ! Downward propagation if ( top_at_1 ) then ! For the flux at this level, what was the previous level, and which layer has the !   radiation just passed through? ! layer index = level index - 1 ! previous level is up (-1) do igpt = 1 , ngpt flux_dir (:, 1 , igpt ) = inc_flux_dir (:, igpt ) * mu0 (:) do ilev = 2 , nlay + 1 flux_dir (:, ilev , igpt ) = flux_dir (:, ilev - 1 , igpt ) * exp ( - tau (:, ilev - 1 , igpt ) * mu0_inv (:)) end do end do else ! layer index = level index ! previous level is up (+1) do igpt = 1 , ngpt flux_dir (:, nlay + 1 , igpt ) = inc_flux_dir (:, igpt ) * mu0 (:) do ilev = nlay , 1 , - 1 flux_dir (:, ilev , igpt ) = flux_dir (:, ilev + 1 , igpt ) * exp ( - tau (:, ilev , igpt ) * mu0_inv (:)) end do end do end if end subroutine sw_solver_noscat","tags":"","loc":"proc/sw_solver_noscat.html"},{"title":"interpolate1D – rte-rrtmgp","text":"public function interpolate1D(val, offset, delta, table) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: val real(kind=wp), intent(in) :: offset real(kind=wp), intent(in) :: delta real(kind=wp), intent(in), dimension(:) :: table Return Value real(kind=wp) Called by proc~~interpolate1d~2~~CalledByGraph proc~interpolate1d~2 interpolate1D proc~compute_planck_source~2 compute_Planck_source proc~compute_planck_source~2->proc~interpolate1d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpolate1D Source Code function interpolate1D ( val , offset , delta , table ) result ( res ) !$acc routine seq !$omp declare target ! input real ( wp ), intent ( in ) :: val , & ! axis value at which to evaluate table offset , & ! minimum of table axis delta ! step size of table axis real ( wp ), dimension (:), & intent ( in ) :: table ! dimensions (axis, values) ! output real ( wp ) :: res ! local real ( wp ) :: val0 ! fraction index adjusted by offset and delta integer :: index ! index term real ( wp ) :: frac ! fractional term ! ------------------------------------- val0 = ( val - offset ) / delta frac = val0 - int ( val0 ) ! get fractional part index = min ( size ( table , dim = 1 ) - 1 , max ( 1 , int ( val0 ) + 1 )) ! limit the index range res = table ( index ) + frac * ( table ( index + 1 ) - table ( index )) end function interpolate1D","tags":"","loc":"proc/interpolate1d~2.html"},{"title":"interpolate2D – rte-rrtmgp","text":"public function interpolate2D(fminor, k, igpt, jeta, jtemp) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: fminor real(kind=wp), intent(in), dimension(:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp Return Value real(kind=wp) Called by proc~~interpolate2d~2~~CalledByGraph proc~interpolate2d~2 interpolate2D proc~gas_optical_depths_minor~2 gas_optical_depths_minor proc~gas_optical_depths_minor~2->proc~interpolate2d~2 proc~compute_tau_rayleigh~2 compute_tau_rayleigh proc~compute_tau_rayleigh~2->proc~interpolate2d~2 proc~compute_tau_absorption~2 compute_tau_absorption proc~compute_tau_absorption~2->proc~gas_optical_depths_minor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpolate2D Source Code function interpolate2D ( fminor , k , igpt , jeta , jtemp ) result ( res ) !$acc routine seq !$omp declare target real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: fminor ! interpolation fractions for minor species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference temperature level real ( wp ), dimension (:,:,:), intent ( in ) :: k ! (g-point, eta, temp) integer , intent ( in ) :: igpt , jtemp ! interpolation index for temperature integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) real ( wp ) :: res ! the result res = & fminor ( 1 , 1 ) * k ( jtemp , jeta ( 1 ) , igpt ) + & fminor ( 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , igpt ) + & fminor ( 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , igpt ) + & fminor ( 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , igpt ) end function interpolate2D","tags":"","loc":"proc/interpolate2d~2.html"},{"title":"interpolate3D – rte-rrtmgp","text":"public function interpolate3D(scaling, fmajor, k, igpt, jeta, jtemp, jpress) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: scaling real(kind=wp), intent(in), dimension(2,2,2) :: fmajor real(kind=wp), intent(in), dimension(:,:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp integer, intent(in) :: jpress Return Value real(kind=wp) Called by proc~~interpolate3d~2~~CalledByGraph proc~interpolate3d~2 interpolate3D proc~gas_optical_depths_major~2 gas_optical_depths_major proc~gas_optical_depths_major~2->proc~interpolate3d~2 proc~compute_planck_source~2 compute_Planck_source proc~compute_planck_source~2->proc~interpolate3d~2 proc~compute_tau_absorption~2 compute_tau_absorption proc~compute_tau_absorption~2->proc~gas_optical_depths_major~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpolate3D Source Code function interpolate3D ( scaling , fmajor , k , igpt , jeta , jtemp , jpress ) result ( res ) !$acc routine seq !$omp declare target real ( wp ), dimension ( 2 ), intent ( in ) :: scaling real ( wp ), dimension ( 2 , 2 , 2 ), intent ( in ) :: fmajor ! interpolation fractions for major species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference pressure level ! index(3) : reference temperature level real ( wp ), dimension (:,:,:,:), intent ( in ) :: k ! (gpt, eta,temp,press) integer , intent ( in ) :: igpt integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) integer , intent ( in ) :: jtemp ! interpolation index for temperature integer , intent ( in ) :: jpress ! interpolation index for pressure real ( wp ) :: res ! the result ! each code block is for a different reference temperature res = & scaling ( 1 ) * & ( fmajor ( 1 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress , igpt ) ) + & scaling ( 2 ) * & ( fmajor ( 1 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress , igpt ) ) end function interpolate3D","tags":"","loc":"proc/interpolate3d~2.html"},{"title":"compute_Planck_source – rte-rrtmgp","text":"public subroutine compute_Planck_source(ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, nPlanckTemp, tlay, tlev, tsfc, sfc_lay, fmajor, jeta, tropo, jtemp, jpress, gpoint_bands, band_lims_gpt, pfracin, temp_ref_min, totplnk_delta, totplnk, gpoint_flavor, sfc_src, lay_src, lev_src_inc, lev_src_dec, sfc_source_Jac) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nPlanckTemp real(kind=wp), intent(in), dimension(ncol,nlay  ) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay+1) :: tlev real(kind=wp), intent(in), dimension(ncol       ) :: tsfc integer, intent(in) :: sfc_lay real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(            ncol,nlay) :: tropo integer, intent(in), dimension(            ncol,nlay) :: jtemp integer, intent(in), dimension(            ncol,nlay) :: jpress integer, intent(in), dimension(ngpt) :: gpoint_bands integer, intent(in), dimension(2, nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: pfracin real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: totplnk_delta real(kind=wp), intent(in), dimension(nPlanckTemp,nbnd) :: totplnk integer, intent(in), dimension(2,ngpt) :: gpoint_flavor real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lay_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_inc real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_dec real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_source_Jac Calls proc~~compute_planck_source~2~~CallsGraph proc~compute_planck_source~2 compute_Planck_source proc~interpolate3d~2 interpolate3D proc~compute_planck_source~2->proc~interpolate3d~2 proc~interpolate1d~2 interpolate1D proc~compute_planck_source~2->proc~interpolate1d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code compute_Planck_source Source Code subroutine compute_Planck_source ( & ncol , nlay , nbnd , ngpt , & nflav , neta , npres , ntemp , nPlanckTemp ,& tlay , tlev , tsfc , sfc_lay , & fmajor , jeta , tropo , jtemp , jpress , & gpoint_bands , band_lims_gpt , & pfracin , temp_ref_min , totplnk_delta , totplnk , gpoint_flavor , & sfc_src , lay_src , lev_src_inc , lev_src_dec , sfc_source_Jac ) bind ( C , name = \"compute_Planck_source\" ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: nflav , neta , npres , ntemp , nPlanckTemp real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: tlay real ( wp ), dimension ( ncol , nlay + 1 ), intent ( in ) :: tlev real ( wp ), dimension ( ncol ), intent ( in ) :: tsfc integer , intent ( in ) :: sfc_lay ! Interpolation variables real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress ! Table-specific integer , dimension ( ngpt ), intent ( in ) :: gpoint_bands ! start and end g-point for each band integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), intent ( in ) :: temp_ref_min , totplnk_delta real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: pfracin real ( wp ), dimension ( nPlanckTemp , nbnd ), intent ( in ) :: totplnk integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: sfc_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: lay_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: lev_src_inc , lev_src_dec real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: sfc_source_Jac ! ----------------- ! local real ( wp ), parameter :: delta_Tsurf = 1.0_wp integer :: ilay , icol , igpt , ibnd , itropo , iflav integer :: gptS , gptE real ( wp ), dimension ( 2 ), parameter :: one = [ 1._wp , 1._wp ] real ( wp ) :: pfrac real ( wp ) :: planck_function_1 , planck_function_2 ! ----------------- !$acc        data copyin(   tlay,tlev,tsfc,fmajor,jeta,tropo,jtemp,jpress,gpoint_bands,pfracin,totplnk,gpoint_flavor) & !$acc             copyout(  sfc_src,lay_src,lev_src_inc,lev_src_dec,sfc_source_Jac) !$omp target data map(   to:tlay,tlev,tsfc,fmajor,jeta,tropo,jtemp,jpress,gpoint_bands,pfracin,totplnk,gpoint_flavor) & !$omp             map(from: sfc_src,lay_src,lev_src_inc,lev_src_dec,sfc_source_Jac) ! Calculation of fraction of band's Planck irradiance associated with each g-point !$acc parallel loop tile(128,2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol !$acc loop seq do igpt = 1 , ngpt ibnd = gpoint_bands ( igpt ) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) !WS moved itropo inside loop for GPU iflav = gpoint_flavor ( itropo , igpt ) !eta interpolation depends on band's flavor pfrac = & ! interpolation in temperature, pressure, and eta interpolate3D ( one , fmajor (:,:,:, icol , ilay , iflav ), pfracin , & igpt , jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay ), jpress ( icol , ilay ) + itropo ) ! Compute layer source irradiance for g-point, equals band irradiance x fraction for g-point planck_function_1 = interpolate1D ( tlay ( icol , ilay ), temp_ref_min , totplnk_delta , totplnk (:, ibnd )) lay_src ( icol , ilay , igpt ) = pfrac * planck_function_1 ! Compute layer source irradiance for g-point, equals band irradiance x fraction for g-point planck_function_1 = interpolate1D ( tlev ( icol , ilay ), temp_ref_min , totplnk_delta , totplnk (:, ibnd )) planck_function_2 = interpolate1D ( tlev ( icol , ilay + 1 ), temp_ref_min , totplnk_delta , totplnk (:, ibnd )) lev_src_dec ( icol , ilay , igpt ) = pfrac * planck_function_1 lev_src_inc ( icol , ilay , igpt ) = pfrac * planck_function_2 if ( ilay == sfc_lay ) then planck_function_1 = interpolate1D ( tsfc ( icol ) , temp_ref_min , totplnk_delta , totplnk (:, ibnd )) planck_function_2 = interpolate1D ( tsfc ( icol ) + delta_Tsurf , temp_ref_min , totplnk_delta , totplnk (:, ibnd )) sfc_src ( icol , igpt ) = pfrac * planck_function_1 sfc_source_Jac ( icol , igpt ) = pfrac * ( planck_function_2 - planck_function_1 ) end if end do ! igpt end do ! icol end do ! ilay !$acc end        data !$omp end target data end subroutine compute_Planck_source","tags":"","loc":"proc/compute_planck_source~2.html"},{"title":"compute_tau_absorption – rte-rrtmgp","text":"public subroutine compute_tau_absorption(ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, nminorlower, nminorklower, nminorupper, nminorkupper, idx_h2o, gpoint_flavor, band_lims_gpt, kmajor, kminor_lower, kminor_upper, minor_limits_gpt_lower, minor_limits_gpt_upper, minor_scales_with_density_lower, minor_scales_with_density_upper, scale_by_complement_lower, scale_by_complement_upper, idx_minor_lower, idx_minor_upper, idx_minor_scaling_lower, idx_minor_scaling_upper, kminor_start_lower, kminor_start_upper, tropo, col_mix, fmajor, fminor, play, tlay, col_gas, jeta, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nminorlower integer, intent(in) :: nminorklower integer, intent(in) :: nminorupper integer, intent(in) :: nminorkupper integer, intent(in) :: idx_h2o integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(ntemp,neta,nminorklower) :: kminor_lower real(kind=wp), intent(in), dimension(ntemp,neta,nminorkupper) :: kminor_upper integer, intent(in), dimension(2,nminorlower) :: minor_limits_gpt_lower integer, intent(in), dimension(2,nminorupper) :: minor_limits_gpt_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: minor_scales_with_density_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: minor_scales_with_density_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: scale_by_complement_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: scale_by_complement_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_scaling_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_scaling_upper integer, intent(in), dimension(  nminorlower) :: kminor_start_lower integer, intent(in), dimension(  nminorupper) :: kminor_start_upper logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav       ) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav       ) :: fmajor real(kind=wp), intent(in), dimension(2,2,  ncol,nlay,nflav       ) :: fminor real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: play real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: tlay real(kind=wp), intent(in), dimension(            ncol,nlay,0:ngas) :: col_gas integer, intent(in), dimension(2,    ncol,nlay,nflav       ) :: jeta integer, intent(in), dimension(            ncol,nlay       ) :: jtemp integer, intent(in), dimension(            ncol,nlay       ) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau Calls proc~~compute_tau_absorption~2~~CallsGraph proc~compute_tau_absorption~2 compute_tau_absorption proc~gas_optical_depths_minor~2 gas_optical_depths_minor proc~compute_tau_absorption~2->proc~gas_optical_depths_minor~2 proc~gas_optical_depths_major~2 gas_optical_depths_major proc~compute_tau_absorption~2->proc~gas_optical_depths_major~2 proc~interpolate2d~2 interpolate2D proc~gas_optical_depths_minor~2->proc~interpolate2d~2 proc~interpolate3d~2 interpolate3D proc~gas_optical_depths_major~2->proc~interpolate3d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code compute_tau_absorption Source Code subroutine compute_tau_absorption ( & ncol , nlay , nbnd , ngpt , & ! dimensions ngas , nflav , neta , npres , ntemp , & nminorlower , nminorklower , & ! number of minor contributors, total num absorption coeffs nminorupper , nminorkupper , & idx_h2o , & gpoint_flavor , & band_lims_gpt , & kmajor , & kminor_lower , & kminor_upper , & minor_limits_gpt_lower , & minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scale_by_complement_lower , & scale_by_complement_upper , & idx_minor_lower , & idx_minor_upper , & idx_minor_scaling_lower , & idx_minor_scaling_upper , & kminor_start_lower , & kminor_start_upper , & tropo , & col_mix , fmajor , fminor , & play , tlay , col_gas , & jeta , jtemp , jpress , & tau ) bind ( C , name = \"compute_tau_absorption\" ) ! --------------------- ! input dimensions integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , intent ( in ) :: nminorlower , nminorklower , nminorupper , nminorkupper integer , intent ( in ) :: idx_h2o ! --------------------- ! inputs from object integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: kmajor real ( wp ), dimension ( ntemp , neta , nminorklower ), intent ( in ) :: kminor_lower real ( wp ), dimension ( ntemp , neta , nminorkupper ), intent ( in ) :: kminor_upper integer , dimension ( 2 , nminorlower ), intent ( in ) :: minor_limits_gpt_lower integer , dimension ( 2 , nminorupper ), intent ( in ) :: minor_limits_gpt_upper logical ( wl ), dimension ( nminorlower ), intent ( in ) :: minor_scales_with_density_lower logical ( wl ), dimension ( nminorupper ), intent ( in ) :: minor_scales_with_density_upper logical ( wl ), dimension ( nminorlower ), intent ( in ) :: scale_by_complement_lower logical ( wl ), dimension ( nminorupper ), intent ( in ) :: scale_by_complement_upper integer , dimension ( nminorlower ), intent ( in ) :: idx_minor_lower integer , dimension ( nminorupper ), intent ( in ) :: idx_minor_upper integer , dimension ( nminorlower ), intent ( in ) :: idx_minor_scaling_lower integer , dimension ( nminorupper ), intent ( in ) :: idx_minor_scaling_upper integer , dimension ( nminorlower ), intent ( in ) :: kminor_start_lower integer , dimension ( nminorupper ), intent ( in ) :: kminor_start_upper logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo ! --------------------- ! inputs from profile or parent function real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay ! pressure and temperature real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp integer , dimension ( ncol , nlay ), intent ( in ) :: jpress ! --------------------- ! output - optical depth real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! --------------------- ! Local variables ! logical ( wl ) :: top_at_1 integer , dimension ( ncol , 2 ) :: itropo_lower , itropo_upper integer :: icol , idx_tropo ! ---------------------------------------------------------------- !$acc enter data create(itropo_lower, itropo_upper) !$omp target enter data map(alloc:itropo_lower, itropo_upper) !$acc enter data copyin(play, tlay, tropo, gpoint_flavor, jeta, jtemp, col_gas, fminor, tau) !$omp target enter data map(to:play, tlay, tropo, gpoint_flavor, jeta, jtemp, col_gas, fminor, tau) ! --------------------- ! Layer limits of upper, lower atmospheres ! --------------------- !$acc kernels copyout(top_at_1) !$omp target map(from:top_at_1) top_at_1 = play ( 1 , 1 ) < play ( 1 , nlay ) !$acc end kernels !$omp end target if ( top_at_1 ) then !$acc parallel loop !$omp target teams distribute parallel do simd do icol = 1 , ncol itropo_lower ( icol , 2 ) = nlay #if defined(_CRAYFTN) || defined(__NVCOMPILER) itropo_upper ( icol , 1 ) = 1 call minmaxloc ( icol , tropo , play , itropo_lower ( icol , 1 ), itropo_upper ( icol , 2 )) #else itropo_lower ( icol , 1 ) = minloc ( play ( icol ,:), dim = 1 , mask = tropo ( icol ,:)) itropo_upper ( icol , 1 ) = 1 itropo_upper ( icol , 2 ) = maxloc ( play ( icol ,:), dim = 1 , mask = (. not . tropo ( icol ,:))) #endif end do else !$acc parallel loop !$omp target teams distribute parallel do simd do icol = 1 , ncol itropo_lower ( icol , 1 ) = 1 #if defined(_CRAYFTN) || defined(__NVCOMPILER) itropo_upper ( icol , 2 ) = nlay call minmaxloc ( icol , tropo , play , itropo_lower ( icol , 2 ), itropo_upper ( icol , 1 )) #else itropo_lower ( icol , 2 ) = minloc ( play ( icol ,:), dim = 1 , mask = tropo ( icol ,:)) itropo_upper ( icol , 2 ) = nlay itropo_upper ( icol , 1 ) = maxloc ( play ( icol ,:), dim = 1 , mask = (. not . tropo ( icol ,:))) #endif end do end if ! --------------------- ! Major Species ! --------------------- call gas_optical_depths_major ( & ncol , nlay , nbnd , ngpt , & ! dimensions nflav , neta , npres , ntemp , & gpoint_flavor , & band_lims_gpt , & kmajor , & col_mix , fmajor , & jeta , tropo , jtemp , jpress , & tau ) ! --------------------- ! Minor Species - lower ! --------------------- idx_tropo = 1 call gas_optical_depths_minor ( & ncol , nlay , ngpt , & ! dimensions ngas , nflav , ntemp , neta , & nminorlower , nminorklower , & idx_h2o , idx_tropo , & gpoint_flavor , & kminor_lower , & minor_limits_gpt_lower , & minor_scales_with_density_lower , & scale_by_complement_lower , & idx_minor_lower , & idx_minor_scaling_lower , & kminor_start_lower , & play , tlay , & col_gas , fminor , jeta , & itropo_lower , jtemp , & tau ) ! --------------------- ! Minor Species - upper ! --------------------- idx_tropo = 2 call gas_optical_depths_minor ( & ncol , nlay , ngpt , & ! dimensions ngas , nflav , ntemp , neta , & nminorupper , nminorkupper , & idx_h2o , idx_tropo , & gpoint_flavor , & kminor_upper , & minor_limits_gpt_upper , & minor_scales_with_density_upper , & scale_by_complement_upper , & idx_minor_upper , & idx_minor_scaling_upper , & kminor_start_upper , & play , tlay , & col_gas , fminor , jeta , & itropo_upper , jtemp , & tau ) !$acc exit data delete(itropo_lower,itropo_upper) !$omp target exit data map(release:itropo_lower, itropo_upper) !$acc exit data delete(play, tlay, tropo, gpoint_flavor, jeta, jtemp, col_gas, fminor) !$omp target exit data map(release:play, tlay, tropo, gpoint_flavor, jeta, jtemp, col_gas, fminor) !$acc exit data copyout(tau) !$omp target exit data map(from:tau) end subroutine compute_tau_absorption","tags":"","loc":"proc/compute_tau_absorption~2.html"},{"title":"compute_tau_rayleigh – rte-rrtmgp","text":"public subroutine compute_tau_rayleigh(ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, krayl, idx_h2o, col_dry, col_gas, fminor, jeta, tropo, jtemp, tau_rayleigh) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,ngpt,2) :: krayl integer, intent(in) :: idx_h2o real(kind=wp), intent(in), dimension(ncol,nlay) :: col_dry real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: tau_rayleigh Calls proc~~compute_tau_rayleigh~2~~CallsGraph proc~compute_tau_rayleigh~2 compute_tau_rayleigh proc~interpolate2d~2 interpolate2D proc~compute_tau_rayleigh~2->proc~interpolate2d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code compute_tau_rayleigh Source Code subroutine compute_tau_rayleigh ( ncol , nlay , nbnd , ngpt , & ngas , nflav , neta , npres , ntemp , & gpoint_flavor , band_lims_gpt , & krayl , & idx_h2o , col_dry , col_gas , & fminor , jeta , tropo , jtemp , & tau_rayleigh ) bind ( C , name = \"compute_tau_rayleigh\" ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), dimension ( ntemp , neta , ngpt , 2 ), intent ( in ) :: krayl integer , intent ( in ) :: idx_h2o real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: col_dry real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp ! outputs real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: tau_rayleigh ! ----------------- ! local variables real ( wp ) :: k ! rayleigh scattering coefficient integer :: icol , ilay , iflav , igpt integer :: itropo ! ----------------- !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol !$acc loop seq do igpt = 1 , ngpt itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere iflav = gpoint_flavor ( itropo , igpt ) k = interpolate2D ( fminor (:,:, icol , ilay , iflav ), & krayl (:,:,:, itropo ), & igpt , jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay )) tau_rayleigh ( icol , ilay , igpt ) = k * ( col_gas ( icol , ilay , idx_h2o ) + col_dry ( icol , ilay )) end do end do end do end subroutine compute_tau_rayleigh","tags":"","loc":"proc/compute_tau_rayleigh~2.html"},{"title":"gas_optical_depths_major – rte-rrtmgp","text":"public subroutine gas_optical_depths_major(ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, kmajor, col_mix, fmajor, jeta, tropo, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp integer, intent(in), dimension(ncol,nlay) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau Calls proc~~gas_optical_depths_major~2~~CallsGraph proc~gas_optical_depths_major~2 gas_optical_depths_major proc~interpolate3d~2 interpolate3D proc~gas_optical_depths_major~2->proc~interpolate3d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gas_optical_depths_major~2~~CalledByGraph proc~gas_optical_depths_major~2 gas_optical_depths_major proc~compute_tau_absorption~2 compute_tau_absorption proc~compute_tau_absorption~2->proc~gas_optical_depths_major~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code gas_optical_depths_major Source Code subroutine gas_optical_depths_major ( ncol , nlay , nbnd , ngpt ,& nflav , neta , npres , ntemp , & ! dimensions gpoint_flavor , band_lims_gpt , & ! inputs from object kmajor , & col_mix , fmajor , & jeta , tropo , jtemp , jpress , & ! local input tau ) bind ( C , name = \"gas_optical_depths_major\" ) ! input dimensions integer , intent ( in ) :: ncol , nlay , nbnd , ngpt , nflav , neta , npres , ntemp ! dimensions ! inputs from object integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: kmajor ! inputs from profile or parent function real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress ! outputs real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! ----------------- ! local variables real ( wp ) :: tau_major ! major species optical depth ! local index integer :: icol , ilay , iflav , igpt , itropo ! ----------------- ! ----------------- ! optical depth calculation for major species !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol !$acc loop seq do igpt = 1 , ngpt ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! WS: moved inside innermost loop ! binary species parameter (eta) and col_mix depend on band flavor iflav = gpoint_flavor ( itropo , igpt ) tau_major = & ! interpolation in temperature, pressure, and eta interpolate3D ( col_mix (:, icol , ilay , iflav ), & fmajor (:,:,:, icol , ilay , iflav ), kmajor , & igpt , jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay ), jpress ( icol , ilay ) + itropo ) tau ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) + tau_major end do ! igpt end do end do ! ilay end subroutine gas_optical_depths_major","tags":"","loc":"proc/gas_optical_depths_major~2.html"},{"title":"gas_optical_depths_minor – rte-rrtmgp","text":"public subroutine gas_optical_depths_minor(ncol, nlay, ngpt, ngas, nflav, ntemp, neta, nminor, nminork, idx_h2o, idx_tropo, gpt_flv, kminor, minor_limits_gpt, minor_scales_with_density, scale_by_complement, idx_minor, idx_minor_scaling, kminor_start, play, tlay, col_gas, fminor, jeta, layer_limits, jtemp, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: ntemp integer, intent(in) :: neta integer, intent(in) :: nminor integer, intent(in) :: nminork integer, intent(in) :: idx_h2o integer, intent(in) :: idx_tropo integer, intent(in), dimension(2, ngpt) :: gpt_flv real(kind=wp), intent(in), dimension(ntemp,neta,nminork) :: kminor integer, intent(in), dimension(2,nminor) :: minor_limits_gpt logical(kind=wl), intent(in), dimension(  nminor) :: minor_scales_with_density logical(kind=wl), intent(in), dimension(  nminor) :: scale_by_complement integer, intent(in), dimension(  nminor) :: idx_minor integer, intent(in), dimension(  nminor) :: idx_minor_scaling integer, intent(in), dimension(  nminor) :: kminor_start real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta integer, intent(in), dimension(ncol, 2) :: layer_limits integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau Calls proc~~gas_optical_depths_minor~2~~CallsGraph proc~gas_optical_depths_minor~2 gas_optical_depths_minor proc~interpolate2d~2 interpolate2D proc~gas_optical_depths_minor~2->proc~interpolate2d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gas_optical_depths_minor~2~~CalledByGraph proc~gas_optical_depths_minor~2 gas_optical_depths_minor proc~compute_tau_absorption~2 compute_tau_absorption proc~compute_tau_absorption~2->proc~gas_optical_depths_minor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code gas_optical_depths_minor Source Code subroutine gas_optical_depths_minor ( ncol , nlay , ngpt , & ngas , nflav , ntemp , neta , & nminor , nminork , & idx_h2o , idx_tropo , & gpt_flv , & kminor , & minor_limits_gpt , & minor_scales_with_density , & scale_by_complement , & idx_minor , idx_minor_scaling , & kminor_start , & play , tlay , & col_gas , fminor , jeta , & layer_limits , jtemp , & tau ) bind ( C , name = \"gas_optical_depths_minor\" ) integer , intent ( in ) :: ncol , nlay , ngpt integer , intent ( in ) :: ngas , nflav integer , intent ( in ) :: ntemp , neta , nminor , nminork integer , intent ( in ) :: idx_h2o , idx_tropo integer , dimension ( 2 , ngpt ), intent ( in ) :: gpt_flv real ( wp ), dimension ( ntemp , neta , nminork ), intent ( in ) :: kminor integer , dimension ( 2 , nminor ), intent ( in ) :: minor_limits_gpt logical ( wl ), dimension ( nminor ), intent ( in ) :: minor_scales_with_density logical ( wl ), dimension ( nminor ), intent ( in ) :: scale_by_complement integer , dimension ( nminor ), intent ( in ) :: kminor_start integer , dimension ( nminor ), intent ( in ) :: idx_minor , idx_minor_scaling real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta integer , dimension ( ncol , 2 ), intent ( in ) :: layer_limits integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! ----------------- ! local variables real ( wp ), parameter :: PaTohPa = 0.01_wp real ( wp ) :: vmr_fact , dry_fact ! conversion from column abundance to dry vol. mixing ratio; real ( wp ) :: scaling , kminor_loc , tau_minor ! minor species absorption coefficient, optical depth integer :: icol , ilay , iflav , igpt , imnr integer :: minor_start , minor_loc , extent real ( wp ) :: myplay , mytlay , mycol_gas_h2o , mycol_gas_imnr , mycol_gas_0 real ( wp ) :: myfminor ( 2 , 2 ) integer :: myjtemp , myjeta ( 2 ) ! ----------------- extent = size ( scale_by_complement , dim = 1 ) !$acc parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol ! ! This check skips individual columns with no pressures in range ! if ( layer_limits ( icol , 1 ) <= 0 . or . ilay < layer_limits ( icol , 1 ) . or . ilay > layer_limits ( icol , 2 ) ) cycle myplay = play ( icol , ilay ) mytlay = tlay ( icol , ilay ) myjtemp = jtemp ( icol , ilay ) mycol_gas_h2o = col_gas ( icol , ilay , idx_h2o ) mycol_gas_0 = col_gas ( icol , ilay , 0 ) !$acc loop seq do imnr = 1 , extent ! What is the starting point in the stored array of minor absorption coefficients? minor_start = kminor_start ( imnr ) !$acc loop seq do igpt = minor_limits_gpt ( 1 , imnr ), minor_limits_gpt ( 2 , imnr ) scaling = col_gas ( icol , ilay , idx_minor ( imnr )) if ( minor_scales_with_density ( imnr )) then ! ! NOTE: P needed in hPa to properly handle density scaling. ! scaling = scaling * ( PaTohPa * myplay / mytlay ) if ( idx_minor_scaling ( imnr ) > 0 ) then ! there is a second gas that affects this gas's absorption mycol_gas_imnr = col_gas ( icol , ilay , idx_minor_scaling ( imnr )) vmr_fact = 1._wp / mycol_gas_0 dry_fact = 1._wp / ( 1._wp + mycol_gas_h2o * vmr_fact ) ! scale by density of special gas if ( scale_by_complement ( imnr )) then ! scale by densities of all gases but the special one scaling = scaling * ( 1._wp - mycol_gas_imnr * vmr_fact * dry_fact ) else scaling = scaling * ( mycol_gas_imnr * vmr_fact * dry_fact ) endif endif endif ! ! Interpolation of absorption coefficient and calculation of optical depth ! tau_minor = 0._wp iflav = gpt_flv ( idx_tropo , igpt ) ! eta interpolation depends on flavor minor_loc = minor_start + ( igpt - minor_limits_gpt ( 1 , imnr )) ! add offset to starting point kminor_loc = interpolate2D ( fminor (:,:, icol , ilay , iflav ), kminor , minor_loc , & jeta (:, icol , ilay , iflav ), myjtemp ) tau_minor = kminor_loc * scaling tau ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) + tau_minor enddo enddo enddo enddo end subroutine gas_optical_depths_minor","tags":"","loc":"proc/gas_optical_depths_minor~2.html"},{"title":"interpolation – rte-rrtmgp","text":"public subroutine interpolation(ncol, nlay, ngas, nflav, neta, npres, ntemp, flavor, press_ref_log, temp_ref, press_ref_log_delta, temp_ref_min, temp_ref_delta, press_ref_trop_log, vmr_ref, play, tlay, col_gas, jtemp, fmajor, fminor, col_mix, tropo, jeta, jpress) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,nflav) :: flavor real(kind=wp), intent(in), dimension(npres) :: press_ref_log real(kind=wp), intent(in), dimension(ntemp) :: temp_ref real(kind=wp), intent(in) :: press_ref_log_delta real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: temp_ref_delta real(kind=wp), intent(in) :: press_ref_trop_log real(kind=wp), intent(in), dimension(2,0:ngas,ntemp) :: vmr_ref real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas integer, intent(out), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(2,2,2,ncol,nlay,nflav) :: fmajor real(kind=wp), intent(out), dimension(2,2,  ncol,nlay,nflav) :: fminor real(kind=wp), intent(out), dimension(2,    ncol,nlay,nflav) :: col_mix logical(kind=wl), intent(out), dimension(ncol,nlay) :: tropo integer, intent(out), dimension(2,    ncol,nlay,nflav) :: jeta integer, intent(out), dimension(ncol,nlay) :: jpress Calls proc~~interpolation~2~~CallsGraph proc~interpolation~2 interpolation float float proc~interpolation~2->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpolation Source Code subroutine interpolation ( & ncol , nlay , ngas , nflav , neta , npres , ntemp , & flavor , & press_ref_log , temp_ref , press_ref_log_delta , & temp_ref_min , temp_ref_delta , press_ref_trop_log , & vmr_ref , & play , tlay , col_gas , & jtemp , fmajor , fminor , col_mix , tropo , jeta , jpress ) bind ( C , name = \"interpolation\" ) ! input dimensions integer , intent ( in ) :: ncol , nlay integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , dimension ( 2 , nflav ), intent ( in ) :: flavor real ( wp ), dimension ( npres ), intent ( in ) :: press_ref_log real ( wp ), dimension ( ntemp ), intent ( in ) :: temp_ref real ( wp ), intent ( in ) :: press_ref_log_delta , & temp_ref_min , temp_ref_delta , & press_ref_trop_log real ( wp ), dimension ( 2 , 0 : ngas , ntemp ), intent ( in ) :: vmr_ref ! inputs from profile or parent function real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas ! outputs integer , dimension ( ncol , nlay ), intent ( out ) :: jtemp , jpress logical ( wl ), dimension ( ncol , nlay ), intent ( out ) :: tropo integer , dimension ( 2 , ncol , nlay , nflav ), intent ( out ) :: jeta real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( out ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( out ) :: fmajor real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( out ) :: fminor ! ----------------- ! local real ( wp ), dimension ( ncol , nlay ) :: ftemp , fpress ! interpolation fraction for temperature, pressure real ( wp ) :: locpress ! needed to find location in pressure grid real ( wp ) :: ratio_eta_half ! ratio of vmrs of major species that defines eta=0.5 ! for given flavor and reference temperature level real ( wp ) :: eta , feta ! binary_species_parameter, interpolation variable for eta real ( wp ) :: loceta ! needed to find location in eta grid real ( wp ) :: ftemp_term ! ----------------- ! local indexes integer :: icol , ilay , iflav , igases ( 2 ), itropo , itemp !$acc data copyin(flavor,press_ref_log,temp_ref,vmr_ref,play,tlay,col_gas) & !$acc      copyout(jtemp,jpress,tropo,jeta,col_mix,fmajor,fminor) & !$acc      create(ftemp,fpress) !$omp target data map(to:flavor, press_ref_log, temp_ref, vmr_ref, play, tlay, col_gas) & !$omp             map(alloc:jtemp, jpress, tropo, jeta, col_mix, fmajor, fminor) & !$omp             map(alloc:ftemp, fpress) !$acc parallel loop gang vector collapse(2) default(none) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol ! index and factor for temperature interpolation jtemp ( icol , ilay ) = int (( tlay ( icol , ilay ) - ( temp_ref_min - temp_ref_delta )) / temp_ref_delta ) jtemp ( icol , ilay ) = min ( ntemp - 1 , max ( 1 , jtemp ( icol , ilay ))) ! limit the index range ftemp ( icol , ilay ) = ( tlay ( icol , ilay ) - temp_ref ( jtemp ( icol , ilay ))) / temp_ref_delta ! index and factor for pressure interpolation locpress = 1._wp + ( log ( play ( icol , ilay )) - press_ref_log ( 1 )) / press_ref_log_delta jpress ( icol , ilay ) = min ( npres - 1 , max ( 1 , int ( locpress ))) fpress ( icol , ilay ) = locpress - float ( jpress ( icol , ilay )) ! determine if in lower or upper part of atmosphere tropo ( icol , ilay ) = log ( play ( icol , ilay )) > press_ref_trop_log end do end do ! loop over implemented combinations of major species ! PGI BUG WORKAROUND: if present(vmr_ref) isn't there, OpenACC runtime ! thinks it isn't present. !$acc parallel loop gang vector collapse(4) default(none) private(igases) present(vmr_ref) !$omp target teams distribute parallel do simd collapse(4) private(igases) do iflav = 1 , nflav do ilay = 1 , nlay ! loop over implemented combinations of major species do icol = 1 , ncol do itemp = 1 , 2 igases (:) = flavor (:, iflav ) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! compute interpolation fractions needed for lower, then upper reference temperature level ! compute binary species parameter (eta) for flavor and temperature and !  associated interpolation index and factors ratio_eta_half = vmr_ref ( itropo , igases ( 1 ),( jtemp ( icol , ilay ) + itemp - 1 )) / & vmr_ref ( itropo , igases ( 2 ),( jtemp ( icol , ilay ) + itemp - 1 )) col_mix ( itemp , icol , ilay , iflav ) = col_gas ( icol , ilay , igases ( 1 )) + ratio_eta_half * col_gas ( icol , ilay , igases ( 2 )) eta = merge ( col_gas ( icol , ilay , igases ( 1 )) / col_mix ( itemp , icol , ilay , iflav ), 0.5_wp , & col_mix ( itemp , icol , ilay , iflav ) > 2._wp * tiny ( col_mix )) loceta = eta * float ( neta - 1 ) jeta ( itemp , icol , ilay , iflav ) = min ( int ( loceta ) + 1 , neta - 1 ) feta = mod ( loceta , 1.0_wp ) ! compute interpolation fractions needed for minor species ! ftemp_term = (1._wp-ftemp(icol,ilay)) for itemp = 1, ftemp(icol,ilay) for itemp=2 ftemp_term = ( real ( 2 - itemp , wp ) + real ( 2 * itemp - 3 , wp ) * ftemp ( icol , ilay )) fminor ( 1 , itemp , icol , ilay , iflav ) = ( 1._wp - feta ) * ftemp_term fminor ( 2 , itemp , icol , ilay , iflav ) = feta * ftemp_term ! compute interpolation fractions needed for major species fmajor ( 1 , 1 , itemp , icol , ilay , iflav ) = ( 1._wp - fpress ( icol , ilay )) * fminor ( 1 , itemp , icol , ilay , iflav ) fmajor ( 2 , 1 , itemp , icol , ilay , iflav ) = ( 1._wp - fpress ( icol , ilay )) * fminor ( 2 , itemp , icol , ilay , iflav ) fmajor ( 1 , 2 , itemp , icol , ilay , iflav ) = fpress ( icol , ilay ) * fminor ( 1 , itemp , icol , ilay , iflav ) fmajor ( 2 , 2 , itemp , icol , ilay , iflav ) = fpress ( icol , ilay ) * fminor ( 2 , itemp , icol , ilay , iflav ) end do ! reference temperatures end do ! icol end do ! ilay end do ! iflav !$acc end data !$omp end target data end subroutine interpolation","tags":"","loc":"proc/interpolation~2.html"},{"title":"minmaxloc – rte-rrtmgp","text":"public subroutine minmaxloc(i, mask, a, minl, maxl) Arguments Type Intent Optional Attributes Name integer :: i logical(kind=wl) :: mask (:,:) real(kind=wp) :: a (:,:) integer :: minl integer :: maxl Contents None","tags":"","loc":"proc/minmaxloc.html"},{"title":"delta_scale_2str_f_k – rte-rrtmgp","text":"public subroutine delta_scale_2str_f_k(ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f Called by proc~~delta_scale_2str_f_k~2~~CalledByGraph proc~delta_scale_2str_f_k~2 delta_scale_2str_f_k interface~delta_scale_2str_kernel~2 delta_scale_2str_kernel interface~delta_scale_2str_kernel~2->proc~delta_scale_2str_f_k~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code delta_scale_2str_f_k Source Code subroutine delta_scale_2str_f_k ( ncol , nlay , ngpt , tau , ssa , g , f ) & bind ( C , name = \"delta_scale_2str_f_k\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau , ssa , g real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: f real ( wp ) :: wf integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copy(ssa(:ncol,:nlay,:ngpt),tau(:ncol,:nlay,:ngpt)) & !$acc&     copyin(f(:ncol,:nlay,:ngpt)) & !$acc&     copy(g(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:ssa, tau) & !$omp& map(to:f) & !$omp& map(tofrom:g) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol if ( tau ( icol , ilay , igpt ) > eps ) then wf = ssa ( icol , ilay , igpt ) * f ( icol , ilay , igpt ) tau ( icol , ilay , igpt ) = ( 1._wp - wf ) * tau ( icol , ilay , igpt ) ssa ( icol , ilay , igpt ) = ( ssa ( icol , ilay , igpt ) - wf ) / ( 1.0_wp - wf ) g ( icol , ilay , igpt ) = ( g ( icol , ilay , igpt ) - f ( icol , ilay , igpt )) / ( 1._wp - f ( icol , ilay , igpt )) end if end do end do end do end subroutine delta_scale_2str_f_k","tags":"","loc":"proc/delta_scale_2str_f_k~2.html"},{"title":"delta_scale_2str_k – rte-rrtmgp","text":"public subroutine delta_scale_2str_k(ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g Called by proc~~delta_scale_2str_k~2~~CalledByGraph proc~delta_scale_2str_k~2 delta_scale_2str_k interface~delta_scale_2str_kernel~2 delta_scale_2str_kernel interface~delta_scale_2str_kernel~2->proc~delta_scale_2str_k~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code delta_scale_2str_k Source Code subroutine delta_scale_2str_k ( ncol , nlay , ngpt , tau , ssa , g ) & bind ( C , name = \"delta_scale_2str_k\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau , ssa , g real ( wp ) :: f , wf integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copy(tau(:ncol,:nlay,:ngpt),ssa(:ncol,:nlay,:ngpt),g(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau, ssa, g) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol if ( tau ( icol , ilay , igpt ) > eps ) then f = g ( icol , ilay , igpt ) * g ( icol , ilay , igpt ) wf = ssa ( icol , ilay , igpt ) * f tau ( icol , ilay , igpt ) = ( 1._wp - wf ) * tau ( icol , ilay , igpt ) ssa ( icol , ilay , igpt ) = ( ssa ( icol , ilay , igpt ) - wf ) / ( 1.0_wp - wf ) g ( icol , ilay , igpt ) = ( g ( icol , ilay , igpt ) - f ) / ( 1.0_wp - f ) end if end do end do end do end subroutine delta_scale_2str_k","tags":"","loc":"proc/delta_scale_2str_k~2.html"},{"title":"extract_subset_absorption_tau – rte-rrtmgp","text":"public subroutine extract_subset_absorption_tau(ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out Called by proc~~extract_subset_absorption_tau~2~~CalledByGraph proc~extract_subset_absorption_tau~2 extract_subset_absorption_tau interface~extract_subset~2 extract_subset interface~extract_subset~2->proc~extract_subset_absorption_tau~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code extract_subset_absorption_tau Source Code subroutine extract_subset_absorption_tau ( ncol , nlay , ngpt , tau_in , ssa_in , & colS , colE , tau_out ) & bind ( C , name = \"extract_subset_absorption_tau\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau_in , ssa_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: tau_out integer :: icol , ilay , igpt !$acc parallel loop collapse(3) & !$acc&     copyin(ssa_in(cols:cole,:nlay,:ngpt)) & !$acc&     copyout(tau_out(:cole-cols+1,:nlay,:ngpt)) & !$acc&     copyin(tau_in(cols:cole,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:ssa_in) & !$omp& map(from:tau_out) & !$omp& map(to:tau_in) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE tau_out ( icol - colS + 1 , ilay , igpt ) = & tau_in ( icol , ilay , igpt ) * ( 1._wp - ssa_in ( icol , ilay , igpt )) end do end do end do end subroutine extract_subset_absorption_tau","tags":"","loc":"proc/extract_subset_absorption_tau~2.html"},{"title":"extract_subset_dim1_3d – rte-rrtmgp","text":"public subroutine extract_subset_dim1_3d(ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out Called by proc~~extract_subset_dim1_3d~2~~CalledByGraph proc~extract_subset_dim1_3d~2 extract_subset_dim1_3d interface~extract_subset~2 extract_subset interface~extract_subset~2->proc~extract_subset_dim1_3d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code extract_subset_dim1_3d Source Code subroutine extract_subset_dim1_3d ( ncol , nlay , ngpt , array_in , colS , colE , array_out ) & bind ( C , name = \"extract_subset_dim1_3d\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: array_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: array_out integer :: icol , ilay , igpt !$acc parallel loop collapse(3) & !$acc&     copyout(array_out(:cole-cols+1,:nlay,:ngpt)) & !$acc&     copyin(array_in(cols:cole,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(from:array_out) & !$omp& map(to:array_in) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE array_out ( icol - colS + 1 , ilay , igpt ) = array_in ( icol , ilay , igpt ) end do end do end do end subroutine extract_subset_dim1_3d","tags":"","loc":"proc/extract_subset_dim1_3d~2.html"},{"title":"extract_subset_dim2_4d – rte-rrtmgp","text":"public subroutine extract_subset_dim2_4d(nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out Called by proc~~extract_subset_dim2_4d~2~~CalledByGraph proc~extract_subset_dim2_4d~2 extract_subset_dim2_4d interface~extract_subset~2 extract_subset interface~extract_subset~2->proc~extract_subset_dim2_4d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code extract_subset_dim2_4d Source Code subroutine extract_subset_dim2_4d ( nmom , ncol , nlay , ngpt , array_in , colS , colE , array_out ) & bind ( C , name = \"extract_subset_dim2_4d\" ) integer , intent ( in ) :: nmom , ncol , nlay , ngpt real ( wp ), dimension ( nmom , ncol , nlay , ngpt ), intent ( in ) :: array_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( nmom , colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: array_out integer :: icol , ilay , igpt , imom !$acc parallel loop collapse(4) & !$acc&     copyout(array_out(:nmom,:cole-cols+1,:nlay,:ngpt)) & !$acc&     copyin(array_in(:nmom,cols:cole,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(4) & !$omp& map(from:array_out) & !$omp& map(to:array_in) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE do imom = 1 , nmom array_out ( imom , icol - colS + 1 , ilay , igpt ) = array_in ( imom , icol , ilay , igpt ) end do end do end do end do end subroutine extract_subset_dim2_4d","tags":"","loc":"proc/extract_subset_dim2_4d~2.html"},{"title":"inc_1scalar_by_1scalar_bybnd – rte-rrtmgp","text":"public subroutine inc_1scalar_by_1scalar_bybnd(ncol, nlay, ngpt, tau1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_1scalar_by_1scalar_bybnd Source Code subroutine inc_1scalar_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt , icol , ilay !$acc parallel loop collapse(3) & !$acc& copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc& copy(tau1(:ncol,:nlay,:ngpt)) & !$acc& copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) endif end do end do end do end do end subroutine inc_1scalar_by_1scalar_bybnd","tags":"","loc":"proc/inc_1scalar_by_1scalar_bybnd~2.html"},{"title":"inc_1scalar_by_2stream_bybnd – rte-rrtmgp","text":"public subroutine inc_1scalar_by_2stream_bybnd(ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_1scalar_by_2stream_bybnd Source Code subroutine inc_1scalar_by_2stream_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt , icol , ilay !$acc parallel loop collapse(3) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd),ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2, ssa2) & !$omp& map(tofrom:tau1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) * ( 1._wp - ssa2 ( icol , ilay , ibnd )) endif end do end do end do end do end subroutine inc_1scalar_by_2stream_bybnd","tags":"","loc":"proc/inc_1scalar_by_2stream_bybnd~2.html"},{"title":"inc_1scalar_by_nstream_bybnd – rte-rrtmgp","text":"public subroutine inc_1scalar_by_nstream_bybnd(ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_1scalar_by_nstream_bybnd Source Code subroutine inc_1scalar_by_nstream_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt , icol , ilay !$acc parallel loop collapse(3) & !$acc&     copyin(gpt_lims(:,:nbnd),tau2(:ncol,:nlay,:nbnd)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:gpt_lims, tau2) & !$omp& map(tofrom:tau1) & !$omp& map(to:ssa2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) * ( 1._wp - ssa2 ( icol , ilay , ibnd )) endif end do end do end do end do end subroutine inc_1scalar_by_nstream_bybnd","tags":"","loc":"proc/inc_1scalar_by_nstream_bybnd~2.html"},{"title":"inc_2stream_by_1scalar_bybnd – rte-rrtmgp","text":"public subroutine inc_2stream_by_1scalar_bybnd(ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_2stream_by_1scalar_bybnd Source Code subroutine inc_2stream_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! g is unchanged endif end do end do end do end do end subroutine inc_2stream_by_1scalar_bybnd","tags":"","loc":"proc/inc_2stream_by_1scalar_bybnd~2.html"},{"title":"inc_2stream_by_2stream_bybnd – rte-rrtmgp","text":"public subroutine inc_2stream_by_2stream_bybnd(ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_2stream_by_2stream_bybnd Source Code subroutine inc_2stream_by_2stream_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , g1 , & tau2 , ssa2 , g2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 , g2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd),ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) & !$acc&     copy(g1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(g2(:ncol,:nlay,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2, ssa2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:gpt_lims) & !$omp& map(tofrom:g1) & !$omp& map(to:g2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * g2 ( icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 endif end do end do end do end do end subroutine inc_2stream_by_2stream_bybnd","tags":"","loc":"proc/inc_2stream_by_2stream_bybnd~2.html"},{"title":"inc_2stream_by_nstream_bybnd – rte-rrtmgp","text":"public subroutine inc_2stream_by_nstream_bybnd(ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_2stream_by_nstream_bybnd Source Code subroutine inc_2stream_by_nstream_bybnd ( ncol , nlay , ngpt , nmom2 , & tau1 , ssa1 , g1 , & tau2 , ssa2 , p2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom2 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , nbnd ), intent ( in ) :: p2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd),ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(p2(:1,:ncol,:nlay,:nbnd),gpt_lims(:,:nbnd)) & !$acc&     copy(g1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2, ssa2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:p2, gpt_lims) & !$omp& map(tofrom:g1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * p2 ( 1 , icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 endif end do end do end do end do end subroutine inc_2stream_by_nstream_bybnd","tags":"","loc":"proc/inc_2stream_by_nstream_bybnd~2.html"},{"title":"inc_nstream_by_1scalar_bybnd – rte-rrtmgp","text":"public subroutine inc_nstream_by_1scalar_bybnd(ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_nstream_by_1scalar_bybnd Source Code subroutine inc_nstream_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! p is unchanged endif end do end do end do end do end subroutine inc_nstream_by_1scalar_bybnd","tags":"","loc":"proc/inc_nstream_by_1scalar_bybnd~2.html"},{"title":"inc_nstream_by_2stream_bybnd – rte-rrtmgp","text":"public subroutine inc_nstream_by_2stream_bybnd(ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_nstream_by_2stream_bybnd Source Code subroutine inc_nstream_by_2stream_bybnd ( ncol , nlay , ngpt , nmom1 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , g2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 , g2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 real ( wp ) :: temp_mom ! TK integer :: imom !TK !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt),p1(:nmom1,:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc&     copyin(gpt_lims(:,:nbnd),g2(:ncol,:nlay,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:ssa2) & !$omp& map(tofrom:ssa1, p1) & !$omp& map(to:tau2) & !$omp& map(to:gpt_lims, g2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) ! ! Here assume Henyey-Greenstein ! temp_mom = g2 ( icol , ilay , ibnd ) do imom = 1 , nmom1 p1 ( imom , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( imom , icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * temp_mom ) / max ( eps , tauscat12 ) temp_mom = temp_mom * g2 ( icol , ilay , igpt ) end do ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 endif end do end do end do end do end subroutine inc_nstream_by_2stream_bybnd","tags":"","loc":"proc/inc_nstream_by_2stream_bybnd~2.html"},{"title":"inc_nstream_by_nstream_bybnd – rte-rrtmgp","text":"public subroutine inc_nstream_by_nstream_bybnd(ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents Source Code inc_nstream_by_nstream_bybnd Source Code subroutine inc_nstream_by_nstream_bybnd ( ncol , nlay , ngpt , nmom1 , nmom2 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , p2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nmom2 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , nbnd ), intent ( in ) :: p2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd , mom_lim real ( wp ) :: tau12 , tauscat12 mom_lim = min ( nmom1 , nmom2 ) !$acc parallel loop collapse(3) & !$acc&     copyin(p2(:mom_lim,:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc&     copy(p1(:mom_lim,:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:p2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:ssa2) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2) & !$omp& map(tofrom:p1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) ! ! If op2 has more moments than op1 these are ignored; !   if it has fewer moments the higher orders are assumed to be 0 ! p1 ( 1 : mom_lim , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : mom_lim , icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * p2 ( 1 : mom_lim , icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 endif end do end do end do end do end subroutine inc_nstream_by_nstream_bybnd","tags":"","loc":"proc/inc_nstream_by_nstream_bybnd~2.html"},{"title":"increment_1scalar_by_1scalar – rte-rrtmgp","text":"public subroutine increment_1scalar_by_1scalar(ncol, nlay, ngpt, tau1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 Contents Source Code increment_1scalar_by_1scalar Source Code subroutine increment_1scalar_by_1scalar ( ncol , nlay , ngpt , & tau1 , & tau2 ) bind ( C , name = \"increment_1scalar_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) end do end do end do end subroutine increment_1scalar_by_1scalar","tags":"","loc":"proc/increment_1scalar_by_1scalar~2.html"},{"title":"increment_1scalar_by_2stream – rte-rrtmgp","text":"public subroutine increment_1scalar_by_2stream(ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 Contents Source Code increment_1scalar_by_2stream Source Code subroutine increment_1scalar_by_2stream ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 ) bind ( C , name = \"increment_1scalar_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) & !$omp& map(to:ssa2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ( 1._wp - ssa2 ( icol , ilay , igpt )) end do end do end do end subroutine increment_1scalar_by_2stream","tags":"","loc":"proc/increment_1scalar_by_2stream~2.html"},{"title":"increment_1scalar_by_nstream – rte-rrtmgp","text":"public subroutine increment_1scalar_by_nstream(ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 Contents Source Code increment_1scalar_by_nstream Source Code subroutine increment_1scalar_by_nstream ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 ) bind ( C , name = \"increment_1scalar_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) & !$omp& map(to:ssa2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ( 1._wp - ssa2 ( icol , ilay , igpt )) end do end do end do end subroutine increment_1scalar_by_nstream","tags":"","loc":"proc/increment_1scalar_by_nstream~2.html"},{"title":"increment_2stream_by_1scalar – rte-rrtmgp","text":"public subroutine increment_2stream_by_1scalar(ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 Contents Source Code increment_2stream_by_1scalar Source Code subroutine increment_2stream_by_1scalar ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 ) bind ( C , name = \"increment_2stream_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt real ( wp ) :: tau12 ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:ssa1) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) if ( tau12 > eps ) then ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / tau12 tau1 ( icol , ilay , igpt ) = tau12 ! g is unchanged end if end do end do end do end subroutine increment_2stream_by_1scalar","tags":"","loc":"proc/increment_2stream_by_1scalar~2.html"},{"title":"increment_2stream_by_2stream – rte-rrtmgp","text":"public subroutine increment_2stream_by_2stream(ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 Contents Source Code increment_2stream_by_2stream Source Code subroutine increment_2stream_by_2stream ( ncol , nlay , ngpt , & tau1 , ssa1 , g1 , & tau2 , ssa2 , g2 ) bind ( C , name = \"increment_2stream_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 , g2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(g2(:ncol,:nlay,:ngpt)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt),tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt),g1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:g2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:ssa2, tau2) & !$omp& map(tofrom:tau1, g1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) if ( tauscat12 > eps ) then g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * g2 ( icol , ilay , igpt )) & / tauscat12 ssa1 ( icol , ilay , igpt ) = tauscat12 / tau12 tau1 ( icol , ilay , igpt ) = tau12 end if end do end do end do end subroutine increment_2stream_by_2stream","tags":"","loc":"proc/increment_2stream_by_2stream~2.html"},{"title":"increment_2stream_by_nstream – rte-rrtmgp","text":"public subroutine increment_2stream_by_nstream(ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2 Contents Source Code increment_2stream_by_nstream Source Code subroutine increment_2stream_by_nstream ( ncol , nlay , ngpt , nmom2 , & tau1 , ssa1 , g1 , & tau2 , ssa2 , p2 ) bind ( C , name = \"increment_2stream_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom2 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , ngpt ), intent ( in ) :: p2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(p2(:1,:ncol,:nlay,:ngpt)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt),tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt),g1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:p2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:ssa2, tau2) & !$omp& map(tofrom:tau1, g1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) if ( tauscat12 > eps ) then g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * p2 ( 1 , icol , ilay , igpt )) / tauscat12 ssa1 ( icol , ilay , igpt ) = tauscat12 / tau12 tau1 ( icol , ilay , igpt ) = tau12 end if end do end do end do end subroutine increment_2stream_by_nstream","tags":"","loc":"proc/increment_2stream_by_nstream~2.html"},{"title":"increment_nstream_by_1scalar – rte-rrtmgp","text":"public subroutine increment_nstream_by_1scalar(ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 Contents Source Code increment_nstream_by_1scalar Source Code subroutine increment_nstream_by_1scalar ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 ) bind ( C , name = \"increment_nstream_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt real ( wp ) :: tau12 ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:ssa1) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) if ( tau12 > eps ) then ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / tau12 tau1 ( icol , ilay , igpt ) = tau12 ! p is unchanged end if end do end do end do end subroutine increment_nstream_by_1scalar","tags":"","loc":"proc/increment_nstream_by_1scalar~2.html"},{"title":"increment_nstream_by_2stream – rte-rrtmgp","text":"public subroutine increment_nstream_by_2stream(ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 Contents Source Code increment_nstream_by_2stream Source Code subroutine increment_nstream_by_2stream ( ncol , nlay , ngpt , nmom1 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , g2 ) bind ( C , name = \"increment_nstream_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 , g2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 real ( wp ) :: temp_mom ! TK integer :: imom !TK ! -------------- ! -------------- !$acc parallel loop collapse(3) & !$acc&     copy(p1(:nmom1,:ncol,:nlay,:ngpt),ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(g2(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:p1, ssa1) & !$omp& map(to:ssa2) & !$omp& map(tofrom:tau1) & !$omp& map(to:g2) & !$omp& map(to:tau2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) ! ! Here assume Henyey-Greenstein ! if ( tauscat12 > eps ) then temp_mom = g2 ( icol , ilay , igpt ) do imom = 1 , nmom1 p1 ( imom , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( imom , icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * temp_mom ) / tauscat12 temp_mom = temp_mom * g2 ( icol , ilay , igpt ) end do ssa1 ( icol , ilay , igpt ) = tauscat12 / tau12 tau1 ( icol , ilay , igpt ) = tau12 end if end do end do end do end subroutine increment_nstream_by_2stream","tags":"","loc":"proc/increment_nstream_by_2stream~2.html"},{"title":"increment_nstream_by_nstream – rte-rrtmgp","text":"public subroutine increment_nstream_by_nstream(ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2 Contents Source Code increment_nstream_by_nstream Source Code subroutine increment_nstream_by_nstream ( ncol , nlay , ngpt , nmom1 , nmom2 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , p2 ) bind ( C , name = \"increment_nstream_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nmom2 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , ngpt ), intent ( in ) :: p2 integer :: icol , ilay , igpt , mom_lim real ( wp ) :: tau12 , tauscat12 ! -------------- ! -------------- mom_lim = min ( nmom1 , nmom2 ) !$acc  parallel loop collapse(3) & !$acc&     copyin(p2(:mom_lim,:ncol,:nlay,:ngpt)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt),tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt),p1(:mom_lim,:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:p2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:ssa2, tau2) & !$omp& map(tofrom:tau1, p1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) if ( tauscat12 > eps ) then ! ! If op2 has more moments than op1 these are ignored; !   if it has fewer moments the higher orders are assumed to be 0 ! p1 ( 1 : mom_lim , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : mom_lim , icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * p2 ( 1 : mom_lim , icol , ilay , igpt )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end if end do end do end do end subroutine increment_nstream_by_nstream","tags":"","loc":"proc/increment_nstream_by_nstream~2.html"},{"title":"delta_scale_2str_kernel – rte-rrtmgp","text":"public interface delta_scale_2str_kernel Calls interface~~delta_scale_2str_kernel~2~~CallsGraph interface~delta_scale_2str_kernel~2 delta_scale_2str_kernel proc~delta_scale_2str_k~2 delta_scale_2str_k interface~delta_scale_2str_kernel~2->proc~delta_scale_2str_k~2 proc~delta_scale_2str_f_k~2 delta_scale_2str_f_k interface~delta_scale_2str_kernel~2->proc~delta_scale_2str_f_k~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures delta_scale_2str_f_k delta_scale_2str_k Module Procedures public subroutine delta_scale_2str_f_k (ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f public subroutine delta_scale_2str_k (ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g","tags":"","loc":"interface/delta_scale_2str_kernel~2.html"},{"title":"extract_subset – rte-rrtmgp","text":"public interface extract_subset Calls interface~~extract_subset~2~~CallsGraph interface~extract_subset~2 extract_subset proc~extract_subset_absorption_tau~2 extract_subset_absorption_tau interface~extract_subset~2->proc~extract_subset_absorption_tau~2 proc~extract_subset_dim1_3d~2 extract_subset_dim1_3d interface~extract_subset~2->proc~extract_subset_dim1_3d~2 proc~extract_subset_dim2_4d~2 extract_subset_dim2_4d interface~extract_subset~2->proc~extract_subset_dim2_4d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures extract_subset_dim1_3d extract_subset_dim2_4d extract_subset_absorption_tau Module Procedures public subroutine extract_subset_dim1_3d (ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out public subroutine extract_subset_dim2_4d (nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out public subroutine extract_subset_absorption_tau (ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out","tags":"","loc":"interface/extract_subset~2.html"},{"title":"lw_solver_2stream – rte-rrtmgp","text":"public subroutine lw_solver_2stream(ncol, nlay, ngpt, top_at_1, tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dn Contents Source Code lw_solver_2stream Source Code subroutine lw_solver_2stream ( ncol , nlay , ngpt , top_at_1 , & tau , ssa , g , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn ) bind ( C , name = \"lw_solver_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , & ! Optical thickness, ssa , & ! single-scattering albedo, g ! asymmetry parameter [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( in ) :: lev_source_inc , lev_source_dec ! Planck source at layer edge for radiation in increasing/decreasing ilay direction [W/m2] ! Includes spectral weighting that accounts for state-dependent frequency to g-space mapping real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux ! Incident diffuse flux, probably 0 [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ---------------------------------------------------------------------- integer :: icol , igpt , top_level real ( wp ), dimension ( ncol , nlay , ngpt ) :: Rdif , Tdif , gamma1 , gamma2 real ( wp ), dimension ( ncol , ngpt ) :: sfc_albedo real ( wp ), dimension ( ncol , nlay + 1 , ngpt ) :: lev_source real ( wp ), dimension ( ncol , nlay , ngpt ) :: source_dn , source_up real ( wp ), dimension ( ncol , ngpt ) :: source_sfc ! ------------------------------------ ! ------------------------------------ !$acc enter data copyin(tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, flux_dn) !$omp target enter data map(to:tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, flux_dn) !$acc enter data create(flux_up, Rdif, Tdif, gamma1, gamma2, sfc_albedo, lev_source, source_dn, source_up, source_sfc) !$omp target enter data map(alloc:flux_up, Rdif, Tdif, gamma1, gamma2, sfc_albedo, lev_source, source_dn, source_up, source_sfc) ! ! RRTMGP provides source functions at each level using the spectral mapping !   of each adjacent layer. Combine these for two-stream calculations ! top_level = nlay + 1 if ( top_at_1 ) top_level = 1 call lw_combine_sources ( ncol , nlay , ngpt , top_at_1 , & lev_source_inc , lev_source_dec , & lev_source ) ! ! Cell properties: reflection, transmission for diffuse radiation !   Coupling coefficients needed for source function ! call lw_two_stream ( ncol , nlay , ngpt , & tau , ssa , g , & gamma1 , gamma2 , Rdif , Tdif ) ! ! Source function for diffuse radiation ! call lw_source_2str ( ncol , nlay , ngpt , top_at_1 , & sfc_emis , sfc_src , & lay_source , lev_source , & gamma1 , gamma2 , Rdif , Tdif , tau , & source_dn , source_up , source_sfc ) !$acc                         parallel loop    collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol sfc_albedo ( icol , igpt ) = 1._wp - sfc_emis ( icol , igpt ) flux_dn ( icol , top_level , igpt ) = inc_flux ( icol , igpt ) end do end do ! ! Transport ! call adding ( ncol , nlay , ngpt , top_at_1 , & sfc_albedo , & Rdif , Tdif , & source_dn , source_up , source_sfc , & flux_up , flux_dn ) !$acc exit data delete(tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src) !$omp target exit data map(release:tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src) !$acc exit data delete(Rdif, Tdif, gamma1, gamma2, sfc_albedo, lev_source, source_dn, source_up, source_sfc) !$omp target exit data map(release:Rdif, Tdif, gamma1, gamma2, sfc_albedo, lev_source, source_dn, source_up, source_sfc) !$acc exit data copyout(flux_up, flux_dn) !$omp target exit data map(from:flux_up, flux_dn) end subroutine lw_solver_2stream","tags":"","loc":"proc/lw_solver_2stream~2.html"},{"title":"lw_solver_noscat – rte-rrtmgp","text":"public subroutine lw_solver_noscat(ncol, nlay, ngpt, top_at_1, D, weight, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, incident_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: D real(kind=wp), intent(in) :: weight real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: incident_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g Called by proc~~lw_solver_noscat~2~~CalledByGraph proc~lw_solver_noscat~2 lw_solver_noscat proc~lw_solver_noscat_gaussquad~2 lw_solver_noscat_GaussQuad proc~lw_solver_noscat_gaussquad~2->proc~lw_solver_noscat~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lw_solver_noscat Source Code subroutine lw_solver_noscat ( ncol , nlay , ngpt , top_at_1 , D , weight , & tau , lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & incident_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) bind ( C , name = \"lw_solver_noscat\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: D ! secant of propagation angle  [] real ( wp ), intent ( in ) :: weight ! quadrature weight real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] ! Planck source at layer edge for radiation in increasing/decreasing ilay direction ! lev_source_dec applies the mapping in layer i to the Planck function at layer i ! lev_source_inc applies the mapping in layer i to the Planck function at layer i+1 real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( in ) :: lev_source_inc , lev_source_dec real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: incident_flux ! Boundary condition for flux [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ! Optional variables - arrays aren't referenced if corresponding logical  == False ! logical ( wl ), intent ( in ) :: do_broadband real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: broadband_up , broadband_dn ! Spectrally-integrated fluxes [W/m2] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_srcJac ! surface temperature Jacobian of surface source function [W/m2/K] real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: flux_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] logical ( wl ), intent ( in ) :: do_rescaling real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: ssa , g ! single-scattering albedo, asymmetry parameter ! ------------------------------------------------------------------------------------------------- ! Local variables integer :: icol , ilay , ilev , igpt integer :: top_level , sfc_level real ( wp ), dimension ( ncol , nlay , ngpt ) :: tau_loc , & ! path length (tau/mu) trans ! transmissivity  = exp(-tau) real ( wp ), dimension ( ncol , nlay , ngpt ) :: source_dn , source_up real ( wp ), dimension (:,:,:), pointer :: lev_source_up , lev_source_dn ! Mapping increasing/decreasing indicies to up/down real ( wp ), parameter :: pi = acos ( - 1._wp ) ! ! For Jacobians ! real ( wp ), dimension ( ncol , nlay + 1 , ngpt ) :: gpt_Jac ! ! Used when approximating scattering ! real ( wp ) :: ssal , wb , scaleTau , scaling real ( wp ), dimension ( ncol , nlay , ngpt ) :: An , Cn ! ------------------------------------ ! Which way is up? ! Level Planck sources for upward and downward radiation ! When top_at_1, lev_source_up => lev_source_dec !                lev_source_dn => lev_source_inc, and vice-versa if ( top_at_1 ) then top_level = 1 sfc_level = nlay + 1 lev_source_up => lev_source_dec lev_source_dn => lev_source_inc else top_level = nlay + 1 sfc_level = 1 lev_source_up => lev_source_inc lev_source_dn => lev_source_dec end if !$acc        data create(   tau_loc,trans,source_dn,source_up ) & !$acc             copyin(   D, tau,lev_source_up,lev_source_dn) !$omp target data map(alloc:tau_loc,trans,source_dn,source_up ) & !$omp             map(to:   D, tau,lev_source_up,lev_source_dn) !$acc        enter data create(   flux_dn,flux_up) !$omp target enter data map(alloc:flux_dn,flux_up) !$acc                         parallel loop    collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ! ! Transport is for intensity !   convert flux at top of domain to intensity assuming azimuthal isotropy ! flux_dn ( icol , top_level , igpt ) = incident_flux ( icol , igpt ) / ( 2._wp * pi * weight ) end do end do !$acc        data create(   An, Cn)  copyin(g)          if(do_rescaling) !$omp target data map(alloc:An, Cn)  map(to:g)          if(do_rescaling) !$acc        data copyin(sfc_srcJac) create(   gpt_Jac) if(do_Jacobians) !$omp target data map(to:sfc_srcJac) map(alloc:gpt_Jac) if(do_Jacobians) !$acc parallel loop no_create(An, Cn, gpt_Jac, g) collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! ! The wb and scaleTau terms are independent of propagation !   angle D and could be pre-computed if several values of D are used ! We re-compute them here to keep not have to localize memory use ! if ( do_rescaling ) then ssal = ssa ( icol , ilay , igpt ) wb = ssal * ( 1._wp - g ( icol , ilay , igpt )) * 0.5_wp scaleTau = ( 1._wp - ssal + wb ) ! here wb/scaleTau is parameter wb/(1-w(1-b)) of Eq.21 of the Tang paper ! actually it is in line of parameter rescaling defined in Eq.7 ! potentialy if g=ssa=1  then  wb/scaleTau = NaN ! it should not happen because g is never 1 in atmospheres ! explanation of factor 0.4 note A of Table Cn ( icol , ilay , igpt ) = 0.4_wp * wb / scaleTau ! Eq.15 of the paper, multiplied by path length tau_loc ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) * D ( icol , igpt ) * scaleTau trans ( icol , ilay , igpt ) = exp ( - tau_loc ( icol , ilay , igpt )) An ( icol , ilay , igpt ) = ( 1._wp - trans ( icol , ilay , igpt ) ** 2 ) else ! ! Optical path and transmission, used in source function and transport calculations ! tau_loc ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) * D ( icol , igpt ) trans ( icol , ilay , igpt ) = exp ( - tau_loc ( icol , ilay , igpt )) end if call lw_source_noscat ( lay_source ( icol , ilay , igpt ), & lev_source_up ( icol , ilay , igpt ), lev_source_dn ( icol , ilay , igpt ), & tau_loc ( icol , ilay , igpt ), trans ( icol , ilay , igpt ), & source_dn ( icol , ilay , igpt ), source_up ( icol , ilay , igpt )) end do end do end do ! ! Transport down ! call lw_transport_noscat_dn ( ncol , nlay , ngpt , top_at_1 , trans , source_dn , flux_dn ) ! ! Surface reflection and emission ! !$acc                         parallel loop    collapse(2) no_create(gpt_Jac, sfc_srcJac) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ! ! Surface albedo, surface source function ! flux_up ( icol , sfc_level , igpt ) = flux_dn ( icol , sfc_level , igpt ) * ( 1._wp - sfc_emis ( icol , igpt )) + & sfc_src ( icol , igpt ) * sfc_emis ( icol , igpt ) if ( do_Jacobians ) & gpt_Jac ( icol , sfc_level , igpt ) = sfc_srcJac ( icol , igpt ) * sfc_emis ( icol , igpt ) end do end do ! ! Transport up, or up and down again if using rescaling ! if ( do_rescaling ) then call lw_transport_1rescl ( ncol , nlay , ngpt , top_at_1 , trans , & source_dn , source_up , & flux_up , flux_dn , An , Cn , & do_Jacobians , gpt_Jac ) else call lw_transport_noscat_up ( ncol , nlay , ngpt , top_at_1 , trans , source_up , flux_up , & do_Jacobians , gpt_Jac ) end if if ( do_broadband ) then ! ! Broadband reduction including !   conversion from intensity to flux assuming azimuthal isotropy and quadrature weight ! call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , flux_dn , broadband_dn ) call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , flux_up , broadband_up ) !$acc        exit data delete(     flux_dn,flux_up) !$omp target exit data map(release:flux_dn,flux_up) else ! ! Convert intensity to flux assuming azimuthal isotropy and quadrature weight ! call apply_factor_3D ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , flux_dn ) call apply_factor_3D ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , flux_up ) !$acc        exit data copyout( flux_dn,flux_up) !$omp target exit data map(from:flux_dn,flux_up) end if ! ! Only broadband-integrated Jacobians are provided ! if ( do_Jacobians ) then call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , gpt_Jac , flux_upJac ) end if !$acc        end data !$omp end target data !$acc        end data !$omp end target data !$acc        end data !$omp end target data end subroutine lw_solver_noscat","tags":"","loc":"proc/lw_solver_noscat~2.html"},{"title":"lw_solver_noscat_GaussQuad – rte-rrtmgp","text":"public subroutine lw_solver_noscat_GaussQuad(ncol, nlay, ngpt, top_at_1, nmus, Ds, weights, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 integer, intent(in) :: nmus real(kind=wp), intent(in), dimension (ncol,      ngpt, nmus) :: Ds real(kind=wp), intent(in), dimension(nmus) :: weights real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(inout), dimension(ncol,nlay+1     ), target :: broadband_up real(kind=wp), intent(inout), dimension(ncol,nlay+1     ), target :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g Calls proc~~lw_solver_noscat_gaussquad~2~~CallsGraph proc~lw_solver_noscat_gaussquad~2 lw_solver_noscat_GaussQuad proc~lw_solver_noscat~2 lw_solver_noscat proc~lw_solver_noscat_gaussquad~2->proc~lw_solver_noscat~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lw_solver_noscat_GaussQuad Source Code subroutine lw_solver_noscat_GaussQuad ( ncol , nlay , ngpt , top_at_1 , & nmus , Ds , weights , & tau , & lay_source , lev_source_inc , lev_source_dec , & sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) bind ( C , name = \"lw_solver_noscat_GaussQuad\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 integer , intent ( in ) :: nmus ! number of quadrature angles real ( wp ), dimension ( ncol , ngpt , & nmus ), intent ( in ) :: Ds real ( wp ), dimension ( nmus ), intent ( in ) :: weights ! quadrature secants, weights real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_source_inc ! Planck source at layer edge for radiation in increasing ilay direction [W/m2] ! Includes spectral weighting that accounts for state-dependent frequency to g-space mapping real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_source_dec ! Planck source at layer edge for radiation in decreasing ilay direction [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux ! Incident diffuse flux, probably 0 [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ! Optional variables - arrays aren't referenced if corresponding logical  == False ! logical ( wl ), intent ( in ) :: do_broadband real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( inout ) :: broadband_up , broadband_dn ! Spectrally-integrated fluxes [W/m2] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_srcJac ! surface temperature Jacobian of surface source function [W/m2/K] real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( out ) :: flux_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] logical ( wl ), intent ( in ) :: do_rescaling real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: ssa , g ! single-scattering albedo, asymmetry parameter ! ------------------------------------ ! ! Local variables ! real ( wp ), dimension (:,:,:), pointer :: this_flux_up , this_flux_dn real ( wp ), dimension (:,:), pointer :: this_broadband_up , this_broadband_dn , this_flux_upJac integer :: icol , ilev , igpt , imu ! ------------------------------------ !$acc        data copyin(Ds, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src) !$omp target data map(to:Ds, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src) !$acc        data copyout( flux_up, flux_dn)             if (.not. do_broadband) !$omp target data map(from:flux_up, flux_dn)             if (.not. do_broadband) !$acc        data copyout( broadband_up, broadband_dn)   if (      do_broadband) !$omp target data map(from:broadband_up, broadband_dn)   if (      do_broadband) !$acc        data copyin(sfc_srcJac)   copyout(flux_upJac) if (do_Jacobians) !$omp target data map(to:sfc_srcJac), map(from:flux_upJac) if (do_Jacobians) if ( do_broadband ) then this_broadband_up => broadband_up this_broadband_dn => broadband_dn allocate ( this_flux_up ( ncol , nlay + 1 , ngpt ), this_flux_dn ( ncol , nlay + 1 , ngpt )) else this_flux_up => flux_up this_flux_dn => flux_dn ! Spectrally-integrated fluxes won't be filled in allocate ( this_broadband_up ( ncol , nlay + 1 ), this_broadband_dn ( ncol , nlay + 1 )) end if !$acc        data create(   this_broadband_up, this_broadband_dn, this_flux_up, this_flux_dn) !$omp target data map(alloc:this_broadband_up, this_broadband_dn, this_flux_up, this_flux_dn) call lw_solver_noscat ( ncol , nlay , ngpt , & top_at_1 , Ds (:,:, 1 ), weights ( 1 ), tau , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & this_flux_up , this_flux_dn , & do_broadband , this_broadband_up , this_broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) !$acc end data !$omp end target data if ( nmus > 1 ) then ! ! For more than one angle use local arrays ! if ( do_broadband ) then nullify ( this_broadband_up , this_broadband_dn ) allocate ( this_broadband_up ( ncol , nlay + 1 ), this_broadband_dn ( ncol , nlay + 1 )) else nullify ( this_flux_up , this_flux_dn ) allocate ( this_flux_up ( ncol , nlay + 1 , ngpt ), this_flux_dn ( ncol , nlay + 1 , ngpt )) end if if ( do_Jacobians ) then allocate ( this_flux_upJac ( ncol , nlay + 1 )) else this_flux_upJac => flux_upJac end if ! ! For more than one angle use local arrays ! !$acc        data create(   this_broadband_up, this_broadband_dn, this_flux_up, this_flux_dn) !$omp target data map(alloc:this_broadband_up, this_broadband_dn, this_flux_up, this_flux_dn) do imu = 2 , nmus call lw_solver_noscat ( ncol , nlay , ngpt , & top_at_1 , Ds (:,:, imu ), weights ( imu ), tau , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & this_flux_up , this_flux_dn , & do_broadband , this_broadband_up , this_broadband_dn , & do_Jacobians , sfc_srcJac , this_flux_upJac , & do_rescaling , ssa , g ) if ( do_broadband ) then call add_arrays ( ncol , nlay + 1 , this_broadband_up , broadband_up ) call add_arrays ( ncol , nlay + 1 , this_broadband_dn , broadband_dn ) else call add_arrays ( ncol , nlay + 1 , ngpt , flux_up , this_flux_up ) call add_arrays ( ncol , nlay + 1 , ngpt , flux_dn , this_flux_dn ) end if if ( do_Jacobians ) then call add_arrays ( ncol , nlay + 1 , this_flux_upJac , flux_upJac ) end if end do !$acc end data !$omp end target data end if !$acc end data !$omp end target data !$acc end data !$omp end target data !$acc end data !$omp end target data !$acc end data !$omp end target data ! Cleanup if (. not . associated ( this_broadband_up , broadband_up )) then deallocate ( this_broadband_up , this_broadband_dn ) end if if (. not . associated ( this_flux_up , flux_up )) then deallocate ( this_flux_up , this_flux_dn ) end if if ( nmus > 1 . and . do_Jacobians ) then deallocate ( this_flux_upJac ) end if end subroutine lw_solver_noscat_GaussQuad","tags":"","loc":"proc/lw_solver_noscat_gaussquad~2.html"},{"title":"sw_solver_2stream – rte-rrtmgp","text":"public subroutine sw_solver_2stream(ncol, nlay, ngpt, top_at_1, tau, ssa, g, mu0, sfc_alb_dir, sfc_alb_dif, inc_flux_dir, flux_up, flux_dn, flux_dir, has_dif_bc, inc_flux_dif, do_broadband, broadband_up, broadband_dn, broadband_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dir real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dif real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dir logical(kind=wl), intent(in) :: has_dif_bc real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dif logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dir Contents Source Code sw_solver_2stream Source Code subroutine sw_solver_2stream ( ncol , nlay , ngpt , top_at_1 , & tau , ssa , g , mu0 , & sfc_alb_dir , sfc_alb_dif , & inc_flux_dir , & flux_up , flux_dn , flux_dir , & has_dif_bc , inc_flux_dif , & do_broadband , broadband_up , & broadband_dn , broadband_dir ) bind ( C , name = \"sw_solver_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , & ! Optical thickness, ssa , & ! single-scattering albedo, g ! asymmetry parameter [] real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 ! cosine of solar zenith angle ! Spectral albedo of surface to direct and diffuse radiation real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_alb_dir , sfc_alb_dif , & inc_flux_dir ! Direct beam incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn , flux_dir ! Fluxes [W/m2] logical ( wl ), intent ( in ) :: has_dif_bc ! Is a boundary condition for diffuse flux supplied? real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux_dif ! Boundary condition for diffuse flux logical ( wl ), intent ( in ) :: do_broadband ! Provide broadband-integrated, not spectrally-resolved, fluxes? real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: broadband_up , broadband_dn , broadband_dir ! ------------------------------------------- integer :: icol , ilay , igpt , top_level real ( wp ) :: bb_flux_s , bb_dir_s real ( wp ), dimension ( ncol , nlay , ngpt ) :: Rdif , Tdif real ( wp ), dimension ( ncol , nlay , ngpt ) :: source_up , source_dn real ( wp ), dimension ( ncol , ngpt ) :: source_srf real ( wp ), dimension (:,:,:), pointer :: gpt_flux_up , gpt_flux_dn , gpt_flux_dir ! ------------------------------------ if ( do_broadband ) then allocate ( gpt_flux_up ( ncol , nlay + 1 , ngpt ), & gpt_flux_dn ( ncol , nlay + 1 , ngpt ), & gpt_flux_dir ( ncol , nlay + 1 , ngpt )) else gpt_flux_up => flux_up gpt_flux_dn => flux_dn gpt_flux_dir => flux_dir end if top_level = nlay + 1 if ( top_at_1 ) top_level = 1 ! ! Boundary conditions direct beam... ! !$acc        data create(   gpt_flux_up, gpt_flux_dn, gpt_flux_dir) & !$acc             copyin(   mu0) !$omp target data map(alloc:gpt_flux_up, gpt_flux_dn, gpt_flux_dir) & !$omp             map(to:   mu0) !$acc        data copyout(flux_up, flux_dn, flux_dir) if (.not. do_broadband) !$omp target data map(to: flux_up, flux_dn, flux_dir) if (.not. do_broadband) !$acc  parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol gpt_flux_dir ( icol , top_level , igpt ) = inc_flux_dir ( icol , igpt ) * mu0 ( icol ) end do end do ! ! ... and diffuse field, using 0 if no BC is provided ! if ( has_dif_bc ) then !$acc                         parallel loop    collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol gpt_flux_dn ( icol , top_level , igpt ) = inc_flux_dif ( icol , igpt ) end do end do else !$acc                         parallel loop    collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol gpt_flux_dn ( icol , top_level , igpt ) = 0._wp end do end do end if ! ! Cell properties: transmittance and reflectance for diffuse radiation ! Direct-beam radiation and source for diffuse radiation ! !$acc        data create(   Rdif, Tdif, source_up, source_dn, source_srf) !$omp target data map(alloc:Rdif, Tdif, source_up, source_dn, source_srf) call sw_dif_and_source ( ncol , nlay , ngpt , top_at_1 , mu0 , sfc_alb_dif , & tau , ssa , g , & Rdif , Tdif , source_dn , source_up , source_srf , gpt_flux_dir ) call adding ( ncol , nlay , ngpt , top_at_1 , & sfc_alb_dif , Rdif , Tdif , & source_dn , source_up , source_srf , gpt_flux_up , gpt_flux_dn ) !$acc        end data !$omp end target data if ( do_broadband ) then ! ! Broadband integration ! !$acc        data copyout( broadband_up, broadband_dn, broadband_dir) !$omp target data map(from:broadband_up, broadband_dn, broadband_dir) call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 1._wp , gpt_flux_up , broadband_up ) call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 1._wp , gpt_flux_dn , broadband_dn ) call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 1._wp , gpt_flux_dir , broadband_dir ) ! ! adding computes only diffuse flux; flux_dn is total ! call add_arrays ( ncol , nlay + 1 , broadband_dir , broadband_dn ) !$acc        end data !$omp end target data else ! ! adding computes only diffuse flux; flux_dn is total ! call add_arrays ( ncol , nlay + 1 , ngpt , flux_dir , flux_dn ) end if !$acc        end data !$omp end target data !$acc        end data !$omp end target data if ( do_broadband ) then deallocate ( gpt_flux_up , gpt_flux_dn , gpt_flux_dir ) end if end subroutine sw_solver_2stream","tags":"","loc":"proc/sw_solver_2stream~2.html"},{"title":"sw_solver_noscat – rte-rrtmgp","text":"public subroutine sw_solver_noscat(ncol, nlay, ngpt, top_at_1, tau, mu0, inc_flux_dir, flux_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dir Contents Source Code sw_solver_noscat Source Code subroutine sw_solver_noscat ( ncol , nlay , ngpt , top_at_1 , & tau , mu0 , inc_flux_dir , flux_dir ) bind ( C , name = \"sw_solver_noscat\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 ! cosine of solar zenith angle real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux_dir ! Direct beam incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_dir ! Direct-beam flux, spectral [W/m2] integer :: icol , ilev , igpt real ( wp ) :: mu0_inv ( ncol ) ! ------------------------------------ ! ------------------------------------ !$acc enter data copyin(tau, mu0) create(mu0_inv, flux_dir) !$omp target enter data map(to:tau, mu0) map(alloc:mu0_inv, flux_dir) !$acc parallel loop !$omp target teams distribute parallel do simd do icol = 1 , ncol mu0_inv ( icol ) = 1._wp / mu0 ( icol ) enddo ! Indexing into arrays for upward and downward propagation depends on the vertical !   orientation of the arrays (whether the domain top is at the first or last index) ! We write the loops out explicitly so compilers will have no trouble optimizing them. ! Downward propagation if ( top_at_1 ) then ! For the flux at this level, what was the previous level, and which layer has the !   radiation just passed through? ! layer index = level index - 1 ! previous level is up (-1) !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol flux_dir ( icol , 1 , igpt ) = inc_flux_dir ( icol , igpt ) * mu0 ( icol ) do ilev = 2 , nlay + 1 flux_dir ( icol , ilev , igpt ) = flux_dir ( icol , ilev - 1 , igpt ) * exp ( - tau ( icol , ilev , igpt ) * mu0_inv ( icol )) end do end do end do else ! layer index = level index ! previous level is up (+1) !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol flux_dir ( icol , nlay + 1 , igpt ) = inc_flux_dir ( icol , igpt ) * mu0 ( icol ) do ilev = nlay , 1 , - 1 flux_dir ( icol , ilev , igpt ) = flux_dir ( icol , ilev + 1 , igpt ) * exp ( - tau ( icol , ilev , igpt ) * mu0_inv ( icol )) end do end do end do end if !$acc exit data delete(tau, mu0, mu0_inv) copyout(flux_dir) !$omp target exit data map(release:tau, mu0, mu0_inv) map(from:flux_dir) end subroutine sw_solver_noscat","tags":"","loc":"proc/sw_solver_noscat~2.html"},{"title":"mo_rrtmgp_util_reorder_kernels – rte-rrtmgp","text":"Uses mo_rte_kind module~~mo_rrtmgp_util_reorder_kernels~~UsesGraph module~mo_rrtmgp_util_reorder_kernels mo_rrtmgp_util_reorder_kernels mo_rte_kind mo_rte_kind module~mo_rrtmgp_util_reorder_kernels->mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines reorder_123x321_kernel Subroutines public subroutine reorder_123x321_kernel (d1, d2, d3, array_in, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: d1 integer, intent(in) :: d2 integer, intent(in) :: d3 real(kind=wp), intent(in), dimension(d1, d2, d3) :: array_in real(kind=wp), intent(out), dimension(d3, d2, d1) :: array_out","tags":"","loc":"module/mo_rrtmgp_util_reorder_kernels.html"},{"title":"mo_gas_optics_kernels – rte-rrtmgp","text":"Uses mo_rte_util_array mo_rte_kind module~~mo_gas_optics_kernels~2~~UsesGraph module~mo_gas_optics_kernels~2 mo_gas_optics_kernels mo_rte_util_array mo_rte_util_array module~mo_gas_optics_kernels~2->mo_rte_util_array mo_rte_kind mo_rte_kind module~mo_gas_optics_kernels~2->mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions interpolate1D interpolate2D interpolate2D_byflav interpolate3D interpolate3D_byflav Subroutines compute_Planck_source compute_tau_absorption compute_tau_rayleigh gas_optical_depths_major gas_optical_depths_minor interpolation Functions public pure function interpolate1D (val, offset, delta, table) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: val real(kind=wp), intent(in) :: offset real(kind=wp), intent(in) :: delta real(kind=wp), intent(in), dimension(:,:) :: table Return Value real(kind=wp),dimension(size(table,dim=2)) public pure function interpolate2D (fminor, k, igpt, jeta, jtemp) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: fminor real(kind=wp), intent(in), dimension(:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp Return Value real(kind=wp) public pure function interpolate2D_byflav (fminor, k, gptS, gptE, jeta, jtemp) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: fminor real(kind=wp), intent(in), dimension(:,:,:) :: k integer, intent(in) :: gptS integer, intent(in) :: gptE integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp Return Value real(kind=wp),dimension(gptE-gptS+1) public pure function interpolate3D (scaling, fmajor, k, igpt, jeta, jtemp, jpress) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: scaling real(kind=wp), intent(in), dimension(2,2,2) :: fmajor real(kind=wp), intent(in), dimension(:,:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp integer, intent(in) :: jpress Return Value real(kind=wp) public pure function interpolate3D_byflav (scaling, fmajor, k, gptS, gptE, jeta, jtemp, jpress) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: scaling real(kind=wp), intent(in), dimension(2,2,2) :: fmajor real(kind=wp), intent(in), dimension(:,:,:,:) :: k integer, intent(in) :: gptS integer, intent(in) :: gptE integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp integer, intent(in) :: jpress Return Value real(kind=wp),dimension(gptS:gptE) Subroutines public subroutine compute_Planck_source (ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, nPlanckTemp, tlay, tlev, tsfc, sfc_lay, fmajor, jeta, tropo, jtemp, jpress, gpoint_bands, band_lims_gpt, pfracin, temp_ref_min, totplnk_delta, totplnk, gpoint_flavor, sfc_src, lay_src, lev_src_inc, lev_src_dec, sfc_source_Jac) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nPlanckTemp real(kind=wp), intent(in), dimension(ncol,nlay  ) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay+1) :: tlev real(kind=wp), intent(in), dimension(ncol       ) :: tsfc integer, intent(in) :: sfc_lay real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(            ncol,nlay) :: tropo integer, intent(in), dimension(            ncol,nlay) :: jtemp integer, intent(in), dimension(            ncol,nlay) :: jpress integer, intent(in), dimension(ngpt) :: gpoint_bands integer, intent(in), dimension(2, nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: pfracin real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: totplnk_delta real(kind=wp), intent(in), dimension(nPlanckTemp,nbnd) :: totplnk integer, intent(in), dimension(2,ngpt) :: gpoint_flavor real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lay_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_inc real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_dec real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_source_Jac public subroutine compute_tau_absorption (ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, nminorlower, nminorklower, nminorupper, nminorkupper, idx_h2o, gpoint_flavor, band_lims_gpt, kmajor, kminor_lower, kminor_upper, minor_limits_gpt_lower, minor_limits_gpt_upper, minor_scales_with_density_lower, minor_scales_with_density_upper, scale_by_complement_lower, scale_by_complement_upper, idx_minor_lower, idx_minor_upper, idx_minor_scaling_lower, idx_minor_scaling_upper, kminor_start_lower, kminor_start_upper, tropo, col_mix, fmajor, fminor, play, tlay, col_gas, jeta, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nminorlower integer, intent(in) :: nminorklower integer, intent(in) :: nminorupper integer, intent(in) :: nminorkupper integer, intent(in) :: idx_h2o integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(ntemp,neta,nminorklower) :: kminor_lower real(kind=wp), intent(in), dimension(ntemp,neta,nminorkupper) :: kminor_upper integer, intent(in), dimension(2,nminorlower) :: minor_limits_gpt_lower integer, intent(in), dimension(2,nminorupper) :: minor_limits_gpt_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: minor_scales_with_density_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: minor_scales_with_density_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: scale_by_complement_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: scale_by_complement_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_scaling_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_scaling_upper integer, intent(in), dimension(  nminorlower) :: kminor_start_lower integer, intent(in), dimension(  nminorupper) :: kminor_start_upper logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav       ) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav       ) :: fmajor real(kind=wp), intent(in), dimension(2,2,  ncol,nlay,nflav       ) :: fminor real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: play real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: tlay real(kind=wp), intent(in), dimension(            ncol,nlay,0:ngas) :: col_gas integer, intent(in), dimension(2,    ncol,nlay,nflav       ) :: jeta integer, intent(in), dimension(            ncol,nlay       ) :: jtemp integer, intent(in), dimension(            ncol,nlay       ) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau public subroutine compute_tau_rayleigh (ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, krayl, idx_h2o, col_dry, col_gas, fminor, jeta, tropo, jtemp, tau_rayleigh) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,ngpt,2) :: krayl integer, intent(in) :: idx_h2o real(kind=wp), intent(in), dimension(ncol,nlay) :: col_dry real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: tau_rayleigh public subroutine gas_optical_depths_major (ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, kmajor, col_mix, fmajor, jeta, tropo, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp integer, intent(in), dimension(ncol,nlay) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau public subroutine gas_optical_depths_minor (ncol, nlay, ngpt, ngas, nflav, ntemp, neta, nminor, nminork, idx_h2o, gpt_flv, kminor, minor_limits_gpt, minor_scales_with_density, scale_by_complement, idx_minor, idx_minor_scaling, kminor_start, play, tlay, col_gas, fminor, jeta, layer_limits, jtemp, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: ntemp integer, intent(in) :: neta integer, intent(in) :: nminor integer, intent(in) :: nminork integer, intent(in) :: idx_h2o integer, intent(in), dimension(ngpt) :: gpt_flv real(kind=wp), intent(in), dimension(ntemp,neta,nminork) :: kminor integer, intent(in), dimension(2,nminor) :: minor_limits_gpt logical(kind=wl), intent(in), dimension(  nminor) :: minor_scales_with_density logical(kind=wl), intent(in), dimension(  nminor) :: scale_by_complement integer, intent(in), dimension(  nminor) :: idx_minor integer, intent(in), dimension(  nminor) :: idx_minor_scaling integer, intent(in), dimension(  nminor) :: kminor_start real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta integer, intent(in), dimension(ncol, 2) :: layer_limits integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau public subroutine interpolation (ncol, nlay, ngas, nflav, neta, npres, ntemp, flavor, press_ref_log, temp_ref, press_ref_log_delta, temp_ref_min, temp_ref_delta, press_ref_trop_log, vmr_ref, play, tlay, col_gas, jtemp, fmajor, fminor, col_mix, tropo, jeta, jpress) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,nflav) :: flavor real(kind=wp), intent(in), dimension(npres) :: press_ref_log real(kind=wp), intent(in), dimension(ntemp) :: temp_ref real(kind=wp), intent(in) :: press_ref_log_delta real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: temp_ref_delta real(kind=wp), intent(in) :: press_ref_trop_log real(kind=wp), intent(in), dimension(2,0:ngas,ntemp) :: vmr_ref real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas integer, intent(out), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(2,2,2,ncol,nlay,nflav) :: fmajor real(kind=wp), intent(out), dimension(2,2,  ncol,nlay,nflav) :: fminor real(kind=wp), intent(out), dimension(2,    ncol,nlay,nflav) :: col_mix logical(kind=wl), intent(out), dimension(ncol,nlay) :: tropo integer, intent(out), dimension(2,    ncol,nlay,nflav) :: jeta integer, intent(out), dimension(ncol,nlay) :: jpress","tags":"","loc":"module/mo_gas_optics_kernels~2.html"},{"title":"mo_fluxes_broadband_kernels – rte-rrtmgp","text":"Uses iso_c_binding mo_rte_kind module~~mo_fluxes_broadband_kernels~~UsesGraph module~mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels mo_rte_kind mo_rte_kind module~mo_fluxes_broadband_kernels->mo_rte_kind iso_c_binding iso_c_binding module~mo_fluxes_broadband_kernels->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces net_broadband Subroutines sum_broadband Interfaces public interface net_broadband private subroutine net_broadband_full(ncol, nlev, ngpt, spectral_flux_dn, spectral_flux_up, broadband_flux_net) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_up real(kind=wp), intent(out), dimension(ncol, nlev) :: broadband_flux_net private subroutine net_broadband_precalc(ncol, nlev, flux_dn, flux_up, broadband_flux_net) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev real(kind=wp), intent(in), dimension(ncol, nlev) :: flux_dn real(kind=wp), intent(in), dimension(ncol, nlev) :: flux_up real(kind=wp), intent(out), dimension(ncol, nlev) :: broadband_flux_net Subroutines public subroutine sum_broadband (ncol, nlev, ngpt, spectral_flux, broadband_flux) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux real(kind=wp), intent(out), dimension(ncol, nlev) :: broadband_flux","tags":"","loc":"module/mo_fluxes_broadband_kernels.html"},{"title":"mo_optical_props_kernels – rte-rrtmgp","text":"Uses iso_c_binding mo_rte_kind module~~mo_optical_props_kernels~2~~UsesGraph module~mo_optical_props_kernels~2 mo_optical_props_kernels mo_rte_kind mo_rte_kind module~mo_optical_props_kernels~2->mo_rte_kind iso_c_binding iso_c_binding module~mo_optical_props_kernels~2->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces delta_scale_2str_kernel extract_subset Subroutines delta_scale_2str_f_k delta_scale_2str_k extract_subset_absorption_tau extract_subset_dim1_3d extract_subset_dim2_4d inc_1scalar_by_1scalar_bybnd inc_1scalar_by_2stream_bybnd inc_1scalar_by_nstream_bybnd inc_2stream_by_1scalar_bybnd inc_2stream_by_2stream_bybnd inc_2stream_by_nstream_bybnd inc_nstream_by_1scalar_bybnd inc_nstream_by_2stream_bybnd inc_nstream_by_nstream_bybnd increment_1scalar_by_1scalar increment_1scalar_by_2stream increment_1scalar_by_nstream increment_2stream_by_1scalar increment_2stream_by_2stream increment_2stream_by_nstream increment_nstream_by_1scalar increment_nstream_by_2stream increment_nstream_by_nstream Interfaces public interface delta_scale_2str_kernel public pure subroutine delta_scale_2str_f_k (ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f public pure subroutine delta_scale_2str_k (ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g public interface extract_subset public pure subroutine extract_subset_dim1_3d (ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out public pure subroutine extract_subset_dim2_4d (nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out public pure subroutine extract_subset_absorption_tau (ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out Subroutines public pure subroutine delta_scale_2str_f_k (ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f public pure subroutine delta_scale_2str_k (ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g public pure subroutine extract_subset_absorption_tau (ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out public pure subroutine extract_subset_dim1_3d (ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out public pure subroutine extract_subset_dim2_4d (nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out public pure subroutine inc_1scalar_by_1scalar_bybnd (ncol, nlay, ngpt, tau1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_1scalar_by_2stream_bybnd (ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_1scalar_by_nstream_bybnd (ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_2stream_by_1scalar_bybnd (ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_2stream_by_2stream_bybnd (ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_2stream_by_nstream_bybnd (ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_nstream_by_1scalar_bybnd (ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_nstream_by_2stream_bybnd (ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_nstream_by_nstream_bybnd (ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine increment_1scalar_by_1scalar (ncol, nlay, ngpt, tau1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 public pure subroutine increment_1scalar_by_2stream (ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 public pure subroutine increment_1scalar_by_nstream (ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 public pure subroutine increment_2stream_by_1scalar (ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 public pure subroutine increment_2stream_by_2stream (ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 public pure subroutine increment_2stream_by_nstream (ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2 public pure subroutine increment_nstream_by_1scalar (ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 public pure subroutine increment_nstream_by_2stream (ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 public pure subroutine increment_nstream_by_nstream (ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2","tags":"","loc":"module/mo_optical_props_kernels~2.html"},{"title":"mo_rte_solver_kernels – rte-rrtmgp","text":"Uses iso_c_binding mo_rte_util_array mo_rte_kind module~~mo_rte_solver_kernels~2~~UsesGraph module~mo_rte_solver_kernels~2 mo_rte_solver_kernels mo_rte_util_array mo_rte_util_array module~mo_rte_solver_kernels~2->mo_rte_util_array mo_rte_kind mo_rte_kind module~mo_rte_solver_kernels~2->mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_solver_kernels~2->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines lw_solver_2stream lw_solver_noscat lw_solver_noscat_GaussQuad sw_solver_2stream sw_solver_noscat Subroutines public subroutine lw_solver_2stream (ncol, nlay, ngpt, top_at_1, tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dn public subroutine lw_solver_noscat (ncol, nlay, ngpt, top_at_1, D, weight, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, incident_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: D real(kind=wp), intent(in) :: weight real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: incident_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g public subroutine lw_solver_noscat_GaussQuad (ncol, nlay, ngpt, top_at_1, nmus, Ds, weights, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 integer, intent(in) :: nmus real(kind=wp), intent(in), dimension (ncol,      ngpt, nmus) :: Ds real(kind=wp), intent(in), dimension(nmus) :: weights real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g public subroutine sw_solver_2stream (ncol, nlay, ngpt, top_at_1, tau, ssa, g, mu0, sfc_alb_dir, sfc_alb_dif, inc_flux_dir, flux_up, flux_dn, flux_dir, has_dif_bc, inc_flux_dif, do_broadband, broadband_up, broadband_dn, broadband_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dir real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dif real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dir logical(kind=wl), intent(in) :: has_dif_bc real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dif logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dir public pure subroutine sw_solver_noscat (ncol, nlay, ngpt, top_at_1, tau, mu0, inc_flux_dir, flux_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dir","tags":"","loc":"module/mo_rte_solver_kernels~2.html"},{"title":"mo_gas_optics_kernels – rte-rrtmgp","text":"Uses mo_rte_util_array mo_rte_kind module~~mo_gas_optics_kernels~~UsesGraph module~mo_gas_optics_kernels mo_gas_optics_kernels mo_rte_util_array mo_rte_util_array module~mo_gas_optics_kernels->mo_rte_util_array mo_rte_kind mo_rte_kind module~mo_gas_optics_kernels->mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions interpolate1D interpolate2D interpolate3D Subroutines compute_Planck_source compute_tau_absorption compute_tau_rayleigh gas_optical_depths_major gas_optical_depths_minor interpolation minmaxloc Functions public function interpolate1D (val, offset, delta, table) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: val real(kind=wp), intent(in) :: offset real(kind=wp), intent(in) :: delta real(kind=wp), intent(in), dimension(:) :: table Return Value real(kind=wp) public function interpolate2D (fminor, k, igpt, jeta, jtemp) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: fminor real(kind=wp), intent(in), dimension(:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp Return Value real(kind=wp) public function interpolate3D (scaling, fmajor, k, igpt, jeta, jtemp, jpress) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: scaling real(kind=wp), intent(in), dimension(2,2,2) :: fmajor real(kind=wp), intent(in), dimension(:,:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp integer, intent(in) :: jpress Return Value real(kind=wp) Subroutines public subroutine compute_Planck_source (ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, nPlanckTemp, tlay, tlev, tsfc, sfc_lay, fmajor, jeta, tropo, jtemp, jpress, gpoint_bands, band_lims_gpt, pfracin, temp_ref_min, totplnk_delta, totplnk, gpoint_flavor, sfc_src, lay_src, lev_src_inc, lev_src_dec, sfc_source_Jac) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nPlanckTemp real(kind=wp), intent(in), dimension(ncol,nlay  ) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay+1) :: tlev real(kind=wp), intent(in), dimension(ncol       ) :: tsfc integer, intent(in) :: sfc_lay real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(            ncol,nlay) :: tropo integer, intent(in), dimension(            ncol,nlay) :: jtemp integer, intent(in), dimension(            ncol,nlay) :: jpress integer, intent(in), dimension(ngpt) :: gpoint_bands integer, intent(in), dimension(2, nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: pfracin real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: totplnk_delta real(kind=wp), intent(in), dimension(nPlanckTemp,nbnd) :: totplnk integer, intent(in), dimension(2,ngpt) :: gpoint_flavor real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lay_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_inc real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_dec real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_source_Jac public subroutine compute_tau_absorption (ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, nminorlower, nminorklower, nminorupper, nminorkupper, idx_h2o, gpoint_flavor, band_lims_gpt, kmajor, kminor_lower, kminor_upper, minor_limits_gpt_lower, minor_limits_gpt_upper, minor_scales_with_density_lower, minor_scales_with_density_upper, scale_by_complement_lower, scale_by_complement_upper, idx_minor_lower, idx_minor_upper, idx_minor_scaling_lower, idx_minor_scaling_upper, kminor_start_lower, kminor_start_upper, tropo, col_mix, fmajor, fminor, play, tlay, col_gas, jeta, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nminorlower integer, intent(in) :: nminorklower integer, intent(in) :: nminorupper integer, intent(in) :: nminorkupper integer, intent(in) :: idx_h2o integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(ntemp,neta,nminorklower) :: kminor_lower real(kind=wp), intent(in), dimension(ntemp,neta,nminorkupper) :: kminor_upper integer, intent(in), dimension(2,nminorlower) :: minor_limits_gpt_lower integer, intent(in), dimension(2,nminorupper) :: minor_limits_gpt_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: minor_scales_with_density_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: minor_scales_with_density_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: scale_by_complement_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: scale_by_complement_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_scaling_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_scaling_upper integer, intent(in), dimension(  nminorlower) :: kminor_start_lower integer, intent(in), dimension(  nminorupper) :: kminor_start_upper logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav       ) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav       ) :: fmajor real(kind=wp), intent(in), dimension(2,2,  ncol,nlay,nflav       ) :: fminor real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: play real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: tlay real(kind=wp), intent(in), dimension(            ncol,nlay,0:ngas) :: col_gas integer, intent(in), dimension(2,    ncol,nlay,nflav       ) :: jeta integer, intent(in), dimension(            ncol,nlay       ) :: jtemp integer, intent(in), dimension(            ncol,nlay       ) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau public subroutine compute_tau_rayleigh (ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, krayl, idx_h2o, col_dry, col_gas, fminor, jeta, tropo, jtemp, tau_rayleigh) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,ngpt,2) :: krayl integer, intent(in) :: idx_h2o real(kind=wp), intent(in), dimension(ncol,nlay) :: col_dry real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: tau_rayleigh public subroutine gas_optical_depths_major (ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, kmajor, col_mix, fmajor, jeta, tropo, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp integer, intent(in), dimension(ncol,nlay) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau public subroutine gas_optical_depths_minor (ncol, nlay, ngpt, ngas, nflav, ntemp, neta, nminor, nminork, idx_h2o, idx_tropo, gpt_flv, kminor, minor_limits_gpt, minor_scales_with_density, scale_by_complement, idx_minor, idx_minor_scaling, kminor_start, play, tlay, col_gas, fminor, jeta, layer_limits, jtemp, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: ntemp integer, intent(in) :: neta integer, intent(in) :: nminor integer, intent(in) :: nminork integer, intent(in) :: idx_h2o integer, intent(in) :: idx_tropo integer, intent(in), dimension(2, ngpt) :: gpt_flv real(kind=wp), intent(in), dimension(ntemp,neta,nminork) :: kminor integer, intent(in), dimension(2,nminor) :: minor_limits_gpt logical(kind=wl), intent(in), dimension(  nminor) :: minor_scales_with_density logical(kind=wl), intent(in), dimension(  nminor) :: scale_by_complement integer, intent(in), dimension(  nminor) :: idx_minor integer, intent(in), dimension(  nminor) :: idx_minor_scaling integer, intent(in), dimension(  nminor) :: kminor_start real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta integer, intent(in), dimension(ncol, 2) :: layer_limits integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau public subroutine interpolation (ncol, nlay, ngas, nflav, neta, npres, ntemp, flavor, press_ref_log, temp_ref, press_ref_log_delta, temp_ref_min, temp_ref_delta, press_ref_trop_log, vmr_ref, play, tlay, col_gas, jtemp, fmajor, fminor, col_mix, tropo, jeta, jpress) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,nflav) :: flavor real(kind=wp), intent(in), dimension(npres) :: press_ref_log real(kind=wp), intent(in), dimension(ntemp) :: temp_ref real(kind=wp), intent(in) :: press_ref_log_delta real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: temp_ref_delta real(kind=wp), intent(in) :: press_ref_trop_log real(kind=wp), intent(in), dimension(2,0:ngas,ntemp) :: vmr_ref real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas integer, intent(out), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(2,2,2,ncol,nlay,nflav) :: fmajor real(kind=wp), intent(out), dimension(2,2,  ncol,nlay,nflav) :: fminor real(kind=wp), intent(out), dimension(2,    ncol,nlay,nflav) :: col_mix logical(kind=wl), intent(out), dimension(ncol,nlay) :: tropo integer, intent(out), dimension(2,    ncol,nlay,nflav) :: jeta integer, intent(out), dimension(ncol,nlay) :: jpress public subroutine minmaxloc (i, mask, a, minl, maxl) Arguments Type Intent Optional Attributes Name integer :: i logical(kind=wl) :: mask (:,:) real(kind=wp) :: a (:,:) integer :: minl integer :: maxl","tags":"","loc":"module/mo_gas_optics_kernels.html"},{"title":"mo_optical_props_kernels – rte-rrtmgp","text":"Uses iso_c_binding mo_rte_kind module~~mo_optical_props_kernels~~UsesGraph module~mo_optical_props_kernels mo_optical_props_kernels mo_rte_kind mo_rte_kind module~mo_optical_props_kernels->mo_rte_kind iso_c_binding iso_c_binding module~mo_optical_props_kernels->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces delta_scale_2str_kernel extract_subset Subroutines delta_scale_2str_f_k delta_scale_2str_k extract_subset_absorption_tau extract_subset_dim1_3d extract_subset_dim2_4d inc_1scalar_by_1scalar_bybnd inc_1scalar_by_2stream_bybnd inc_1scalar_by_nstream_bybnd inc_2stream_by_1scalar_bybnd inc_2stream_by_2stream_bybnd inc_2stream_by_nstream_bybnd inc_nstream_by_1scalar_bybnd inc_nstream_by_2stream_bybnd inc_nstream_by_nstream_bybnd increment_1scalar_by_1scalar increment_1scalar_by_2stream increment_1scalar_by_nstream increment_2stream_by_1scalar increment_2stream_by_2stream increment_2stream_by_nstream increment_nstream_by_1scalar increment_nstream_by_2stream increment_nstream_by_nstream Interfaces public interface delta_scale_2str_kernel public subroutine delta_scale_2str_f_k (ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f public subroutine delta_scale_2str_k (ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g public interface extract_subset public subroutine extract_subset_dim1_3d (ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out public subroutine extract_subset_dim2_4d (nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out public subroutine extract_subset_absorption_tau (ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out Subroutines public subroutine delta_scale_2str_f_k (ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f public subroutine delta_scale_2str_k (ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g public subroutine extract_subset_absorption_tau (ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out public subroutine extract_subset_dim1_3d (ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out public subroutine extract_subset_dim2_4d (nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out public subroutine inc_1scalar_by_1scalar_bybnd (ncol, nlay, ngpt, tau1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_1scalar_by_2stream_bybnd (ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_1scalar_by_nstream_bybnd (ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_2stream_by_1scalar_bybnd (ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_2stream_by_2stream_bybnd (ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_2stream_by_nstream_bybnd (ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_nstream_by_1scalar_bybnd (ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_nstream_by_2stream_bybnd (ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_nstream_by_nstream_bybnd (ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine increment_1scalar_by_1scalar (ncol, nlay, ngpt, tau1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 public subroutine increment_1scalar_by_2stream (ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 public subroutine increment_1scalar_by_nstream (ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 public subroutine increment_2stream_by_1scalar (ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 public subroutine increment_2stream_by_2stream (ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 public subroutine increment_2stream_by_nstream (ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2 public subroutine increment_nstream_by_1scalar (ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 public subroutine increment_nstream_by_2stream (ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 public subroutine increment_nstream_by_nstream (ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2","tags":"","loc":"module/mo_optical_props_kernels.html"},{"title":"mo_rte_solver_kernels – rte-rrtmgp","text":"Uses iso_c_binding mo_rte_util_array mo_rte_kind module~~mo_rte_solver_kernels~~UsesGraph module~mo_rte_solver_kernels mo_rte_solver_kernels mo_rte_util_array mo_rte_util_array module~mo_rte_solver_kernels->mo_rte_util_array mo_rte_kind mo_rte_kind module~mo_rte_solver_kernels->mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_solver_kernels->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines lw_solver_2stream lw_solver_noscat lw_solver_noscat_GaussQuad sw_solver_2stream sw_solver_noscat Subroutines public subroutine lw_solver_2stream (ncol, nlay, ngpt, top_at_1, tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dn public subroutine lw_solver_noscat (ncol, nlay, ngpt, top_at_1, D, weight, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, incident_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: D real(kind=wp), intent(in) :: weight real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: incident_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g public subroutine lw_solver_noscat_GaussQuad (ncol, nlay, ngpt, top_at_1, nmus, Ds, weights, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 integer, intent(in) :: nmus real(kind=wp), intent(in), dimension (ncol,      ngpt, nmus) :: Ds real(kind=wp), intent(in), dimension(nmus) :: weights real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(inout), dimension(ncol,nlay+1     ), target :: broadband_up real(kind=wp), intent(inout), dimension(ncol,nlay+1     ), target :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g public subroutine sw_solver_2stream (ncol, nlay, ngpt, top_at_1, tau, ssa, g, mu0, sfc_alb_dir, sfc_alb_dif, inc_flux_dir, flux_up, flux_dn, flux_dir, has_dif_bc, inc_flux_dif, do_broadband, broadband_up, broadband_dn, broadband_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dir real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dif real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dir logical(kind=wl), intent(in) :: has_dif_bc real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dif logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dir public subroutine sw_solver_noscat (ncol, nlay, ngpt, top_at_1, tau, mu0, inc_flux_dir, flux_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dir","tags":"","loc":"module/mo_rte_solver_kernels.html"},{"title":"Additional Documentation – rte-rrtmgp","text":"This and subsequent pages contain documentation to help new users of RTE-RRTMGP get started and understand how to use this documentation.\nIt contains a Tutorial , and a more [organized_listing] of the functionality of the framework. Take me back to the User Documentation .","tags":"","loc":"page//index.html"},{"title":"Organized Listing – rte-rrtmgp","text":"Describing and providing links to specific items Describing and providing links to specific items The most involved class structure is in mo_optical_props.F90 . Here we have an  base class ( ty_optical_props ) that defines ~20 type-bound procedures, an abstract sub-class ( ty_optical_props_arry ) that defines three more deferred interfaces, and three sub-classes of ty_optical_props_arry ( ty_optical_props_1scl , ty_optical_props_2str , ty_optical_props_nstr that add new procedures (e.g. init_and_alloc_2str )","tags":"","loc":"page/./Organized_Listing.html"},{"title":"Tutorial – rte-rrtmgp","text":"Prerequisites Getting Started With rte-rrtmgp More Documentation Prerequisites This tutorial assumes that you have working knowledge of, and are comfortable using the following tools: Getting Started With rte-rrtmgp If this is your first encounter with rte-rrtmgp,\nthe following resources might be useful.... With those installed and configured, you should be able to open a terminal and issue the following commands. *Command line example git clone https://github.com/earth-system-radiation/rte-rrtmgp.git\ncd rte-rrtmgp More Documentation You should also read through the organized listing of capabilities to get a more comprehensive view of the available functionality. The organized listing contains a more comprehensive view of the available capabilities an functionality of the code.","tags":"","loc":"page/./Tutorial.html"}]}