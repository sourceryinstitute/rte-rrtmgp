var tipuesearch = {"pages":[{"title":" rte-rrtmgp ","text":"rte-rrtmgp Welcome to the rte-rrtmgp documentation. How to Read This Documentation Start with the README and the Tutorial .\nAdditionally, there is a page that provides a higher level organizational overview that you can find here . The listings below are not exhaustive.\nTo see the full listings use the links at the top of the page.\nAlso, if you know what you're looking for, there is a search bar in the top right.","tags":"home","loc":"index.html"},{"title":"mo_rte_config.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rte_config.f90~~EfferentGraph sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rte_config.f90~~AfferentGraph sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_cloud_optics.f90 mo_cloud_optics.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_heating_rates.f90 mo_heating_rates.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_cloud_sampling.f90 mo_cloud_sampling.F90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_config Source Code mo_rte_config.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2020,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Control over input sanitization in Fortan front-end !   Module variables can be changed only by calling one of the included subroutine ! ! ------------------------------------------------------------------------------------------------- module mo_rte_config use mo_rte_kind , only : wl implicit none private logical ( wl ), protected , public :: check_extents = . true . logical ( wl ), protected , public :: check_values = . true . interface rte_config_checks module procedure rte_config_checks_each , rte_config_checks_all end interface public :: rte_config_checks contains ! -------------------------------------------------------------- subroutine rte_config_checks_each ( extents , values ) logical ( wl ), intent ( in ) :: extents , values check_extents = extents check_values = values end subroutine rte_config_checks_each ! -------------------------------------------------------------- subroutine rte_config_checks_all ( do_checks ) logical ( wl ), intent ( in ) :: do_checks check_extents = do_checks check_values = do_checks end subroutine rte_config_checks_all ! -------------------------------------------------------------- end module mo_rte_config","tags":"","loc":"sourcefile/mo_rte_config.f90.html"},{"title":"mo_rte_kind.F90 – rte-rrtmgp","text":"Files dependent on this one sourcefile~~mo_rte_kind.f90~~AfferentGraph sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_broadband_kernels.f90 mo_fluxes_broadband_kernels.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_fluxes_broadband_kernels.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_gas_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_solver_kernels.f90 mo_rte_solver_kernels.F90 sourcefile~mo_rte_solver_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_solver_kernels.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rrtmgp_util_reorder_kernels.f90 mo_rrtmgp_util_reorder_kernels.F90 sourcefile~mo_rrtmgp_util_reorder_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_cloud_optics.f90 mo_cloud_optics.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_optical_props_kernels.f90~2 mo_optical_props_kernels.F90 sourcefile~mo_optical_props_kernels.f90~2->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics_kernels.f90 mo_gas_optics_kernels.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics_kernels.f90 sourcefile~mo_rrtmgp_util_reorder.f90 mo_rrtmgp_util_reorder.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_util_reorder.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rrtmgp_constants.f90 mo_rrtmgp_constants.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_constants.f90 sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics_kernels.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes_broadband_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rrtmgp_util_reorder.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rrtmgp_util_reorder.f90->sourcefile~mo_rrtmgp_util_reorder_kernels.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_solver_kernels.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_heating_rates.f90 mo_heating_rates.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rrtmgp_constants.f90 sourcefile~mo_gas_optics_kernels.f90~2 mo_gas_optics_kernels.F90 sourcefile~mo_gas_optics_kernels.f90~2->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics_kernels.f90~2->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rrtmgp_constants.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_solar_variability.f90 mo_solar_variability.F90 sourcefile~mo_solar_variability.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_solver_kernels.f90~2 mo_rte_solver_kernels.F90 sourcefile~mo_rte_solver_kernels.f90~2->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_solver_kernels.f90~2->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_solver_kernels.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_cloud_sampling.f90 mo_cloud_sampling.F90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_kind Source Code mo_rte_kind.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! This module provides the Fortran KIND parameters for REAL and INTEGER variables. !   By default we use constant from the ISO C binding and use double precision for working. !   If the host model in which RRTGMP is embedded has defined these constants elsewhere !   the model definitions can be used instead by renaming. For example, ! use  mo_model_kind, only wp => dp, ... !   where the syntax is local_name => original_name !   and all the local names need to be defined module mo_rte_kind use , intrinsic :: iso_c_binding , only : c_float , c_double , c_long , c_int , c_bool implicit none public integer , parameter :: dp = c_double , sp = c_float , i8 = c_long , i4 = c_int ! ! Floating point working precision ! integer , parameter :: wp = dp ! ! Logical - for use with kernels ! ! Note that c_boolians don't work with PGI compiler currently ! #ifdef USE_CBOOL integer , parameter :: wl = c_bool #else integer , parameter :: wl = kind (. true .) #endif end module mo_rte_kind","tags":"","loc":"sourcefile/mo_rte_kind.f90.html"},{"title":"mo_fluxes.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_fluxes.f90~~EfferentGraph sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_broadband_kernels.f90 mo_fluxes_broadband_kernels.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_fluxes_broadband_kernels.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_broadband_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_fluxes.f90~~AfferentGraph sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_fluxes Source Code mo_fluxes.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Compute output quantities from RTE based on spectrally-resolved flux profiles !    This module contains an abstract class and a broadband implmentation that sums over all spectral points !    The abstract base class defines the routines that extenstions must implement: reduce() and are_desired() !    The intent is for users to extend it as required, using mo_flxues_broadband as an example ! ! ------------------------------------------------------------------------------------------------- module mo_fluxes use mo_rte_kind , only : wp use mo_rte_config , only : check_extents use mo_rte_util_array , only : extents_are use mo_optical_props , only : ty_optical_props use mo_fluxes_broadband_kernels , & only : sum_broadband , net_broadband implicit none private ! ----------------------------------------------------------------------------------------------- ! ! Abstract base class !   reduce() function accepts spectral flux profiles, computes desired outputs !   are_desired() returns a logical - does it makes sense to invoke reduce()? ! ! ----------------------------------------------------------------------------------------------- type , abstract , public :: ty_fluxes contains procedure ( reduce_abstract ), deferred , public :: reduce procedure ( are_desired_abstract ), deferred , public :: are_desired end type ty_fluxes ! ----------------------------------------------------------------------------------------------- ! ! Class implementing broadband integration for the complete flux profile !   Data components are pointers so results can be written directly into memory ! ! ----------------------------------------------------------------------------------------------- type , extends ( ty_fluxes ), public :: ty_fluxes_broadband real ( wp ), dimension (:,:), pointer :: flux_up => NULL (), flux_dn => NULL () real ( wp ), dimension (:,:), pointer :: flux_net => NULL () ! Net (down - up) real ( wp ), dimension (:,:), pointer :: flux_dn_dir => NULL () ! Direct flux down contains procedure , public :: reduce => reduce_broadband procedure , public :: are_desired => are_desired_broadband end type ty_fluxes_broadband ! ----------------------------------------------------------------------------------------------- ! ----------------------------------------------------------------------------------------------- ! ! Abstract interfaces: any implemntation has to provide routines with these interfaces ! abstract interface ! ------------------- ! ! This routine takes the fully resolved calculation (detailed in spectral and vertical dimensions) and !   computes desired outputs. Output values will normally be data components of the derived type. ! function reduce_abstract ( this , gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) result ( error_msg ) import ty_fluxes , ty_optical_props import wp class ( ty_fluxes ), intent ( inout ) :: this real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_up ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_dn ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) class ( ty_optical_props ), intent ( in ) :: spectral_disc !< derived type with spectral information logical , intent ( in ) :: top_at_1 real ( kind = wp ), dimension (:,:,:), optional , & intent ( in ) :: gpt_flux_dn_dir ! Direct flux down character ( len = 128 ) :: error_msg end function reduce_abstract ! ------------------- ! ! This routine determines if the reduction should proceed - it's useful in ensuring !   that space has been allocated for the results, for example. ! function are_desired_abstract ( this ) import ty_fluxes class ( ty_fluxes ), intent ( in ) :: this logical :: are_desired_abstract end function are_desired_abstract ! ---------------------- end interface contains ! -------------------------------------------------------------------------------------- ! ! Broadband fluxes -- simply sum over the spectral dimension and report the whole profile ! ! -------------------------------------------------------------------------------------- function reduce_broadband ( this , gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) result ( error_msg ) class ( ty_fluxes_broadband ), intent ( inout ) :: this real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_up ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_dn ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) class ( ty_optical_props ), intent ( in ) :: spectral_disc !< derived type with spectral information logical , intent ( in ) :: top_at_1 real ( kind = wp ), dimension (:,:,:), optional , & intent ( in ) :: gpt_flux_dn_dir ! Direct flux down character ( len = 128 ) :: error_msg ! ------ integer :: ncol , nlev , ngpt ! ------ ncol = size ( gpt_flux_up , DIM = 1 ) nlev = size ( gpt_flux_up , DIM = 2 ) ngpt = size ( gpt_flux_up , DIM = 3 ) error_msg = \"\" if ( check_extents ) then ! ! Check array sizes !  Input arrays ! if (. not . extents_are ( gpt_flux_dn , ncol , nlev , ngpt )) & error_msg = \"reduce: gpt_flux_dn array incorrectly sized\" if ( present ( gpt_flux_dn_dir )) then if (. not . extents_are ( gpt_flux_dn_dir , ncol , nlev , ngpt )) & error_msg = \"reduce: gpt_flux_dn_dir array incorrectly sized\" end if ! ! Output arrays ! if ( associated ( this % flux_up )) then if (. not . extents_are ( this % flux_up , ncol , nlev )) & error_msg = 'reduce: flux_up array incorrectly sized' end if if ( associated ( this % flux_dn )) then if (. not . extents_are ( this % flux_dn , ncol , nlev )) & error_msg = 'reduce: flux_dn array incorrectly sized' end if if ( associated ( this % flux_net )) then if (. not . extents_are ( this % flux_net , ncol , nlev )) & error_msg = 'reduce: flux_net array incorrectly sized' end if if ( associated ( this % flux_dn_dir )) then if (. not . extents_are ( this % flux_dn_dir , ncol , nlev )) & error_msg = 'reduce: flux_dn_dir array incorrectly sized' end if if ( error_msg /= \"\" ) return end if ! ! Self-consistency -- shouldn't be asking for direct beam flux if it isn't supplied ! if ( associated ( this % flux_dn_dir ) . and . . not . present ( gpt_flux_dn_dir )) then error_msg = \"reduce: requesting direct downward flux but this hasn't been supplied\" return end if ! ! Broadband fluxes - call the kernels ! if ( associated ( this % flux_up )) & call sum_broadband ( ncol , nlev , ngpt , gpt_flux_up , this % flux_up ) if ( associated ( this % flux_dn )) & call sum_broadband ( ncol , nlev , ngpt , gpt_flux_dn , this % flux_dn ) if ( associated ( this % flux_dn_dir )) & call sum_broadband ( ncol , nlev , ngpt , gpt_flux_dn_dir , this % flux_dn_dir ) if ( associated ( this % flux_net )) then ! !  Reuse down and up results if possible ! if ( associated ( this % flux_dn ) . and . associated ( this % flux_up )) then call net_broadband ( ncol , nlev , this % flux_dn , this % flux_up , this % flux_net ) else call net_broadband ( ncol , nlev , ngpt , gpt_flux_dn , gpt_flux_up , this % flux_net ) end if end if end function reduce_broadband ! -------------------------------------------------------------------------------------- ! ! Are any fluxes desired from this set of g-point fluxes? We can tell because memory will !   be allocated for output ! ! -------------------------------------------------------------------------------------- function are_desired_broadband ( this ) class ( ty_fluxes_broadband ), intent ( in ) :: this logical :: are_desired_broadband are_desired_broadband = any ( [ associated ( this % flux_up ), & associated ( this % flux_dn ), & associated ( this % flux_dn_dir ), & associated ( this % flux_net )] ) end function are_desired_broadband ! -------------------------------------------------------------------------------------- end module mo_fluxes","tags":"","loc":"sourcefile/mo_fluxes.f90.html"},{"title":"mo_rte_lw.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rte_lw.f90~~EfferentGraph sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_solver_kernels.f90 mo_rte_solver_kernels.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_solver_kernels.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_broadband_kernels.f90 mo_fluxes_broadband_kernels.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_fluxes_broadband_kernels.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_solver_kernels.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_solver_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_broadband_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rte_lw.f90~~AfferentGraph sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_lw Source Code mo_rte_lw.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2021,  Atmospheric and Environmental Research, ! Regents of the University of Colorado, Trustees of Columbia University.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! !  Contains a single routine to compute direct and diffuse fluxes of solar radiation given !    atmospheric optical properties, spectrally-resolved !    information about vertical ordering !    internal Planck source functions, defined per g-point on the same spectral grid at the atmosphere !    boundary conditions: surface emissivity defined per band !    optionally, a boundary condition for incident diffuse radiation !    optionally, an integer number of angles at which to do Gaussian quadrature if scattering is neglected ! ! If optical properties are supplied via class ty_optical_props_1scl (absorption optical thickenss only) !    then an emission/absorption solver is called !    If optical properties are supplied via class ty_optical_props_2str fluxes are computed via !    two-stream calculations and adding. ! ! It is the user's responsibility to ensure that emissivity is on the same !   spectral grid as the optical properties. ! ! Final output is via user-extensible ty_fluxes which must reduce the detailed spectral fluxes to !   whatever summary the user needs. ! ! The routine does error checking and choses which lower-level kernel to invoke based on !   what kinds of optical properties are supplied ! ! ------------------------------------------------------------------------------------------------- module mo_rte_lw use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_extents , check_values use mo_rte_util_array , only : any_vals_less_than , any_vals_outside , extents_are , zero_array use mo_optical_props , only : ty_optical_props , & ty_optical_props_arry , ty_optical_props_1scl , ty_optical_props_2str , ty_optical_props_nstr use mo_source_functions , & only : ty_source_func_lw use mo_fluxes , only : ty_fluxes , ty_fluxes_broadband use mo_rte_solver_kernels , & only : lw_solver_noscat , lw_solver_noscat_GaussQuad , lw_solver_2stream implicit none private public :: rte_lw contains ! -------------------------------------------------- ! ! Interface using only optical properties and source functions as inputs; fluxes as outputs. ! ! -------------------------------------------------- function rte_lw ( optical_props , top_at_1 , & sources , sfc_emis , & fluxes , & inc_flux , n_gauss_angles , use_2stream , & lw_Ds , flux_up_Jac ) result ( error_msg ) class ( ty_optical_props_arry ), intent ( in ) :: optical_props ! Set of optical properties as one or more arrays logical , intent ( in ) :: top_at_1 ! Is the top of the domain at index 1? ! (if not, ordering is bottom-to-top) type ( ty_source_func_lw ), intent ( in ) :: sources ! Derived type with Planck source functions real ( wp ), dimension (:,:), intent ( in ) :: sfc_emis ! emissivity at surface [] (nband, ncol) class ( ty_fluxes ), intent ( inout ) :: fluxes ! Dervied type for computing spectral integrals from g-point fluxes. ! Default computes broadband fluxes at all levels ! if output arrays are defined. Can be extended per user desires. real ( wp ), dimension (:,:), & target , optional , intent ( in ) :: inc_flux ! incident flux at domain top [W/m2] (ncol, ngpts) integer , optional , intent ( in ) :: n_gauss_angles ! Number of angles used in Gaussian quadrature (max 3) ! (no-scattering solution) logical , optional , intent ( in ) :: use_2stream ! When 2-stream parameters (tau/ssa/g) are provided, use 2-stream methods ! Default is to use re-scaled longwave transport real ( wp ), dimension (:,:), & optional , intent ( in ) :: lw_Ds ! User-specifed 1/cos of transport angle per col, g-point real ( wp ), dimension (:,:), target , & optional , intent ( inout ) :: flux_up_Jac ! surface temperature flux  Jacobian [W/m2/K] (ncol, nlay+1) character ( len = 128 ) :: error_msg ! If empty, calculation was successful ! -------------------------------- ! ! Local variables ! integer :: ncol , nlay , ngpt , nband integer :: icol , ilev , igpt , imu integer :: n_quad_angs logical ( wl ) :: using_2stream , do_Jacobians , do_broadband real ( wp ), dimension (:,:), allocatable :: sfc_emis_gpt real ( wp ), dimension (:,:,:), allocatable :: secants real ( wp ), dimension (:,:), pointer :: jacobian real ( wp ), dimension ( optical_props % get_ncol (), & optical_props % get_nlay () + 1 ), target & :: decoy2D ! Used for optional outputs - needs to be full size. ! Memory needs to be allocated for the full g-point fluxes even if they aren't !    used later because a) the GPU kernels use this memory to work in parallel and !    b) the fluxes are intent(out) in the solvers ! Shortwave solver takes a different approach since three fields are needed real ( wp ), dimension ( optical_props % get_ncol (), & optical_props % get_nlay () + 1 , & optical_props % get_ngpt ()) & :: gpt_flux_up , gpt_flux_dn real ( wp ), dimension (:,:), pointer :: flux_dn_loc , flux_up_loc real ( wp ), dimension (:,:), pointer :: inc_flux_diffuse ! -------------------------------------------------- ! ! Weights and angle secants for first order (k=1) Gaussian quadrature. !   Values from Table 2, Clough et al, 1992, doi:10.1029/92JD01419 !   after Abramowitz & Stegun 1972, page 921 ! integer , parameter :: max_gauss_pts = 4 real ( wp ), parameter , & dimension ( max_gauss_pts , max_gauss_pts ) :: & gauss_Ds = RESHAPE ([ 1.66_wp , 0._wp , 0._wp , 0._wp , & ! Diffusivity angle, not Gaussian angle 1.18350343_wp , 2.81649655_wp , 0._wp , 0._wp , & 1.09719858_wp , 1.69338507_wp , 4.70941630_wp , 0._wp , & 1.06056257_wp , 1.38282560_wp , 2.40148179_wp , 7.15513024_wp ], & [ max_gauss_pts , max_gauss_pts ]), & gauss_wts = RESHAPE ([ 0.5_wp , 0._wp , 0._wp , 0._wp , & 0.3180413817_wp , 0.1819586183_wp , 0._wp , 0._wp , & 0.2009319137_wp , 0.2292411064_wp , 0.0698269799_wp , 0._wp , & 0.1355069134_wp , 0.2034645680_wp , 0.1298475476_wp , 0.0311809710_wp ], & [ max_gauss_pts , max_gauss_pts ]) ! ------------------------------------------------------------------------------------ ncol = optical_props % get_ncol () nlay = optical_props % get_nlay () ngpt = optical_props % get_ngpt () nband = optical_props % get_nband () do_Jacobians = present ( flux_up_Jac ) error_msg = \"\" ! ------------------------------------------------------------------------------------ ! ! Error checking -- input consistency of sizes and validity of values if (. not . fluxes % are_desired ()) & error_msg = \"rte_lw: no space allocated for fluxes\" if ( do_Jacobians . and . check_extents ) then if ( . not . extents_are ( flux_up_Jac , ncol , nlay + 1 )) & error_msg = \"rte_lw: flux Jacobian inconsistently sized\" endif if ( check_extents ) then ! ! Source functions ! if ( any ([ sources % get_ncol (), sources % get_nlay (), sources % get_ngpt ()] /= [ ncol , nlay , ngpt ])) & error_msg = \"rte_lw: sources and optical properties inconsistently sized\" ! ! Surface emissivity ! if (. not . extents_are ( sfc_emis , nband , ncol )) & error_msg = \"rte_lw: sfc_emis inconsistently sized\" ! ! Incident flux, if present ! if ( present ( inc_flux )) then if (. not . extents_are ( inc_flux , ncol , ngpt )) & error_msg = \"rte_lw: inc_flux inconsistently sized\" end if if ( present ( lw_Ds )) then if (. not . extents_are ( lw_Ds , ncol , ngpt )) & error_msg = \"rte_lw: lw_Ds inconsistently sized\" end if end if if ( check_values ) then if ( any_vals_outside ( sfc_emis , 0._wp , 1._wp )) & error_msg = \"rte_lw: sfc_emis has values < 0 or > 1\" if ( present ( inc_flux )) then if ( any_vals_less_than ( inc_flux , 0._wp )) & error_msg = \"rte_lw: inc_flux has values < 0\" end if if ( present ( lw_Ds )) then if ( any_vals_less_than ( lw_Ds , 1._wp )) & error_msg = \"rte_lw: one or more values of lw_Ds < 1.\" end if if ( present ( n_gauss_angles )) then if ( n_gauss_angles > max_gauss_pts ) & error_msg = \"rte_lw: asking for too many quadrature points for no-scattering calculation\" if ( n_gauss_angles < 1 ) & error_msg = \"rte_lw: have to ask for at least one quadrature point for no-scattering calculation\" end if end if if ( len_trim ( error_msg ) > 0 ) return ! ! Number of quadrature points for no-scattering calculation ! n_quad_angs = 1 if ( present ( n_gauss_angles )) n_quad_angs = n_gauss_angles ! ! Optionally - use 2-stream methods when low-order scattering properties are provided? ! using_2stream = . false . if ( present ( use_2stream )) using_2stream = use_2stream ! ! Checking that optional arguments are consistent with one another and with optical properties ! select type ( optical_props ) class is ( ty_optical_props_1scl ) if ( using_2stream ) & error_msg = \"rte_lw: can't use two-stream methods with only absorption optical depth\" if ( present ( lw_Ds ) . and . n_quad_angs /= 1 ) & error_msg = \"rte_lw: providing lw_Ds incompatible with specifying n_gauss_angles\" class is ( ty_optical_props_2str ) if ( present ( lw_Ds )) & error_msg = \"rte_lw: lw_Ds not valid when providing scattering optical properties\" if ( using_2stream . and . n_quad_angs /= 1 ) & error_msg = \"rte_lw: using_2stream=true incompatible with specifying n_gauss_angles\" if ( using_2stream . and . do_Jacobians ) & error_msg = \"rte_lw: can't provide Jacobian of fluxes w.r.t surface temperature with 2-stream\" class default error_msg = \"rte_lw: lw_solver(...ty_optical_props_nstr...) not yet implemented\" end select if ( len_trim ( error_msg ) > 0 ) then if ( len_trim ( optical_props % get_name ()) > 0 ) & error_msg = trim ( optical_props % get_name ()) // ': ' // trim ( error_msg ) return end if ! ------------------------------------------------------------------------------------ !  Boundary conditions !    Lower boundary condition -- expand surface emissivity by band to gpoints ! allocate ( sfc_emis_gpt ( ncol , ngpt )) !   Upper boundary condition -  use values in optional arg or be set to 0 ! if ( present ( inc_flux )) then inc_flux_diffuse => inc_flux !$acc        enter data copyin(   inc_flux_diffuse) !$omp target enter data map(to:   inc_flux_diffuse) else allocate ( inc_flux_diffuse ( ncol , ngpt )) !$acc        enter data create(   inc_flux_diffuse) !$omp target enter data map(alloc:inc_flux_diffuse) call zero_array ( ncol , ngpt , inc_flux_diffuse ) end if ! ------------------------------------------------------------------------------------ if ( do_Jacobians ) then jacobian => flux_up_Jac else jacobian => decoy2D end if select type ( fluxes ) ! ! Broadband fluxes are treated as a special case within the solvers; memory !   for both up and down fluxes needs to be available even if the user doesn't !   want one of them ! type is ( ty_fluxes_broadband ) do_broadband = . true . _ wl ! ! Broadband fluxes class has three possible outputs; allocate memory for local use !   if one or more haven't been requested ! if ( associated ( fluxes % flux_up )) then flux_up_loc => fluxes % flux_up else allocate ( flux_up_loc ( ncol , nlay + 1 )) end if if ( associated ( fluxes % flux_dn )) then flux_dn_loc => fluxes % flux_dn else allocate ( flux_dn_loc ( ncol , nlay + 1 )) end if !$acc        enter data create(   flux_up_loc, flux_dn_loc) !$omp target enter data map(alloc:flux_up_loc, flux_dn_loc) class default ! ! If broadband integrals aren't being computed, allocate working space !   and decoy addresses for spectrally-integrated fields ! do_broadband = . false . _ wl flux_up_loc => decoy2D flux_dn_loc => decoy2D end select ! ! Compute the radiative transfer... ! !$acc        data create(   sfc_emis_gpt, flux_up_loc, flux_dn_loc, gpt_flux_up, gpt_flux_dn) !$omp target data map(alloc:sfc_emis_gpt, flux_up_loc, flux_dn_loc, gpt_flux_up, gpt_flux_dn) call expand_and_transpose ( optical_props , sfc_emis , sfc_emis_gpt ) if ( check_values ) error_msg = optical_props % validate () if ( len_trim ( error_msg ) == 0 ) then ! Can't do an early return within OpenACC/MP data regions select type ( optical_props ) class is ( ty_optical_props_1scl ) ! ! No scattering two-stream calculation ! ! ! Secant of radiation angle - either user-supplied, one per g-point, or !   taken from first-order Gaussian quadrate and applied to all columns a g-points ! allocate ( secants ( ncol , ngpt , n_quad_angs )) !$acc        data create(   secants) !$omp target data map(alloc:secants) if ( present ( lw_Ds )) then !$acc                         parallel loop    collapse(2) copyin(lw_Ds) !$omp target teams distribute parallel do simd collapse(2) ! nmu is 1 do igpt = 1 , ngpt do icol = 1 , ncol secants ( icol , igpt , 1 ) = lw_Ds ( icol , igpt ) end do end do else ! !   Is there an alternative to making ncol x ngpt copies of each value? ! !$acc                         parallel loop    collapse(3) copyin(gauss_Ds) !$omp target teams distribute parallel do simd collapse(3) do imu = 1 , n_quad_angs do igpt = 1 , ngpt do icol = 1 , ncol secants ( icol , igpt , imu ) = gauss_Ds ( imu , n_quad_angs ) end do end do end do end if call lw_solver_noscat_GaussQuad ( ncol , nlay , ngpt , & logical ( top_at_1 , wl ), n_quad_angs , & secants , gauss_wts ( 1 : n_quad_angs , n_quad_angs ), & optical_props % tau , & sources % lay_source , sources % lev_source_inc , & sources % lev_source_dec , & sfc_emis_gpt , sources % sfc_source , & inc_flux_diffuse , & gpt_flux_up , gpt_flux_dn , & do_broadband , flux_up_loc , flux_dn_loc , & logical ( do_Jacobians , wl ), sources % sfc_source_Jac , jacobian , & logical (. false ., wl ), optical_props % tau , optical_props % tau ) ! The last two arguments won't be used since the ! third-to-last is .false. but need valid addresses !$acc        end data !$omp end target data class is ( ty_optical_props_2str ) if ( using_2stream ) then ! ! two-stream calculation with scattering ! call lw_solver_2stream ( ncol , nlay , ngpt , logical ( top_at_1 , wl ), & optical_props % tau , optical_props % ssa , optical_props % g , & sources % lay_source , sources % lev_source_inc , sources % lev_source_dec , & sfc_emis_gpt , sources % sfc_source , & inc_flux_diffuse , & gpt_flux_up , gpt_flux_dn ) else allocate ( secants ( ncol , ngpt , n_quad_angs )) !$acc        data create(   secants) !$omp target data map(alloc:secants) !$acc                         parallel loop    collapse(3) copyin(gauss_Ds) !$omp target teams distribute parallel do simd collapse(3) do imu = 1 , n_quad_angs do igpt = 1 , ngpt do icol = 1 , ncol secants ( icol , igpt , imu ) = gauss_Ds ( imu , n_quad_angs ) end do end do end do ! ! Re-scaled solution to account for scattering ! call lw_solver_noscat_GaussQuad ( ncol , nlay , ngpt , & logical ( top_at_1 , wl ), n_quad_angs , & secants , gauss_wts ( 1 : n_quad_angs , n_quad_angs ), & optical_props % tau , & sources % lay_source , sources % lev_source_inc , & sources % lev_source_dec , & sfc_emis_gpt , sources % sfc_source , & inc_flux_diffuse , & gpt_flux_up , gpt_flux_dn , & do_broadband , flux_up_loc , flux_dn_loc , & logical ( do_Jacobians , wl ), sources % sfc_source_Jac , jacobian , & logical (. true ., wl ), optical_props % ssa , optical_props % g ) !$acc        end data !$omp end target data endif class is ( ty_optical_props_nstr ) ! ! n-stream calculation ! error_msg = 'lw_solver(...ty_optical_props_nstr...) not yet implemented' end select select type ( fluxes ) ! ! Tidy up memory for broadband fluxes on GPUs ! type is ( ty_fluxes_broadband ) if ( associated ( fluxes % flux_net )) then ! ! FIXME: Do we need the create/copyout here? ! !$acc                         parallel loop    collapse(2) copyin(fluxes) copyout( fluxes%flux_net) !$omp target teams distribute parallel do simd collapse(2) map(from:fluxes%flux_net) do ilev = 1 , nlay + 1 do icol = 1 , ncol fluxes % flux_net ( icol , ilev ) = flux_dn_loc ( icol , ilev ) - flux_up_loc ( icol , ilev ) end do end do end if class default ! ! ...or reduce spectral fluxes to desired output quantities ! error_msg = fluxes % reduce ( gpt_flux_up , gpt_flux_dn , optical_props , top_at_1 ) end select end if ! no error message from validation !$acc        end data !$omp end target data if (. not . present ( inc_flux )) then !$acc        exit data delete(     inc_flux_diffuse) !$omp target exit data map(release:inc_flux_diffuse) deallocate ( inc_flux_diffuse ) end if select type ( fluxes ) type is ( ty_fluxes_broadband ) !$acc        exit data copyout( flux_up_loc, flux_dn_loc) !$omp target exit data map(from:flux_up_loc, flux_dn_loc) if (. not . associated ( flux_up_loc , fluxes % flux_up )) deallocate ( flux_up_loc ) if (. not . associated ( flux_dn_loc , fluxes % flux_dn )) deallocate ( flux_dn_loc ) end select end function rte_lw !-------------------------------------------------------------------------------------------------------------------- ! ! Expand from band to g-point dimension, transpose dimensions (nband, ncol) -> (ncol,ngpt) ! subroutine expand_and_transpose ( ops , arr_in , arr_out ) class ( ty_optical_props ), intent ( in ) :: ops real ( wp ), dimension (:,:), intent ( in ) :: arr_in ! (nband, ncol) real ( wp ), dimension (:,:), intent ( out ) :: arr_out ! (ncol, igpt) ! ------------- integer :: ncol , nband , ngpt integer :: icol , iband , igpt integer , dimension ( 2 , ops % get_nband ()) :: limits ncol = size ( arr_in , 2 ) nband = ops % get_nband () ngpt = ops % get_ngpt () limits = ops % get_band_lims_gpoint () !$acc                         parallel loop    collapse(2) copyin(arr_in, limits) !$omp target teams distribute parallel do simd collapse(2) map(to:arr_in, limits) do iband = 1 , nband do icol = 1 , ncol do igpt = limits ( 1 , iband ), limits ( 2 , iband ) arr_out ( icol , igpt ) = arr_in ( iband , icol ) end do end do end do end subroutine expand_and_transpose !-------------------------------------------------------------------------------------------------------------------- end module mo_rte_lw","tags":"","loc":"sourcefile/mo_rte_lw.f90.html"},{"title":"mo_rte_sw.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rte_sw.f90~~EfferentGraph sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_solver_kernels.f90 mo_rte_solver_kernels.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_solver_kernels.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_broadband_kernels.f90 mo_fluxes_broadband_kernels.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_fluxes_broadband_kernels.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_solver_kernels.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_solver_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_broadband_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rte_sw.f90~~AfferentGraph sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_sw Source Code mo_rte_sw.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2021,  Atmospheric and Environmental Research, ! Regents of the University of Colorado, Trustees of Columbia University.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! !  Contains a single routine to compute direct and diffuse fluxes of solar radiation given !    atmospheric optical properties on a spectral grid !    information about vertical ordering !    boundary conditions !      solar zenith angle, spectrally-resolved incident colimated flux, surface albedos for direct and diffuse radiation !    optionally, a boundary condition for incident diffuse radiation ! ! It is the user's responsibility to ensure that boundary conditions (incident fluxes, surface albedos) are on the same !   spectral grid as the optical properties. ! ! Final output is via user-extensible ty_fluxes which must reduce the detailed spectral fluxes to !   whatever summary the user needs. ! ! The routine does error checking and choses which lower-level kernel to invoke based on !   what kinds of optical properties are supplied ! ! ------------------------------------------------------------------------------------------------- module mo_rte_sw use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_extents , check_values use mo_rte_util_array , only : any_vals_less_than , any_vals_outside , extents_are , zero_array use mo_optical_props , only : ty_optical_props , & ty_optical_props_arry , ty_optical_props_1scl , ty_optical_props_2str , ty_optical_props_nstr use mo_fluxes , only : ty_fluxes , ty_fluxes_broadband use mo_rte_solver_kernels , & only : sw_solver_noscat , sw_solver_2stream implicit none private public :: rte_sw contains ! -------------------------------------------------- function rte_sw ( atmos , top_at_1 , & mu0 , inc_flux , & sfc_alb_dir , sfc_alb_dif , & fluxes , inc_flux_dif ) result ( error_msg ) class ( ty_optical_props_arry ), intent ( in ) :: atmos ! Optical properties provided as arrays logical , intent ( in ) :: top_at_1 ! Is the top of the domain at index 1? ! (if not, ordering is bottom-to-top) real ( wp ), dimension (:), intent ( in ) :: mu0 ! cosine of solar zenith angle (ncol) real ( wp ), dimension (:,:), intent ( in ) :: inc_flux , & ! incident flux at top of domain [W/m2] (ncol, ngpt) sfc_alb_dir , & ! surface albedo for direct and sfc_alb_dif ! diffuse radiation (nband, ncol) class ( ty_fluxes ), intent ( inout ) :: fluxes ! Class describing output calculations real ( wp ), dimension (:,:), optional , target , & intent ( in ) :: inc_flux_dif ! incident diffuse flux at top of domain [W/m2] (ncol, ngpt) character ( len = 128 ) :: error_msg ! If empty, calculation was successful ! -------------------------------- ! ! Local variables ! integer :: ncol , nlay , ngpt , nband integer :: icol , ilev logical ( wl ) :: has_dif_bc , do_broadband real ( wp ), dimension (:,:,:), pointer :: gpt_flux_up , gpt_flux_dn , gpt_flux_dir real ( wp ), dimension (:,:), allocatable :: sfc_alb_dir_gpt , sfc_alb_dif_gpt real ( wp ), dimension (:,:), pointer :: flux_dn_loc , flux_up_loc , flux_dir_loc real ( wp ), dimension (:,:), pointer :: inc_flux_diffuse real ( wp ), dimension (:,:,:), allocatable , target :: decoy3D real ( wp ), dimension (:,:), allocatable , target :: decoy2D ! ------------------------------------------------------------------------------------ ncol = atmos % get_ncol () nlay = atmos % get_nlay () ngpt = atmos % get_ngpt () nband = atmos % get_nband () error_msg = \"\" ! ------------------------------------------------------------------------------------ ! ! Error checking -- consistency of sizes and validity of values ! ! -------------------------------- if (. not . fluxes % are_desired ()) & error_msg = \"rte_sw: no space allocated for fluxes\" has_dif_bc = logical ( present ( inc_flux_dif ), wl ) ! ! Sizes of input arrays ! ! Copy variables whose sizes and values are checked to the GPU so the checks can happen there. !   No harm done if checks are not performed  (?) !$acc        data copyin(mu0, inc_flux, sfc_alb_dir, sfc_alb_dif) !$omp target data map(to:mu0, inc_flux, sfc_alb_dir, sfc_alb_dif) !$acc        data copyin(inc_flux_dif) if (has_dif_bc) !$omp target data map(to:inc_flux_dif) if (has_dif_bc) if ( check_extents ) then if (. not . extents_are ( mu0 , ncol )) & error_msg = \"rte_sw: mu0 inconsistently sized\" if (. not . extents_are ( inc_flux , ncol , ngpt )) & error_msg = \"rte_sw: inc_flux inconsistently sized\" if (. not . extents_are ( sfc_alb_dir , nband , ncol )) & error_msg = \"rte_sw: sfc_alb_dir inconsistently sized\" if (. not . extents_are ( sfc_alb_dif , nband , ncol )) & error_msg = \"rte_sw: sfc_alb_dif inconsistently sized\" if ( has_dif_bc ) then if (. not . extents_are ( inc_flux_dif , ncol , ngpt )) & error_msg = \"rte_sw: inc_flux_dif inconsistently sized\" end if end if ! ! Values of input arrays ! if ( check_values ) then if ( any_vals_outside ( mu0 , 0._wp , 1._wp )) & error_msg = \"rte_sw: one or more mu0 <= 0 or > 1\" if ( any_vals_less_than ( inc_flux , 0._wp )) & error_msg = \"rte_sw: one or more inc_flux < 0\" if ( any_vals_outside ( sfc_alb_dir , 0._wp , 1._wp )) & error_msg = \"rte_sw: sfc_alb_dir out of bounds [0,1]\" if ( any_vals_outside ( sfc_alb_dif , 0._wp , 1._wp )) & error_msg = \"rte_sw: sfc_alb_dif out of bounds [0,1]\" if ( has_dif_bc ) then if ( any_vals_less_than ( inc_flux_dif , 0._wp )) & error_msg = \"rte_sw: one or more inc_flux_dif < 0\" end if end if ! ------------------------------------------------------------------------------------ select type ( fluxes ) type is ( ty_fluxes_broadband ) do_broadband = . true . _ wl ! ! Solvers will integrate in place (one g-point at a time on CPUs) !   so won't need big working arrays ! allocate ( decoy3D ( ncol , nlay + 1 , ngpt )) gpt_flux_up => decoy3D gpt_flux_dn => decoy3D gpt_flux_dir => decoy3D ! ! Broadband fluxes class has three possible outputs; allocate memory for local use !   if one or more haven't been requested ! if ( associated ( fluxes % flux_up )) then flux_up_loc => fluxes % flux_up else allocate ( flux_up_loc ( ncol , nlay + 1 )) end if if ( associated ( fluxes % flux_dn )) then flux_dn_loc => fluxes % flux_dn else allocate ( flux_dn_loc ( ncol , nlay + 1 )) end if if ( associated ( fluxes % flux_dn_dir )) then flux_dir_loc => fluxes % flux_dn_dir else allocate ( flux_dir_loc ( ncol , nlay + 1 )) end if !$acc        enter data create(   flux_up_loc, flux_dn_loc, flux_dir_loc) !$omp target enter data map(alloc:flux_up_loc, flux_dn_loc, flux_dir_loc) class default ! ! If broadband integrals aren't being computed, allocate working space !   and decoy addresses for spectrally-integrated fields ! do_broadband = . false . _ wl allocate ( decoy2D ( ncol , nlay + 1 )) flux_up_loc => decoy2D flux_dn_loc => decoy2D flux_dir_loc => decoy2D allocate ( gpt_flux_up ( ncol , nlay + 1 , ngpt ), & gpt_flux_dn ( ncol , nlay + 1 , ngpt ), & gpt_flux_dir ( ncol , nlay + 1 , ngpt )) end select allocate ( sfc_alb_dir_gpt ( ncol , ngpt ), sfc_alb_dif_gpt ( ncol , ngpt )) if ( len_trim ( error_msg ) > 0 ) then if ( len_trim ( atmos % get_name ()) > 0 ) & error_msg = trim ( atmos % get_name ()) // ': ' // trim ( error_msg ) end if ! Fluxes need to be copied out only if do_broadband is .true. !$acc        data copyin(   flux_up_loc,flux_dn_loc,flux_dir_loc) if (      do_broadband) !$omp target data map(to:   flux_up_loc,flux_dn_loc,flux_dir_loc) if (      do_broadband) !$acc        data create(   flux_up_loc,flux_dn_loc,flux_dir_loc) if (.not. do_broadband) !$omp target data map(alloc:flux_up_loc,flux_dn_loc,flux_dir_loc) if (.not. do_broadband) !$acc        data create(   gpt_flux_up,gpt_flux_dn,gpt_flux_dir) & !$acc             create(   sfc_alb_dir_gpt, sfc_alb_dif_gpt) !$omp target data map(alloc:gpt_flux_up,gpt_flux_dn,gpt_flux_dir) & !$omp             map(alloc:sfc_alb_dir_gpt, sfc_alb_dif_gpt) ! ------------------------------------------------------------------------------------ ! Boundary conditions !   Lower boundary condition -- expand surface albedos by band to gpoints !     and switch dimension ordering call expand_and_transpose ( atmos , sfc_alb_dir , sfc_alb_dir_gpt ) call expand_and_transpose ( atmos , sfc_alb_dif , sfc_alb_dif_gpt ) ! !   Diffuse flux boundary condition - will use values in optional arg or be set to 0 ! if ( has_dif_bc ) then inc_flux_diffuse => inc_flux_dif !$acc        enter data copyin(   inc_flux_diffuse) !$omp target enter data map(to:   inc_flux_diffuse) else allocate ( inc_flux_diffuse ( ncol , ngpt )) !$acc        enter data create(   inc_flux_diffuse) !$omp target enter data map(alloc:inc_flux_diffuse) call zero_array ( ncol , ngpt , inc_flux_diffuse ) end if ! ------------------------------------------------------------------------------------ if ( check_values ) error_msg = atmos % validate () ! ! Compute the radiative transfer... ! if ( len_trim ( error_msg ) == 0 ) then select type ( atmos ) class is ( ty_optical_props_1scl ) ! ! Direct beam only - for completeness, unlikely to be used in practice ! call sw_solver_noscat ( ncol , nlay , ngpt , logical ( top_at_1 , wl ), & atmos % tau , mu0 , inc_flux , & gpt_flux_dir ) call zero_array ( ncol , nlay + 1 , ngpt , gpt_flux_up ) ! !$acc kernels !$omp target gpt_flux_dn (:,:,:) = gpt_flux_dir (:,:,:) !$acc end kernels !$omp end target class is ( ty_optical_props_2str ) ! ! two-stream calculation with scattering ! call sw_solver_2stream ( ncol , nlay , ngpt , logical ( top_at_1 , wl ), & atmos % tau , atmos % ssa , atmos % g , mu0 , & sfc_alb_dir_gpt , sfc_alb_dif_gpt , & inc_flux , & gpt_flux_up , gpt_flux_dn , gpt_flux_dir , & has_dif_bc , inc_flux_diffuse , & do_broadband , flux_up_loc , flux_dn_loc , flux_dir_loc ) class is ( ty_optical_props_nstr ) ! ! n-stream calculation ! ! not yet implemented so fail ! error_msg = 'sw_solver(...ty_optical_props_nstr...) not yet implemented' end select if ( len_trim ( error_msg ) > 0 ) then if ( len_trim ( atmos % get_name ()) > 0 ) & error_msg = trim ( atmos % get_name ()) // ': ' // trim ( error_msg ) end if ! ! Flux reduction (summarizing for output) ! select type ( fluxes ) ! ! Tidy up memory for broadband fluxes ! type is ( ty_fluxes_broadband ) if ( associated ( fluxes % flux_net )) then !$acc                         parallel loop    collapse(2) copyout(fluxes%flux_net) !$omp target teams distribute parallel do simd collapse(2) do ilev = 1 , nlay + 1 do icol = 1 , ncol fluxes % flux_net ( icol , ilev ) = flux_dn_loc ( icol , ilev ) - flux_up_loc ( icol , ilev ) end do end do end if class default ! ! ...or reduce spectral fluxes to desired output quantities ! error_msg = fluxes % reduce ( gpt_flux_up , gpt_flux_dn , atmos , top_at_1 , gpt_flux_dir ) end select end if ! In case of an error we exit here !$acc        end data !$omp end target data !$acc        end data !$omp end target data !$acc        end data !$omp end target data !$acc        end data !$omp end target data !$acc        end data !$omp end target data ! ! Deallocate any memory allocated locally to pointer variables ! select type ( fluxes ) type is ( ty_fluxes_broadband ) !$acc        exit data copyout( flux_up_loc, flux_dn_loc, flux_dir_loc) !$omp target exit data map(from:flux_up_loc, flux_dn_loc, flux_dir_loc) if (. not . associated ( fluxes % flux_up )) deallocate ( flux_up_loc ) if (. not . associated ( fluxes % flux_dn )) deallocate ( flux_dn_loc ) if (. not . associated ( fluxes % flux_dn_dir )) deallocate ( flux_dir_loc ) class default deallocate ( gpt_flux_up , gpt_flux_dn , gpt_flux_dir ) end select if (. not . has_dif_bc ) then !$acc        exit data delete(     inc_flux_diffuse) !$omp target exit data map(release:inc_flux_diffuse) deallocate ( inc_flux_diffuse ) end if end function rte_sw !-------------------------------------------------------------------------------------------------------------------- ! ! Expand from band to g-point dimension, transpose dimensions (nband, ncol) -> (ncol,ngpt) ! subroutine expand_and_transpose ( ops , arr_in , arr_out ) class ( ty_optical_props ), intent ( in ) :: ops real ( wp ), dimension (:,:), intent ( in ) :: arr_in ! (nband, ncol) real ( wp ), dimension (:,:), intent ( out ) :: arr_out ! (ncol, igpt) ! ------------- integer :: ncol , nband , ngpt integer :: icol , iband , igpt integer , dimension ( 2 , ops % get_nband ()) :: limits ncol = size ( arr_in , 2 ) nband = ops % get_nband () ngpt = ops % get_ngpt () limits = ops % get_band_lims_gpoint () !$acc                         parallel loop    collapse(2) copyin(arr_in, limits) !$omp target teams distribute parallel do simd collapse(2) map(to:arr_in, limits) do iband = 1 , nband do icol = 1 , ncol do igpt = limits ( 1 , iband ), limits ( 2 , iband ) arr_out ( icol , igpt ) = arr_in ( iband , icol ) end do end do end do end subroutine expand_and_transpose end module mo_rte_sw","tags":"","loc":"sourcefile/mo_rte_sw.f90.html"},{"title":"mo_optical_props.F90 – rte-rrtmgp","text":"This code is part of Radiative Transfer for Energetics (RTE) Contacts: Robert Pincus and Eli Mlawer\nemail:  rrtmgp@aer.com Copyright 2015-2018,  Atmospheric and Environmental Research and\nRegents of the University of Colorado.  All right reserved. Use and duplication is permitted under the terms of the\n   BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause This file depends on sourcefile~~mo_optical_props.f90~~EfferentGraph sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_optical_props.f90~~AfferentGraph sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_cloud_optics.f90 mo_cloud_optics.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_cloud_sampling.f90 mo_cloud_sampling.F90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_optical_props Source Code mo_optical_props.F90 Source Code !! This code is part of Radiative Transfer for Energetics (RTE) !! !! Contacts: Robert Pincus and Eli Mlawer !! email:  rrtmgp@aer.com !! !! Copyright 2015-2018,  Atmospheric and Environmental Research and !! Regents of the University of Colorado.  All right reserved. !! !! Use and duplication is permitted under the terms of the !!    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause !! ------------------------------------------------------------------------------------------------- !> Encapsulate optical properties defined on a spectral grid of N bands. !>   The bands are described by their limiting wavenumbers. They need not be contiguous or complete. !>   A band may contain more than one spectral sub-point (g-point) in which case a mapping must be supplied. !>   A name may be provided and will be prepended to error messages. !>   The base class (ty_optical_props) encapsulates only this spectral discretization and must be initialized !>      with the spectral information before use. !> !>   Optical properties may be represented as arrays with dimensions ncol, nlay, ngpt !>   (abstract class ty_optical_props_arry). !>   The type holds arrays depending on how much information is needed !>   There are three possibilites !>      ty_optical_props_1scl holds absorption optical depth tau, used in calculations accounting for extinction and emission !>      ty_optical_props_2str holds extincion optical depth tau, single-scattering albedo ssa, and !>        asymmetry parameter g. These fields are what's needed for two-stream calculations. !>      ty_optical_props_nstr holds extincion optical depth tau, single-scattering albedo ssa, and !>        phase function moments p with leading dimension nmom. These fields are what's needed for multi-stream calculations. !>   These classes must be allocated before use. Initialization and allocation can be combined. !>   The classes have a validate() function that checks all arrays for valid values (e.g. tau > 0.) !> !> Optical properties can be delta-scaled (though this is currently implemented only for two-stream arrays) !> !> Optical properties can increment or \"add themselves to\" a set of properties represented with arrays !>   as long as both sets have the same underlying band structure. Properties defined by band !>   may be added to properties defined by g-point; the same value is assumed for all g-points with each band. !> !> Subsets of optical properties held as arrays may be extracted along the column dimension. !> !> ------------------------------------------------------------------------------------------------- module mo_optical_props use mo_rte_kind , only : wp use mo_rte_config , only : check_extents , check_values use mo_rte_util_array , only : any_vals_less_than , any_vals_outside , extents_are use mo_optical_props_kernels , only : & increment_1scalar_by_1scalar , increment_1scalar_by_2stream , increment_1scalar_by_nstream , & increment_2stream_by_1scalar , increment_2stream_by_2stream , increment_2stream_by_nstream , & increment_nstream_by_1scalar , increment_nstream_by_2stream , increment_nstream_by_nstream , & inc_1scalar_by_1scalar_bybnd , inc_1scalar_by_2stream_bybnd , inc_1scalar_by_nstream_bybnd , & inc_2stream_by_1scalar_bybnd , inc_2stream_by_2stream_bybnd , inc_2stream_by_nstream_bybnd , & inc_nstream_by_1scalar_bybnd , inc_nstream_by_2stream_bybnd , inc_nstream_by_nstream_bybnd , & delta_scale_2str_kernel , & extract_subset implicit none integer , parameter :: name_len = 32 !> ------------------------------------------------------------------------------------------------- !> !> Base class for optical properties !>   Describes the spectral discretization including the wavenumber limits !>   of each band (spectral region) and the mapping between g-points and bands !> !> ------------------------------------------------------------------------------------------------- type , public :: ty_optical_props integer , dimension (:,:), allocatable :: band2gpt !! (begin g-point, end g-point) = band2gpt(2,band) integer , dimension (:), allocatable :: gpt2band !! band = gpt2band(g-point) real ( wp ), dimension (:,:), allocatable :: band_lims_wvn !! (upper and lower wavenumber by band) = band_lims_wvn(2,band) character ( len = name_len ) :: name = \"\" contains generic , public :: init => init_base , init_base_from_copy procedure , private :: init_base procedure , private :: init_base_from_copy procedure , public :: is_initialized => is_initialized_base procedure , private :: is_initialized_base procedure , public :: finalize => finalize_base procedure , private :: finalize_base procedure , public :: get_nband procedure , public :: get_ngpt procedure , public :: get_gpoint_bands procedure , public :: convert_band2gpt procedure , public :: convert_gpt2band procedure , public :: get_band_lims_gpoint procedure , public :: get_band_lims_wavenumber procedure , public :: get_band_lims_wavelength procedure , public :: bands_are_equal procedure , public :: gpoints_are_equal procedure , public :: expand procedure , public :: set_name procedure , public :: get_name end type !>---------------------------------------------------------------------------------------- !> !> Optical properties as arrays, normally dimensioned ncol, nlay, ngpt/nbnd !>   The abstract base class for arrays defines what procedures will be available !>   The optical depth field is also part of the abstract base class, since !>    any representation of values as arrays needs an optical depth field !> !> ------------------------------------------------------------------------------------------------- type , extends ( ty_optical_props ), abstract , public :: ty_optical_props_arry real ( wp ), dimension (:,:,:), allocatable :: tau !! optical depth (ncol, nlay, ngpt) contains procedure , public :: get_ncol procedure , public :: get_nlay !> !> Increment another set of values !> procedure , public :: increment !> !> Deferred procedures -- each must be implemented in each child class with !>   arguments following the abstract interface (defined below) !> procedure ( validate_abstract ), deferred , public :: validate procedure ( delta_scale_abstract ), deferred , public :: delta_scale procedure ( subset_range_abstract ), deferred , public :: get_subset end type !> !> Interfaces for the methods to be implemented !> abstract interface !> !> Validation function looks only at internal data !> function validate_abstract ( this ) result ( err_message ) import ty_optical_props_arry class ( ty_optical_props_arry ), intent ( in ) :: this character ( len = 128 ) :: err_message end function validate_abstract !> !> Delta-scaling !> function delta_scale_abstract ( this , for ) result ( err_message ) import ty_optical_props_arry import wp class ( ty_optical_props_arry ), intent ( inout ) :: this real ( wp ), dimension (:,:,:), optional , & intent ( in ) :: for !> Forward scattering fraction; g**2 if not provided character ( len = 128 ) :: err_message end function delta_scale_abstract !> !> Subsetting -- currently there are only routines with start col and count !> function subset_range_abstract ( full , start , n , subset ) result ( err_message ) import ty_optical_props_arry class ( ty_optical_props_arry ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_optical_props_arry ), intent ( inout ) :: subset character ( 128 ) :: err_message end function subset_range_abstract end interface !>---------------------------------------------------------------------------------------- !> !>   ty_optical_props_arry  includes only (extinction) optical depth !>   Class two-stream adds arrays for single scattering albedo ssa and !>     asymmetry parameter needed in two-stream methods !>   Class n-stream adds arrays for single scattering albedo ssa and !>     phase function moments (index 1 = g) for use with discrete ordinate methods !> !> ------------------------------------------------------------------------------------------------- type , public , extends ( ty_optical_props_arry ) :: ty_optical_props_1scl contains procedure , public :: validate => validate_1scalar procedure , public :: get_subset => subset_1scl_range procedure , public :: delta_scale => delta_scale_1scl procedure , public :: finalize_1scl procedure , private :: alloc_only_1scl procedure , private :: init_and_alloc_1scl procedure , private :: copy_and_alloc_1scl generic , public :: alloc_1scl => alloc_only_1scl , init_and_alloc_1scl , copy_and_alloc_1scl end type ! --- 2 stream ------------------------------------------------------------------------ type , public , extends ( ty_optical_props_arry ) :: ty_optical_props_2str real ( wp ), dimension (:,:,:), allocatable :: ssa !! single-scattering albedo (ncol, nlay, ngpt) real ( wp ), dimension (:,:,:), allocatable :: g !! asymmetry parameter (ncol, nlay, ngpt) contains procedure , public :: validate => validate_2stream procedure , public :: get_subset => subset_2str_range procedure , public :: delta_scale => delta_scale_2str procedure , public :: finalize_2str procedure , private :: alloc_only_2str procedure , private :: init_and_alloc_2str procedure , private :: copy_and_alloc_2str generic , public :: alloc_2str => alloc_only_2str , init_and_alloc_2str , copy_and_alloc_2str end type ! --- n stream ------------------------------------------------------------------------ type , public , extends ( ty_optical_props_arry ) :: ty_optical_props_nstr real ( wp ), dimension (:,:,:), allocatable :: ssa !! single-scattering albedo (ncol, nlay, ngpt) real ( wp ), dimension (:,:,:,:), allocatable :: p !! phase-function moments (nmom, ncol, nlay, ngpt) contains procedure , public :: validate => validate_nstream procedure , public :: get_subset => subset_nstr_range procedure , public :: delta_scale => delta_scale_nstr procedure , public :: get_nmom procedure , public :: finalize_nstr procedure , private :: alloc_only_nstr procedure , private :: init_and_alloc_nstr procedure , private :: copy_and_alloc_nstr generic , public :: alloc_nstr => alloc_only_nstr , init_and_alloc_nstr , copy_and_alloc_nstr end type ! ------------------------------------------------------------------------------------------------- contains ! ------------------------------------------------------------------------------------------------- ! !  Routines for the base class: initialization, validity checking, finalization ! !> ------------------------------------------------------------------------------------------------- !> !> Base class: Initialization !>   Values are assumed to be defined in bands a mapping between bands and g-points is provided !> !> ------------------------------------------------------------------------------------------------- function init_base ( this , band_lims_wvn , band_lims_gpt , name ) result ( err_message ) class ( ty_optical_props ), intent ( inout ) :: this real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn integer , dimension (:,:), & optional , intent ( in ) :: band_lims_gpt character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message integer :: iband integer , dimension ( 2 , size ( band_lims_wvn , 2 )) :: band_lims_gpt_lcl ! ------------------------- ! ! Error checking -- are the arrays the size we expect, contain positive values? ! err_message = \"\" if ( size ( band_lims_wvn , 1 ) /= 2 ) & err_message = \"optical_props%init(): band_lims_wvn 1st dim should be 2\" if ( check_values ) then if ( any_vals_less_than ( band_lims_wvn , 0._wp ) ) & err_message = \"optical_props%init(): band_lims_wvn has values <  0., respectively\" end if if ( err_message /= \"\" ) return if ( present ( band_lims_gpt )) then if ( check_extents ) then if (. not . extents_are ( band_lims_gpt , 2 , size ( band_lims_wvn , 2 ))) & err_message = \"optical_props%init(): band_lims_gpt size inconsistent with band_lims_wvn\" end if if ( check_values ) then if ( any ( band_lims_gpt < 1 ) ) & err_message = \"optical_props%init(): band_lims_gpt has values < 1\" end if if ( err_message /= \"\" ) return band_lims_gpt_lcl (:,:) = band_lims_gpt (:,:) else ! ! Assume that values are defined by band, one g-point per band ! do iband = 1 , size ( band_lims_wvn , 2 ) band_lims_gpt_lcl ( 1 : 2 , iband ) = iband end do end if ! ! Assignment ! if ( allocated ( this % band2gpt )) deallocate ( this % band2gpt ) if ( allocated ( this % band_lims_wvn )) deallocate ( this % band_lims_wvn ) allocate ( this % band2gpt ( 2 , size ( band_lims_wvn , 2 )), & this % band_lims_wvn ( 2 , size ( band_lims_wvn , 2 ))) this % band2gpt = band_lims_gpt_lcl this % band_lims_wvn = band_lims_wvn if ( present ( name )) this % name = trim ( name ) ! ! Make a map between g-points and bands !   Efficient only when g-point indexes start at 1 and are contiguous. ! if ( allocated ( this % gpt2band )) deallocate ( this % gpt2band ) allocate ( this % gpt2band ( maxval ( band_lims_gpt_lcl ))) do iband = 1 , size ( band_lims_gpt_lcl , dim = 2 ) this % gpt2band ( band_lims_gpt_lcl ( 1 , iband ): band_lims_gpt_lcl ( 2 , iband )) = iband end do end function init_base !------------------------------------------------------------------------------------------------- function init_base_from_copy ( this , spectral_desc ) result ( err_message ) class ( ty_optical_props ), intent ( inout ) :: this class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len = 128 ) :: err_message if (. not . spectral_desc % is_initialized ()) then err_message = \"optical_props%init(): can't initialize based on un-initialized input\" return else err_message = this % init ( spectral_desc % get_band_lims_wavenumber (), & spectral_desc % get_band_lims_gpoint ()) end if end function init_base_from_copy !>------------------------------------------------------------------------------------------------- !> !> Base class: return true if initialized, false otherwise !> !> ------------------------------------------------------------------------------------------------- pure function is_initialized_base ( this ) class ( ty_optical_props ), intent ( in ) :: this logical :: is_initialized_base is_initialized_base = allocated ( this % band2gpt ) end function is_initialized_base !>------------------------------------------------------------------------------------------------- !> !> Base class: finalize (deallocate memory) !> !> ------------------------------------------------------------------------------------------------- subroutine finalize_base ( this ) class ( ty_optical_props ), intent ( inout ) :: this if ( allocated ( this % band2gpt )) deallocate ( this % band2gpt ) if ( allocated ( this % gpt2band )) deallocate ( this % gpt2band ) if ( allocated ( this % band_lims_wvn )) & deallocate ( this % band_lims_wvn ) this % name = \"\" end subroutine finalize_base ! ------------------------------------------------------------------------------------------ ! !  Routines for array classes: initialization, allocation, and finalization !    Initialization and allocation can be combined by supplying either ! !> ------------------------------------------------------------------------------------------ !> !> Straight allocation routines !> !> --- 1 scalar ------------------------------------------------------------------------ function alloc_only_1scl ( this , ncol , nlay ) result ( err_message ) class ( ty_optical_props_1scl ) :: this integer , intent ( in ) :: ncol , nlay character ( len = 128 ) :: err_message err_message = \"\" if (. not . this % is_initialized ()) then err_message = \"optical_props%alloc: spectral discretization hasn't been provided\" return end if if ( any ([ ncol , nlay ] <= 0 )) then err_message = \"optical_props%alloc: must provide positive extents for ncol, nlay\" else if ( allocated ( this % tau )) deallocate ( this % tau ) allocate ( this % tau ( ncol , nlay , this % get_ngpt ())) end if end function alloc_only_1scl !> --- 2 stream ------------------------------------------------------------------------ function alloc_only_2str ( this , ncol , nlay ) result ( err_message ) class ( ty_optical_props_2str ) :: this integer , intent ( in ) :: ncol , nlay character ( len = 128 ) :: err_message err_message = \"\" if (. not . this % is_initialized ()) & err_message = \"optical_props%alloc: spectral discretization hasn't been provided\" if ( any ([ ncol , nlay ] <= 0 )) & err_message = \"optical_props%alloc: must provide positive extents for ncol, nlay\" if ( err_message /= \"\" ) return if ( allocated ( this % tau )) deallocate ( this % tau ) allocate ( this % tau ( ncol , nlay , this % get_ngpt ())) if ( allocated ( this % ssa )) deallocate ( this % ssa ) if ( allocated ( this % g )) deallocate ( this % g ) allocate ( this % ssa ( ncol , nlay , this % get_ngpt ()), this % g ( ncol , nlay , this % get_ngpt ())) end function alloc_only_2str !> --- n stream ------------------------------------------------------------------------ function alloc_only_nstr ( this , nmom , ncol , nlay ) result ( err_message ) class ( ty_optical_props_nstr ) :: this integer , intent ( in ) :: nmom ! number of moments integer , intent ( in ) :: ncol , nlay character ( len = 128 ) :: err_message err_message = \"\" if (. not . this % is_initialized ()) & err_message = \"optical_props%alloc: spectral discretization hasn't been provided\" if ( any ([ ncol , nlay ] <= 0 )) & err_message = \"optical_props%alloc: must provide positive extents for ncol, nlay\" if ( err_message /= \"\" ) return if ( allocated ( this % tau )) deallocate ( this % tau ) allocate ( this % tau ( ncol , nlay , this % get_ngpt ())) if ( allocated ( this % ssa )) deallocate ( this % ssa ) if ( allocated ( this % p )) deallocate ( this % p ) allocate ( this % ssa ( ncol , nlay , this % get_ngpt ()), this % p ( nmom , ncol , nlay , this % get_ngpt ())) end function alloc_only_nstr ! ------------------------------------------------------------------------------------------ ! ! Combined allocation/initialization routines ! !> ------------------------------------------------------------------------------------------ !> !> Initialization by specifying band limits and possibly g-point/band mapping !> !> --------------------------------------------------------------------------- function init_and_alloc_1scl ( this , ncol , nlay , band_lims_wvn , band_lims_gpt , name ) result ( err_message ) class ( ty_optical_props_1scl ) :: this integer , intent ( in ) :: ncol , nlay real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn integer , dimension (:,:), & optional , intent ( in ) :: band_lims_gpt character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = this % ty_optical_props % init ( band_lims_wvn , & band_lims_gpt , name ) if ( err_message /= \"\" ) return err_message = this % alloc_1scl ( ncol , nlay ) end function init_and_alloc_1scl ! --------------------------------------------------------------------------- function init_and_alloc_2str ( this , ncol , nlay , band_lims_wvn , band_lims_gpt , name ) result ( err_message ) class ( ty_optical_props_2str ) :: this integer , intent ( in ) :: ncol , nlay real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn integer , dimension (:,:), & optional , intent ( in ) :: band_lims_gpt character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = this % ty_optical_props % init ( band_lims_wvn , & band_lims_gpt , name ) if ( err_message /= \"\" ) return err_message = this % alloc_2str ( ncol , nlay ) end function init_and_alloc_2str ! --------------------------------------------------------------------------- function init_and_alloc_nstr ( this , nmom , ncol , nlay , band_lims_wvn , band_lims_gpt , name ) result ( err_message ) class ( ty_optical_props_nstr ) :: this integer , intent ( in ) :: nmom , ncol , nlay real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn integer , dimension (:,:), & optional , intent ( in ) :: band_lims_gpt character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = this % ty_optical_props % init ( band_lims_wvn , & band_lims_gpt , name ) if ( err_message /= \"\" ) return err_message = this % alloc_nstr ( nmom , ncol , nlay ) end function init_and_alloc_nstr !>------------------------------------------------------------------------------------------------- !> !> Initialization from an existing spectral discretization/ty_optical_props !> !>------------------------------------------------------------------------------------------------- function copy_and_alloc_1scl ( this , ncol , nlay , spectral_desc , name ) result ( err_message ) class ( ty_optical_props_1scl ) :: this integer , intent ( in ) :: ncol , nlay class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = \"\" if ( this % ty_optical_props % is_initialized ()) call this % ty_optical_props % finalize () err_message = this % ty_optical_props % init ( spectral_desc % get_band_lims_wavenumber (), & spectral_desc % get_band_lims_gpoint (), name ) if ( err_message /= \"\" ) return err_message = this % alloc_1scl ( ncol , nlay ) end function copy_and_alloc_1scl ! --------------------------------------------------------------------------- function copy_and_alloc_2str ( this , ncol , nlay , spectral_desc , name ) result ( err_message ) class ( ty_optical_props_2str ) :: this integer , intent ( in ) :: ncol , nlay class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = \"\" if ( this % ty_optical_props % is_initialized ()) call this % ty_optical_props % finalize () err_message = this % ty_optical_props % init ( spectral_desc % get_band_lims_wavenumber (), & spectral_desc % get_band_lims_gpoint (), name ) if ( err_message /= \"\" ) return err_message = this % alloc_2str ( ncol , nlay ) end function copy_and_alloc_2str ! --------------------------------------------------------------------------- function copy_and_alloc_nstr ( this , nmom , ncol , nlay , spectral_desc , name ) result ( err_message ) class ( ty_optical_props_nstr ) :: this integer , intent ( in ) :: nmom , ncol , nlay class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = \"\" if ( this % ty_optical_props % is_initialized ()) call this % ty_optical_props % finalize () err_message = this % ty_optical_props % init ( spectral_desc % get_band_lims_wavenumber (), & spectral_desc % get_band_lims_gpoint (), name ) if ( err_message /= \"\" ) return err_message = this % alloc_nstr ( nmom , ncol , nlay ) end function copy_and_alloc_nstr !> ------------------------------------------------------------------------------------------ !> !> Finalize routines !> !> ------------------------------------------------------------------------------------------ function finalize_1scl ( this ) result ( err_message ) class ( ty_optical_props_1scl ) :: this character ( len = 128 ) :: err_message if ( allocated ( this % tau )) deallocate ( this % tau ) err_message = \"\" end function finalize_1scl ! --------------------------------------------------------------------------- function finalize_2str ( this ) result ( err_message ) class ( ty_optical_props_2str ) :: this character ( len = 128 ) :: err_message if ( allocated ( this % tau )) deallocate ( this % tau ) if ( allocated ( this % ssa )) deallocate ( this % ssa ) if ( allocated ( this % g )) deallocate ( this % g ) err_message = \"\" end function finalize_2str ! --------------------------------------------------------------------------- function finalize_nstr ( this ) result ( err_message ) class ( ty_optical_props_nstr ) :: this character ( len = 128 ) :: err_message if ( allocated ( this % tau )) deallocate ( this % tau ) if ( allocated ( this % ssa )) deallocate ( this % ssa ) if ( allocated ( this % p )) deallocate ( this % p ) err_message = \"\" end function finalize_nstr ! ------------------------------------------------------------------------------------------ ! !  Routines for array classes: delta-scaling, validation (ensuring all values can be used ) ! !> ------------------------------------------------------------------------------------------ !> --- delta scaling !> ------------------------------------------------------------------------------------------ function delta_scale_1scl ( this , for ) result ( err_message ) class ( ty_optical_props_1scl ), intent ( inout ) :: this real ( wp ), dimension (:,:,:), optional , & intent ( in ) :: for character ( 128 ) :: err_message ! ! Nothing to do ! err_message = \"\" end function delta_scale_1scl ! ------------------------------------------------------------------------------------------ function delta_scale_2str ( this , for ) result ( err_message ) class ( ty_optical_props_2str ), intent ( inout ) :: this real ( wp ), dimension (:,:,:), optional , & intent ( in ) :: for !! Forward scattering fraction; g**2 if not provided character ( 128 ) :: err_message integer :: ncol , nlay , ngpt ! -------------------------------- ncol = this % get_ncol () nlay = this % get_nlay () ngpt = this % get_ngpt () err_message = \"\" if ( present ( for )) then if ( check_extents ) then if (. not . extents_are ( for , ncol , nlay , ngpt )) then err_message = \"delta_scale: dimension of 'for' don't match optical properties arrays\" return end if end if if ( check_values ) then if ( any_vals_outside ( for , 0._wp , 1._wp )) then err_message = \"delta_scale: values of 'for' out of bounds [0,1]\" return end if end if call delta_scale_2str_kernel ( ncol , nlay , ngpt , this % tau , this % ssa , this % g , for ) else call delta_scale_2str_kernel ( ncol , nlay , ngpt , this % tau , this % ssa , this % g ) end if end function delta_scale_2str ! ------------------------------------------------------------------------------------------ function delta_scale_nstr ( this , for ) result ( err_message ) class ( ty_optical_props_nstr ), intent ( inout ) :: this real ( wp ), dimension (:,:,:), optional , & intent ( in ) :: for character ( 128 ) :: err_message err_message = 'delta_scale_nstr: Not yet implemented' end function delta_scale_nstr !> ------------------------------------------------------------------------------------------ !> !> --- Validation !> !> ------------------------------------------------------------------------------------------ function validate_1scalar ( this ) result ( err_message ) class ( ty_optical_props_1scl ), intent ( in ) :: this character ( len = 128 ) :: err_message err_message = '' if (. not . allocated ( this % tau )) then err_message = \"validate: tau not allocated/initialized\" return end if if ( check_values ) then if ( any_vals_less_than ( this % tau , 0._wp )) & err_message = \"validate: tau values out of range\" end if if ( len_trim ( err_message ) > 0 . and . len_trim ( this % get_name ()) > 0 ) & err_message = trim ( this % get_name ()) // ': ' // trim ( err_message ) end function validate_1scalar ! ------------------------------------------------------------------------------------------ function validate_2stream ( this ) result ( err_message ) class ( ty_optical_props_2str ), intent ( in ) :: this character ( len = 128 ) :: err_message integer :: d1 , d2 , d3 err_message = '' ! ! Array allocation status, sizing ! if ( check_extents ) then if (. not . all ([ allocated ( this % tau ), allocated ( this % ssa ), allocated ( this % g )])) then err_message = \"validate: arrays not allocated/initialized\" return end if d1 = size ( this % tau , 1 ) d2 = size ( this % tau , 2 ) d3 = size ( this % tau , 3 ) if (. not . extents_are ( this % ssa , d1 , d2 , d3 ) . or . & . not . extents_are ( this % g , d1 , d2 , d3 )) & err_message = \"validate: arrays not sized consistently\" end if ! ! Valid values ! if ( check_values ) then if ( any_vals_less_than ( this % tau , 0._wp )) & err_message = \"validate: tau values out of range\" if ( any_vals_outside ( this % ssa , 0._wp , 1._wp )) & err_message = \"validate: ssa values out of range\" if ( any_vals_outside ( this % g , - 1._wp , 1._wp )) & err_message = \"validate: g values out of range\" end if if ( len_trim ( err_message ) > 0 . and . len_trim ( this % get_name ()) > 0 ) & err_message = trim ( this % get_name ()) // ': ' // trim ( err_message ) end function validate_2stream ! ------------------------------------------------------------------------------------------ function validate_nstream ( this ) result ( err_message ) class ( ty_optical_props_nstr ), intent ( in ) :: this character ( len = 128 ) :: err_message integer :: d1 , d2 , d3 , d4 err_message = '' ! ! Array allocation status, sizing ! if (. not . all ([ allocated ( this % tau ), allocated ( this % ssa ), allocated ( this % p )])) then err_message = \"validate: arrays not allocated/initialized\" return end if d1 = size ( this % tau , 1 ) d2 = size ( this % tau , 2 ) d3 = size ( this % tau , 3 ) d4 = size ( this % p , 1 ) if ( check_extents ) then if (. not . extents_are ( this % ssa , d1 , d2 , d3 ) . or . & . not . extents_are ( this % p , d4 , d1 , d2 , d3 )) & err_message = \"validate: arrays not sized consistently\" end if ! ! Valid values ! if ( check_values ) then if ( any_vals_less_than ( this % tau , 0._wp )) & err_message = \"validate: tau values out of range\" if ( any_vals_outside ( this % ssa , 0._wp , 1._wp )) & err_message = \"validate: ssa values out of range\" if ( any_vals_outside ( this % p ( 1 ,:,:,:), - 1._wp , 1._wp )) & err_message = \"validate: p(1,:,:,:)  = g values out of range\" end if if ( len_trim ( err_message ) > 0 . and . len_trim ( this % get_name ()) > 0 ) & err_message = trim ( this % get_name ()) // ': ' // trim ( err_message ) end function validate_nstream !> ------------------------------------------------------------------------------------------ !> !>  Routines for array classes: subsetting of optical properties arrays along x (col) direction !> !> Allocate class, then arrays; copy. Could probably be more efficient if !>   classes used pointers internally. !> !> This set takes start position and number as scalars !> !> ------------------------------------------------------------------------------------------ function subset_1scl_range ( full , start , n , subset ) result ( err_message ) class ( ty_optical_props_1scl ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_optical_props_arry ), intent ( inout ) :: subset character ( 128 ) :: err_message integer :: ncol , nlay , ngpt , nmom err_message = \"\" if (. not . full % is_initialized ()) then err_message = \"optical_props%subset: Asking for a subset of uninitialized data\" return end if ncol = full % get_ncol () nlay = full % get_nlay () ngpt = full % get_ngpt () if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return if ( subset % is_initialized ()) call subset % finalize () err_message = subset % init ( full ) ! Seems like the deallocation statements should be needed under Fortran 2003 !   but Intel compiler doesn't run without them if ( allocated ( subset % tau )) deallocate ( subset % tau ) select type ( subset ) class is ( ty_optical_props_1scl ) err_message = subset % alloc_1scl ( n , nlay ) if ( err_message /= \"\" ) return class is ( ty_optical_props_2str ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % g )) deallocate ( subset % g ) err_message = subset % alloc_2str ( n , nlay ) if ( err_message /= \"\" ) return subset % ssa ( 1 : n ,:,:) = 0._wp subset % g ( 1 : n ,:,:) = 0._wp class is ( ty_optical_props_nstr ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % p )) then nmom = subset % get_nmom () deallocate ( subset % p ) else nmom = 1 end if err_message = subset % alloc_nstr ( nmom , n , nlay ) if ( err_message /= \"\" ) return subset % ssa ( 1 : n ,:,:) = 0._wp subset % p (:, 1 : n ,:,:) = 0._wp end select call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) end function subset_1scl_range ! ------------------------------------------------------------------------------------------ function subset_2str_range ( full , start , n , subset ) result ( err_message ) class ( ty_optical_props_2str ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_optical_props_arry ), intent ( inout ) :: subset character ( 128 ) :: err_message integer :: ncol , nlay , ngpt , nmom err_message = \"\" if (. not . full % is_initialized ()) then err_message = \"optical_props%subset: Asking for a subset of uninitialized data\" return end if ncol = full % get_ncol () nlay = full % get_nlay () ngpt = full % get_ngpt () if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return if ( subset % is_initialized ()) call subset % finalize () err_message = subset % init ( full ) select type ( subset ) class is ( ty_optical_props_1scl ) err_message = subset % alloc_1scl ( n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , full % ssa , start , start + n - 1 , subset % tau ) class is ( ty_optical_props_2str ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % g )) deallocate ( subset % g ) err_message = subset % alloc_2str ( n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) call extract_subset ( ncol , nlay , ngpt , full % ssa , start , start + n - 1 , subset % ssa ) call extract_subset ( ncol , nlay , ngpt , full % g , start , start + n - 1 , subset % g ) class is ( ty_optical_props_nstr ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % p )) then nmom = subset % get_nmom () deallocate ( subset % p ) else nmom = 1 end if err_message = subset % alloc_nstr ( nmom , n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) call extract_subset ( ncol , nlay , ngpt , full % ssa , start , start + n - 1 , subset % ssa ) subset % p ( 1 , 1 : n ,:,:) = full % g ( start : start + n - 1 ,:,:) subset % p ( 2 :,:, :,:) = 0._wp end select end function subset_2str_range ! ------------------------------------------------------------------------------------------ function subset_nstr_range ( full , start , n , subset ) result ( err_message ) class ( ty_optical_props_nstr ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_optical_props_arry ), intent ( inout ) :: subset character ( 128 ) :: err_message integer :: ncol , nlay , ngpt , nmom err_message = \"\" if (. not . full % is_initialized ()) then err_message = \"optical_props%subset: Asking for a subset of uninitialized data\" return end if ncol = full % get_ncol () nlay = full % get_nlay () ngpt = full % get_ngpt () if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return if ( subset % is_initialized ()) call subset % finalize () err_message = subset % init ( full ) if ( allocated ( subset % tau )) deallocate ( subset % tau ) select type ( subset ) class is ( ty_optical_props_1scl ) err_message = subset % alloc_1scl ( n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , full % ssa , start , start + n - 1 , subset % tau ) class is ( ty_optical_props_2str ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % g )) deallocate ( subset % g ) err_message = subset % alloc_2str ( n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) call extract_subset ( ncol , nlay , ngpt , full % ssa , start , start + n - 1 , subset % ssa ) subset % g ( 1 : n ,:,:) = full % p ( 1 , start : start + n - 1 ,:,:) class is ( ty_optical_props_nstr ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % p )) deallocate ( subset % p ) err_message = subset % alloc_nstr ( nmom , n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) call extract_subset ( ncol , nlay , ngpt , full % ssa , start , start + n - 1 , subset % ssa ) call extract_subset ( nmom , ncol , nlay , ngpt , full % p , start , start + n - 1 , subset % p ) end select end function subset_nstr_range !> ------------------------------------------------------------------------------------------ !> !>  Routines for array classes: incrementing !>   a%increment(b) adds the values of a to b, changing b and leaving a untouched !> !> ----------------------------------------------------------------------------------------- function increment ( op_in , op_io ) result ( err_message ) class ( ty_optical_props_arry ), intent ( in ) :: op_in class ( ty_optical_props_arry ), intent ( inout ) :: op_io character ( 128 ) :: err_message ! ----- integer :: ncol , nlay , ngpt ! ----- err_message = \"\" if (. not . op_in % is_initialized ()) & err_message = \"ty_optical_props%increment: Incrementing optical properties aren't initialized\" if (. not . op_in % is_initialized ()) & err_message = \"ty_optical_props%increment: optical properties to be incremented aren't initialized\" if ( err_message /= \"\" ) return ncol = op_io % get_ncol () nlay = op_io % get_nlay () ngpt = op_io % get_ngpt () if (. not . op_in % bands_are_equal ( op_io )) & err_message = \"ty_optical_props%increment: optical properties objects have different band structures\" if (. not . all ([ op_in % get_ncol (), op_in % get_nlay ()] == [ ncol , nlay ])) & err_message = \"ty_optical_props%increment: optical properties objects have different ncol and/or nlay\" if ( err_message /= \"\" ) return if ( op_in % gpoints_are_equal ( op_io )) then ! ! Increment by gpoint !   (or by band if both op_in and op_io are defined that way) ! select type ( op_io ) class is ( ty_optical_props_1scl ) select type ( op_in ) class is ( ty_optical_props_1scl ) call increment_1scalar_by_1scalar ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau ) class is ( ty_optical_props_2str ) call increment_1scalar_by_2stream ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , op_in % ssa ) class is ( ty_optical_props_nstr ) call increment_1scalar_by_nstream ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , op_in % ssa ) end select class is ( ty_optical_props_2str ) select type ( op_in ) class is ( ty_optical_props_1scl ) call increment_2stream_by_1scalar ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa ,& op_in % tau ) class is ( ty_optical_props_2str ) call increment_2stream_by_2stream ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , op_io % g , & op_in % tau , op_in % ssa , op_in % g ) class is ( ty_optical_props_nstr ) call increment_2stream_by_nstream ( ncol , nlay , ngpt , op_in % get_nmom (), & op_io % tau , op_io % ssa , op_io % g , & op_in % tau , op_in % ssa , op_in % p ) end select class is ( ty_optical_props_nstr ) select type ( op_in ) class is ( ty_optical_props_1scl ) call increment_nstream_by_1scalar ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , & op_in % tau ) class is ( ty_optical_props_2str ) call increment_nstream_by_2stream ( ncol , nlay , ngpt , op_io % get_nmom (), & op_io % tau , op_io % ssa , op_io % p , & op_in % tau , op_in % ssa , op_in % g ) class is ( ty_optical_props_nstr ) call increment_nstream_by_nstream ( ncol , nlay , ngpt , op_io % get_nmom (), op_in % get_nmom (), & op_io % tau , op_io % ssa , op_io % p , & op_in % tau , op_in % ssa , op_in % p ) end select end select else ! ! Values defined by-band will have ngpt() = nband() ! We can use values by band in op_in to increment op_io !   Anything else is an error ! if ( op_in % get_ngpt () /= op_io % get_nband ()) then err_message = \"ty_optical_props%increment: optical properties objects have incompatible g-point structures\" return end if ! ! Increment by band ! select type ( op_io ) class is ( ty_optical_props_1scl ) select type ( op_in ) class is ( ty_optical_props_1scl ) call inc_1scalar_by_1scalar_bybnd ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_2str ) call inc_1scalar_by_2stream_bybnd ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , op_in % ssa , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_nstr ) call inc_1scalar_by_nstream_bybnd ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , op_in % ssa , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) end select class is ( ty_optical_props_2str ) select type ( op_in ) class is ( ty_optical_props_1scl ) call inc_2stream_by_1scalar_bybnd ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , & op_in % tau , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_2str ) call inc_2stream_by_2stream_bybnd ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , op_io % g , & op_in % tau , op_in % ssa , op_in % g , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_nstr ) call inc_2stream_by_nstream_bybnd ( ncol , nlay , ngpt , op_in % get_nmom (), & op_io % tau , op_io % ssa , op_io % g , & op_in % tau , op_in % ssa , op_in % p , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) end select class is ( ty_optical_props_nstr ) select type ( op_in ) class is ( ty_optical_props_1scl ) call inc_nstream_by_1scalar_bybnd ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , & op_in % tau , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_2str ) call inc_nstream_by_2stream_bybnd ( ncol , nlay , ngpt , op_io % get_nmom (), & op_io % tau , op_io % ssa , op_io % p , & op_in % tau , op_in % ssa , op_in % g , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_nstr ) call inc_nstream_by_nstream_bybnd ( ncol , nlay , ngpt , op_io % get_nmom (), op_in % get_nmom (), & op_io % tau , op_io % ssa , op_io % p , & op_in % tau , op_in % ssa , op_in % p , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) end select end select end if end function increment !> ----------------------------------------------------------------------------------------------- !> !>  Routines for array classes: problem sizes !> !> ----------------------------------------------------------------------------------------------- pure function get_arry_extent ( this , dim ) class ( ty_optical_props_arry ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: get_arry_extent if ( allocated ( this % tau )) then get_arry_extent = size ( this % tau , dim ) else get_arry_extent = 0 end if end function get_arry_extent ! ------------------------------------------------------------------------------------------ pure function get_ncol ( this ) class ( ty_optical_props_arry ), intent ( in ) :: this integer :: get_ncol get_ncol = get_arry_extent ( this , 1 ) end function get_ncol ! ------------------------------------------------------------------------------------------ pure function get_nlay ( this ) class ( ty_optical_props_arry ), intent ( in ) :: this integer :: get_nlay get_nlay = get_arry_extent ( this , 2 ) end function get_nlay ! ------------------------------------------------------------------------------------------ pure function get_nmom ( this ) class ( ty_optical_props_nstr ), intent ( in ) :: this integer :: get_nmom if ( allocated ( this % p )) then get_nmom = size ( this % p , 1 ) else get_nmom = 0 end if end function get_nmom ! ----------------------------------------------------------------------------------------------- ! !  Routines for base class: spectral discretization ! !> ----------------------------------------------------------------------------------------------- !> !> Number of bands !> pure function get_nband ( this ) class ( ty_optical_props ), intent ( in ) :: this integer :: get_nband if ( this % is_initialized ()) then get_nband = size ( this % band2gpt , dim = 2 ) else get_nband = 0 end if end function get_nband !> ----------------------------------------------------------------------------------------------- !> !> Number of g-points !> pure function get_ngpt ( this ) class ( ty_optical_props ), intent ( in ) :: this integer :: get_ngpt if ( this % is_initialized ()) then get_ngpt = maxval ( this % band2gpt ) else get_ngpt = 0 end if end function get_ngpt !>-------------------------------------------------------------------------------------------------------------------- !> !> The first and last g-point of all bands at once !> dimension (2, nbands) !> pure function get_band_lims_gpoint ( this ) class ( ty_optical_props ), intent ( in ) :: this integer , dimension ( size ( this % band2gpt , dim = 1 ), size ( this % band2gpt , dim = 2 )) & :: get_band_lims_gpoint get_band_lims_gpoint = this % band2gpt end function get_band_lims_gpoint !>-------------------------------------------------------------------------------------------------------------------- !> !> First and last g-point of a specific band !> pure function convert_band2gpt ( this , band ) class ( ty_optical_props ), intent ( in ) :: this integer , intent ( in ) :: band integer , dimension ( 2 ) :: convert_band2gpt if ( this % is_initialized ()) then convert_band2gpt (:) = this % band2gpt (:, band ) else convert_band2gpt (:) = 0 end if end function convert_band2gpt !>-------------------------------------------------------------------------------------------------------------------- !> !> Lower and upper wavenumber of all bands !> (upper and lower wavenumber by band) = band_lims_wvn(2,band) !> pure function get_band_lims_wavenumber ( this ) class ( ty_optical_props ), intent ( in ) :: this real ( wp ), dimension ( size ( this % band_lims_wvn , 1 ), size ( this % band_lims_wvn , 2 )) & :: get_band_lims_wavenumber if ( this % is_initialized ()) then get_band_lims_wavenumber (:,:) = this % band_lims_wvn (:,:) else get_band_lims_wavenumber (:,:) = 0._wp end if end function get_band_lims_wavenumber !>-------------------------------------------------------------------------------------------------------------------- !> !> Lower and upper wavelength of all bands !> pure function get_band_lims_wavelength ( this ) class ( ty_optical_props ), intent ( in ) :: this real ( wp ), dimension ( size ( this % band_lims_wvn , 1 ), size ( this % band_lims_wvn , 2 )) & :: get_band_lims_wavelength if ( this % is_initialized ()) then get_band_lims_wavelength (:,:) = 1._wp / this % band_lims_wvn (:,:) else get_band_lims_wavelength (:,:) = 0._wp end if end function get_band_lims_wavelength !>-------------------------------------------------------------------------------------------------------------------- !> Bands for all the g-points at once !> dimension (ngpt) !> pure function get_gpoint_bands ( this ) class ( ty_optical_props ), intent ( in ) :: this integer , dimension ( size ( this % gpt2band , dim = 1 )) & :: get_gpoint_bands if ( this % is_initialized ()) then get_gpoint_bands (:) = this % gpt2band (:) else get_gpoint_bands (:) = 0 end if end function get_gpoint_bands !>-------------------------------------------------------------------------------------------------------------------- !> !> Band associated with a specific g-point !> pure function convert_gpt2band ( this , gpt ) class ( ty_optical_props ), intent ( in ) :: this integer , intent ( in ) :: gpt integer :: convert_gpt2band if ( this % is_initialized ()) then convert_gpt2band = this % gpt2band ( gpt ) else convert_gpt2band = 0 end if end function convert_gpt2band !>-------------------------------------------------------------------------------------------------------------------- !> !> Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) !> pure function expand ( this , arr_in ) result ( arr_out ) class ( ty_optical_props ), intent ( in ) :: this real ( wp ), dimension (:), intent ( in ) :: arr_in ! (nband) real ( wp ), dimension ( size ( this % gpt2band )) :: arr_out integer :: iband do iband = 1 , this % get_nband () arr_out ( this % band2gpt ( 1 , iband ): this % band2gpt ( 2 , iband )) = arr_in ( iband ) end do end function expand !>-------------------------------------------------------------------------------------------------------------------- !> !> Are the bands of two objects the same? (same number, same wavelength limits) !> pure function bands_are_equal ( this , that ) class ( ty_optical_props ), intent ( in ) :: this , that logical :: bands_are_equal bands_are_equal = this % get_nband () == that % get_nband () . and . & this % get_nband () > 0 if (. not . bands_are_equal ) return bands_are_equal = & all ( abs ( this % get_band_lims_wavenumber () - that % get_band_lims_wavenumber ()) < & 5._wp * spacing ( this % get_band_lims_wavenumber ())) end function bands_are_equal !>-------------------------------------------------------------------------------------------------------------------- !> !> Is the g-point structure of two objects the same? !>   (same bands, same number of g-points, same mapping between bands and g-points) !> pure function gpoints_are_equal ( this , that ) class ( ty_optical_props ), intent ( in ) :: this , that logical :: gpoints_are_equal gpoints_are_equal = this % bands_are_equal ( that ) . and . & this % get_ngpt () == that % get_ngpt () if (. not . gpoints_are_equal ) return gpoints_are_equal = & all ( this % get_gpoint_bands () == that % get_gpoint_bands ()) end function gpoints_are_equal !> ----------------------------------------------------------------------------------------------- !> !> --- Setting/getting the name !> !> ----------------------------------------------------------------------------------------------- subroutine set_name ( this , name ) class ( ty_optical_props ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: name this % name = trim ( name ) end subroutine set_name ! -------------------------------------------------------- function get_name ( this ) class ( ty_optical_props ), intent ( in ) :: this character ( len = name_len ) :: get_name get_name = trim ( this % name ) end function get_name ! ------------------------------------------------------------------------------------------ end module mo_optical_props","tags":"","loc":"sourcefile/mo_optical_props.f90.html"},{"title":"mo_source_functions.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_source_functions.f90~~EfferentGraph sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_source_functions.f90~~AfferentGraph sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_source_functions Source Code mo_source_functions.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Encapsulate source function arrays for longwave/lw/internal sources !    and shortwave/sw/external source. ! ! ------------------------------------------------------------------------------------------------- module mo_source_functions use mo_rte_kind , only : wp use mo_optical_props , only : ty_optical_props implicit none ! ------------------------------------------------------------------------------------------------- ! ! Type for longwave sources: computed at layer center, at layer edges using !   spectral mapping in each direction separately, and at the surface ! type , extends ( ty_optical_props ), public :: ty_source_func_lw real ( wp ), allocatable , dimension (:,:,:) :: lay_source , & ! Planck source at layer average temperature ! [W/m2] (ncol, nlay, ngpt) lev_source_inc , & ! Planck source at layer edge, lev_source_dec ! [W/m2] (ncol, nlay, ngpt) ! in increasing/decreasing ilay direction ! Includes spectral weighting that accounts for state-dependent ! frequency to g-space mapping real ( wp ), allocatable , dimension (:,: ) :: sfc_source real ( wp ), allocatable , dimension (:,: ) :: sfc_source_Jac ! surface source Jacobian contains generic , public :: alloc => alloc_lw , copy_and_alloc_lw procedure , private :: alloc_lw procedure , private :: copy_and_alloc_lw procedure , public :: is_allocated => is_allocated_lw procedure , public :: finalize => finalize_lw procedure , public :: get_subset => get_subset_range_lw procedure , public :: get_ncol => get_ncol_lw procedure , public :: get_nlay => get_nlay_lw ! validate? end type ty_source_func_lw ! ------------------------------------------------------------------------------------------------- ! ! Type for shortave sources: top-of-domain spectrally-resolved flux ! type , extends ( ty_optical_props ), public :: ty_source_func_sw real ( wp ), allocatable , dimension (:,: ) :: toa_source contains generic , public :: alloc => alloc_sw , copy_and_alloc_sw procedure , private :: alloc_sw procedure , private :: copy_and_alloc_sw procedure , public :: is_allocated => is_allocated_sw procedure , public :: finalize => finalize_sw procedure , public :: get_subset => get_subset_range_sw procedure , public :: get_ncol => get_ncol_sw ! validate? end type ty_source_func_sw ! ------------------------------------------------------------------------------------------------- contains ! ------------------------------------------------------------------------------------------ ! !  Routines for initialization, validity checking, finalization ! ! ------------------------------------------------------------------------------------------ ! ! Longwave ! ! ------------------------------------------------------------------------------------------ pure function is_allocated_lw ( this ) class ( ty_source_func_lw ), intent ( in ) :: this logical :: is_allocated_lw is_allocated_lw = this % is_initialized () . and . & allocated ( this % sfc_source ) end function is_allocated_lw ! -------------------------------------------------------------- function alloc_lw ( this , ncol , nlay ) result ( err_message ) class ( ty_source_func_lw ), intent ( inout ) :: this integer , intent ( in ) :: ncol , nlay character ( len = 128 ) :: err_message integer :: ngpt err_message = \"\" if (. not . this % is_initialized ()) & err_message = \"source_func_lw%alloc: not initialized so can't allocate\" if ( any ([ ncol , nlay ] <= 0 )) & err_message = \"source_func_lw%alloc: must provide positive extents for ncol, nlay\" if ( err_message /= \"\" ) return if ( allocated ( this % sfc_source )) deallocate ( this % sfc_source ) if ( allocated ( this % sfc_source_Jac )) deallocate ( this % sfc_source_Jac ) if ( allocated ( this % lay_source )) deallocate ( this % lay_source ) if ( allocated ( this % lev_source_inc )) deallocate ( this % lev_source_inc ) if ( allocated ( this % lev_source_dec )) deallocate ( this % lev_source_dec ) ngpt = this % get_ngpt () allocate ( this % sfc_source ( ncol , ngpt ), this % lay_source ( ncol , nlay , ngpt ), & this % lev_source_inc ( ncol , nlay , ngpt ), this % lev_source_dec ( ncol , nlay , ngpt )) allocate ( this % sfc_source_Jac ( ncol , ngpt )) end function alloc_lw ! -------------------------------------------------------------- function copy_and_alloc_lw ( this , ncol , nlay , spectral_desc ) result ( err_message ) class ( ty_source_func_lw ), intent ( inout ) :: this integer , intent ( in ) :: ncol , nlay class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len = 128 ) :: err_message err_message = \"\" if (. not . spectral_desc % is_initialized ()) then err_message = \"source_func_lw%alloc: spectral_desc not initialized\" return end if call this % finalize () err_message = this % init ( spectral_desc ) if ( err_message /= \"\" ) return err_message = this % alloc ( ncol , nlay ) end function copy_and_alloc_lw ! ------------------------------------------------------------------------------------------ ! ! Shortwave ! ! ------------------------------------------------------------------------------------------ pure function is_allocated_sw ( this ) class ( ty_source_func_sw ), intent ( in ) :: this logical :: is_allocated_sw is_allocated_sw = this % ty_optical_props % is_initialized () . and . & allocated ( this % toa_source ) end function is_allocated_sw ! -------------------------------------------------------------- function alloc_sw ( this , ncol ) result ( err_message ) class ( ty_source_func_sw ), intent ( inout ) :: this integer , intent ( in ) :: ncol character ( len = 128 ) :: err_message err_message = \"\" if (. not . this % is_initialized ()) & err_message = \"source_func_sw%alloc: not initialized so can't allocate\" if ( ncol <= 0 ) & err_message = \"source_func_sw%alloc: must provide positive extents for ncol\" if ( err_message /= \"\" ) return if ( allocated ( this % toa_source )) deallocate ( this % toa_source ) allocate ( this % toa_source ( ncol , this % get_ngpt ())) end function alloc_sw ! -------------------------------------------------------------- function copy_and_alloc_sw ( this , ncol , spectral_desc ) result ( err_message ) class ( ty_source_func_sw ), intent ( inout ) :: this integer , intent ( in ) :: ncol class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len = 128 ) :: err_message err_message = \"\" if (. not . spectral_desc % is_initialized ()) then err_message = \"source_func_sw%alloc: spectral_desc not initialized\" return end if err_message = this % init ( spectral_desc ) if ( err_message /= \"\" ) return err_message = this % alloc ( ncol ) end function copy_and_alloc_sw ! ------------------------------------------------------------------------------------------ ! ! Finalization (memory deallocation) ! ! ------------------------------------------------------------------------------------------ subroutine finalize_lw ( this ) class ( ty_source_func_lw ), intent ( inout ) :: this if ( allocated ( this % lay_source )) deallocate ( this % lay_source ) if ( allocated ( this % lev_source_inc )) deallocate ( this % lev_source_inc ) if ( allocated ( this % lev_source_dec )) deallocate ( this % lev_source_dec ) if ( allocated ( this % sfc_source )) deallocate ( this % sfc_source ) if ( allocated ( this % sfc_source_Jac )) deallocate ( this % sfc_source_Jac ) call this % ty_optical_props % finalize () end subroutine finalize_lw ! -------------------------------------------------------------- subroutine finalize_sw ( this ) class ( ty_source_func_sw ), intent ( inout ) :: this if ( allocated ( this % toa_source )) deallocate ( this % toa_source ) call this % ty_optical_props % finalize () end subroutine finalize_sw ! ------------------------------------------------------------------------------------------ ! !  Routines for finding the problem size ! ! ------------------------------------------------------------------------------------------ pure function get_ncol_lw ( this ) class ( ty_source_func_lw ), intent ( in ) :: this integer :: get_ncol_lw if ( this % is_allocated ()) then get_ncol_lw = size ( this % lay_source , 1 ) else get_ncol_lw = 0 end if end function get_ncol_lw ! -------------------------------------------------------------- pure function get_nlay_lw ( this ) class ( ty_source_func_lw ), intent ( in ) :: this integer :: get_nlay_lw if ( this % is_allocated ()) then get_nlay_lw = size ( this % lay_source , 2 ) else get_nlay_lw = 0 end if end function get_nlay_lw ! -------------------------------------------------------------- pure function get_ncol_sw ( this ) class ( ty_source_func_sw ), intent ( in ) :: this integer :: get_ncol_sw if ( this % is_allocated ()) then get_ncol_sw = size ( this % toa_source , 1 ) else get_ncol_sw = 0 end if end function get_ncol_sw ! ------------------------------------------------------------------------------------------ ! !  Routines for subsetting ! ! ------------------------------------------------------------------------------------------ function get_subset_range_lw ( full , start , n , subset ) result ( err_message ) class ( ty_source_func_lw ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_source_func_lw ), intent ( inout ) :: subset character ( 128 ) :: err_message err_message = \"\" if (. not . full % is_allocated ()) then err_message = \"source_func_lw%subset: Asking for a subset of unallocated data\" return end if if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return ! ! Could check to see if subset is correctly sized, has consistent spectral discretization ! if ( subset % is_allocated ()) call subset % finalize () err_message = subset % alloc ( n , full % get_nlay (), full ) if ( err_message /= \"\" ) return subset % sfc_source ( 1 : n , :) = full % sfc_source ( start : start + n - 1 , :) subset % sfc_source_Jac ( 1 : n , :) = full % sfc_source_Jac ( start : start + n - 1 , :) subset % lay_source ( 1 : n ,:,:) = full % lay_source ( start : start + n - 1 ,:,:) subset % lev_source_inc ( 1 : n ,:,:) = full % lev_source_inc ( start : start + n - 1 ,:,:) subset % lev_source_dec ( 1 : n ,:,:) = full % lev_source_dec ( start : start + n - 1 ,:,:) end function get_subset_range_lw ! ------------------------------------------------------------------------------------------ function get_subset_range_sw ( full , start , n , subset ) result ( err_message ) class ( ty_source_func_sw ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_source_func_sw ), intent ( inout ) :: subset character ( 128 ) :: err_message err_message = \"\" if (. not . full % is_allocated ()) then err_message = \"source_func_sw%subset: Asking for a subset of unallocated data\" return end if if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return ! ! Could check to see if subset is correctly sized, has consistent spectral discretization ! if ( subset % is_allocated ()) call subset % finalize () ! Seems like I should be able to call \"alloc\" generically but the compilers are complaining err_message = subset % copy_and_alloc_sw ( n , full ) subset % toa_source ( 1 : n , :) = full % toa_source ( start : start + n - 1 , :) end function get_subset_range_sw end module mo_source_functions","tags":"","loc":"sourcefile/mo_source_functions.f90.html"},{"title":"mo_rte_util_array.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rte_util_array.f90~~EfferentGraph sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rte_util_array.f90~~AfferentGraph sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_solver_kernels.f90 mo_rte_solver_kernels.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_solver_kernels.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_solver_kernels.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_cloud_optics.f90 mo_cloud_optics.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics_kernels.f90 mo_gas_optics_kernels.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics_kernels.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_gas_optics_kernels.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_heating_rates.f90 mo_heating_rates.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_gas_optics_kernels.f90~2 mo_gas_optics_kernels.F90 sourcefile~mo_gas_optics_kernels.f90~2->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_solver_kernels.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_solver_kernels.f90~2 mo_rte_solver_kernels.F90 sourcefile~mo_rte_solver_kernels.f90~2->sourcefile~mo_rte_util_array.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_cloud_sampling.f90 mo_cloud_sampling.F90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_util_array Source Code mo_rte_util_array.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2019,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- module mo_rte_util_array ! ! This module provide utilites for sanitizing input arrays: !    checking values and sizes ! These are in a module so code can be written for both CPUs and GPUs ! Used only by Fortran classes so routines don't need C bindings and can use assumed-shape ! use mo_rte_kind , only : wp , wl implicit none interface any_vals_less_than module procedure any_vals_less_than_1D , any_vals_less_than_2D , any_vals_less_than_3D module procedure any_vals_less_than_1D_masked , any_vals_less_than_2D_masked , any_vals_less_than_3D_masked end interface interface any_vals_outside module procedure any_vals_outside_1D , any_vals_outside_2D , any_vals_outside_3D module procedure any_vals_outside_1D_masked , any_vals_outside_2D_masked , any_vals_outside_3D_masked end interface interface zero_array module procedure zero_array_1D , zero_array_2D , zero_array_3D , zero_array_4D end interface interface extents_are module procedure extents_are_1D , extents_are_2D , extents_are_3D module procedure extents_are_4D , extents_are_5D , extents_are_6D module procedure extents_are_2d_int end interface extents_are private public :: any_vals_less_than , any_vals_outside , extents_are , zero_array contains !------------------------------------------------------------------------------------------------- ! Values less than a floor !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_1D ( array , check_value ) real ( wp ), dimension (:), intent ( in ) :: array real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array) !$omp target map(to:array) map(from:minValue) minValue = minval ( array ) !$acc end kernels !$omp end target any_vals_less_than_1D = ( minValue < check_value ) end function any_vals_less_than_1D !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_2D ( array , check_value ) real ( wp ), dimension (:,:), intent ( in ) :: array real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array) !$omp target map(to:array) map(from:minValue) minValue = minval ( array ) !$acc end kernels !$omp end target any_vals_less_than_2D = ( minValue < check_value ) end function any_vals_less_than_2D !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_3D ( array , check_value ) real ( wp ), dimension (:,:,:), intent ( in ) :: array real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue #ifdef _OPENMP integer :: dim1 , dim2 , dim3 , i , j , k dim1 = size ( array , 1 ) dim2 = size ( array , 2 ) dim3 = size ( array , 3 ) minValue = check_value + epsilon ( check_value ) ! initialize to some value !$omp target teams map(to:array) & !$omp defaultmap(tofrom:scalar) reduction(min:minValue) !$omp distribute parallel do simd reduction(min:minValue) do i = 1 , dim1 do j = 1 , dim2 do k = 1 , dim3 minValue = min ( minValue , array ( i , j , k )) enddo enddo enddo !$omp end target teams #else !$acc kernels copyin(array) minValue = minval ( array ) !$acc end kernels #endif any_vals_less_than_3D = ( minValue < check_value ) end function any_vals_less_than_3D !------------------------------------------------------------------------------------------------- ! Masked versions !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_1D_masked ( array , mask , check_value ) real ( wp ), dimension (:), intent ( in ) :: array logical ( wl ), dimension (:), intent ( in ) :: mask real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array) !$omp target map(to:array, mask) map(from:minValue) minValue = minval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_less_than_1D_masked = ( minValue < check_value ) end function any_vals_less_than_1D_masked !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_2D_masked ( array , mask , check_value ) real ( wp ), dimension (:,:), intent ( in ) :: array logical ( wl ), dimension (:,:), intent ( in ) :: mask real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array) !$omp target map(to:array, mask) map(from:minValue) minValue = minval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_less_than_2D_masked = ( minValue < check_value ) end function any_vals_less_than_2D_masked !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_3D_masked ( array , mask , check_value ) real ( wp ), dimension (:,:,:), intent ( in ) :: array logical ( wl ), dimension (:,:,:), intent ( in ) :: mask real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array) !$omp target map(to:array, mask) map(from:minValue) minValue = minval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_less_than_3D_masked = ( minValue < check_value ) end function any_vals_less_than_3D_masked !------------------------------------------------------------------------------------------------- ! Values outside a range !------------------------------------------------------------------------------------------------- logical function any_vals_outside_1D ( array , checkMin , checkMax ) real ( wp ), dimension (:), intent ( in ) :: array real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array) !$omp target map(to:array) map(from:minValue, maxValue) minValue = minval ( array ) maxValue = maxval ( array ) !$acc end kernels !$omp end target any_vals_outside_1D = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_1D ! ---------------------------------------------------------- logical function any_vals_outside_2D ( array , checkMin , checkMax ) real ( wp ), dimension (:,:), intent ( in ) :: array real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array) !$omp target map(to:array) map(from:minValue, maxValue) minValue = minval ( array ) maxValue = maxval ( array ) !$acc end kernels !$omp end target any_vals_outside_2D = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_2D ! ---------------------------------------------------------- logical function any_vals_outside_3D ( array , checkMin , checkMax ) real ( wp ), dimension (:,:,:), intent ( in ) :: array real ( wp ), intent ( in ) :: checkMin , checkMax ! Compact version using intrinsics below ! but an explicit loop is the only current solution on GPUs real ( wp ) :: minValue , maxValue #ifdef _OPENMP integer :: dim1 , dim2 , dim3 , i , j , k dim1 = size ( array , 1 ) dim2 = size ( array , 2 ) dim3 = size ( array , 3 ) minValue = checkMin + epsilon ( checkMin ) ! initialize to some value maxValue = checkMax - epsilon ( checkMax ) ! initialize to some value !$omp target teams map(to:array) & !$omp defaultmap(tofrom:scalar) reduction(min:minValue) reduction(max:maxValue) !$omp distribute parallel do simd reduction(min:minValue) reduction(max:maxValue) do i = 1 , dim1 do j = 1 , dim2 do k = 1 , dim3 minValue = min ( minValue , array ( i , j , k )) maxValue = max ( maxValue , array ( i , j , k )) enddo enddo enddo !$omp end target teams #else !$acc kernels copyin(array) minValue = minval ( array ) maxValue = maxval ( array ) !$acc end kernels #endif any_vals_outside_3D = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_3D ! ---------------------------------------------------------- ! Masked versions ! ---------------------------------------------------------- logical function any_vals_outside_1D_masked ( array , mask , checkMin , checkMax ) real ( wp ), dimension (:), intent ( in ) :: array logical ( wl ), dimension (:), intent ( in ) :: mask real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array) !$omp target map(to:array, mask) map(from:minValue, maxValue) minValue = minval ( array , mask = mask ) maxValue = maxval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_outside_1D_masked = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_1D_masked ! ---------------------------------------------------------- logical function any_vals_outside_2D_masked ( array , mask , checkMin , checkMax ) real ( wp ), dimension (:,:), intent ( in ) :: array logical ( wl ), dimension (:,:), intent ( in ) :: mask real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array) !$omp target map(to:array, mask) map(from:minValue, maxValue) minValue = minval ( array , mask = mask ) maxValue = maxval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_outside_2D_masked = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_2D_masked ! ---------------------------------------------------------- logical function any_vals_outside_3D_masked ( array , mask , checkMin , checkMax ) real ( wp ), dimension (:,:,:), intent ( in ) :: array logical ( wl ), dimension (:,:,:), intent ( in ) :: mask real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array) !$omp target map(to:array, mask) map(from:minValue, maxValue) minValue = minval ( array , mask = mask ) maxValue = maxval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_outside_3D_masked = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_3D_masked !-------------------------------------------------------------------------------------------------------------------- ! ! Extents ! ! -------------------------------------------------------------------------------------- function extents_are_1d ( array , n1 ) real ( wp ), dimension (: ), intent ( in ) :: array integer , intent ( in ) :: n1 logical ( wl ) :: extents_are_1d extents_are_1d = ( size ( array , 1 ) == n1 ) end function extents_are_1d ! -------------------------------------------------------------------------------------- function extents_are_2d ( array , n1 , n2 ) real ( wp ), dimension (:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 logical ( wl ) :: extents_are_2d extents_are_2d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 ) end function extents_are_2d ! -------------------------------------------------------------------------------------- function extents_are_3d ( array , n1 , n2 , n3 ) real ( wp ), dimension (:,:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 , n3 logical ( wl ) :: extents_are_3d extents_are_3d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 . and . & size ( array , 3 ) == n3 ) end function extents_are_3d ! -------------------------------------------------------------------------------------- function extents_are_4d ( array , n1 , n2 , n3 , n4 ) real ( wp ), dimension (:,:,:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 , n3 , n4 logical ( wl ) :: extents_are_4d extents_are_4d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 . and . & size ( array , 3 ) == n3 . and . & size ( array , 4 ) == n4 ) end function extents_are_4d ! -------------------------------------------------------------------------------------- function extents_are_5d ( array , n1 , n2 , n3 , n4 , n5 ) real ( wp ), dimension (:,:,:,:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 , n3 , n4 , n5 logical ( wl ) :: extents_are_5d extents_are_5d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 . and . & size ( array , 3 ) == n3 . and . & size ( array , 4 ) == n4 . and . & size ( array , 5 ) == n5 ) end function extents_are_5d ! -------------------------------------------------------------------------------------- function extents_are_6d ( array , n1 , n2 , n3 , n4 , n5 , n6 ) real ( wp ), dimension (:,:,:,:,:,:), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 , n3 , n4 , n5 , n6 logical ( wl ) :: extents_are_6d extents_are_6d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 . and . & size ( array , 3 ) == n3 . and . & size ( array , 4 ) == n4 . and . & size ( array , 5 ) == n5 . and . & size ( array , 6 ) == n6 ) end function extents_are_6d ! -------------------------------------------------------------------------------------- function extents_are_2d_int ( array , n1 , n2 ) integer , dimension (:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 logical ( wl ) :: extents_are_2d_int extents_are_2d_int = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 ) end function extents_are_2d_int !------------------------------------------------------------------------------------------------- ! Initializing arrays to 0 !------------------------------------------------------------------------------------------------- subroutine zero_array_1D ( ni , array ) bind ( C , name = \"zero_array_1D\" ) integer , intent ( in ) :: ni real ( wp ), dimension ( ni ), intent ( out ) :: array ! ----------------------- integer :: i ! ----------------------- !$acc parallel loop copyout(array) !$omp target teams distribute parallel do simd map(from:array) do i = 1 , ni array ( i ) = 0.0_wp end do end subroutine zero_array_1D ! ---------------------------------------------------------- subroutine zero_array_2D ( ni , nj , array ) bind ( C , name = \"zero_array_2D\" ) integer , intent ( in ) :: ni , nj real ( wp ), dimension ( ni , nj ), intent ( out ) :: array ! ----------------------- integer :: i , j ! ----------------------- !$acc parallel loop collapse(2) copyout(array) !$omp target teams distribute parallel do simd collapse(2) map(from:array) do j = 1 , nj do i = 1 , ni array ( i , j ) = 0.0_wp end do end do end subroutine zero_array_2D ! ---------------------------------------------------------- subroutine zero_array_3D ( ni , nj , nk , array ) bind ( C , name = \"zero_array_3D\" ) integer , intent ( in ) :: ni , nj , nk real ( wp ), dimension ( ni , nj , nk ), intent ( out ) :: array ! ----------------------- integer :: i , j , k ! ----------------------- !$acc parallel loop collapse(3) copyout(array) !$omp target teams distribute parallel do simd collapse(3) map(from:array) do k = 1 , nk do j = 1 , nj do i = 1 , ni array ( i , j , k ) = 0.0_wp end do end do end do end subroutine zero_array_3D ! ---------------------------------------------------------- subroutine zero_array_4D ( ni , nj , nk , nl , array ) bind ( C , name = \"zero_array_4D\" ) integer , intent ( in ) :: ni , nj , nk , nl real ( wp ), dimension ( ni , nj , nk , nl ), intent ( out ) :: array ! ----------------------- integer :: i , j , k , l ! ----------------------- !$acc parallel loop collapse(4) copyout(array) !$omp target teams distribute parallel do simd collapse(4) map(from:array) do l = 1 , nl do k = 1 , nk do j = 1 , nj do i = 1 , ni array ( i , j , k , l ) = 0.0_wp end do end do end do end do end subroutine zero_array_4D end module mo_rte_util_array","tags":"","loc":"sourcefile/mo_rte_util_array.f90.html"},{"title":"mo_rte_solver_kernels.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rte_solver_kernels.f90~~EfferentGraph sourcefile~mo_rte_solver_kernels.f90 mo_rte_solver_kernels.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rte_solver_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_rte_solver_kernels.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rte_solver_kernels.f90~~AfferentGraph sourcefile~mo_rte_solver_kernels.f90 mo_rte_solver_kernels.F90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_solver_kernels.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_solver_kernels.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_solver_kernels Source Code mo_rte_solver_kernels.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2021,  Atmospheric and Environmental Research, ! Regents of the University of Colorado, Trustees of Columbia University.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Numeric calculations for radiative transfer solvers. !   Emission/absorption (no-scattering) calculations !     solver for multi-angle Gaussian quadrature !     solver for a single angle, calling !       source function computation (linear-in-tau) !       transport !   Extinction-only calculation (direct solar beam) !   Two-stream calculations !     solvers for LW and SW with different boundary conditions and source functions !       source function calculation for LW, SW !       two-stream calculations for LW, SW (using different assumtions about phase function) !       transport (adding) !   Application of boundary conditions ! ! ------------------------------------------------------------------------------------------------- module mo_rte_solver_kernels use , intrinsic :: iso_c_binding use mo_rte_kind , only : wp , wl use mo_rte_util_array , only : zero_array implicit none private public :: lw_solver_noscat , lw_solver_noscat_GaussQuad , lw_solver_2stream , & sw_solver_noscat , sw_solver_2stream interface add_arrays module procedure add_arrays_2D , add_arrays_3D end interface real ( wp ), parameter :: pi = acos ( - 1._wp ) contains ! ------------------------------------------------------------------------------------------------- ! ! Top-level longwave kernels ! ! ------------------------------------------------------------------------------------------------- ! ! LW fluxes, no scattering, mu (cosine of integration angle) specified by column !   Does radiation calculation at user-supplied angles; converts radiances to flux !   using user-supplied weights ! ! --------------------------------------------------------------- subroutine lw_solver_noscat ( ncol , nlay , ngpt , top_at_1 , D , weight , & tau , lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & incident_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) bind ( C , name = \"lw_solver_noscat\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: D ! secant of propagation angle  [] real ( wp ), intent ( in ) :: weight ! quadrature weight real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] ! Planck source at layer edge for radiation in increasing/decreasing ilay direction ! lev_source_dec applies the mapping in layer i to the Planck function at layer i ! lev_source_inc applies the mapping in layer i to the Planck function at layer i+1 real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( in ) :: lev_source_inc , lev_source_dec real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: incident_flux ! Boundary condition for flux [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ! Optional variables - arrays aren't referenced if corresponding logical  == False ! logical ( wl ), intent ( in ) :: do_broadband real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: broadband_up , broadband_dn ! Spectrally-integrated fluxes [W/m2] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_srcJac ! surface temperature Jacobian of surface source function [W/m2/K] real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: flux_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] logical ( wl ), intent ( in ) :: do_rescaling real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: ssa , g ! single-scattering albedo, asymmetry parameter ! ------------------------------------------------------------------------------------------------- ! Local variables integer :: icol , ilay , ilev , igpt integer :: top_level , sfc_level real ( wp ), dimension ( ncol , nlay , ngpt ) :: tau_loc , & ! path length (tau/mu) trans ! transmissivity  = exp(-tau) real ( wp ), dimension ( ncol , nlay , ngpt ) :: source_dn , source_up real ( wp ), dimension (:,:,:), pointer :: lev_source_up , lev_source_dn ! Mapping increasing/decreasing indicies to up/down real ( wp ), parameter :: pi = acos ( - 1._wp ) ! ! For Jacobians ! real ( wp ), dimension ( ncol , nlay + 1 , ngpt ) :: gpt_Jac ! ! Used when approximating scattering ! real ( wp ) :: ssal , wb , scaleTau , scaling real ( wp ), dimension ( ncol , nlay , ngpt ) :: An , Cn ! ------------------------------------ ! Which way is up? ! Level Planck sources for upward and downward radiation ! When top_at_1, lev_source_up => lev_source_dec !                lev_source_dn => lev_source_inc, and vice-versa if ( top_at_1 ) then top_level = 1 sfc_level = nlay + 1 lev_source_up => lev_source_dec lev_source_dn => lev_source_inc else top_level = nlay + 1 sfc_level = 1 lev_source_up => lev_source_inc lev_source_dn => lev_source_dec end if !$acc        data create(   tau_loc,trans,source_dn,source_up ) & !$acc             copyin(   D, tau,lev_source_up,lev_source_dn) !$omp target data map(alloc:tau_loc,trans,source_dn,source_up ) & !$omp             map(to:   D, tau,lev_source_up,lev_source_dn) !$acc        enter data create(   flux_dn,flux_up) !$omp target enter data map(alloc:flux_dn,flux_up) !$acc                         parallel loop    collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ! ! Transport is for intensity !   convert flux at top of domain to intensity assuming azimuthal isotropy ! flux_dn ( icol , top_level , igpt ) = incident_flux ( icol , igpt ) / ( 2._wp * pi * weight ) end do end do !$acc        data create(   An, Cn)  copyin(g)          if(do_rescaling) !$omp target data map(alloc:An, Cn)  map(to:g)          if(do_rescaling) !$acc        data copyin(sfc_srcJac) create(   gpt_Jac) if(do_Jacobians) !$omp target data map(to:sfc_srcJac) map(alloc:gpt_Jac) if(do_Jacobians) !$acc parallel loop no_create(An, Cn, gpt_Jac, g) collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! ! The wb and scaleTau terms are independent of propagation !   angle D and could be pre-computed if several values of D are used ! We re-compute them here to keep not have to localize memory use ! if ( do_rescaling ) then ssal = ssa ( icol , ilay , igpt ) wb = ssal * ( 1._wp - g ( icol , ilay , igpt )) * 0.5_wp scaleTau = ( 1._wp - ssal + wb ) ! here wb/scaleTau is parameter wb/(1-w(1-b)) of Eq.21 of the Tang paper ! actually it is in line of parameter rescaling defined in Eq.7 ! potentialy if g=ssa=1  then  wb/scaleTau = NaN ! it should not happen because g is never 1 in atmospheres ! explanation of factor 0.4 note A of Table Cn ( icol , ilay , igpt ) = 0.4_wp * wb / scaleTau ! Eq.15 of the paper, multiplied by path length tau_loc ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) * D ( icol , igpt ) * scaleTau trans ( icol , ilay , igpt ) = exp ( - tau_loc ( icol , ilay , igpt )) An ( icol , ilay , igpt ) = ( 1._wp - trans ( icol , ilay , igpt ) ** 2 ) else ! ! Optical path and transmission, used in source function and transport calculations ! tau_loc ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) * D ( icol , igpt ) trans ( icol , ilay , igpt ) = exp ( - tau_loc ( icol , ilay , igpt )) end if call lw_source_noscat ( lay_source ( icol , ilay , igpt ), & lev_source_up ( icol , ilay , igpt ), lev_source_dn ( icol , ilay , igpt ), & tau_loc ( icol , ilay , igpt ), trans ( icol , ilay , igpt ), & source_dn ( icol , ilay , igpt ), source_up ( icol , ilay , igpt )) end do end do end do ! ! Transport down ! call lw_transport_noscat_dn ( ncol , nlay , ngpt , top_at_1 , trans , source_dn , flux_dn ) ! ! Surface reflection and emission ! !$acc                         parallel loop    collapse(2) no_create(gpt_Jac, sfc_srcJac) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ! ! Surface albedo, surface source function ! flux_up ( icol , sfc_level , igpt ) = flux_dn ( icol , sfc_level , igpt ) * ( 1._wp - sfc_emis ( icol , igpt )) + & sfc_src ( icol , igpt ) * sfc_emis ( icol , igpt ) if ( do_Jacobians ) & gpt_Jac ( icol , sfc_level , igpt ) = sfc_srcJac ( icol , igpt ) * sfc_emis ( icol , igpt ) end do end do ! ! Transport up, or up and down again if using rescaling ! if ( do_rescaling ) then call lw_transport_1rescl ( ncol , nlay , ngpt , top_at_1 , trans , & source_dn , source_up , & flux_up , flux_dn , An , Cn , & do_Jacobians , gpt_Jac ) else call lw_transport_noscat_up ( ncol , nlay , ngpt , top_at_1 , trans , source_up , flux_up , & do_Jacobians , gpt_Jac ) end if if ( do_broadband ) then ! ! Broadband reduction including !   conversion from intensity to flux assuming azimuthal isotropy and quadrature weight ! call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , flux_dn , broadband_dn ) call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , flux_up , broadband_up ) !$acc        exit data delete(     flux_dn,flux_up) !$omp target exit data map(release:flux_dn,flux_up) else ! ! Convert intensity to flux assuming azimuthal isotropy and quadrature weight ! call apply_factor_3D ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , flux_dn ) call apply_factor_3D ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , flux_up ) !$acc        exit data copyout( flux_dn,flux_up) !$omp target exit data map(from:flux_dn,flux_up) end if ! ! Only broadband-integrated Jacobians are provided ! if ( do_Jacobians ) then call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 2._wp * pi * weight , gpt_Jac , flux_upJac ) end if !$acc        end data !$omp end target data !$acc        end data !$omp end target data !$acc        end data !$omp end target data end subroutine lw_solver_noscat ! --------------------------------------------------------------- ! ! LW transport, no scattering, multi-angle quadrature !   Users provide a set of weights and quadrature angles !   Routine sums over single-angle solutions for each sets of angles/weights ! ! --------------------------------------------------------------- subroutine lw_solver_noscat_GaussQuad ( ncol , nlay , ngpt , top_at_1 , & nmus , Ds , weights , & tau , & lay_source , lev_source_inc , lev_source_dec , & sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) bind ( C , name = \"lw_solver_noscat_GaussQuad\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 integer , intent ( in ) :: nmus ! number of quadrature angles real ( wp ), dimension ( ncol , ngpt , & nmus ), intent ( in ) :: Ds real ( wp ), dimension ( nmus ), intent ( in ) :: weights ! quadrature secants, weights real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_source_inc ! Planck source at layer edge for radiation in increasing ilay direction [W/m2] ! Includes spectral weighting that accounts for state-dependent frequency to g-space mapping real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_source_dec ! Planck source at layer edge for radiation in decreasing ilay direction [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux ! Incident diffuse flux, probably 0 [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ! Optional variables - arrays aren't referenced if corresponding logical  == False ! logical ( wl ), intent ( in ) :: do_broadband real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( inout ) :: broadband_up , broadband_dn ! Spectrally-integrated fluxes [W/m2] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_srcJac ! surface temperature Jacobian of surface source function [W/m2/K] real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( out ) :: flux_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] logical ( wl ), intent ( in ) :: do_rescaling real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: ssa , g ! single-scattering albedo, asymmetry parameter ! ------------------------------------ ! ! Local variables ! real ( wp ), dimension (:,:,:), pointer :: this_flux_up , this_flux_dn real ( wp ), dimension (:,:), pointer :: this_broadband_up , this_broadband_dn , this_flux_upJac integer :: icol , ilev , igpt , imu ! ------------------------------------ !$acc        data copyin(Ds, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src) !$omp target data map(to:Ds, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src) !$acc        data copyout( flux_up, flux_dn)             if (.not. do_broadband) !$omp target data map(from:flux_up, flux_dn)             if (.not. do_broadband) !$acc        data copyout( broadband_up, broadband_dn)   if (      do_broadband) !$omp target data map(from:broadband_up, broadband_dn)   if (      do_broadband) !$acc        data copyin(sfc_srcJac)   copyout(flux_upJac) if (do_Jacobians) !$omp target data map(to:sfc_srcJac), map(from:flux_upJac) if (do_Jacobians) if ( do_broadband ) then this_broadband_up => broadband_up this_broadband_dn => broadband_dn allocate ( this_flux_up ( ncol , nlay + 1 , ngpt ), this_flux_dn ( ncol , nlay + 1 , ngpt )) else this_flux_up => flux_up this_flux_dn => flux_dn ! Spectrally-integrated fluxes won't be filled in allocate ( this_broadband_up ( ncol , nlay + 1 ), this_broadband_dn ( ncol , nlay + 1 )) end if !$acc        data create(   this_broadband_up, this_broadband_dn, this_flux_up, this_flux_dn) !$omp target data map(alloc:this_broadband_up, this_broadband_dn, this_flux_up, this_flux_dn) call lw_solver_noscat ( ncol , nlay , ngpt , & top_at_1 , Ds (:,:, 1 ), weights ( 1 ), tau , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & this_flux_up , this_flux_dn , & do_broadband , this_broadband_up , this_broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) !$acc end data !$omp end target data if ( nmus > 1 ) then ! ! For more than one angle use local arrays ! if ( do_broadband ) then nullify ( this_broadband_up , this_broadband_dn ) allocate ( this_broadband_up ( ncol , nlay + 1 ), this_broadband_dn ( ncol , nlay + 1 )) else nullify ( this_flux_up , this_flux_dn ) allocate ( this_flux_up ( ncol , nlay + 1 , ngpt ), this_flux_dn ( ncol , nlay + 1 , ngpt )) end if if ( do_Jacobians ) then allocate ( this_flux_upJac ( ncol , nlay + 1 )) else this_flux_upJac => flux_upJac end if ! ! For more than one angle use local arrays ! !$acc        data create(   this_broadband_up, this_broadband_dn, this_flux_up, this_flux_dn) !$omp target data map(alloc:this_broadband_up, this_broadband_dn, this_flux_up, this_flux_dn) do imu = 2 , nmus call lw_solver_noscat ( ncol , nlay , ngpt , & top_at_1 , Ds (:,:, imu ), weights ( imu ), tau , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & this_flux_up , this_flux_dn , & do_broadband , this_broadband_up , this_broadband_dn , & do_Jacobians , sfc_srcJac , this_flux_upJac , & do_rescaling , ssa , g ) if ( do_broadband ) then call add_arrays ( ncol , nlay + 1 , this_broadband_up , broadband_up ) call add_arrays ( ncol , nlay + 1 , this_broadband_dn , broadband_dn ) else call add_arrays ( ncol , nlay + 1 , ngpt , flux_up , this_flux_up ) call add_arrays ( ncol , nlay + 1 , ngpt , flux_dn , this_flux_dn ) end if if ( do_Jacobians ) then call add_arrays ( ncol , nlay + 1 , this_flux_upJac , flux_upJac ) end if end do !$acc end data !$omp end target data end if !$acc end data !$omp end target data !$acc end data !$omp end target data !$acc end data !$omp end target data !$acc end data !$omp end target data ! Cleanup if (. not . associated ( this_broadband_up , broadband_up )) then deallocate ( this_broadband_up , this_broadband_dn ) end if if (. not . associated ( this_flux_up , flux_up )) then deallocate ( this_flux_up , this_flux_dn ) end if if ( nmus > 1 . and . do_Jacobians ) then deallocate ( this_flux_upJac ) end if end subroutine lw_solver_noscat_GaussQuad ! ------------------------------------------------------------------------------------------------- ! ! Longwave two-stream calculation: !   combine RRTMGP-specific sources at levels !   compute layer reflectance, transmittance !   compute total source function at levels using linear-in-tau !   transport ! ! ------------------------------------------------------------------------------------------------- subroutine lw_solver_2stream ( ncol , nlay , ngpt , top_at_1 , & tau , ssa , g , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn ) bind ( C , name = \"lw_solver_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , & ! Optical thickness, ssa , & ! single-scattering albedo, g ! asymmetry parameter [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( in ) :: lev_source_inc , lev_source_dec ! Planck source at layer edge for radiation in increasing/decreasing ilay direction [W/m2] ! Includes spectral weighting that accounts for state-dependent frequency to g-space mapping real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux ! Incident diffuse flux, probably 0 [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ---------------------------------------------------------------------- integer :: icol , igpt , top_level real ( wp ), dimension ( ncol , nlay , ngpt ) :: Rdif , Tdif , gamma1 , gamma2 real ( wp ), dimension ( ncol , ngpt ) :: sfc_albedo real ( wp ), dimension ( ncol , nlay + 1 , ngpt ) :: lev_source real ( wp ), dimension ( ncol , nlay , ngpt ) :: source_dn , source_up real ( wp ), dimension ( ncol , ngpt ) :: source_sfc ! ------------------------------------ ! ------------------------------------ !$acc enter data copyin(tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, flux_dn) !$omp target enter data map(to:tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, flux_dn) !$acc enter data create(flux_up, Rdif, Tdif, gamma1, gamma2, sfc_albedo, lev_source, source_dn, source_up, source_sfc) !$omp target enter data map(alloc:flux_up, Rdif, Tdif, gamma1, gamma2, sfc_albedo, lev_source, source_dn, source_up, source_sfc) ! ! RRTMGP provides source functions at each level using the spectral mapping !   of each adjacent layer. Combine these for two-stream calculations ! top_level = nlay + 1 if ( top_at_1 ) top_level = 1 call lw_combine_sources ( ncol , nlay , ngpt , top_at_1 , & lev_source_inc , lev_source_dec , & lev_source ) ! ! Cell properties: reflection, transmission for diffuse radiation !   Coupling coefficients needed for source function ! call lw_two_stream ( ncol , nlay , ngpt , & tau , ssa , g , & gamma1 , gamma2 , Rdif , Tdif ) ! ! Source function for diffuse radiation ! call lw_source_2str ( ncol , nlay , ngpt , top_at_1 , & sfc_emis , sfc_src , & lay_source , lev_source , & gamma1 , gamma2 , Rdif , Tdif , tau , & source_dn , source_up , source_sfc ) !$acc                         parallel loop    collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol sfc_albedo ( icol , igpt ) = 1._wp - sfc_emis ( icol , igpt ) flux_dn ( icol , top_level , igpt ) = inc_flux ( icol , igpt ) end do end do ! ! Transport ! call adding ( ncol , nlay , ngpt , top_at_1 , & sfc_albedo , & Rdif , Tdif , & source_dn , source_up , source_sfc , & flux_up , flux_dn ) !$acc exit data delete(tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src) !$omp target exit data map(release:tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src) !$acc exit data delete(Rdif, Tdif, gamma1, gamma2, sfc_albedo, lev_source, source_dn, source_up, source_sfc) !$omp target exit data map(release:Rdif, Tdif, gamma1, gamma2, sfc_albedo, lev_source, source_dn, source_up, source_sfc) !$acc exit data copyout(flux_up, flux_dn) !$omp target exit data map(from:flux_up, flux_dn) end subroutine lw_solver_2stream ! ------------------------------------------------------------------------------------------------- ! !   Top-level shortwave kernels ! ! ------------------------------------------------------------------------------------------------- ! !   Extinction-only i.e. solar direct beam ! ! ------------------------------------------------------------------------------------------------- subroutine sw_solver_noscat ( ncol , nlay , ngpt , top_at_1 , & tau , mu0 , inc_flux_dir , flux_dir ) bind ( C , name = \"sw_solver_noscat\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 ! cosine of solar zenith angle real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux_dir ! Direct beam incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_dir ! Direct-beam flux, spectral [W/m2] integer :: icol , ilev , igpt real ( wp ) :: mu0_inv ( ncol ) ! ------------------------------------ ! ------------------------------------ !$acc enter data copyin(tau, mu0) create(mu0_inv, flux_dir) !$omp target enter data map(to:tau, mu0) map(alloc:mu0_inv, flux_dir) !$acc parallel loop !$omp target teams distribute parallel do simd do icol = 1 , ncol mu0_inv ( icol ) = 1._wp / mu0 ( icol ) enddo ! Indexing into arrays for upward and downward propagation depends on the vertical !   orientation of the arrays (whether the domain top is at the first or last index) ! We write the loops out explicitly so compilers will have no trouble optimizing them. ! Downward propagation if ( top_at_1 ) then ! For the flux at this level, what was the previous level, and which layer has the !   radiation just passed through? ! layer index = level index - 1 ! previous level is up (-1) !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol flux_dir ( icol , 1 , igpt ) = inc_flux_dir ( icol , igpt ) * mu0 ( icol ) do ilev = 2 , nlay + 1 flux_dir ( icol , ilev , igpt ) = flux_dir ( icol , ilev - 1 , igpt ) * exp ( - tau ( icol , ilev , igpt ) * mu0_inv ( icol )) end do end do end do else ! layer index = level index ! previous level is up (+1) !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol flux_dir ( icol , nlay + 1 , igpt ) = inc_flux_dir ( icol , igpt ) * mu0 ( icol ) do ilev = nlay , 1 , - 1 flux_dir ( icol , ilev , igpt ) = flux_dir ( icol , ilev + 1 , igpt ) * exp ( - tau ( icol , ilev , igpt ) * mu0_inv ( icol )) end do end do end do end if !$acc exit data delete(tau, mu0, mu0_inv) copyout(flux_dir) !$omp target exit data map(release:tau, mu0, mu0_inv) map(from:flux_dir) end subroutine sw_solver_noscat ! ------------------------------------------------------------------------------------------------- ! ! Shortwave two-stream calculation: !   compute layer reflectance, transmittance !   compute solar source function for diffuse radiation !   transport ! ! ------------------------------------------------------------------------------------------------- subroutine sw_solver_2stream ( ncol , nlay , ngpt , top_at_1 , & tau , ssa , g , mu0 , & sfc_alb_dir , sfc_alb_dif , & inc_flux_dir , & flux_up , flux_dn , flux_dir , & has_dif_bc , inc_flux_dif , & do_broadband , broadband_up , & broadband_dn , broadband_dir ) bind ( C , name = \"sw_solver_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , & ! Optical thickness, ssa , & ! single-scattering albedo, g ! asymmetry parameter [] real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 ! cosine of solar zenith angle ! Spectral albedo of surface to direct and diffuse radiation real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_alb_dir , sfc_alb_dif , & inc_flux_dir ! Direct beam incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn , flux_dir ! Fluxes [W/m2] logical ( wl ), intent ( in ) :: has_dif_bc ! Is a boundary condition for diffuse flux supplied? real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux_dif ! Boundary condition for diffuse flux logical ( wl ), intent ( in ) :: do_broadband ! Provide broadband-integrated, not spectrally-resolved, fluxes? real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: broadband_up , broadband_dn , broadband_dir ! ------------------------------------------- integer :: icol , ilay , igpt , top_level real ( wp ) :: bb_flux_s , bb_dir_s real ( wp ), dimension ( ncol , nlay , ngpt ) :: Rdif , Tdif real ( wp ), dimension ( ncol , nlay , ngpt ) :: source_up , source_dn real ( wp ), dimension ( ncol , ngpt ) :: source_srf real ( wp ), dimension (:,:,:), pointer :: gpt_flux_up , gpt_flux_dn , gpt_flux_dir ! ------------------------------------ if ( do_broadband ) then allocate ( gpt_flux_up ( ncol , nlay + 1 , ngpt ), & gpt_flux_dn ( ncol , nlay + 1 , ngpt ), & gpt_flux_dir ( ncol , nlay + 1 , ngpt )) else gpt_flux_up => flux_up gpt_flux_dn => flux_dn gpt_flux_dir => flux_dir end if top_level = nlay + 1 if ( top_at_1 ) top_level = 1 ! ! Boundary conditions direct beam... ! !$acc        data create(   gpt_flux_up, gpt_flux_dn, gpt_flux_dir) & !$acc             copyin(   mu0) !$omp target data map(alloc:gpt_flux_up, gpt_flux_dn, gpt_flux_dir) & !$omp             map(to:   mu0) !$acc        data copyout(flux_up, flux_dn, flux_dir) if (.not. do_broadband) !$omp target data map(to: flux_up, flux_dn, flux_dir) if (.not. do_broadband) !$acc  parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol gpt_flux_dir ( icol , top_level , igpt ) = inc_flux_dir ( icol , igpt ) * mu0 ( icol ) end do end do ! ! ... and diffuse field, using 0 if no BC is provided ! if ( has_dif_bc ) then !$acc                         parallel loop    collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol gpt_flux_dn ( icol , top_level , igpt ) = inc_flux_dif ( icol , igpt ) end do end do else !$acc                         parallel loop    collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol gpt_flux_dn ( icol , top_level , igpt ) = 0._wp end do end do end if ! ! Cell properties: transmittance and reflectance for diffuse radiation ! Direct-beam radiation and source for diffuse radiation ! !$acc        data create(   Rdif, Tdif, source_up, source_dn, source_srf) !$omp target data map(alloc:Rdif, Tdif, source_up, source_dn, source_srf) call sw_dif_and_source ( ncol , nlay , ngpt , top_at_1 , mu0 , sfc_alb_dif , & tau , ssa , g , & Rdif , Tdif , source_dn , source_up , source_srf , gpt_flux_dir ) call adding ( ncol , nlay , ngpt , top_at_1 , & sfc_alb_dif , Rdif , Tdif , & source_dn , source_up , source_srf , gpt_flux_up , gpt_flux_dn ) !$acc        end data !$omp end target data if ( do_broadband ) then ! ! Broadband integration ! !$acc        data copyout( broadband_up, broadband_dn, broadband_dir) !$omp target data map(from:broadband_up, broadband_dn, broadband_dir) call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 1._wp , gpt_flux_up , broadband_up ) call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 1._wp , gpt_flux_dn , broadband_dn ) call sum_broadband_factor ( ncol , nlay + 1 , ngpt , 1._wp , gpt_flux_dir , broadband_dir ) ! ! adding computes only diffuse flux; flux_dn is total ! call add_arrays ( ncol , nlay + 1 , broadband_dir , broadband_dn ) !$acc        end data !$omp end target data else ! ! adding computes only diffuse flux; flux_dn is total ! call add_arrays ( ncol , nlay + 1 , ngpt , flux_dir , flux_dn ) end if !$acc        end data !$omp end target data !$acc        end data !$omp end target data if ( do_broadband ) then deallocate ( gpt_flux_up , gpt_flux_dn , gpt_flux_dir ) end if end subroutine sw_solver_2stream ! ------------------------------------------------------------------------------------------------- ! !   Lower-level longwave kernels ! ! --------------------------------------------------------------- ! ! Compute LW source function for upward and downward emission at levels using linear-in-tau assumption ! See Clough et al., 1992, doi: 10.1029/92JD01419, Eq 13 ! This routine implements point-wise stencil, and has to be called in a loop ! ! --------------------------------------------------------------- subroutine lw_source_noscat ( lay_source , lev_source_up , lev_source_dn , tau , trans , & source_dn , source_up ) !$acc routine seq !$omp declare target ! real ( wp ), intent ( in ) :: lay_source , & ! Planck source at layer center lev_source_up , & ! Planck source at levels (layer edges), lev_source_dn , & !   increasing/decreasing layer index tau , & ! Optical path (tau/mu) trans ! Transmissivity (exp(-tau)) real ( wp ), intent ( inout ) :: source_dn , source_up ! Source function at layer edges ! Down at the bottom of the layer, up at the top ! -------------------------------- real ( wp ), parameter :: tau_thresh = sqrt ( epsilon ( tau )) real ( wp ) :: fact ! --------------------------------------------------------------- ! ! Weighting factor. Use 2nd order series expansion when rounding error (~tau&#94;2) !   is of order epsilon (smallest difference from 1. in working precision) !   Thanks to Peter Blossey ! if ( tau > tau_thresh ) then fact = ( 1._wp - trans ) / tau - trans else fact = tau * ( 0.5_wp - 1._wp / 3._wp * tau ) end if ! ! Equation below is developed in Clough et al., 1992, doi:10.1029/92JD01419, Eq 13 ! source_dn = ( 1._wp - trans ) * lev_source_dn + & 2._wp * fact * ( lay_source - lev_source_dn ) source_up = ( 1._wp - trans ) * lev_source_up + & 2._wp * fact * ( lay_source - lev_source_up ) end subroutine lw_source_noscat ! --------------------------------------------------------------- ! ! Longwave no-scattering transport ! ! --------------------------------------------------------------- subroutine lw_transport_noscat_dn ( ncol , nlay , ngpt , top_at_1 , & trans , source_dn , radn_dn ) bind ( C , name = \"lw_transport_noscat_dn\" ) !dir$ optimize(-O0) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 ! real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: trans ! transmissivity = exp(-tau) real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: source_dn ! Diffuse radiation emitted by the layer real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( inout ) :: radn_dn ! Radiances [W/m2-str] ! Top level must contain incident flux boundary condition ! Local variables integer :: igpt , ilev , icol ! --------------------------------------------------- ! --------------------------------------------------- if ( top_at_1 ) then ! ! Top of domain is index 1 ! !$acc  parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol do ilev = 2 , nlay + 1 radn_dn ( icol , ilev , igpt ) = trans ( icol , ilev - 1 , igpt ) * radn_dn ( icol , ilev - 1 , igpt ) + source_dn ( icol , ilev - 1 , igpt ) end do end do end do else ! ! Top of domain is index nlay+1 ! !$acc  parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol do ilev = nlay , 1 , - 1 radn_dn ( icol , ilev , igpt ) = trans ( icol , ilev , igpt ) * radn_dn ( icol , ilev + 1 , igpt ) + source_dn ( icol , ilev , igpt ) end do end do end do end if end subroutine lw_transport_noscat_dn ! ------------------------------------------------------------------------------------------------- subroutine lw_transport_noscat_up ( ncol , nlay , ngpt , & top_at_1 , trans , source_up , radn_up , do_Jacobians , radn_upJac ) bind ( C , name = \"lw_transport_noscat_up\" ) !dir$ optimize(-O0) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 ! real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: trans ! transmissivity = exp(-tau) real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: source_up ! Diffuse radiation emitted by the layer real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: radn_up ! Radiances [W/m2-str] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( inout ) :: radn_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] ! Local variables integer :: igpt , ilev , icol ! --------------------------------------------------- ! --------------------------------------------------- if ( top_at_1 ) then ! ! Top of domain is index 1 ! !$acc  parallel loop collapse(2) no_create(radn_upJac) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol do ilev = nlay , 1 , - 1 radn_up ( icol , ilev , igpt ) = trans ( icol , ilev , igpt ) * radn_up ( icol , ilev + 1 , igpt ) + source_up ( icol , ilev , igpt ) end do if ( do_Jacobians ) then do ilev = nlay , 1 , - 1 radn_upJac ( icol , ilev , igpt ) = trans ( icol , ilev , igpt ) * radn_upJac ( icol , ilev + 1 , igpt ) end do end if end do end do else ! ! Top of domain is index nlay+1 ! !$acc  parallel loop collapse(2) no_create(radn_upJac) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol do ilev = 2 , nlay + 1 radn_up ( icol , ilev , igpt ) = trans ( icol , ilev - 1 , igpt ) * radn_up ( icol , ilev - 1 , igpt ) + source_up ( icol , ilev - 1 , igpt ) end do if ( do_Jacobians ) then do ilev = nlay , 1 , - 1 radn_upJac ( icol , ilev , igpt ) = trans ( icol , ilev - 1 , igpt ) * radn_upJac ( icol , ilev - 1 , igpt ) end do end if end do end do end if end subroutine lw_transport_noscat_up ! ------------------------------------------------------------------------------------------------- ! ! Longwave two-stream solutions to diffuse reflectance and transmittance for a layer !    with optical depth tau, single scattering albedo w0, and asymmetery parameter g. ! ! Equations are developed in Meador and Weaver, 1980, !    doi:10.1175/1520-0469(1980)037<0630:TSATRT>2.0.CO;2 ! subroutine lw_two_stream ( ncol , nlay , ngpt , tau , w0 , g , & gamma1 , gamma2 , Rdif , Tdif ) bind ( C , name = \"lw_two_stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , w0 , g real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: gamma1 , gamma2 , Rdif , Tdif ! ----------------------- integer :: icol , ilay , igpt ! Variables used in Meador and Weaver real ( wp ) :: k ! Ancillary variables real ( wp ) :: RT_term real ( wp ) :: exp_minusktau , exp_minus2ktau real ( wp ), parameter :: LW_diff_sec = 1.66 ! 1./cos(diffusivity angle) ! --------------------------------- ! --------------------------------- !$acc enter data copyin(tau, w0, g) !$omp target enter data map(to:tau, w0, g) !$acc enter data create(gamma1, gamma2, Rdif, Tdif) !$omp target enter data map(alloc:gamma1, gamma2, Rdif, Tdif) !$acc  parallel loop collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! ! Coefficients differ from SW implementation because the phase function is more isotropic !   Here we follow Fu et al. 1997, doi:10.1175/1520-0469(1997)054<2799:MSPITI>2.0.CO;2 !   and use a diffusivity sec of 1.66 ! gamma1 ( icol , ilay , igpt ) = LW_diff_sec * ( 1._wp - 0.5_wp * w0 ( icol , ilay , igpt ) * ( 1._wp + g ( icol , ilay , igpt ))) ! Fu et al. Eq 2.9 gamma2 ( icol , ilay , igpt ) = LW_diff_sec * 0.5_wp * w0 ( icol , ilay , igpt ) * ( 1._wp - g ( icol , ilay , igpt )) ! Fu et al. Eq 2.10 ! Written to encourage vectorization of exponential, square root ! Eq 18;  k = SQRT(gamma1**2 - gamma2**2), limited below to avoid div by 0. !   k = 0 for isotropic, conservative scattering; this lower limit on k !   gives relative error with respect to conservative solution !   of < 0.1% in Rdif down to tau = 10&#94;-9 k = sqrt ( max (( gamma1 ( icol , ilay , igpt ) - gamma2 ( icol , ilay , igpt )) * & ( gamma1 ( icol , ilay , igpt ) + gamma2 ( icol , ilay , igpt )), & 1.e-12_wp )) exp_minusktau = exp ( - tau ( icol , ilay , igpt ) * k ) ! ! Diffuse reflection and transmission ! exp_minus2ktau = exp_minusktau * exp_minusktau ! Refactored to avoid rounding errors when k, gamma1 are of very different magnitudes RT_term = 1._wp / ( k * ( 1._wp + exp_minus2ktau ) + & gamma1 ( icol , ilay , igpt ) * ( 1._wp - exp_minus2ktau ) ) ! Equation 25 Rdif ( icol , ilay , igpt ) = RT_term * gamma2 ( icol , ilay , igpt ) * ( 1._wp - exp_minus2ktau ) ! Equation 26 Tdif ( icol , ilay , igpt ) = RT_term * 2._wp * k * exp_minusktau end do end do end do !$acc exit data delete (tau, w0, g) !$omp target exit data map(release:tau, w0, g) !$acc exit data copyout(gamma1, gamma2, Rdif, Tdif) !$omp target exit data map(from:gamma1, gamma2, Rdif, Tdif) end subroutine lw_two_stream ! ------------------------------------------------------------------------------------------------- ! ! Source function combination ! RRTMGP provides two source functions at each level !   using the spectral mapping from each of the adjascent layers. !   Need to combine these for use in two-stream calculation. ! ! ------------------------------------------------------------------------------------------------- subroutine lw_combine_sources ( ncol , nlay , ngpt , top_at_1 , & lev_src_inc , lev_src_dec , lev_source ) bind ( C , name = \"lw_combine_sources\" ) integer , intent ( in ) :: ncol , nlay , ngpt logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_src_inc , lev_src_dec real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: lev_source integer :: icol , ilay , igpt ! --------------------------------------------------------------- ! --------------------------------- !$acc enter data copyin(lev_src_inc, lev_src_dec) !$omp target enter data map(to:lev_src_inc, lev_src_dec) !$acc enter data create(lev_source) !$omp target enter data map(alloc:lev_source) !$acc  parallel loop collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay + 1 do icol = 1 , ncol if ( ilay == 1 ) then lev_source ( icol , ilay , igpt ) = lev_src_dec ( icol , ilay , igpt ) else if ( ilay == nlay + 1 ) then lev_source ( icol , ilay , igpt ) = lev_src_inc ( icol , ilay - 1 , igpt ) else lev_source ( icol , ilay , igpt ) = sqrt ( lev_src_dec ( icol , ilay , igpt ) * & lev_src_inc ( icol , ilay - 1 , igpt )) end if end do end do end do !$acc exit data delete (lev_src_inc, lev_src_dec) !$omp target exit data map(release:lev_src_inc, lev_src_dec) !$acc exit data copyout(lev_source) !$omp target exit data map(from:lev_source) end subroutine lw_combine_sources ! --------------------------------------------------------------- ! ! Compute LW source function for upward and downward emission at levels using linear-in-tau assumption !   This version straight from ECRAD !   Source is provided as W/m2-str; factor of pi converts to flux units ! ! --------------------------------------------------------------- subroutine lw_source_2str ( ncol , nlay , ngpt , top_at_1 , & sfc_emis , sfc_src , & lay_source , lev_source , & gamma1 , gamma2 , rdif , tdif , tau , source_dn , source_up , source_sfc ) & bind ( C , name = \"lw_source_2str\" ) integer , intent ( in ) :: ncol , nlay , ngpt logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis , sfc_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source , & ! Planck source at layer center tau , & ! Optical depth (tau) gamma1 , gamma2 ,& ! Coupling coefficients rdif , tdif ! Layer reflectance and transmittance real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( in ) :: lev_source ! Planck source at layer edges real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: source_dn , source_up real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: source_sfc ! Source function for upward radation at surface integer :: icol , ilay , igpt real ( wp ) :: Z , Zup_top , Zup_bottom , Zdn_top , Zdn_bottom real ( wp ) :: lev_source_bot , lev_source_top ! --------------------------------------------------------------- ! --------------------------------- !$acc enter data copyin(sfc_emis, sfc_src, lay_source, tau, gamma1, gamma2, rdif, tdif, lev_source) !$omp target enter data map(to:sfc_emis, sfc_src, lay_source, tau, gamma1, gamma2, rdif, tdif, lev_source) !$acc enter data create(source_dn, source_up, source_sfc) !$omp target enter data map(alloc:source_dn, source_up, source_sfc) !$acc parallel loop collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol if ( tau ( icol , ilay , igpt ) > 1.0e-8_wp ) then if ( top_at_1 ) then lev_source_top = lev_source ( icol , ilay , igpt ) lev_source_bot = lev_source ( icol , ilay + 1 , igpt ) else lev_source_top = lev_source ( icol , ilay + 1 , igpt ) lev_source_bot = lev_source ( icol , ilay , igpt ) end if ! ! Toon et al. (JGR 1989) Eqs 26-27 ! Z = ( lev_source_bot - lev_source_top ) / ( tau ( icol , ilay , igpt ) * ( gamma1 ( icol , ilay , igpt ) + gamma2 ( icol , ilay , igpt ))) Zup_top = Z + lev_source_top Zup_bottom = Z + lev_source_bot Zdn_top = - Z + lev_source_top Zdn_bottom = - Z + lev_source_bot source_up ( icol , ilay , igpt ) = pi * ( Zup_top - rdif ( icol , ilay , igpt ) * Zdn_top - tdif ( icol , ilay , igpt ) * Zup_bottom ) source_dn ( icol , ilay , igpt ) = pi * ( Zdn_bottom - rdif ( icol , ilay , igpt ) * Zup_bottom - tdif ( icol , ilay , igpt ) * Zdn_top ) else source_up ( icol , ilay , igpt ) = 0._wp source_dn ( icol , ilay , igpt ) = 0._wp end if if ( ilay == 1 ) source_sfc ( icol , igpt ) = pi * sfc_emis ( icol , igpt ) * sfc_src ( icol , igpt ) end do end do end do !$acc exit data delete(sfc_emis, sfc_src, lay_source, tau, gamma1, gamma2, rdif, tdif, lev_source) !$omp target exit data map(release:sfc_emis, sfc_src, lay_source, tau, gamma1, gamma2, rdif, tdif, lev_source) !$acc exit data copyout(source_dn, source_up, source_sfc) !$omp target exit data map(from:source_dn, source_up, source_sfc) end subroutine lw_source_2str ! ------------------------------------------------------------------------------------------------- ! !   Lower-level shortwave kernels ! ! ------------------------------------------------------------------------------------------------- ! ------------------------------------------------------------------------------------------------- ! ! Two-stream solutions to direct and diffuse reflectance and transmittance for a layer !    with optical depth tau, single scattering albedo w0, and asymmetery parameter g. ! ! Equations are developed in Meador and Weaver, 1980, !    doi:10.1175/1520-0469(1980)037<0630:TSATRT>2.0.CO;2 ! ! --------------------------------------------------------------- ! ! Direct beam source for diffuse radiation in layers and at surface; !   report direct beam as a byproduct ! ! ------------------------------------------------------------------------------------------------- subroutine sw_dif_and_source ( ncol , nlay , ngpt , top_at_1 , mu0 , sfc_albedo , & tau , w0 , g , & Rdif , Tdif , source_dn , source_up , source_sfc , & flux_dn_dir ) bind ( C , name = \"sw_source_dir\" ) integer , intent ( in ) :: ncol , nlay , ngpt logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_albedo ! surface albedo for direct radiation real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , w0 , g real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( out ) :: Rdif , Tdif , source_dn , source_up real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: source_sfc ! Source function for upward radation at surface real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( inout ) :: flux_dn_dir ! Direct beam flux ! ----------------------- integer :: icol , ilay , igpt ! Variables used in Meador and Weaver real ( wp ) :: gamma1 , gamma2 , gamma3 , gamma4 , alpha1 , alpha2 ! Ancillary variables real ( wp ) :: k , exp_minusktau , k_mu , k_gamma3 , k_gamma4 real ( wp ) :: RT_term , exp_minus2ktau real ( wp ) :: Rdir , Tdir , Tnoscat , inc_flux integer :: lay_index , inc_index , trans_index real ( wp ) :: tau_s , w0_s , g_s , mu0_s ! --------------------------------- !$acc  parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol do ilay = 1 , nlay if ( top_at_1 ) then lay_index = ilay inc_index = lay_index trans_index = lay_index + 1 else lay_index = nlay - ilay + 1 inc_index = lay_index + 1 trans_index = lay_index end if inc_flux = flux_dn_dir ( icol , inc_index , igpt ) ! ! Scalars ! tau_s = tau ( icol , lay_index , igpt ) w0_s = w0 ( icol , lay_index , igpt ) g_s = g ( icol , lay_index , igpt ) mu0_s = mu0 ( icol ) ! ! Zdunkowski Practical Improved Flux Method \"PIFM\" !  (Zdunkowski et al., 1980;  Contributions to Atmospheric Physics 53, 147-66) ! gamma1 = ( 8._wp - w0_s * ( 5._wp + 3._wp * g_s )) * . 25_wp gamma2 = 3._wp * ( w0_s * ( 1._wp - g_s )) * . 25_wp gamma3 = ( 2._wp - 3._wp * mu0_s * g_s ) * . 25_wp gamma4 = 1._wp - gamma3 alpha1 = gamma1 * gamma4 + gamma2 * gamma3 ! Eq. 16 alpha2 = gamma1 * gamma3 + gamma2 * gamma4 ! Eq. 17 ! ! Direct reflect and transmission ! ! Eq 18;  k = SQRT(gamma1**2 - gamma2**2), limited below to avoid div by 0. !   k = 0 for isotropic, conservative scattering; this lower limit on k !   gives relative error with respect to conservative solution !   of < 0.1% in Rdif down to tau = 10&#94;-9 k = sqrt ( max (( gamma1 - gamma2 ) * ( gamma1 + gamma2 ), 1.e-12_wp )) k_mu = k * mu0_s k_gamma3 = k * gamma3 k_gamma4 = k * gamma4 exp_minusktau = exp ( - tau_s * k ) exp_minus2ktau = exp_minusktau * exp_minusktau ! Refactored to avoid rounding errors when k, gamma1 are of very different magnitudes RT_term = 1._wp / ( k * ( 1._wp + exp_minus2ktau ) + & gamma1 * ( 1._wp - exp_minus2ktau ) ) ! Equation 25 Rdif ( icol , lay_index , igpt ) = RT_term * gamma2 * ( 1._wp - exp_minus2ktau ) ! Equation 26 Tdif ( icol , lay_index , igpt ) = RT_term * 2._wp * k * exp_minusktau ! ! Equation 14, multiplying top and bottom by exp(-k*tau) !   and rearranging to avoid div by 0. ! RT_term = w0_s * RT_term / merge ( 1._wp - k_mu * k_mu , & epsilon ( 1._wp ), & abs ( 1._wp - k_mu * k_mu ) >= epsilon ( 1._wp )) ! ! Transmittance of direct, unscattered beam. ! Tnoscat = exp ( - tau_s / mu0_s ) Rdir = RT_term * & (( 1._wp - k_mu ) * ( alpha2 + k_gamma3 ) - & ( 1._wp + k_mu ) * ( alpha2 - k_gamma3 ) * exp_minus2ktau - & 2.0_wp * ( k_gamma3 - alpha2 * k_mu ) * exp_minusktau * Tnoscat ) ! ! Equation 15, multiplying top and bottom by exp(-k*tau), !   multiplying through by exp(-tau/mu0) to !   prefer underflow to overflow ! Omitting direct transmittance ! Tdir = - RT_term * & (( 1._wp + k_mu ) * ( alpha1 + k_gamma4 ) * Tnoscat - & ( 1._wp - k_mu ) * ( alpha1 - k_gamma4 ) * exp_minus2ktau * Tnoscat - & 2.0_wp * ( k_gamma4 + alpha1 * k_mu ) * exp_minusktau ) source_up ( icol , lay_index , igpt ) = Rdir * inc_flux source_dn ( icol , lay_index , igpt ) = Tdir * inc_flux flux_dn_dir ( icol , trans_index , igpt ) = Tnoscat * inc_flux end do source_sfc ( icol , igpt ) = flux_dn_dir ( icol , trans_index , igpt ) * sfc_albedo ( icol , igpt ) end do end do end subroutine sw_dif_and_source ! --------------------------------------------------------------- ! ! Transport of diffuse radiation through a vertically layered atmosphere. !   Equations are after Shonk and Hogan 2008, doi:10.1175/2007JCLI1940.1 (SH08) !   This routine is shared by longwave and shortwave ! ! ------------------------------------------------------------------------------------------------- subroutine adding ( ncol , nlay , ngpt , top_at_1 , & albedo_sfc , & rdif , tdif , & src_dn , src_up , src_sfc , & flux_up , flux_dn ) bind ( C , name = \"adding\" ) !dir$ optimize(-O0) integer , intent ( in ) :: ncol , nlay , ngpt logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: albedo_sfc real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: rdif , tdif real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: src_dn , src_up real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: src_sfc real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_up ! intent(inout) because top layer includes incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( inout ) :: flux_dn ! ------------------ integer :: icol , ilev , igpt ! These arrays could be private per thread in OpenACC, with 1 dimension of size nlay (or nlay+1) ! However, current PGI (19.4) has a bug preventing it from properly handling such private arrays. ! So we explicitly create the temporary arrays of size nlay(+1) per each of the ncol*ngpt elements ! real ( wp ), dimension ( ncol , nlay + 1 , ngpt ) :: albedo , & ! reflectivity to diffuse radiation below this level ! alpha in SH08 src ! source of diffuse upwelling radiation from emission or ! scattering of direct beam ! G in SH08 real ( wp ), dimension ( ncol , nlay , ngpt ) :: denom ! beta in SH08 ! ------------------ ! --------------------------------- ! ! Indexing into arrays for upward and downward propagation depends on the vertical !   orientation of the arrays (whether the domain top is at the first or last index) ! We write the loops out explicitly so compilers will have no trouble optimizing them. ! !$acc enter data copyin(albedo_sfc, rdif, tdif, src_dn, src_up, src_sfc, flux_dn) !$omp target enter data map(to:albedo_sfc, rdif, tdif, src_dn, src_up, src_sfc, flux_dn) !$acc enter data create(flux_up, albedo, src, denom) !$omp target enter data map(alloc:flux_up, albedo, src, denom) if ( top_at_1 ) then !$acc parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ilev = nlay + 1 ! Albedo of lowest level is the surface albedo... albedo ( icol , ilev , igpt ) = albedo_sfc ( icol , igpt ) ! ... and source of diffuse radiation is surface emission src ( icol , ilev , igpt ) = src_sfc ( icol , igpt ) ! ! From bottom to top of atmosphere -- !   compute albedo and source of upward radiation ! do ilev = nlay , 1 , - 1 denom ( icol , ilev , igpt ) = 1._wp / ( 1._wp - rdif ( icol , ilev , igpt ) * albedo ( icol , ilev + 1 , igpt )) ! Eq 10 albedo ( icol , ilev , igpt ) = rdif ( icol , ilev , igpt ) + & tdif ( icol , ilev , igpt ) * tdif ( icol , ilev , igpt ) * albedo ( icol , ilev + 1 , igpt ) * denom ( icol , ilev , igpt ) ! Equation 9 ! ! Equation 11 -- source is emitted upward radiation at top of layer plus !   radiation emitted at bottom of layer, !   transmitted through the layer and reflected from layers below (tdiff*src*albedo) ! src ( icol , ilev , igpt ) = src_up ( icol , ilev , igpt ) + & tdif ( icol , ilev , igpt ) * denom ( icol , ilev , igpt ) * & ( src ( icol , ilev + 1 , igpt ) + albedo ( icol , ilev + 1 , igpt ) * src_dn ( icol , ilev , igpt )) end do ! Eq 12, at the top of the domain upwelling diffuse is due to ... ilev = 1 flux_up ( icol , ilev , igpt ) = flux_dn ( icol , ilev , igpt ) * albedo ( icol , ilev , igpt ) + & ! ... reflection of incident diffuse and src ( icol , ilev , igpt ) ! emission from below ! ! From the top of the atmosphere downward -- compute fluxes ! do ilev = 2 , nlay + 1 flux_dn ( icol , ilev , igpt ) = ( tdif ( icol , ilev - 1 , igpt ) * flux_dn ( icol , ilev - 1 , igpt ) + & ! Equation 13 rdif ( icol , ilev - 1 , igpt ) * src ( icol , ilev , igpt ) + & src_dn ( icol , ilev - 1 , igpt )) * denom ( icol , ilev - 1 , igpt ) flux_up ( icol , ilev , igpt ) = flux_dn ( icol , ilev , igpt ) * albedo ( icol , ilev , igpt ) + & ! Equation 12 src ( icol , ilev , igpt ) end do end do end do else !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ilev = 1 ! Albedo of lowest level is the surface albedo... albedo ( icol , ilev , igpt ) = albedo_sfc ( icol , igpt ) ! ... and source of diffuse radiation is surface emission src ( icol , ilev , igpt ) = src_sfc ( icol , igpt ) ! ! From bottom to top of atmosphere -- !   compute albedo and source of upward radiation ! do ilev = 1 , nlay denom ( icol , ilev , igpt ) = 1._wp / ( 1._wp - rdif ( icol , ilev , igpt ) * albedo ( icol , ilev , igpt )) ! Eq 10 albedo ( icol , ilev + 1 , igpt ) = rdif ( icol , ilev , igpt ) + & tdif ( icol , ilev , igpt ) * tdif ( icol , ilev , igpt ) * albedo ( icol , ilev , igpt ) * denom ( icol , ilev , igpt ) ! Equation 9 ! ! Equation 11 -- source is emitted upward radiation at top of layer plus !   radiation emitted at bottom of layer, !   transmitted through the layer and reflected from layers below (tdiff*src*albedo) ! src ( icol , ilev + 1 , igpt ) = src_up ( icol , ilev , igpt ) + & tdif ( icol , ilev , igpt ) * denom ( icol , ilev , igpt ) * & ( src ( icol , ilev , igpt ) + albedo ( icol , ilev , igpt ) * src_dn ( icol , ilev , igpt )) end do ! Eq 12, at the top of the domain upwelling diffuse is due to ... ilev = nlay + 1 flux_up ( icol , ilev , igpt ) = flux_dn ( icol , ilev , igpt ) * albedo ( icol , ilev , igpt ) + & ! ... reflection of incident diffuse and src ( icol , ilev , igpt ) ! scattering by the direct beam below ! ! From the top of the atmosphere downward -- compute fluxes ! do ilev = nlay , 1 , - 1 flux_dn ( icol , ilev , igpt ) = ( tdif ( icol , ilev , igpt ) * flux_dn ( icol , ilev + 1 , igpt ) + & ! Equation 13 rdif ( icol , ilev , igpt ) * src ( icol , ilev , igpt ) + & src_dn ( icol , ilev , igpt )) * denom ( icol , ilev , igpt ) flux_up ( icol , ilev , igpt ) = flux_dn ( icol , ilev , igpt ) * albedo ( icol , ilev , igpt ) + & ! Equation 12 src ( icol , ilev , igpt ) end do end do end do end if !$acc exit data delete(albedo_sfc, rdif, tdif, src_dn, src_up, src_sfc, albedo, src, denom) !$omp target exit data map(release:albedo_sfc, rdif, tdif, src_dn, src_up, src_sfc, albedo, src, denom) !$acc exit data copyout(flux_up, flux_dn) !$omp target exit data map(from:flux_up, flux_dn) end subroutine adding ! ------------------------------------------------------------------------------------------------- ! ! Similar to Longwave no-scattering tarnsport  (lw_transport_noscat) !   a) adds adjustment factor based on cloud properties ! !   implementation notice: !       the adjustmentFactor computation can be skipped where Cn <= epsilon ! ! ------------------------------------------------------------------------------------------------- subroutine lw_transport_1rescl ( ncol , nlay , ngpt , top_at_1 , & trans , source_dn , source_up , & radn_up , radn_dn , An , Cn , & do_Jacobians , radn_up_Jac ) bind ( C , name = \"lw_transport_1rescl\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 ! real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: trans ! transmissivity = exp(-tau) real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: source_dn , & source_up ! Diffuse radiation emitted by the layer real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( inout ) :: radn_up ! Radiances [W/m2-str] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( inout ) :: radn_dn !Top level must contain incident flux boundary condition real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: An , Cn logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( inout ) :: radn_up_Jac ! Radiances [W/m2-str] ! --------------------------------------------------- ! Local variables integer :: ilev , icol , igpt real ( wp ) :: adjustmentFactor ! --------------------------------------------------- if ( top_at_1 ) then ! ! Top of domain is index 1 ! ! Downward propagation !$acc                         parallel loop    collapse(2) no_create(radn_up_Jac) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ! Upward propagation do ilev = nlay , 1 , - 1 adjustmentFactor = Cn ( icol , ilev , igpt ) * & ( An ( icol , ilev , igpt ) * radn_dn ( icol , ilev , igpt ) - & source_dn ( icol , ilev , igpt ) * trans ( icol , ilev , igpt ) - & source_up ( icol , ilev , igpt )) radn_up ( icol , ilev , igpt ) = trans ( icol , ilev , igpt ) * radn_up ( icol , ilev + 1 , igpt ) + & source_up ( icol , ilev , igpt ) + adjustmentFactor enddo if ( do_Jacobians ) then do ilev = nlay , 1 , - 1 radn_up_Jac ( icol , ilev , igpt ) = trans ( icol , ilev , igpt ) * radn_up_Jac ( icol , ilev + 1 , igpt ) end do end if ! radn_dn_Jac(icol,1,igpt) = 0._wp ! 2nd Downward propagation do ilev = 1 , nlay ! radn_dn_Jac(icol,ilev+1,igpt) = trans(icol,ilev,igpt)*radn_dn_Jac(icol,ilev,igpt) adjustmentFactor = Cn ( icol , ilev , igpt ) * ( & An ( icol , ilev , igpt ) * radn_up ( icol , ilev , igpt ) - & source_up ( icol , ilev , igpt ) * trans ( icol , ilev , igpt ) - & source_dn ( icol , ilev , igpt ) ) radn_dn ( icol , ilev + 1 , igpt ) = trans ( icol , ilev , igpt ) * radn_dn ( icol , ilev , igpt ) + & source_dn ( icol , ilev , igpt ) + adjustmentFactor ! adjustmentFactor             = Cn(icol,ilev,igpt)*An(icol,ilev,igpt)*radn_up_Jac(icol,ilev,igpt) ! radn_dn_Jac(icol,ilev+1,igpt) = radn_dn_Jac(icol,ilev+1,igpt) + adjustmentFactor enddo enddo enddo else !$acc  parallel loop collapse(2) no_create(radn_up_Jac) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol ! Upward propagation do ilev = 1 , nlay adjustmentFactor = Cn ( icol , ilev , igpt ) * & ( An ( icol , ilev , igpt ) * radn_dn ( icol , ilev + 1 , igpt ) - & source_dn ( icol , ilev , igpt ) * trans ( icol , ilev , igpt ) - & source_up ( icol , ilev , igpt )) radn_up ( icol , ilev + 1 , igpt ) = trans ( icol , ilev , igpt ) * radn_up ( icol , ilev , igpt ) + & source_up ( icol , ilev , igpt ) + adjustmentFactor end do if ( do_Jacobians ) then do ilev = 1 , nlay radn_up_Jac ( icol , ilev + 1 , igpt ) = trans ( icol , ilev , igpt ) * radn_up_Jac ( icol , ilev , igpt ) end do end if ! 2st Downward propagation ! radn_dn_Jac(icol,nlay+1,igpt) = 0._wp do ilev = nlay , 1 , - 1 ! radn_dn_Jac(icol,ilev,igpt) = trans(icol,ilev,igpt)*radn_dn_Jac(icol,ilev+1,igpt) adjustmentFactor = Cn ( icol , ilev , igpt ) * ( & An ( icol , ilev , igpt ) * radn_up ( icol , ilev , igpt ) - & source_up ( icol , ilev , igpt ) * trans ( icol , ilev , igpt ) - & source_dn ( icol , ilev , igpt ) ) radn_dn ( icol , ilev , igpt ) = trans ( icol , ilev , igpt ) * radn_dn ( icol , ilev + 1 , igpt ) + & source_dn ( icol , ilev , igpt ) + adjustmentFactor ! adjustmentFactor           = Cn(icol,ilev,igpt)*An(icol,ilev,igpt)*radn_up_Jac(icol,ilev,igpt) ! radn_dn_Jac(icol,ilev,igpt) = radn_dn_Jac(icol,ilev,igpt) + adjustmentFactor end do enddo enddo end if end subroutine lw_transport_1rescl ! ------------------------------------------------------------------------------------------------- ! ! Spectral reduction over all points ! subroutine sum_broadband_factor ( ncol , nlev , ngpt , factor , spectral_flux , broadband_flux ) integer , intent ( in ) :: ncol , nlev , ngpt real ( wp ), intent ( in ) :: factor real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( in ) :: spectral_flux real ( wp ), dimension ( ncol , nlev ), intent ( out ) :: broadband_flux integer :: icol , ilev , igpt real ( wp ) :: scalar ! local scalar version !$acc                         parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd          collapse(2) do ilev = 1 , nlev do icol = 1 , ncol scalar = 0.0_wp do igpt = 1 , ngpt scalar = scalar + spectral_flux ( icol , ilev , igpt ) end do broadband_flux ( icol , ilev ) = factor * scalar end do end do end subroutine sum_broadband_factor ! ------------------------------------------------------------------------------------------------- ! ! Apply a scalar weight to every element of an array ! subroutine apply_factor_3D ( ncol , nlev , ngpt , factor , array ) integer , intent ( in ) :: ncol , nlev , ngpt real ( wp ), intent ( in ) :: factor real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( inout ) :: array integer :: icol , ilev , igpt !$acc                         parallel loop gang vector collapse(3) !$omp target teams distribute parallel do simd          collapse(3) do igpt = 1 , ngpt do ilev = 1 , nlev do icol = 1 , ncol array ( icol , ilev , igpt ) = factor * array ( icol , ilev , igpt ) end do end do end do end subroutine apply_factor_3D ! ------------------------------------------------------------------------------------------------- ! ! Add an array to an existing array ! subroutine add_arrays_3D ( ncol , nlev , ngpt , increment , array ) integer , intent ( in ) :: ncol , nlev , ngpt real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( in ) :: increment real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( inout ) :: array integer :: icol , ilev , igpt !$acc                         parallel loop gang vector collapse(3) !$omp target teams distribute parallel do simd          collapse(3) do igpt = 1 , ngpt do ilev = 1 , nlev do icol = 1 , ncol array ( icol , ilev , igpt ) = array ( icol , ilev , igpt ) + increment ( icol , ilev , igpt ) end do end do end do end subroutine add_arrays_3D ! ------------------------------------------------------------------------------------------------- subroutine add_arrays_2D ( ncol , nlev , increment , array ) integer , intent ( in ) :: ncol , nlev real ( wp ), dimension ( ncol , nlev ), intent ( in ) :: increment real ( wp ), dimension ( ncol , nlev ), intent ( inout ) :: array integer :: icol , ilev !$acc                         parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd          collapse(2) do ilev = 1 , nlev do icol = 1 , ncol array ( icol , ilev ) = array ( icol , ilev ) + increment ( icol , ilev ) end do end do end subroutine add_arrays_2D ! ------------------------------------------------------------------------------------------------- end module mo_rte_solver_kernels","tags":"","loc":"sourcefile/mo_rte_solver_kernels.f90.html"},{"title":"mo_optical_props_kernels.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_optical_props_kernels.f90~~EfferentGraph sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_optical_props_kernels.f90~~AfferentGraph sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_cloud_optics.f90 mo_cloud_optics.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_cloud_sampling.f90 mo_cloud_sampling.F90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_optical_props_kernels Source Code mo_optical_props_kernels.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2015-2016,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Description:  Addition of optical properties -- the first set are incremented by the second set. !   There are three possible representations of optical properties (scalar = optical depth only; !   two-stream = tau, single-scattering albedo, and asymmetry factor g, and !   n-stream = tau, ssa, and phase function moments p.) Thus we need nine routines, three for !   each choice of representation on the left hand side times three representations of the !   optical properties to be added. !   There are two sets of these nine routines. In the first the two sets of optical !   properties are defined at the same spectral resolution. There is also a set of routines !   to add properties defined at lower spectral resolution to a set defined at higher spectral !   resolution (adding properties defined by band to those defined by g-point) module mo_optical_props_kernels use , intrinsic :: iso_c_binding use mo_rte_kind , only : wp , wl implicit none public interface delta_scale_2str_kernel module procedure delta_scale_2str_f_k , delta_scale_2str_k end interface interface extract_subset module procedure extract_subset_dim1_3d , extract_subset_dim2_4d module procedure extract_subset_absorption_tau end interface extract_subset real ( wp ), parameter , private :: eps = 3.0_wp * tiny ( 1.0_wp ) contains ! ------------------------------------------------------------------------------------------------- ! ! Delta-scaling, provided only for two-stream properties at present ! ! ------------------------------------------------------------------------------------------------- ! Delta-scale !   user-provided value of f (forward scattering) ! subroutine delta_scale_2str_f_k ( ncol , nlay , ngpt , tau , ssa , g , f ) & bind ( C , name = \"delta_scale_2str_f_k\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau , ssa , g real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: f real ( wp ) :: wf integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copy(ssa(:ncol,:nlay,:ngpt),tau(:ncol,:nlay,:ngpt)) & !$acc&     copyin(f(:ncol,:nlay,:ngpt)) & !$acc&     copy(g(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:ssa, tau) & !$omp& map(to:f) & !$omp& map(tofrom:g) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol if ( tau ( icol , ilay , igpt ) > eps ) then wf = ssa ( icol , ilay , igpt ) * f ( icol , ilay , igpt ) tau ( icol , ilay , igpt ) = ( 1._wp - wf ) * tau ( icol , ilay , igpt ) ssa ( icol , ilay , igpt ) = ( ssa ( icol , ilay , igpt ) - wf ) / ( 1.0_wp - wf ) g ( icol , ilay , igpt ) = ( g ( icol , ilay , igpt ) - f ( icol , ilay , igpt )) / ( 1._wp - f ( icol , ilay , igpt )) end if end do end do end do end subroutine delta_scale_2str_f_k ! --------------------------------- ! Delta-scale !   f = g*g ! subroutine delta_scale_2str_k ( ncol , nlay , ngpt , tau , ssa , g ) & bind ( C , name = \"delta_scale_2str_k\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau , ssa , g real ( wp ) :: f , wf integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copy(tau(:ncol,:nlay,:ngpt),ssa(:ncol,:nlay,:ngpt),g(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau, ssa, g) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol if ( tau ( icol , ilay , igpt ) > eps ) then f = g ( icol , ilay , igpt ) * g ( icol , ilay , igpt ) wf = ssa ( icol , ilay , igpt ) * f tau ( icol , ilay , igpt ) = ( 1._wp - wf ) * tau ( icol , ilay , igpt ) ssa ( icol , ilay , igpt ) = ( ssa ( icol , ilay , igpt ) - wf ) / ( 1.0_wp - wf ) g ( icol , ilay , igpt ) = ( g ( icol , ilay , igpt ) - f ) / ( 1.0_wp - f ) end if end do end do end do end subroutine delta_scale_2str_k ! ------------------------------------------------------------------------------------------------- ! ! Addition of optical properties: the first set are incremented by the second set. ! !   There are three possible representations of optical properties (scalar = optical depth only; !   two-stream = tau, single-scattering albedo, and asymmetry factor g, and !   n-stream = tau, ssa, and phase function moments p.) Thus we need nine routines, three for !   each choice of representation on the left hand side times three representations of the !   optical properties to be added. ! !   There are two sets of these nine routines. In the first the two sets of optical !   properties are defined at the same spectral resolution. There is also a set of routines !   to add properties defined at lower spectral resolution to a set defined at higher spectral !   resolution (adding properties defined by band to those defined by g-point) ! ! ------------------------------------------------------------------------------------------------- subroutine increment_1scalar_by_1scalar ( ncol , nlay , ngpt , & tau1 , & tau2 ) bind ( C , name = \"increment_1scalar_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) end do end do end do end subroutine increment_1scalar_by_1scalar ! --------------------------------- ! increment 1scalar by 2stream subroutine increment_1scalar_by_2stream ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 ) bind ( C , name = \"increment_1scalar_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) & !$omp& map(to:ssa2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ( 1._wp - ssa2 ( icol , ilay , igpt )) end do end do end do end subroutine increment_1scalar_by_2stream ! --------------------------------- ! increment 1scalar by nstream subroutine increment_1scalar_by_nstream ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 ) bind ( C , name = \"increment_1scalar_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 integer :: icol , ilay , igpt ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) & !$omp& map(to:ssa2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ( 1._wp - ssa2 ( icol , ilay , igpt )) end do end do end do end subroutine increment_1scalar_by_nstream ! --------------------------------- ! --------------------------------- ! increment 2stream by 1scalar subroutine increment_2stream_by_1scalar ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 ) bind ( C , name = \"increment_2stream_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt real ( wp ) :: tau12 ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:ssa1) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) if ( tau12 > eps ) then ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / tau12 tau1 ( icol , ilay , igpt ) = tau12 ! g is unchanged end if end do end do end do end subroutine increment_2stream_by_1scalar ! --------------------------------- ! increment 2stream by 2stream subroutine increment_2stream_by_2stream ( ncol , nlay , ngpt , & tau1 , ssa1 , g1 , & tau2 , ssa2 , g2 ) bind ( C , name = \"increment_2stream_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 , g2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(g2(:ncol,:nlay,:ngpt)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt),tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt),g1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:g2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:ssa2, tau2) & !$omp& map(tofrom:tau1, g1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) if ( tauscat12 > eps ) then g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * g2 ( icol , ilay , igpt )) & / tauscat12 ssa1 ( icol , ilay , igpt ) = tauscat12 / tau12 tau1 ( icol , ilay , igpt ) = tau12 end if end do end do end do end subroutine increment_2stream_by_2stream ! --------------------------------- ! increment 2stream by nstream subroutine increment_2stream_by_nstream ( ncol , nlay , ngpt , nmom2 , & tau1 , ssa1 , g1 , & tau2 , ssa2 , p2 ) bind ( C , name = \"increment_2stream_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom2 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , ngpt ), intent ( in ) :: p2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copyin(p2(:1,:ncol,:nlay,:ngpt)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt),tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt),g1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:p2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:ssa2, tau2) & !$omp& map(tofrom:tau1, g1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) if ( tauscat12 > eps ) then g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * p2 ( 1 , icol , ilay , igpt )) / tauscat12 ssa1 ( icol , ilay , igpt ) = tauscat12 / tau12 tau1 ( icol , ilay , igpt ) = tau12 end if end do end do end do end subroutine increment_2stream_by_nstream ! --------------------------------- ! --------------------------------- ! increment nstream by 1scalar subroutine increment_nstream_by_1scalar ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 ) bind ( C , name = \"increment_nstream_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt real ( wp ) :: tau12 ! -------------- ! -------------- !$acc  parallel loop collapse(3) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:ssa1) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) if ( tau12 > eps ) then ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / tau12 tau1 ( icol , ilay , igpt ) = tau12 ! p is unchanged end if end do end do end do end subroutine increment_nstream_by_1scalar ! --------------------------------- ! increment nstream by 2stream subroutine increment_nstream_by_2stream ( ncol , nlay , ngpt , nmom1 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , g2 ) bind ( C , name = \"increment_nstream_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 , g2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 real ( wp ) :: temp_mom ! TK integer :: imom !TK ! -------------- ! -------------- !$acc parallel loop collapse(3) & !$acc&     copy(p1(:nmom1,:ncol,:nlay,:ngpt),ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(g2(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:p1, ssa1) & !$omp& map(to:ssa2) & !$omp& map(tofrom:tau1) & !$omp& map(to:g2) & !$omp& map(to:tau2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) ! ! Here assume Henyey-Greenstein ! if ( tauscat12 > eps ) then temp_mom = g2 ( icol , ilay , igpt ) do imom = 1 , nmom1 p1 ( imom , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( imom , icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * temp_mom ) / tauscat12 temp_mom = temp_mom * g2 ( icol , ilay , igpt ) end do ssa1 ( icol , ilay , igpt ) = tauscat12 / tau12 tau1 ( icol , ilay , igpt ) = tau12 end if end do end do end do end subroutine increment_nstream_by_2stream ! --------------------------------- ! increment nstream by nstream subroutine increment_nstream_by_nstream ( ncol , nlay , ngpt , nmom1 , nmom2 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , p2 ) bind ( C , name = \"increment_nstream_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nmom2 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , ngpt ), intent ( in ) :: p2 integer :: icol , ilay , igpt , mom_lim real ( wp ) :: tau12 , tauscat12 ! -------------- ! -------------- mom_lim = min ( nmom1 , nmom2 ) !$acc  parallel loop collapse(3) & !$acc&     copyin(p2(:mom_lim,:ncol,:nlay,:ngpt)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:ngpt),tau2(:ncol,:nlay,:ngpt)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt),p1(:mom_lim,:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:p2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:ssa2, tau2) & !$omp& map(tofrom:tau1, p1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) if ( tauscat12 > eps ) then ! ! If op2 has more moments than op1 these are ignored; !   if it has fewer moments the higher orders are assumed to be 0 ! p1 ( 1 : mom_lim , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : mom_lim , icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * p2 ( 1 : mom_lim , icol , ilay , igpt )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end if end do end do end do end subroutine increment_nstream_by_nstream ! --------------------------------- ! ! Incrementing when the second set of optical properties is defined at lower spectral resolution !   (e.g. by band instead of by gpoint) ! ! --------------------------------- subroutine inc_1scalar_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt , icol , ilay !$acc parallel loop collapse(3) & !$acc& copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc& copy(tau1(:ncol,:nlay,:ngpt)) & !$acc& copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2) & !$omp& map(tofrom:tau1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) endif end do end do end do end do end subroutine inc_1scalar_by_1scalar_bybnd ! --------------------------------- ! increment 1scalar by 2stream subroutine inc_1scalar_by_2stream_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt , icol , ilay !$acc parallel loop collapse(3) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd),ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:tau2, ssa2) & !$omp& map(tofrom:tau1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) * ( 1._wp - ssa2 ( icol , ilay , ibnd )) endif end do end do end do end do end subroutine inc_1scalar_by_2stream_bybnd ! --------------------------------- ! increment 1scalar by nstream subroutine inc_1scalar_by_nstream_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt , icol , ilay !$acc parallel loop collapse(3) & !$acc&     copyin(gpt_lims(:,:nbnd),tau2(:ncol,:nlay,:nbnd)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:gpt_lims, tau2) & !$omp& map(tofrom:tau1) & !$omp& map(to:ssa2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) * ( 1._wp - ssa2 ( icol , ilay , ibnd )) endif end do end do end do end do end subroutine inc_1scalar_by_nstream_bybnd ! --------------------------------- ! increment 2stream by 1scalar subroutine inc_2stream_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! g is unchanged endif end do end do end do end do end subroutine inc_2stream_by_1scalar_bybnd ! --------------------------------- ! increment 2stream by 2stream subroutine inc_2stream_by_2stream_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , g1 , & tau2 , ssa2 , g2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 , g2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd),ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) & !$acc&     copy(g1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(g2(:ncol,:nlay,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2, ssa2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:gpt_lims) & !$omp& map(tofrom:g1) & !$omp& map(to:g2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * g2 ( icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 endif end do end do end do end do end subroutine inc_2stream_by_2stream_bybnd ! --------------------------------- ! increment 2stream by nstream subroutine inc_2stream_by_nstream_bybnd ( ncol , nlay , ngpt , nmom2 , & tau1 , ssa1 , g1 , & tau2 , ssa2 , p2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom2 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , nbnd ), intent ( in ) :: p2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd),ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(p2(:1,:ncol,:nlay,:nbnd),gpt_lims(:,:nbnd)) & !$acc&     copy(g1(:ncol,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2, ssa2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:p2, gpt_lims) & !$omp& map(tofrom:g1) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * p2 ( 1 , icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 endif end do end do end do end do end subroutine inc_2stream_by_nstream_bybnd ! --------------------------------- ! --------------------------------- ! increment nstream by 1scalar subroutine inc_nstream_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! p is unchanged endif end do end do end do end do end subroutine inc_nstream_by_1scalar_bybnd ! --------------------------------- ! increment nstream by 2stream subroutine inc_nstream_by_2stream_bybnd ( ncol , nlay , ngpt , nmom1 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , g2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 , g2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 real ( wp ) :: temp_mom ! TK integer :: imom !TK !$acc parallel loop collapse(3) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt),p1(:nmom1,:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc&     copyin(gpt_lims(:,:nbnd),g2(:ncol,:nlay,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(tofrom:tau1) & !$omp& map(to:ssa2) & !$omp& map(tofrom:ssa1, p1) & !$omp& map(to:tau2) & !$omp& map(to:gpt_lims, g2) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) ! ! Here assume Henyey-Greenstein ! temp_mom = g2 ( icol , ilay , ibnd ) do imom = 1 , nmom1 p1 ( imom , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( imom , icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * temp_mom ) / max ( eps , tauscat12 ) temp_mom = temp_mom * g2 ( icol , ilay , igpt ) end do ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 endif end do end do end do end do end subroutine inc_nstream_by_2stream_bybnd ! --------------------------------- ! increment nstream by nstream subroutine inc_nstream_by_nstream_bybnd ( ncol , nlay , ngpt , nmom1 , nmom2 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , p2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nmom2 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , nbnd ), intent ( in ) :: p2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd , mom_lim real ( wp ) :: tau12 , tauscat12 mom_lim = min ( nmom1 , nmom2 ) !$acc parallel loop collapse(3) & !$acc&     copyin(p2(:mom_lim,:ncol,:nlay,:nbnd)) & !$acc&     copy(ssa1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(ssa2(:ncol,:nlay,:nbnd)) & !$acc&     copy(tau1(:ncol,:nlay,:ngpt)) & !$acc&     copyin(tau2(:ncol,:nlay,:nbnd)) & !$acc&     copy(p1(:mom_lim,:ncol,:nlay,:ngpt)) & !$acc&     copyin(gpt_lims(:,:nbnd)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:p2) & !$omp& map(tofrom:ssa1) & !$omp& map(to:ssa2) & !$omp& map(tofrom:tau1) & !$omp& map(to:tau2) & !$omp& map(tofrom:p1) & !$omp& map(to:gpt_lims) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol do ibnd = 1 , nbnd if ( igpt >= gpt_lims ( 1 , ibnd ) . and . igpt <= gpt_lims ( 2 , ibnd ) ) then tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) ! ! If op2 has more moments than op1 these are ignored; !   if it has fewer moments the higher orders are assumed to be 0 ! p1 ( 1 : mom_lim , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : mom_lim , icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * p2 ( 1 : mom_lim , icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 endif end do end do end do end do end subroutine inc_nstream_by_nstream_bybnd ! --------------------------------- ! ------------------------------------------------------------------------------------------------- ! ! Subsetting, meaning extracting some portion of the 3D domain ! ! ------------------------------------------------------------------------------------------------- subroutine extract_subset_dim1_3d ( ncol , nlay , ngpt , array_in , colS , colE , array_out ) & bind ( C , name = \"extract_subset_dim1_3d\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: array_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: array_out integer :: icol , ilay , igpt !$acc parallel loop collapse(3) & !$acc&     copyout(array_out(:cole-cols+1,:nlay,:ngpt)) & !$acc&     copyin(array_in(cols:cole,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(from:array_out) & !$omp& map(to:array_in) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE array_out ( icol - colS + 1 , ilay , igpt ) = array_in ( icol , ilay , igpt ) end do end do end do end subroutine extract_subset_dim1_3d ! --------------------------------- subroutine extract_subset_dim2_4d ( nmom , ncol , nlay , ngpt , array_in , colS , colE , array_out ) & bind ( C , name = \"extract_subset_dim2_4d\" ) integer , intent ( in ) :: nmom , ncol , nlay , ngpt real ( wp ), dimension ( nmom , ncol , nlay , ngpt ), intent ( in ) :: array_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( nmom , colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: array_out integer :: icol , ilay , igpt , imom !$acc parallel loop collapse(4) & !$acc&     copyout(array_out(:nmom,:cole-cols+1,:nlay,:ngpt)) & !$acc&     copyin(array_in(:nmom,cols:cole,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(4) & !$omp& map(from:array_out) & !$omp& map(to:array_in) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE do imom = 1 , nmom array_out ( imom , icol - colS + 1 , ilay , igpt ) = array_in ( imom , icol , ilay , igpt ) end do end do end do end do end subroutine extract_subset_dim2_4d ! --------------------------------- ! ! Extract the absorption optical thickness which requires mulitplying by 1 - ssa ! subroutine extract_subset_absorption_tau ( ncol , nlay , ngpt , tau_in , ssa_in , & colS , colE , tau_out ) & bind ( C , name = \"extract_subset_absorption_tau\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau_in , ssa_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: tau_out integer :: icol , ilay , igpt !$acc parallel loop collapse(3) & !$acc&     copyin(ssa_in(cols:cole,:nlay,:ngpt)) & !$acc&     copyout(tau_out(:cole-cols+1,:nlay,:ngpt)) & !$acc&     copyin(tau_in(cols:cole,:nlay,:ngpt)) !$omp target teams distribute parallel do simd collapse(3) & !$omp& map(to:ssa_in) & !$omp& map(from:tau_out) & !$omp& map(to:tau_in) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE tau_out ( icol - colS + 1 , ilay , igpt ) = & tau_in ( icol , ilay , igpt ) * ( 1._wp - ssa_in ( icol , ilay , igpt )) end do end do end do end subroutine extract_subset_absorption_tau end module mo_optical_props_kernels","tags":"","loc":"sourcefile/mo_optical_props_kernels.f90.html"},{"title":"mo_fluxes_broadband_kernels.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_fluxes_broadband_kernels.f90~~EfferentGraph sourcefile~mo_fluxes_broadband_kernels.f90 mo_fluxes_broadband_kernels.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_fluxes_broadband_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_fluxes_broadband_kernels.f90~~AfferentGraph sourcefile~mo_fluxes_broadband_kernels.f90 mo_fluxes_broadband_kernels.F90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_fluxes_broadband_kernels.f90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_fluxes_broadband_kernels Source Code mo_fluxes_broadband_kernels.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Kernels for computing broadband fluxes by summing over all elements in the spectral dimension ! ! ------------------------------------------------------------------------------------------------- module mo_fluxes_broadband_kernels use , intrinsic :: iso_c_binding use mo_rte_kind , only : wp implicit none private public :: sum_broadband , net_broadband interface net_broadband module procedure net_broadband_full , net_broadband_precalc end interface net_broadband contains ! ---------------------------------------------------------------------------- ! ! Spectral reduction over all points ! subroutine sum_broadband ( ncol , nlev , ngpt , spectral_flux , broadband_flux ) bind ( C , name = \"sum_broadband\" ) integer , intent ( in ) :: ncol , nlev , ngpt real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( in ) :: spectral_flux real ( wp ), dimension ( ncol , nlev ), intent ( out ) :: broadband_flux integer :: icol , ilev , igpt real ( wp ) :: bb_flux_s ! local scalar version !$acc enter data copyin(spectral_flux) create(broadband_flux) !$omp target enter data map(to:spectral_flux) map(alloc:broadband_flux) !$acc parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilev = 1 , nlev do icol = 1 , ncol bb_flux_s = 0.0_wp do igpt = 1 , ngpt bb_flux_s = bb_flux_s + spectral_flux ( icol , ilev , igpt ) end do broadband_flux ( icol , ilev ) = bb_flux_s end do end do !$acc exit data delete(spectral_flux) copyout(broadband_flux) !$omp target exit data map(release:spectral_flux) map(from:broadband_flux) end subroutine sum_broadband ! ---------------------------------------------------------------------------- ! ! Net flux: Spectral reduction over all points ! subroutine net_broadband_full ( ncol , nlev , ngpt , spectral_flux_dn , spectral_flux_up , broadband_flux_net ) & bind ( C , name = \"net_broadband_full\" ) integer , intent ( in ) :: ncol , nlev , ngpt real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( in ) :: spectral_flux_dn , spectral_flux_up real ( wp ), dimension ( ncol , nlev ), intent ( out ) :: broadband_flux_net integer :: icol , ilev , igpt real ( wp ) :: diff !$acc enter data copyin(spectral_flux_dn, spectral_flux_up) create(broadband_flux_net) !$omp target enter data map(to:spectral_flux_dn, spectral_flux_up) map(alloc:broadband_flux_net) !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilev = 1 , nlev do icol = 1 , ncol diff = spectral_flux_dn ( icol , ilev , 1 ) - spectral_flux_up ( icol , ilev , 1 ) broadband_flux_net ( icol , ilev ) = diff end do end do !$acc parallel loop collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 2 , ngpt do ilev = 1 , nlev do icol = 1 , ncol diff = spectral_flux_dn ( icol , ilev , igpt ) - spectral_flux_up ( icol , ilev , igpt ) !$acc atomic update !$omp atomic update broadband_flux_net ( icol , ilev ) = broadband_flux_net ( icol , ilev ) + diff end do end do end do !$acc exit data delete(spectral_flux_dn, spectral_flux_up) copyout(broadband_flux_net) !$omp target exit data map(release:spectral_flux_dn, spectral_flux_up) map(from:broadband_flux_net) end subroutine net_broadband_full ! ---------------------------------------------------------------------------- ! ! Net flux when bradband flux up and down are already available ! subroutine net_broadband_precalc ( ncol , nlev , flux_dn , flux_up , broadband_flux_net ) & bind ( C , name = \"net_broadband_precalc\" ) integer , intent ( in ) :: ncol , nlev real ( wp ), dimension ( ncol , nlev ), intent ( in ) :: flux_dn , flux_up real ( wp ), dimension ( ncol , nlev ), intent ( out ) :: broadband_flux_net integer :: icol , ilev !$acc enter data copyin(flux_dn, flux_up) create(broadband_flux_net) !$omp target enter data map(to:flux_dn, flux_up) map(alloc:broadband_flux_net) !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilev = 1 , nlev do icol = 1 , ncol broadband_flux_net ( icol , ilev ) = flux_dn ( icol , ilev ) - flux_up ( icol , ilev ) end do end do !$acc exit data delete(flux_dn, flux_up) copyout(broadband_flux_net) !$omp target exit data map(release:flux_dn, flux_up) map(from:broadband_flux_net) end subroutine net_broadband_precalc ! ---------------------------------------------------------------------------- end module mo_fluxes_broadband_kernels","tags":"","loc":"sourcefile/mo_fluxes_broadband_kernels.f90.html"},{"title":"mo_rte_solver_kernels.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rte_solver_kernels.f90~2~~EfferentGraph sourcefile~mo_rte_solver_kernels.f90~2 mo_rte_solver_kernels.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rte_solver_kernels.f90~2->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_rte_solver_kernels.f90~2->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_solver_kernels Source Code mo_rte_solver_kernels.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2021,  Atmospheric and Environmental Research, ! Regents of the University of Colorado, Trustees of Columbia University.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Numeric calculations for radiative transfer solvers. !   Emission/absorption (no-scattering) calculations !     solver for multi-angle Gaussian quadrature !     solver for a single angle, calling !       source function computation (linear-in-tau) !       transport !   Extinction-only calculation (direct solar beam) !   Two-stream calculations !     solvers for LW and SW with different boundary conditions and source functions !       source function calculation for LW, SW !       two-stream calculations for LW, SW (using different assumtions about phase function) !       transport (adding) !   Application of boundary conditions ! ! ------------------------------------------------------------------------------------------------- module mo_rte_solver_kernels use , intrinsic :: iso_c_binding use mo_rte_kind , only : wp , wl use mo_rte_util_array , only : zero_array implicit none private public :: lw_solver_noscat , lw_solver_noscat_GaussQuad , lw_solver_2stream , & sw_solver_noscat , sw_solver_2stream real ( wp ), parameter :: pi = acos ( - 1._wp ) contains ! ------------------------------------------------------------------------------------------------- ! ! Top-level longwave kernels ! ! ------------------------------------------------------------------------------------------------- ! ! LW fluxes, no scattering, mu (cosine of integration angle) specified by column !   Does radiation calculation at user-supplied angles; converts radiances to flux !   using user-supplied weights ! ! --------------------------------------------------------------- subroutine lw_solver_noscat ( ncol , nlay , ngpt , top_at_1 , D , weight , & tau , lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & incident_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) bind ( C , name = \"lw_solver_noscat\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: D ! secant of propagation angle  [] real ( wp ), intent ( in ) :: weight ! quadrature weight real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] ! Planck source at layer edge for radiation in increasing/decreasing ilay direction ! lev_source_dec applies the mapping in layer i to the Planck function at layer i ! lev_source_inc applies the mapping in layer i to the Planck function at layer i+1 real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( in ) :: lev_source_inc , lev_source_dec real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: incident_flux ! Boundary condition for flux [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & ! Fluxes [W/m2] intent ( out ) :: flux_up , flux_dn ! ! Optional variables - arrays aren't referenced if corresponding logical  == False ! logical ( wl ), intent ( in ) :: do_broadband real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: broadband_up , broadband_dn ! Spectrally-integrated fluxes [W/m2] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_srcJac ! surface temperature Jacobian of surface source function [W/m2/K] real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: flux_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] logical ( wl ), intent ( in ) :: do_rescaling real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: ssa , g ! single-scattering albedo, asymmetry parameter ! ------------------------------------ ! Local variables, no g-point dependency ! integer :: icol , ilay , igpt integer :: top_level , sfc_level real ( wp ), dimension ( ncol , nlay ) :: tau_loc , & ! path length (tau/mu) trans ! transmissivity  = exp(-tau) real ( wp ), dimension ( ncol , nlay ) :: source_dn , source_up real ( wp ), dimension ( ncol ) :: sfc_albedo real ( wp ), dimension (:,:,:), pointer :: lev_source_up , lev_source_dn ! Mapping increasing/decreasing indicies to up/down real ( wp ), parameter :: pi = acos ( - 1._wp ) ! loc_fluxes hold a single g-point flux if fluxes are being integrated instead of returned !   with spectral detail real ( wp ), dimension ( ncol , nlay + 1 ), & target :: loc_flux_up , loc_flux_dn ! gpt_fluxes point to calculations for the current g-point real ( wp ), dimension (:,:), pointer :: gpt_flux_up , gpt_flux_dn ! ------------------------------------------------------------------------------------------------- ! Optionally, use an approximate treatment of scattering using rescaling !   Implemented based on the paper !   Tang G, et al, 2018: https://doi.org/10.1175/JAS-D-18-0014.1 !   a) relies on rescaling of the optical parameters based on asymetry factor and single scattering albedo !       scaling can be computed  by scaling_1rescl !   b) adds adustment term based on cloud properties (lw_transport_1rescl) !      adustment terms is computed based on solution of the Tang equations !      for \"linear-in-tau\" internal source (not in the paper) ! ! Used when approximating scattering ! real ( wp ) :: ssal , wb , scaleTau real ( wp ), dimension ( ncol , nlay ) :: An , Cn real ( wp ), dimension ( ncol , nlay + 1 ) :: gpt_flux_Jac ! ------------------------------------ ! Which way is up? ! Level Planck sources for upward and downward radiation ! When top_at_1, lev_source_up => lev_source_dec !                lev_source_dn => lev_source_inc, and vice-versa if ( top_at_1 ) then top_level = 1 sfc_level = nlay + 1 lev_source_up => lev_source_dec lev_source_dn => lev_source_inc else top_level = nlay + 1 sfc_level = 1 lev_source_up => lev_source_inc lev_source_dn => lev_source_dec end if ! ! Integrated fluxes need zeroing ! if ( do_broadband ) then call zero_array ( ncol , nlay + 1 , broadband_up ) call zero_array ( ncol , nlay + 1 , broadband_dn ) end if if ( do_Jacobians ) & call zero_array ( ncol , nlay + 1 , flux_upJac ) do igpt = 1 , ngpt if ( do_broadband ) then gpt_flux_up => loc_flux_up gpt_flux_dn => loc_flux_dn else gpt_flux_up => flux_up (:,:, igpt ) gpt_flux_dn => flux_dn (:,:, igpt ) end if ! ! Transport is for intensity !   convert flux at top of domain to intensity assuming azimuthal isotropy ! gpt_flux_dn (:, top_level ) = incident_flux (:, igpt ) / ( 2._wp * pi * weight ) ! ! Optical path and transmission, used in source function and transport calculations ! if ( do_rescaling ) then ! ! The scaling and scaleTau terms are independent of propagation !   angle D and could be pre-computed if several values of D are used ! We re-compute them here to keep not have to localize memory use ! do ilay = 1 , nlay do icol = 1 , ncol ssal = ssa ( icol , ilay , igpt ) ! w is the layer single scattering albedo ! b is phase function parameter (Eq.13 of the paper) ! for the similarity principle scaling scheme ! b = (1-g)/2 (where g is phase function avergae cosine) wb = ssal * ( 1._wp - g ( icol , ilay , igpt )) * 0.5_wp ! scaleTau=1-w(1-b) is a scaling factor of the optical thickness representing ! the radiative transfer equation in a nonscattering form Eq(14) of the paper scaleTau = ( 1._wp - ssal + wb ) ! Cn = 0.5*wb/(1-w(1-b)) is parameter of Eq.21-22 of the Tang paper ! Tang paper, p.2222 advises to replace 0.5 with 0.4 based on simulations Cn ( icol , ilay ) = 0.4_wp * wb / scaleTau ! Eqs.15, 18ab and 19 of the paper, ! rescaling of the optical depth multiplied by path length tau_loc ( icol , ilay ) = tau ( icol , ilay , igpt ) * D ( icol , igpt ) * scaleTau end do trans (:, ilay ) = exp ( - tau_loc (:, ilay )) An (:, ilay ) = ( 1._wp - trans (:, ilay ) ** 2 ) end do else do ilay = 1 , nlay tau_loc (:, ilay ) = tau (:, ilay , igpt ) * D (:, igpt ) trans (:, ilay ) = exp ( - tau_loc (:, ilay )) end do end if ! ! Source function for diffuse radiation ! call lw_source_noscat ( ncol , nlay , & lay_source (:,:, igpt ), lev_source_up (:,:, igpt ), lev_source_dn (:,:, igpt ), & tau_loc , trans , source_dn , source_up ) ! ! Transport down ! call lw_transport_noscat_dn ( ncol , nlay , top_at_1 , trans , source_dn , gpt_flux_dn ) ! ! Surface albedo, surface source function, reflection and emission ! sfc_albedo (:) = 1._wp - sfc_emis (:, igpt ) gpt_flux_up (:, sfc_level ) = gpt_flux_dn (:, sfc_level ) * sfc_albedo (:) + & sfc_emis (:, igpt ) * sfc_src (:, igpt ) if ( do_Jacobians ) & gpt_flux_Jac (:, sfc_level ) = sfc_emis (:, igpt ) * sfc_srcJac (:, igpt ) ! ! Transport up, or up and down again if using rescaling ! if ( do_rescaling ) then call lw_transport_1rescl ( ncol , nlay , top_at_1 , trans , & source_dn , source_up , & gpt_flux_up , gpt_flux_dn , An , Cn , & do_Jacobians , gpt_flux_Jac ) ! Standing in for Jacobian, i.e. rad_up_Jac(:,:,igpt), rad_dn_Jac(:,:,igpt)) else call lw_transport_noscat_up ( ncol , nlay , top_at_1 , trans , source_up , gpt_flux_up , & do_Jacobians , gpt_flux_Jac ) end if if ( do_broadband ) then broadband_up (:,:) = broadband_up (:,:) + gpt_flux_up (:,:) broadband_dn (:,:) = broadband_dn (:,:) + gpt_flux_dn (:,:) else ! ! Convert intensity to flux assuming azimuthal isotropy and quadrature weight ! gpt_flux_dn (:,:) = 2._wp * pi * weight * gpt_flux_dn (:,:) gpt_flux_up (:,:) = 2._wp * pi * weight * gpt_flux_up (:,:) end if ! ! Only broadband-integrated Jacobians are provided ! if ( do_Jacobians ) & flux_upJac (:,:) = flux_upJac (:,:) + gpt_flux_Jac (:,:) end do ! g point loop if ( do_broadband ) then broadband_up (:,:) = 2._wp * pi * weight * broadband_up (:,:) broadband_dn (:,:) = 2._wp * pi * weight * broadband_dn (:,:) end if if ( do_Jacobians ) & flux_upJac (:,:) = 2._wp * pi * weight * flux_upJac (:,:) end subroutine lw_solver_noscat ! ------------------------------------------------------------------------------------------------- ! ! LW transport, no scattering, multi-angle quadrature !   Users provide a set of weights and quadrature angles !   Routine sums over single-angle solutions for each sets of angles/weights ! ! --------------------------------------------------------------- subroutine lw_solver_noscat_GaussQuad ( ncol , nlay , ngpt , top_at_1 , & nmus , Ds , weights , & tau , & lay_source , lev_source_inc , lev_source_dec , & sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) bind ( C , name = \"lw_solver_noscat_GaussQuad\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 integer , intent ( in ) :: nmus ! number of quadrature angles real ( wp ), dimension ( ncol , ngpt , & nmus ), intent ( in ) :: Ds real ( wp ), dimension ( nmus ), intent ( in ) :: weights ! quadrature secants, weights real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_source_inc ! Planck source at layer edge for radiation in increasing ilay direction [W/m2] ! Includes spectral weighting that accounts for state-dependent frequency to g-space mapping real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lev_source_dec ! Planck source at layer edge for radiation in decreasing ilay direction [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux ! Incident diffuse flux, probably 0 [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ! Optional variables - arrays aren't referenced if corresponding logical  == False ! logical ( wl ), intent ( in ) :: do_broadband real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( out ) :: broadband_up , broadband_dn ! Spectrally-integrated fluxes [W/m2] logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_srcJac ! surface temperature Jacobian of surface source function [W/m2/K] real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( out ) :: flux_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] logical ( wl ), intent ( in ) :: do_rescaling real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: ssa , g ! single-scattering albedo, asymmetry parameter ! ------------------------------------ ! ! Local variables - used for a single quadrature angle ! real ( wp ), dimension (:,:,:), pointer :: this_flux_up , this_flux_dn real ( wp ), dimension (:,:), pointer :: this_broadband_up , this_broadband_dn , this_flux_upJac integer :: imu ! ------------------------------------ ! ! For the first angle output arrays store total flux ! call lw_solver_noscat ( ncol , nlay , ngpt , & top_at_1 , Ds (:,:, 1 ), weights ( 1 ), tau , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn , & do_broadband , broadband_up , broadband_dn , & do_Jacobians , sfc_srcJac , flux_upJac , & do_rescaling , ssa , g ) ! ! For more than one angle use local arrays ! if ( nmus > 1 ) then if ( do_broadband ) then allocate ( this_broadband_up ( ncol , nlay + 1 ), this_broadband_dn ( ncol , nlay + 1 )) ! Spectrally-resolved fluxes won't be filled in so can point to caller-supplied memory this_flux_up => flux_up this_flux_dn => flux_dn else allocate ( this_flux_up ( ncol , nlay + 1 , ngpt ), this_flux_dn ( ncol , nlay + 1 , ngpt )) ! Spectrally-integrated fluxes won't be filled in so can point to caller-supplied memory this_broadband_up => broadband_up this_broadband_dn => broadband_dn end if if ( do_Jacobians ) then allocate ( this_flux_upJac ( ncol , nlay + 1 )) else this_flux_upJac => flux_upJac end if end if do imu = 2 , nmus call lw_solver_noscat ( ncol , nlay , ngpt , & top_at_1 , Ds (:,:, imu ), weights ( imu ), tau , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & this_flux_up , this_flux_dn , & do_broadband , this_broadband_up , this_broadband_dn , & do_Jacobians , sfc_srcJac , this_flux_upJac , & do_rescaling , ssa , g ) if ( do_broadband ) then broadband_up (:,:) = broadband_up (:,:) + this_broadband_up (:,:) broadband_dn (:,:) = broadband_dn (:,:) + this_broadband_dn (:,:) else flux_up (:,:,:) = flux_up (:,:,:) + this_flux_up (:,:,:) flux_dn (:,:,:) = flux_dn (:,:,:) + this_flux_dn (:,:,:) end if if ( do_Jacobians ) & flux_upJac (:,:) = flux_upJac (:,: ) + this_flux_upJac (:,: ) end do if ( nmus > 1 ) then if ( do_broadband ) deallocate ( this_broadband_up , this_broadband_dn ) if (. not . do_broadband ) deallocate ( this_flux_up , this_flux_dn ) if ( do_Jacobians ) deallocate ( this_flux_upJac ) end if end subroutine lw_solver_noscat_GaussQuad ! ------------------------------------------------------------------------------------------------- ! ! Longwave two-stream calculation: !   combine RRTMGP-specific sources at levels !   compute layer reflectance, transmittance !   compute total source function at levels using linear-in-tau !   transport ! ! ------------------------------------------------------------------------------------------------- subroutine lw_solver_2stream ( ncol , nlay , ngpt , top_at_1 , & tau , ssa , g , & lay_source , lev_source_inc , lev_source_dec , sfc_emis , sfc_src , & inc_flux , & flux_up , flux_dn ) bind ( C , name = \"lw_solver_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , & ! Optical thickness, ssa , & ! single-scattering albedo, g ! asymmetry parameter [] real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: lay_source ! Planck source at layer average temperature [W/m2] real ( wp ), dimension ( ncol , nlay , ngpt ), target , & intent ( in ) :: lev_source_inc , lev_source_dec ! Planck source at layer edge for radiation in increasing/decreasing ilay direction [W/m2] ! Includes spectral weighting that accounts for state-dependent frequency to g-space mapping real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_emis ! Surface emissivity      [] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_src ! Surface source function [W/m2] real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux ! Incident diffuse flux, probably 0 [W/m2] real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_up , flux_dn ! Fluxes [W/m2] ! ---------------------------------------------------------------------- integer :: igpt , top_level real ( wp ), dimension ( ncol , nlay ) :: Rdif , Tdif , gamma1 , gamma2 real ( wp ), dimension ( ncol ) :: sfc_albedo real ( wp ), dimension ( ncol , nlay + 1 ) :: lev_source real ( wp ), dimension ( ncol , nlay ) :: source_dn , source_up real ( wp ), dimension ( ncol ) :: source_sfc ! ------------------------------------ top_level = nlay + 1 if ( top_at_1 ) top_level = 1 do igpt = 1 , ngpt ! ! RRTMGP provides source functions at each level using the spectral mapping !   of each adjacent layer. Combine these for two-stream calculations ! call lw_combine_sources ( ncol , nlay , top_at_1 , & lev_source_inc (:,:, igpt ), lev_source_dec (:,:, igpt ), & lev_source ) ! ! Cell properties: reflection, transmission for diffuse radiation !   Coupling coefficients needed for source function ! call lw_two_stream ( ncol , nlay , & tau (:,:, igpt ), ssa (:,:, igpt ), g (:,:, igpt ), & gamma1 , gamma2 , Rdif , Tdif ) ! ! Source function for diffuse radiation ! call lw_source_2str ( ncol , nlay , top_at_1 , & sfc_emis (:, igpt ), sfc_src (:, igpt ), & lay_source (:,:, igpt ), lev_source , & gamma1 , gamma2 , Rdif , Tdif , tau (:,:, igpt ), & source_dn , source_up , source_sfc ) ! ! Transport ! sfc_albedo ( 1 : ncol ) = 1._wp - sfc_emis (:, igpt ) ! ! Boundary condition ! flux_dn (:, top_level , igpt ) = inc_flux (:, igpt ) call adding ( ncol , nlay , top_at_1 , & sfc_albedo , & Rdif , Tdif , & source_dn , source_up , source_sfc , & flux_up (:,:, igpt ), flux_dn (:,:, igpt )) end do end subroutine lw_solver_2stream ! ------------------------------------------------------------------------------------------------- ! !   Top-level shortwave kernels ! ! ------------------------------------------------------------------------------------------------- ! !   Extinction-only i.e. solar direct beam ! ! ------------------------------------------------------------------------------------------------- pure subroutine sw_solver_noscat ( ncol , nlay , ngpt , top_at_1 , & tau , mu0 , inc_flux_dir , flux_dir ) bind ( C , name = \"sw_solver_noscat\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau ! Absorption optical thickness [] real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 ! cosine of solar zenith angle real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux_dir ! Direct beam incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), intent ( out ) :: flux_dir ! Direct-beam flux, spectral [W/m2] integer :: ilev , igpt real ( wp ) :: mu0_inv ( ncol ) ! ------------------------------------ mu0_inv ( 1 : ncol ) = 1._wp / mu0 ( 1 : ncol ) ! Indexing into arrays for upward and downward propagation depends on the vertical !   orientation of the arrays (whether the domain top is at the first or last index) ! We write the loops out explicitly so compilers will have no trouble optimizing them. ! Downward propagation if ( top_at_1 ) then ! For the flux at this level, what was the previous level, and which layer has the !   radiation just passed through? ! layer index = level index - 1 ! previous level is up (-1) do igpt = 1 , ngpt flux_dir (:, 1 , igpt ) = inc_flux_dir (:, igpt ) * mu0 (:) do ilev = 2 , nlay + 1 flux_dir (:, ilev , igpt ) = flux_dir (:, ilev - 1 , igpt ) * exp ( - tau (:, ilev - 1 , igpt ) * mu0_inv (:)) end do end do else ! layer index = level index ! previous level is up (+1) do igpt = 1 , ngpt flux_dir (:, nlay + 1 , igpt ) = inc_flux_dir (:, igpt ) * mu0 (:) do ilev = nlay , 1 , - 1 flux_dir (:, ilev , igpt ) = flux_dir (:, ilev + 1 , igpt ) * exp ( - tau (:, ilev , igpt ) * mu0_inv (:)) end do end do end if end subroutine sw_solver_noscat ! ------------------------------------------------------------------------------------------------- ! ! Shortwave two-stream calculation: !   compute layer reflectance, transmittance !   compute solar source function for diffuse radiation !   transport ! ! ------------------------------------------------------------------------------------------------- subroutine sw_solver_2stream ( ncol , nlay , ngpt , top_at_1 , & tau , ssa , g , mu0 , & sfc_alb_dir , sfc_alb_dif , & inc_flux_dir , & flux_up , flux_dn , flux_dir , & has_dif_bc , inc_flux_dif , & do_broadband , broadband_up , & broadband_dn , broadband_dir ) bind ( C , name = \"sw_solver_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau , & ! Optical thickness, ssa , & ! single-scattering albedo, g ! asymmetry parameter [] real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 ! cosine of solar zenith angle ! Spectral albedo of surface to direct and diffuse radiation real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: sfc_alb_dir , sfc_alb_dif , & inc_flux_dir ! Direct beam incident flux real ( wp ), dimension ( ncol , nlay + 1 , ngpt ), target , & intent ( out ) :: flux_up , flux_dn , flux_dir ! Fluxes [W/m2] logical ( wl ), intent ( in ) :: has_dif_bc ! Is a boundary condition for diffuse flux supplied? real ( wp ), dimension ( ncol , ngpt ), intent ( in ) :: inc_flux_dif ! Boundary condition for diffuse flux logical ( wl ), intent ( in ) :: do_broadband ! Provide broadband-integrated, not spectrally-resolved, fluxes? real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: broadband_up , broadband_dn , broadband_dir ! -------------------------------------------           ! Broadband integrated fluxes integer :: igpt , top_level real ( wp ), dimension ( ncol , nlay ) :: Rdif , Tdif real ( wp ), dimension ( ncol , nlay ) :: source_up , source_dn real ( wp ), dimension ( ncol ) :: source_srf ! loc_fluxes hold a single g-point flux if fluxes are being integrated instead of returned !   with spectral detail real ( wp ), dimension ( ncol , nlay + 1 ), & target :: loc_flux_up , loc_flux_dn , loc_flux_dir ! gpt_fluxes point to calculations for the current g-point real ( wp ), dimension (:,:), pointer :: gpt_flux_up , gpt_flux_dn , gpt_flux_dir ! ------------------------------------ top_level = nlay + 1 if ( top_at_1 ) top_level = 1 ! ! Integrated fluxes need zeroing ! if ( do_broadband ) then call zero_array ( ncol , nlay + 1 , broadband_up ) call zero_array ( ncol , nlay + 1 , broadband_dn ) call zero_array ( ncol , nlay + 1 , broadband_dir ) end if do igpt = 1 , ngpt if ( do_broadband ) then gpt_flux_up => loc_flux_up gpt_flux_dn => loc_flux_dn gpt_flux_dir => loc_flux_dir else gpt_flux_up => flux_up (:,:, igpt ) gpt_flux_dn => flux_dn (:,:, igpt ) gpt_flux_dir => flux_dir (:,:, igpt ) end if ! ! Boundary conditions direct beam... ! gpt_flux_dir (:, top_level ) = inc_flux_dir (:, igpt ) * mu0 (:) ! ! ... and diffuse field, using 0 if no BC is provided ! if ( has_dif_bc ) then gpt_flux_dn (:, top_level ) = inc_flux_dif (:, igpt ) else gpt_flux_dn (:, top_level ) = 0._wp end if ! ! Cell properties: transmittance and reflectance for diffuse radiation !   Direct-beam and source for diffuse radiation ! call sw_dif_and_source ( ncol , nlay , top_at_1 , mu0 , sfc_alb_dir (:, igpt ), & tau (:,:, igpt ), ssa (:,:, igpt ), g (:,:, igpt ), & Rdif , Tdif , source_dn , source_up , source_srf , & gpt_flux_dir ) ! ! Transport ! call adding ( ncol , nlay , top_at_1 , & sfc_alb_dif (:, igpt ), Rdif , Tdif , & source_dn , source_up , source_srf , gpt_flux_up , gpt_flux_dn ) ! ! adding() computes only diffuse flux; flux_dn is total ! if ( do_broadband ) then broadband_up (:,:) = broadband_up (:,:) + gpt_flux_up (:,:) broadband_dn (:,:) = broadband_dn (:,:) + gpt_flux_dn (:,:) + gpt_flux_dir (:,:) broadband_dir (:,:) = broadband_dir (:,:) + gpt_flux_dir (:,:) else gpt_flux_dn (:,:) = gpt_flux_dn (:,:) + gpt_flux_dir (:,:) end if end do end subroutine sw_solver_2stream ! ------------------------------------------------------------------------------------------------- ! !   Lower-level longwave kernels ! ! ------------------------------------------------------------------------------------------------- ! ! Compute LW source function for upward and downward emission at levels using linear-in-tau assumption ! See Clough et al., 1992, doi: 10.1029/92JD01419, Eq 13 ! ! --------------------------------------------------------------- subroutine lw_source_noscat ( ncol , nlay , lay_source , lev_source_up , lev_source_dn , tau , trans , & source_dn , source_up ) bind ( C , name = \"lw_source_noscat\" ) integer , intent ( in ) :: ncol , nlay real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: lay_source , & ! Planck source at layer center lev_source_up , & ! Planck source at levels (layer edges), lev_source_dn , & !   increasing/decreasing layer index tau , & ! Optical path (tau/mu) trans ! Transmissivity (exp(-tau)) real ( wp ), dimension ( ncol , nlay ), intent ( out ) :: source_dn , source_up ! Source function at layer edges ! Down at the bottom of the layer, up at the top ! -------------------------------- integer :: icol , ilay real ( wp ) :: fact real ( wp ), parameter :: tau_thresh = sqrt ( epsilon ( tau )) ! --------------------------------------------------------------- do ilay = 1 , nlay do icol = 1 , ncol ! ! Weighting factor. Use 2nd order series expansion when rounding error (~tau&#94;2) !   is of order epsilon (smallest difference from 1. in working precision) !   Thanks to Peter Blossey ! if ( tau ( icol , ilay ) > tau_thresh ) then fact = ( 1._wp - trans ( icol , ilay )) / tau ( icol , ilay ) - trans ( icol , ilay ) else fact = tau ( icol , ilay ) * ( 0.5_wp - 1._wp / 3._wp * tau ( icol , ilay )) end if ! ! Equation below is developed in Clough et al., 1992, doi:10.1029/92JD01419, Eq 13 ! source_dn ( icol , ilay ) = ( 1._wp - trans ( icol , ilay )) * lev_source_dn ( icol , ilay ) + & 2._wp * fact * ( lay_source ( icol , ilay ) - lev_source_dn ( icol , ilay )) source_up ( icol , ilay ) = ( 1._wp - trans ( icol , ilay )) * lev_source_up ( icol , ilay ) + & 2._wp * fact * ( lay_source ( icol , ilay ) - lev_source_up ( icol , ilay )) end do end do end subroutine lw_source_noscat ! ------------------------------------------------------------------------------------------------- ! ! Longwave no-scattering transport - separate routines for up and down ! ! ------------------------------------------------------------------------------------------------- subroutine lw_transport_noscat_dn ( ncol , nlay , top_at_1 , & trans , source_dn , radn_dn ) bind ( C , name = \"lw_transport_noscat_dn\" ) integer , intent ( in ) :: ncol , nlay ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 ! real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: trans ! transmissivity = exp(-tau) real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: source_dn ! Diffuse radiation emitted by the layer real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: radn_dn ! Radiances [W/m2-str] Top level must contain incident flux boundary condition ! --------------------------------------------------- ! Local variables integer :: ilev ! --------------------------------------------------- if ( top_at_1 ) then ! ! Top of domain is index 1 ! do ilev = 2 , nlay + 1 radn_dn (:, ilev ) = trans (:, ilev - 1 ) * radn_dn (:, ilev - 1 ) + source_dn (:, ilev - 1 ) end do else ! ! Top of domain is index nlay+1 ! do ilev = nlay , 1 , - 1 radn_dn (:, ilev ) = trans (:, ilev ) * radn_dn (:, ilev + 1 ) + source_dn (:, ilev ) end do end if end subroutine lw_transport_noscat_dn ! ------------------------------------------------------------------------------------------------- subroutine lw_transport_noscat_up ( ncol , nlay , top_at_1 , & trans , source_up , radn_up , do_Jacobians , radn_upJac ) bind ( C , name = \"lw_transport_noscat_up\" ) integer , intent ( in ) :: ncol , nlay ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 ! real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: trans ! transmissivity = exp(-tau) real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: source_up ! Diffuse radiation emitted by the layer real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: radn_up ! Radiances [W/m2-str] Top level must contain incident flux boundary condition logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: radn_upJac ! surface temperature Jacobian of Radiances [W/m2-str / K] ! --------------------------------------------------- ! Local variables integer :: ilev ! --------------------------------------------------- if ( top_at_1 ) then ! ! Top of domain is index 1 ! ! Upward propagation do ilev = nlay , 1 , - 1 radn_up (:, ilev ) = trans (:, ilev ) * radn_up (:, ilev + 1 ) + source_up (:, ilev ) if ( do_Jacobians ) & radn_upJac (:, ilev ) = trans (:, ilev ) * radn_upJac (:, ilev + 1 ) end do else ! ! Top of domain is index nlay+1 ! ! Upward propagation do ilev = 2 , nlay + 1 radn_up (:, ilev ) = trans (:, ilev - 1 ) * radn_up (:, ilev - 1 ) + source_up (:, ilev - 1 ) if ( do_Jacobians ) & radn_upJac (:, ilev ) = trans (:, ilev - 1 ) * radn_upJac (:, ilev - 1 ) end do end if end subroutine lw_transport_noscat_up ! ------------------------------------------------------------------------------------------------- ! Upward and (second) downward transport for re-scaled longwave solution !   adds adjustment factor based on cloud properties ! !   implementation notice: !       the adjustmentFactor computation can be skipped where Cn <= epsilon ! ------------------------------------------------------------------------------------------------- subroutine lw_transport_1rescl ( ncol , nlay , top_at_1 , & trans , source_dn , source_up , & radn_up , radn_dn , An , Cn ,& do_Jacobians , radn_up_Jac ) bind ( C , name = \"lw_transport_1rescl\" ) integer , intent ( in ) :: ncol , nlay ! Number of columns, layers, g-points logical ( wl ), intent ( in ) :: top_at_1 ! real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: trans ! transmissivity = exp(-tau) real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: source_dn , & source_up ! Diffuse radiation emitted by the layer real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: radn_up ! Radiances [W/m2-str] real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: radn_dn !Top level must contain incident flux boundary condition real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: An , Cn logical ( wl ), intent ( in ) :: do_Jacobians real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: radn_up_Jac ! Surface temperature Jacobians [W/m2-str/K] ! ! We could in principle compute a downwelling Jacobian too, but it's small !   (only a small proportion of LW is scattered) and it complicates code and the API, !   so we will not ! ! Local variables integer :: ilev , icol ! --------------------------------------------------- real ( wp ) :: adjustmentFactor if ( top_at_1 ) then ! ! Top of domain is index 1 ! ! Upward propagation ! adjustment factor is obtained as a solution of 18b of the Tang paper ! eqvivalent to Eq.20 of the Tang paper but for linear-in-tau source do ilev = nlay , 1 , - 1 do icol = 1 , ncol adjustmentFactor = Cn ( icol , ilev ) * ( An ( icol , ilev ) * radn_dn ( icol , ilev ) - & trans ( icol , ilev ) * source_dn ( icol , ilev ) - source_up ( icol , ilev ) ) radn_up ( icol , ilev ) = trans ( icol , ilev ) * radn_up ( icol , ilev + 1 ) + source_up ( icol , ilev ) + & adjustmentFactor end do if ( do_Jacobians ) & radn_up_Jac (:, ilev ) = trans (:, ilev ) * radn_up_Jac (:, ilev + 1 ) end do ! Downward propagation ! radn_dn_Jac(:,1) = 0._wp ! adjustment factor is obtained as a solution of 19 of the Tang paper ! eqvivalent to Eq.21 of the Tang paper but for linear-in-tau source do ilev = 1 , nlay ! radn_dn_Jac(:,ilev+1) = trans(:,ilev)*radn_dn_Jac(:,ilev) do icol = 1 , ncol adjustmentFactor = Cn ( icol , ilev ) * ( An ( icol , ilev ) * radn_up ( icol , ilev ) - & trans ( icol , ilev ) * source_up ( icol , ilev ) - source_dn ( icol , ilev ) ) radn_dn ( icol , ilev + 1 ) = trans ( icol , ilev ) * radn_dn ( icol , ilev ) + source_dn ( icol , ilev ) + & adjustmentFactor ! adjustmentFactor         = Cn(icol,ilev)*An(icol,ilev)*radn_up_Jac(icol,ilev) ! radn_dn_Jac(icol,ilev+1) = radn_dn_Jac(icol,ilev+1) + adjustmentFactor enddo end do else ! ! Top of domain is index nlay+1 ! ! Upward propagation ! adjustment factor is obtained as a solution of 18b of the Tang paper ! eqvivalent to Eq.20 of the Tang paper but for linear-in-tau source do ilev = 1 , nlay radn_up (:, ilev + 1 ) = trans (:, ilev ) * radn_up (:, ilev ) + source_up (:, ilev ) do icol = 1 , ncol adjustmentFactor = Cn ( icol , ilev ) * ( An ( icol , ilev ) * radn_dn ( icol , ilev + 1 ) - & trans ( icol , ilev ) * source_dn ( icol , ilev ) - source_up ( icol , ilev ) ) radn_up ( icol , ilev + 1 ) = trans ( icol , ilev ) * radn_up ( icol , ilev ) + source_up ( icol , ilev ) + & adjustmentFactor enddo if ( do_Jacobians ) & radn_up_Jac (:, ilev + 1 ) = trans (:, ilev ) * radn_up_Jac (:, ilev ) end do ! Downward propagation ! adjustment factor is obtained as a solution of 19 of the Tang paper ! eqvivalent to Eq.21 of the Tang paper but for linear-in-tau source ! radn_dn_Jac(:,nlay+1) = 0._wp do ilev = nlay , 1 , - 1 ! radn_dn_Jac(:,ilev) = trans(:,ilev)*radn_dn_Jac(:,ilev+1) do icol = 1 , ncol adjustmentFactor = Cn ( icol , ilev ) * ( An ( icol , ilev ) * radn_up ( icol , ilev ) - & trans ( icol , ilev ) * source_up ( icol , ilev ) - source_dn ( icol , ilev ) ) radn_dn ( icol , ilev ) = trans ( icol , ilev ) * radn_dn ( icol , ilev + 1 ) + source_dn ( icol , ilev ) + & adjustmentFactor ! adjustmentFactor    = Cn(icol,ilev)*An(icol,ilev)*radn_up_Jac(icol,ilev) ! radn_dn_Jac(icol,ilev) = radn_dn_Jac(icol,ilev) + adjustmentFactor enddo end do end if end subroutine lw_transport_1rescl ! ------------------------------------------------------------------------------------------------- ! ! Longwave two-stream solutions to diffuse reflectance and transmittance for a layer !    with optical depth tau, single scattering albedo w0, and asymmetery parameter g. ! ! Equations are developed in Meador and Weaver, 1980, !    doi:10.1175/1520-0469(1980)037<0630:TSATRT>2.0.CO;2 ! ! ------------------------------------------------------------------------------------------------- pure subroutine lw_two_stream ( ncol , nlay , tau , w0 , g , & gamma1 , gamma2 , Rdif , Tdif ) bind ( C , name = \"lw_two_stream\" ) integer , intent ( in ) :: ncol , nlay real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: tau , w0 , g real ( wp ), dimension ( ncol , nlay ), intent ( out ) :: gamma1 , gamma2 , Rdif , Tdif ! ----------------------- integer :: i , j ! Variables used in Meador and Weaver real ( wp ) :: k ( ncol ) ! Ancillary variables real ( wp ) :: RT_term ( ncol ) real ( wp ) :: exp_minusktau ( ncol ), exp_minus2ktau ( ncol ) real ( wp ), parameter :: LW_diff_sec = 1.66 ! 1./cos(diffusivity angle) ! --------------------------------- do j = 1 , nlay do i = 1 , ncol ! ! Coefficients differ from SW implementation because the phase function is more isotropic !   Here we follow Fu et al. 1997, doi:10.1175/1520-0469(1997)054<2799:MSPITI>2.0.CO;2 !   and use a diffusivity sec of 1.66 ! gamma1 ( i , j ) = LW_diff_sec * ( 1._wp - 0.5_wp * w0 ( i , j ) * ( 1._wp + g ( i , j ))) ! Fu et al. Eq 2.9 gamma2 ( i , j ) = LW_diff_sec * 0.5_wp * w0 ( i , j ) * ( 1._wp - g ( i , j )) ! Fu et al. Eq 2.10 ! Eq 18;  k = SQRT(gamma1**2 - gamma2**2), limited below to avoid div by 0. !   k = 0 for isotropic, conservative scattering; this lower limit on k !   gives relative error with respect to conservative solution !   of < 0.1% in Rdif down to tau = 10&#94;-9 k ( i ) = sqrt ( max (( gamma1 ( i , j ) - gamma2 ( i , j )) * ( gamma1 ( i , j ) + gamma2 ( i , j )), 1.e-12_wp )) end do ! Written to encourage vectorization of exponential exp_minusktau ( 1 : ncol ) = exp ( - tau ( 1 : ncol , j ) * k ( 1 : ncol )) ! ! Diffuse reflection and transmission ! do i = 1 , ncol exp_minus2ktau ( i ) = exp_minusktau ( i ) * exp_minusktau ( i ) ! Refactored to avoid rounding errors when k, gamma1 are of very different magnitudes RT_term ( i ) = 1._wp / ( k ( i ) * ( 1._wp + exp_minus2ktau ( i )) + & gamma1 ( i , j ) * ( 1._wp - exp_minus2ktau ( i )) ) ! Equation 25 Rdif ( i , j ) = RT_term ( i ) * gamma2 ( i , j ) * ( 1._wp - exp_minus2ktau ( i )) ! Equation 26 Tdif ( i , j ) = RT_term ( i ) * 2._wp * k ( i ) * exp_minusktau ( i ) end do end do end subroutine lw_two_stream ! ------------------------------------------------------------------------------------------------- ! ! Source function combination ! RRTMGP provides two source functions at each level !   using the spectral mapping from each of the adjascent layers. !   Need to combine these for use in two-stream calculation. ! ! ------------------------------------------------------------------------------------------------- subroutine lw_combine_sources ( ncol , nlay , top_at_1 , & lev_src_inc , lev_src_dec , lev_source ) bind ( C , name = \"lw_combine_sources\" ) integer , intent ( in ) :: ncol , nlay logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: lev_src_inc , lev_src_dec real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: lev_source integer :: icol , ilay ! --------------------------------------------------------------- ilay = 1 do icol = 1 , ncol lev_source ( icol , ilay ) = lev_src_dec ( icol , ilay ) end do do ilay = 2 , nlay do icol = 1 , ncol lev_source ( icol , ilay ) = sqrt ( lev_src_dec ( icol , ilay ) * & lev_src_inc ( icol , ilay - 1 )) end do end do ilay = nlay + 1 do icol = 1 , ncol lev_source ( icol , ilay ) = lev_src_inc ( icol , ilay - 1 ) end do end subroutine lw_combine_sources ! --------------------------------------------------------------- ! ! Compute LW source function for upward and downward emission at levels using linear-in-tau assumption !   This version straight from ECRAD !   Source is provided as W/m2-str; factor of pi converts to flux units ! ! --------------------------------------------------------------- subroutine lw_source_2str ( ncol , nlay , top_at_1 , & sfc_emis , sfc_src , & lay_source , lev_source , & gamma1 , gamma2 , rdif , tdif , tau , source_dn , source_up , source_sfc ) & bind ( C , name = \"lw_source_2str\" ) integer , intent ( in ) :: ncol , nlay logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol ), intent ( in ) :: sfc_emis , sfc_src real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: lay_source , & ! Planck source at layer center tau , & ! Optical depth (tau) gamma1 , gamma2 ,& ! Coupling coefficients rdif , tdif ! Layer reflectance and transmittance real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( in ) :: lev_source ! Planck source at layer edges real ( wp ), dimension ( ncol , nlay ), intent ( out ) :: source_dn , source_up real ( wp ), dimension ( ncol ), intent ( out ) :: source_sfc ! Source function for upward radation at surface integer :: icol , ilay real ( wp ) :: Z , Zup_top , Zup_bottom , Zdn_top , Zdn_bottom real ( wp ), dimension (:), pointer :: lev_source_bot , lev_source_top ! --------------------------------------------------------------- do ilay = 1 , nlay if ( top_at_1 ) then lev_source_top => lev_source (:, ilay ) lev_source_bot => lev_source (:, ilay + 1 ) else lev_source_top => lev_source (:, ilay + 1 ) lev_source_bot => lev_source (:, ilay ) end if do icol = 1 , ncol if ( tau ( icol , ilay ) > 1.0e-8_wp ) then ! ! Toon et al. (JGR 1989) Eqs 26-27 ! Z = ( lev_source_bot ( icol ) - lev_source_top ( icol )) / ( tau ( icol , ilay ) * ( gamma1 ( icol , ilay ) + gamma2 ( icol , ilay ))) Zup_top = Z + lev_source_top ( icol ) Zup_bottom = Z + lev_source_bot ( icol ) Zdn_top = - Z + lev_source_top ( icol ) Zdn_bottom = - Z + lev_source_bot ( icol ) source_up ( icol , ilay ) = pi * ( Zup_top - rdif ( icol , ilay ) * Zdn_top - tdif ( icol , ilay ) * Zup_bottom ) source_dn ( icol , ilay ) = pi * ( Zdn_bottom - rdif ( icol , ilay ) * Zup_bottom - tdif ( icol , ilay ) * Zdn_top ) else source_up ( icol , ilay ) = 0._wp source_dn ( icol , ilay ) = 0._wp end if end do end do do icol = 1 , ncol source_sfc ( icol ) = pi * sfc_emis ( icol ) * sfc_src ( icol ) end do end subroutine lw_source_2str ! ------------------------------------------------------------------------------------------------- ! !   Lower-level shortwave kernels ! ! ------------------------------------------------------------------------------------------------- ! ! Two-stream solutions to diffuse reflectance and transmittance for a layer !    with optical depth tau, single scattering albedo w0, and asymmetery parameter g. ! Direct reflectance and transmittance used to compute direct beam source for diffuse radiation !   in layers and at surface; report direct beam as a byproduct ! Computing the direct-beam source for diffuse radiation at the same time as R and T for !   direct radiation reduces memory traffic and use. ! ! Equations are developed in Meador and Weaver, 1980, !    doi:10.1175/1520-0469(1980)037<0630:TSATRT>2.0.CO;2 ! ! ------------------------------------------------------------------------------------------------- pure subroutine sw_dif_and_source ( ncol , nlay , top_at_1 , mu0 , sfc_albedo , & tau , w0 , g , & Rdif , Tdif , source_dn , source_up , source_sfc , flux_dn_dir ) bind ( C , name = \"sw_source_dir\" ) integer , intent ( in ) :: ncol , nlay logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol ), intent ( in ) :: mu0 , sfc_albedo ! surface albedo for direct radiation real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: tau , w0 , g real ( wp ), dimension ( ncol , nlay ), intent ( out ) :: Rdif , Tdif , source_dn , source_up real ( wp ), dimension ( ncol ), intent ( out ) :: source_sfc ! Source function for upward radation at surface real ( wp ), dimension ( ncol , nlay + 1 ), target , & intent ( inout ) :: flux_dn_dir ! Direct beam flux ! ----------------------- integer :: i , j ! Variables used in Meador and Weaver real ( wp ) :: gamma1 , gamma2 , gamma3 , gamma4 , alpha1 , alpha2 ! Ancillary variables real ( wp ) :: k , exp_minusktau , k_mu , k_gamma3 , k_gamma4 real ( wp ) :: RT_term , exp_minus2ktau real ( wp ) :: Rdir , Tdir , Tnoscat real ( wp ), pointer , dimension (:) :: dir_flux_inc , dir_flux_trans integer :: lay_index real ( wp ) :: tau_s , w0_s , g_s , mu0_s ! --------------------------------- do j = 1 , nlay if ( top_at_1 ) then lay_index = j dir_flux_inc => flux_dn_dir (:, lay_index ) dir_flux_trans => flux_dn_dir (:, lay_index + 1 ) else lay_index = nlay - j + 1 dir_flux_inc => flux_dn_dir (:, lay_index + 1 ) dir_flux_trans => flux_dn_dir (:, lay_index ) end if do i = 1 , ncol ! ! Scalars ! tau_s = tau ( i , lay_index ) w0_s = w0 ( i , lay_index ) g_s = g ( i , lay_index ) mu0_s = mu0 ( i ) ! ! Zdunkowski Practical Improved Flux Method \"PIFM\" !  (Zdunkowski et al., 1980;  Contributions to Atmospheric Physics 53, 147-66) ! gamma1 = ( 8._wp - w0_s * ( 5._wp + 3._wp * g_s )) * . 25_wp gamma2 = 3._wp * ( w0_s * ( 1._wp - g_s )) * . 25_wp gamma3 = ( 2._wp - 3._wp * mu0_s * g_s ) * . 25_wp gamma4 = 1._wp - gamma3 alpha1 = gamma1 * gamma4 + gamma2 * gamma3 ! Eq. 16 alpha2 = gamma1 * gamma3 + gamma2 * gamma4 ! Eq. 17 ! ! Direct reflect and transmission ! ! Eq 18;  k = SQRT(gamma1**2 - gamma2**2), limited below to avoid div by 0. !   k = 0 for isotropic, conservative scattering; this lower limit on k !   gives relative error with respect to conservative solution !   of < 0.1% in Rdif down to tau = 10&#94;-9 k = sqrt ( max (( gamma1 - gamma2 ) * ( gamma1 + gamma2 ), 1.e-12_wp )) k_mu = k * mu0_s k_gamma3 = k * gamma3 k_gamma4 = k * gamma4 exp_minusktau = exp ( - tau_s * k ) exp_minus2ktau = exp_minusktau * exp_minusktau ! Refactored to avoid rounding errors when k, gamma1 are of very different magnitudes RT_term = 1._wp / ( k * ( 1._wp + exp_minus2ktau ) + & gamma1 * ( 1._wp - exp_minus2ktau ) ) ! Equation 25 Rdif ( i , lay_index ) = RT_term * gamma2 * ( 1._wp - exp_minus2ktau ) ! Equation 26 Tdif ( i , lay_index ) = RT_term * 2._wp * k * exp_minusktau ! ! Equation 14, multiplying top and bottom by exp(-k*tau) !   and rearranging to avoid div by 0. ! RT_term = w0_s * RT_term / merge ( 1._wp - k_mu * k_mu , & epsilon ( 1._wp ), & abs ( 1._wp - k_mu * k_mu ) >= epsilon ( 1._wp )) ! ! Transmittance of direct, unscattered beam. ! Tnoscat = exp ( - tau_s / mu0_s ) Rdir = RT_term * & (( 1._wp - k_mu ) * ( alpha2 + k_gamma3 ) - & ( 1._wp + k_mu ) * ( alpha2 - k_gamma3 ) * exp_minus2ktau - & 2.0_wp * ( k_gamma3 - alpha2 * k_mu ) * exp_minusktau * Tnoscat ) ! ! Equation 15, multiplying top and bottom by exp(-k*tau), !   multiplying through by exp(-tau/mu0) to !   prefer underflow to overflow ! Omitting direct transmittance ! Tdir = - RT_term * & (( 1._wp + k_mu ) * ( alpha1 + k_gamma4 ) * Tnoscat - & ( 1._wp - k_mu ) * ( alpha1 - k_gamma4 ) * exp_minus2ktau * Tnoscat - & 2.0_wp * ( k_gamma4 + alpha1 * k_mu ) * exp_minusktau ) source_up ( i , lay_index ) = Rdir * dir_flux_inc ( i ) source_dn ( i , lay_index ) = Tdir * dir_flux_inc ( i ) dir_flux_trans ( i ) = Tnoscat * dir_flux_inc ( i ) end do end do source_sfc (:) = dir_flux_trans (:) * sfc_albedo (:) end subroutine sw_dif_and_source ! --------------------------------------------------------------- ! ! Transport of diffuse radiation through a vertically layered atmosphere. !   Equations are after Shonk and Hogan 2008, doi:10.1175/2007JCLI1940.1 (SH08) !   This routine is shared by longwave and shortwave ! ! ------------------------------------------------------------------------------------------------- subroutine adding ( ncol , nlay , top_at_1 , & albedo_sfc , & rdif , tdif , & src_dn , src_up , src_sfc , & flux_up , flux_dn ) bind ( C , name = \"adding\" ) integer , intent ( in ) :: ncol , nlay logical ( wl ), intent ( in ) :: top_at_1 real ( wp ), dimension ( ncol ), intent ( in ) :: albedo_sfc real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: rdif , tdif real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: src_dn , src_up real ( wp ), dimension ( ncol ), intent ( in ) :: src_sfc real ( wp ), dimension ( ncol , nlay + 1 ), intent ( out ) :: flux_up ! intent(inout) because top layer includes incident flux real ( wp ), dimension ( ncol , nlay + 1 ), intent ( inout ) :: flux_dn ! ------------------ integer :: ilev real ( wp ), dimension ( ncol , nlay + 1 ) :: albedo , & ! reflectivity to diffuse radiation below this level ! alpha in SH08 src ! source of diffuse upwelling radiation from emission or ! scattering of direct beam ! G in SH08 real ( wp ), dimension ( ncol , nlay ) :: denom ! beta in SH08 ! ------------------ ! ! Indexing into arrays for upward and downward propagation depends on the vertical !   orientation of the arrays (whether the domain top is at the first or last index) ! We write the loops out explicitly so compilers will have no trouble optimizing them. ! if ( top_at_1 ) then ilev = nlay + 1 ! Albedo of lowest level is the surface albedo... albedo (:, ilev ) = albedo_sfc (:) ! ... and source of diffuse radiation is surface emission src (:, ilev ) = src_sfc (:) ! ! From bottom to top of atmosphere -- !   compute albedo and source of upward radiation ! do ilev = nlay , 1 , - 1 denom (:, ilev ) = 1._wp / ( 1._wp - rdif (:, ilev ) * albedo (:, ilev + 1 )) ! Eq 10 albedo (:, ilev ) = rdif (:, ilev ) + & tdif (:, ilev ) * tdif (:, ilev ) * albedo (:, ilev + 1 ) * denom (:, ilev ) ! Equation 9 ! ! Equation 11 -- source is emitted upward radiation at top of layer plus !   radiation emitted at bottom of layer, !   transmitted through the layer and reflected from layers below (tdiff*src*albedo) ! src (:, ilev ) = src_up (:, ilev ) + & tdif (:, ilev ) * denom (:, ilev ) * & ( src (:, ilev + 1 ) + albedo (:, ilev + 1 ) * src_dn (:, ilev )) end do ! Eq 12, at the top of the domain upwelling diffuse is due to ... ilev = 1 flux_up (:, ilev ) = flux_dn (:, ilev ) * albedo (:, ilev ) + & ! ... reflection of incident diffuse and src (:, ilev ) ! emission from below ! ! From the top of the atmosphere downward -- compute fluxes ! do ilev = 2 , nlay + 1 flux_dn (:, ilev ) = ( tdif (:, ilev - 1 ) * flux_dn (:, ilev - 1 ) + & ! Equation 13 rdif (:, ilev - 1 ) * src (:, ilev ) + & src_dn (:, ilev - 1 )) * denom (:, ilev - 1 ) flux_up (:, ilev ) = flux_dn (:, ilev ) * albedo (:, ilev ) + & ! Equation 12 src (:, ilev ) end do else ilev = 1 ! Albedo of lowest level is the surface albedo... albedo (:, ilev ) = albedo_sfc (:) ! ... and source of diffuse radiation is surface emission src (:, ilev ) = src_sfc (:) ! ! From bottom to top of atmosphere -- !   compute albedo and source of upward radiation ! do ilev = 1 , nlay denom (:, ilev ) = 1._wp / ( 1._wp - rdif (:, ilev ) * albedo (:, ilev )) ! Eq 10 albedo (:, ilev + 1 ) = rdif (:, ilev ) + & tdif (:, ilev ) * tdif (:, ilev ) * albedo (:, ilev ) * denom (:, ilev ) ! Equation 9 ! ! Equation 11 -- source is emitted upward radiation at top of layer plus !   radiation emitted at bottom of layer, !   transmitted through the layer and reflected from layers below (tdiff*src*albedo) ! src (:, ilev + 1 ) = src_up (:, ilev ) + & tdif (:, ilev ) * denom (:, ilev ) * & ( src (:, ilev ) + albedo (:, ilev ) * src_dn (:, ilev )) end do ! Eq 12, at the top of the domain upwelling diffuse is due to ... ilev = nlay + 1 flux_up (:, ilev ) = flux_dn (:, ilev ) * albedo (:, ilev ) + & ! ... reflection of incident diffuse and src (:, ilev ) ! scattering by the direct beam below ! ! From the top of the atmosphere downward -- compute fluxes ! do ilev = nlay , 1 , - 1 flux_dn (:, ilev ) = ( tdif (:, ilev ) * flux_dn (:, ilev + 1 ) + & ! Equation 13 rdif (:, ilev ) * src (:, ilev ) + & src_dn (:, ilev )) * denom (:, ilev ) flux_up (:, ilev ) = flux_dn (:, ilev ) * albedo (:, ilev ) + & ! Equation 12 src (:, ilev ) end do end if end subroutine adding end module mo_rte_solver_kernels","tags":"","loc":"sourcefile/mo_rte_solver_kernels.f90~2.html"},{"title":"mo_optical_props_kernels.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_optical_props_kernels.f90~2~~EfferentGraph sourcefile~mo_optical_props_kernels.f90~2 mo_optical_props_kernels.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_optical_props_kernels.f90~2->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_optical_props_kernels Source Code mo_optical_props_kernels.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Kernels for arrays of optical properties: !   delta-scaling !   adding two sets of properties !   extracting subsets !   validity checking ! ! ------------------------------------------------------------------------------------------------- module mo_optical_props_kernels use , intrinsic :: iso_c_binding use mo_rte_kind , only : wp , wl implicit none public interface delta_scale_2str_kernel module procedure delta_scale_2str_f_k , delta_scale_2str_k end interface interface extract_subset module procedure extract_subset_dim1_3d , extract_subset_dim2_4d module procedure extract_subset_absorption_tau end interface extract_subset real ( wp ), parameter , private :: eps = 3.0_wp * tiny ( 1.0_wp ) contains ! ------------------------------------------------------------------------------------------------- ! ! Delta-scaling, provided only for two-stream properties at present ! ! ------------------------------------------------------------------------------------------------- ! Delta-scale two-stream optical properties !   user-provided value of f (forward scattering) ! pure subroutine delta_scale_2str_f_k ( ncol , nlay , ngpt , tau , ssa , g , f ) & bind ( C , name = \"delta_scale_2str_f_k\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau , ssa , g real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: f real ( wp ) :: wf integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol wf = ssa ( icol , ilay , igpt ) * f ( icol , ilay , igpt ) tau ( icol , ilay , igpt ) = ( 1._wp - wf ) * tau ( icol , ilay , igpt ) ssa ( icol , ilay , igpt ) = ( ssa ( icol , ilay , igpt ) - wf ) / max ( eps ,( 1.0_wp - wf )) g ( icol , ilay , igpt ) = ( g ( icol , ilay , igpt ) - f ( icol , ilay , igpt )) / & max ( eps ,( 1._wp - f ( icol , ilay , igpt ))) end do end do end do end subroutine delta_scale_2str_f_k ! --------------------------------- ! Delta-scale !   f = g*g ! pure subroutine delta_scale_2str_k ( ncol , nlay , ngpt , tau , ssa , g ) & bind ( C , name = \"delta_scale_2str_k\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau , ssa , g real ( wp ) :: f , wf integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol f = g ( icol , ilay , igpt ) * g ( icol , ilay , igpt ) wf = ssa ( icol , ilay , igpt ) * f tau ( icol , ilay , igpt ) = ( 1._wp - wf ) * tau ( icol , ilay , igpt ) ssa ( icol , ilay , igpt ) = ( ssa ( icol , ilay , igpt ) - wf ) / max ( eps ,( 1.0_wp - wf )) g ( icol , ilay , igpt ) = ( g ( icol , ilay , igpt ) - f ) / max ( eps ,( 1.0_wp - f )) end do end do end do end subroutine delta_scale_2str_k ! ------------------------------------------------------------------------------------------------- ! ! Addition of optical properties: the first set are incremented by the second set. ! !   There are three possible representations of optical properties (scalar = optical depth only; !   two-stream = tau, single-scattering albedo, and asymmetry factor g, and !   n-stream = tau, ssa, and phase function moments p.) Thus we need nine routines, three for !   each choice of representation on the left hand side times three representations of the !   optical properties to be added. ! !   There are two sets of these nine routines. In the first the two sets of optical !   properties are defined at the same spectral resolution. There is also a set of routines !   to add properties defined at lower spectral resolution to a set defined at higher spectral !   resolution (adding properties defined by band to those defined by g-point) ! ! ------------------------------------------------------------------------------------------------- pure subroutine increment_1scalar_by_1scalar ( ncol , nlay , ngpt , & tau1 , & tau2 ) bind ( C , name = \"increment_1scalar_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) end do end do end do end subroutine increment_1scalar_by_1scalar ! --------------------------------- ! increment 1scalar by 2stream pure subroutine increment_1scalar_by_2stream ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 ) bind ( C , name = \"increment_1scalar_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ( 1._wp - ssa2 ( icol , ilay , igpt )) end do end do end do end subroutine increment_1scalar_by_2stream ! --------------------------------- ! increment 1scalar by nstream pure subroutine increment_1scalar_by_nstream ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 ) bind ( C , name = \"increment_1scalar_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ( 1._wp - ssa2 ( icol , ilay , igpt )) end do end do end do end subroutine increment_1scalar_by_nstream ! --------------------------------- ! --------------------------------- ! increment 2stream by 1scalar pure subroutine increment_2stream_by_1scalar ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 ) bind ( C , name = \"increment_2stream_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt real ( wp ) :: tau12 do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! g is unchanged end do end do end do end subroutine increment_2stream_by_1scalar ! --------------------------------- ! increment 2stream by 2stream pure subroutine increment_2stream_by_2stream ( ncol , nlay , ngpt , & tau1 , ssa1 , g1 , & tau2 , ssa2 , g2 ) bind ( C , name = \"increment_2stream_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 , g2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * g2 ( icol , ilay , igpt )) & / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end subroutine increment_2stream_by_2stream ! --------------------------------- ! increment 2stream by nstream pure subroutine increment_2stream_by_nstream ( ncol , nlay , ngpt , nmom2 , & tau1 , ssa1 , g1 , & tau2 , ssa2 , p2 ) bind ( C , name = \"increment_2stream_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom2 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , ngpt ), intent ( in ) :: p2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * p2 ( 1 , icol , ilay , igpt )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end subroutine increment_2stream_by_nstream ! --------------------------------- ! --------------------------------- ! increment nstream by 1scalar pure subroutine increment_nstream_by_1scalar ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 ) bind ( C , name = \"increment_nstream_by_1scalar\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 integer :: icol , ilay , igpt real ( wp ) :: tau12 do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! p is unchanged end do end do end do end subroutine increment_nstream_by_1scalar ! --------------------------------- ! increment nstream by 2stream pure subroutine increment_nstream_by_2stream ( ncol , nlay , ngpt , nmom1 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , g2 ) bind ( C , name = \"increment_nstream_by_2stream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 , g2 integer :: icol , ilay , igpt real ( wp ) :: tau12 , tauscat12 real ( wp ), dimension ( nmom1 ) :: temp_moms ! TK integer :: imom !TK do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) ! ! Here assume Henyey-Greenstein ! temp_moms ( 1 ) = g2 ( icol , ilay , igpt ) do imom = 2 , nmom1 temp_moms ( imom ) = temp_moms ( imom - 1 ) * g2 ( icol , ilay , igpt ) end do p1 ( 1 : nmom1 , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : nmom1 , icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * temp_moms ( 1 : nmom1 ) ) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end subroutine increment_nstream_by_2stream ! --------------------------------- ! increment nstream by nstream pure subroutine increment_nstream_by_nstream ( ncol , nlay , ngpt , nmom1 , nmom2 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , p2 ) bind ( C , name = \"increment_nstream_by_nstream\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nmom2 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , ngpt ), intent ( in ) :: p2 integer :: icol , ilay , igpt , mom_lim real ( wp ) :: tau12 , tauscat12 mom_lim = min ( nmom1 , nmom2 ) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , igpt ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) ! ! If op2 has more moments than op1 these are ignored; !   if it has fewer moments the higher orders are assumed to be 0 ! p1 ( 1 : mom_lim , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : mom_lim , icol , ilay , igpt ) + & tau2 ( icol , ilay , igpt ) * ssa2 ( icol , ilay , igpt ) * p2 ( 1 : mom_lim , icol , ilay , igpt )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end subroutine increment_nstream_by_nstream ! ------------------------------------------------------------------------------------------------- ! ! Incrementing when the second set of optical properties is defined at lower spectral resolution !   (e.g. by band instead of by gpoint) ! ! ------------------------------------------------------------------------------------------------- pure subroutine inc_1scalar_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) tau1 (:,:, igpt ) = tau1 (:,:, igpt ) + tau2 (:,:, ibnd ) end do end do end subroutine inc_1scalar_by_1scalar_bybnd ! --------------------------------- ! increment 1scalar by 2stream pure subroutine inc_1scalar_by_2stream_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) tau1 (:,:, igpt ) = tau1 (:,:, igpt ) + tau2 (:,:, ibnd ) * ( 1._wp - ssa2 (:,:, ibnd )) end do end do end subroutine inc_1scalar_by_2stream_bybnd ! --------------------------------- ! increment 1scalar by nstream pure subroutine inc_1scalar_by_nstream_bybnd ( ncol , nlay , ngpt , & tau1 , & tau2 , ssa2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_1scalar_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: ibnd , igpt do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) tau1 (:,:, igpt ) = tau1 (:,:, igpt ) + tau2 (:,:, ibnd ) * ( 1._wp - ssa2 (:,:, ibnd )) end do end do end subroutine inc_1scalar_by_nstream_bybnd ! --------------------------------- ! increment 2stream by 1scalar pure subroutine inc_2stream_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! g is unchanged end do end do end do end do end subroutine inc_2stream_by_1scalar_bybnd ! --------------------------------- ! increment 2stream by 2stream pure subroutine inc_2stream_by_2stream_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , g1 , & tau2 , ssa2 , g2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 , g2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * g2 ( icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end do end subroutine inc_2stream_by_2stream_bybnd ! --------------------------------- ! increment 2stream by nstream pure subroutine inc_2stream_by_nstream_bybnd ( ncol , nlay , ngpt , nmom2 , & tau1 , ssa1 , g1 , & tau2 , ssa2 , p2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_2stream_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom2 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 , g1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , nbnd ), intent ( in ) :: p2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol ! t=tau1 + tau2 tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ! w=(tau1*ssa1 + tau2*ssa2) / t tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) g1 ( icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * g1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * p2 ( 1 , icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end do end subroutine inc_2stream_by_nstream_bybnd ! --------------------------------- ! --------------------------------- ! increment nstream by 1scalar pure subroutine inc_nstream_by_1scalar_bybnd ( ncol , nlay , ngpt , & tau1 , ssa1 , & tau2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_1scalar_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) ssa1 ( icol , ilay , igpt ) = tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 ! p is unchanged end do end do end do end do end subroutine inc_nstream_by_1scalar_bybnd ! --------------------------------- ! increment nstream by 2stream pure subroutine inc_nstream_by_2stream_bybnd ( ncol , nlay , ngpt , nmom1 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , g2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_2stream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 , g2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd real ( wp ) :: tau12 , tauscat12 real ( wp ), dimension ( nmom1 ) :: temp_moms ! TK integer :: imom !TK do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) ! ! Here assume Henyey-Greenstein ! temp_moms ( 1 ) = g2 ( icol , ilay , ibnd ) do imom = 2 , nmom1 temp_moms ( imom ) = temp_moms ( imom - 1 ) * g2 ( icol , ilay , ibnd ) end do p1 ( 1 : nmom1 , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : nmom1 , icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * temp_moms ( 1 : nmom1 ) ) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end do end subroutine inc_nstream_by_2stream_bybnd ! --------------------------------- ! increment nstream by nstream pure subroutine inc_nstream_by_nstream_bybnd ( ncol , nlay , ngpt , nmom1 , nmom2 , & tau1 , ssa1 , p1 , & tau2 , ssa2 , p2 , & nbnd , gpt_lims ) bind ( C , name = \"inc_nstream_by_nstream_bybnd\" ) integer , intent ( in ) :: ncol , nlay , ngpt , nmom1 , nmom2 , nbnd real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau1 , ssa1 real ( wp ), dimension ( nmom1 , & ncol , nlay , ngpt ), intent ( inout ) :: p1 real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: tau2 , ssa2 real ( wp ), dimension ( nmom2 , & ncol , nlay , nbnd ), intent ( in ) :: p2 integer , dimension ( 2 , nbnd ), intent ( in ) :: gpt_lims ! Starting and ending gpoint for each band integer :: icol , ilay , igpt , ibnd , mom_lim real ( wp ) :: tau12 , tauscat12 mom_lim = min ( nmom1 , nmom2 ) do ibnd = 1 , nbnd do igpt = gpt_lims ( 1 , ibnd ), gpt_lims ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol tau12 = tau1 ( icol , ilay , igpt ) + tau2 ( icol , ilay , ibnd ) tauscat12 = & tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) ! ! If op2 has more moments than op1 these are ignored; !   if it has fewer moments the higher orders are assumed to be 0 ! p1 ( 1 : mom_lim , icol , ilay , igpt ) = & ( tau1 ( icol , ilay , igpt ) * ssa1 ( icol , ilay , igpt ) * p1 ( 1 : mom_lim , icol , ilay , igpt ) + & tau2 ( icol , ilay , ibnd ) * ssa2 ( icol , ilay , ibnd ) * p2 ( 1 : mom_lim , icol , ilay , ibnd )) / max ( eps , tauscat12 ) ssa1 ( icol , ilay , igpt ) = tauscat12 / max ( eps , tau12 ) tau1 ( icol , ilay , igpt ) = tau12 end do end do end do end do end subroutine inc_nstream_by_nstream_bybnd ! ------------------------------------------------------------------------------------------------- ! ! Subsetting, meaning extracting some portion of the 3D domain ! ! ------------------------------------------------------------------------------------------------- pure subroutine extract_subset_dim1_3d ( ncol , nlay , ngpt , array_in , colS , colE , array_out ) & bind ( C , name = \"extract_subset_dim1_3d\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: array_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: array_out integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE array_out ( icol - colS + 1 , ilay , igpt ) = array_in ( icol , ilay , igpt ) end do end do end do end subroutine extract_subset_dim1_3d ! --------------------------------- pure subroutine extract_subset_dim2_4d ( nmom , ncol , nlay , ngpt , array_in , colS , colE , array_out ) & bind ( C , name = \"extract_subset_dim2_4d\" ) integer , intent ( in ) :: nmom , ncol , nlay , ngpt real ( wp ), dimension ( nmom , ncol , nlay , ngpt ), intent ( in ) :: array_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( nmom , colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: array_out integer :: icol , ilay , igpt , imom do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE do imom = 1 , nmom array_out ( imom , icol - colS + 1 , ilay , igpt ) = array_in ( imom , icol , ilay , igpt ) end do end do end do end do end subroutine extract_subset_dim2_4d ! --------------------------------- ! ! Extract the absorption optical thickness which requires mulitplying by 1 - ssa ! pure subroutine extract_subset_absorption_tau ( ncol , nlay , ngpt , tau_in , ssa_in , & colS , colE , tau_out ) & bind ( C , name = \"extract_subset_absorption_tau\" ) integer , intent ( in ) :: ncol , nlay , ngpt real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( in ) :: tau_in , ssa_in integer , intent ( in ) :: colS , colE real ( wp ), dimension ( colE - colS + 1 ,& nlay , ngpt ), intent ( out ) :: tau_out integer :: icol , ilay , igpt do igpt = 1 , ngpt do ilay = 1 , nlay do icol = colS , colE tau_out ( icol - colS + 1 , ilay , igpt ) = & tau_in ( icol , ilay , igpt ) * ( 1._wp - ssa_in ( icol , ilay , igpt )) end do end do end do end subroutine extract_subset_absorption_tau end module mo_optical_props_kernels","tags":"","loc":"sourcefile/mo_optical_props_kernels.f90~2.html"},{"title":"mo_rrtmgp_util_string.F90 – rte-rrtmgp","text":"Files dependent on this one sourcefile~~mo_rrtmgp_util_string.f90~~AfferentGraph sourcefile~mo_rrtmgp_util_string.f90 mo_rrtmgp_util_string.F90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rrtmgp_util_string Source Code mo_rrtmgp_util_string.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Routines for handling strings: !   convert to lower case !   does a string exist within an array of strings? !   what is the location of a string with an array? ! ! ------------------------------------------------------------------------------------------------- module mo_rrtmgp_util_string implicit none private public :: lower_case , string_in_array , string_loc_in_array ! List of character for case conversion character ( len = 26 ), parameter :: LOWER_CASE_CHARS = 'abcdefghijklmnopqrstuvwxyz' character ( len = 26 ), parameter :: UPPER_CASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' contains ! ------------------------------------------------------------------------------------------------- pure function lower_case ( input_string ) result ( output_string ) character ( len =* ), intent ( in ) :: input_string character ( len = len ( input_string )) :: output_string integer :: i , n ! Copy input string output_string = input_string ! Convert case character by character do i = 1 , len ( output_string ) n = index ( UPPER_CASE_CHARS , output_string ( i : i )) if ( n /= 0 ) output_string ( i : i ) = LOWER_CASE_CHARS ( n : n ) end do end function ! -------------------------------------------------------------------------------------- ! ! Is string somewhere in array? ! pure function string_in_array ( string , array ) character ( len =* ), intent ( in ) :: string character ( len =* ), dimension (:), intent ( in ) :: array logical :: string_in_array integer :: i character ( len = len_trim ( string )) :: lc_string string_in_array = . false . lc_string = lower_case ( trim ( string )) do i = 1 , size ( array ) if ( lc_string == lower_case ( trim ( array ( i )))) then string_in_array = . true . exit end if end do end function string_in_array ! -------------------------------------------------------------------------------------- ! ! Is string somewhere in array? ! pure function string_loc_in_array ( string , array ) character ( len =* ), intent ( in ) :: string character ( len =* ), dimension (:), intent ( in ) :: array integer :: string_loc_in_array integer :: i character ( len = len_trim ( string )) :: lc_string string_loc_in_array = - 1 lc_string = lower_case ( trim ( string )) do i = 1 , size ( array ) if ( lc_string == lower_case ( trim ( array ( i )))) then string_loc_in_array = i exit end if end do end function string_loc_in_array ! -------------------------------------------------------------------------------------- end module","tags":"","loc":"sourcefile/mo_rrtmgp_util_string.f90.html"},{"title":"mo_rrtmgp_util_reorder.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rrtmgp_util_reorder.f90~~EfferentGraph sourcefile~mo_rrtmgp_util_reorder.f90 mo_rrtmgp_util_reorder.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rrtmgp_util_reorder.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rrtmgp_util_reorder_kernels.f90 mo_rrtmgp_util_reorder_kernels.F90 sourcefile~mo_rrtmgp_util_reorder.f90->sourcefile~mo_rrtmgp_util_reorder_kernels.f90 sourcefile~mo_rrtmgp_util_reorder_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rrtmgp_util_reorder.f90~~AfferentGraph sourcefile~mo_rrtmgp_util_reorder.f90 mo_rrtmgp_util_reorder.F90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_util_reorder.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rrtmgp_util_reorder Source Code mo_rrtmgp_util_reorder.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Routines for permuting arrays: here one (x,y,z) -> (z,x,y) and (x,y,z) -> (z,y,x) !   Routines are just the front end to kernels ! ! ------------------------------------------------------------------------------------------------- module mo_rrtmgp_util_reorder use mo_rte_kind , only : wp use mo_rrtmgp_util_reorder_kernels , & only : reorder_123x321_kernel implicit none private public :: reorder123x321 contains ! ------------------------------------------------------------------------------------------------- ! ! (x,y,z) -> (z,y,x) ! subroutine reorder123x321 ( array , array_out ) real ( wp ), dimension (:,:,:), intent ( in ) :: array real ( wp ), dimension (:,:,:), intent ( out ) :: array_out call reorder_123x321_kernel ( size ( array , dim = 1 ), size ( array , dim = 2 ), size ( array , dim = 3 ), array , array_out ) end subroutine reorder123x321 ! ------------------------------------------------------------------------------------------------- end module","tags":"","loc":"sourcefile/mo_rrtmgp_util_reorder.f90.html"},{"title":"mo_gas_concentrations.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_gas_concentrations.f90~~EfferentGraph sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rrtmgp_util_string.f90 mo_rrtmgp_util_string.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_gas_concentrations.f90~~AfferentGraph sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_gas_concentrations Source Code mo_gas_concentrations.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! Encapsulates a collection of volume mixing ratios (concentrations) of gases. !   Each concentration is associated with a name, normally the chemical formula. ! ! Values may be provided as scalars, 1-dimensional profiles (nlay), or 2-D fields (ncol,nlay). !   (nlay and ncol are determined from the input arrays; self-consistency is enforced) !   example: !   error_msg = gas_concs%set_vmr('h2o', values(:,:)) !   error_msg = gas_concs%set_vmr('o3' , values(:)  ) !   error_msg = gas_concs%set_vmr('co2', value      ) ! ! Values can be requested as profiles (valid only if there are no 2D fields present in the object) !   or as 2D fields. Values for all columns are returned although the entire collection !   can be subsetted in the column dimension ! ! Subsets can be extracted in the column dimension ! ! Functions return strings. Non-empty strings indicate an error. ! ! ------------------------------------------------------------------------------------------------- module mo_gas_concentrations use mo_rte_kind , only : wp use mo_rte_config , only : check_values use mo_rrtmgp_util_string , only : lower_case use mo_rte_util_array , only : any_vals_outside implicit none integer , parameter :: GAS_NOT_IN_LIST = - 1 type , private :: conc_field real ( wp ), dimension (:,:), pointer :: conc => NULL () end type conc_field type , public :: ty_gas_concs ! ! Data ! character ( len = 32 ), dimension (:), allocatable :: gas_name type ( conc_field ), dimension (:), allocatable :: concs integer :: ncol = 0 , nlay = 0 contains ! ! Procedures ! procedure , private :: find_gas procedure , private :: set_vmr_scalar procedure , private :: set_vmr_1d procedure , private :: set_vmr_2d procedure , private :: get_vmr_1d procedure , private :: get_vmr_2d procedure , private :: get_subset_range final :: del ! ! public interface ! procedure , public :: init procedure , public :: reset generic , public :: set_vmr => set_vmr_scalar , & set_vmr_1d , & set_vmr_2d generic , public :: get_vmr => get_vmr_1d , & get_vmr_2d generic , public :: get_subset => get_subset_range procedure , public :: get_num_gases procedure , public :: get_gas_names end type ty_gas_concs contains ! ------------------------------------------------------------------------------------- function init ( this , gas_names ) result ( error_msg ) class ( ty_gas_concs ), intent ( inout ) :: this character ( len =* ), dimension (:), intent ( in ) :: gas_names character ( len = 128 ) :: error_msg ! --------- integer :: i , j , ngas ! --------- error_msg = '' ngas = size ( gas_names ) ! ! Check for no duplicate gas names, no empty names ! if ( any ( len_trim ( gas_names ) == 0 )) & error_msg = \"ty_gas_concs%init(): must provide non-empty gas names\" do i = 1 , ngas - 1 do j = i + 1 , ngas if ( lower_case ( trim ( gas_names ( i ))) == lower_case ( trim ( gas_names ( j )))) then error_msg = \"ty_gas_concs%init(): duplicate gas names aren't allowed\" exit end if end do end do if ( error_msg /= \"\" ) return ! ! Allocate fixed-size arrays ! call this % reset () allocate ( this % gas_name ( ngas ), this % concs ( ngas )) !$acc enter data copyin(this) !$acc enter data copyin(this%concs) !$omp target enter data map(to:this%concs) this % gas_name (:) = gas_names (:) end function ! ------------------------------------------------------------------------------------- ! ! Set concentrations --- scalar, 1D, 2D ! ! ------------------------------------------------------------------------------------- function set_vmr_scalar ( this , gas , w ) result ( error_msg ) ! In OpenACC context scalar w always assumed to be on the CPU class ( ty_gas_concs ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: gas real ( wp ), intent ( in ) :: w character ( len = 128 ) :: error_msg ! --------- real ( wp ), dimension (:,:), pointer :: p integer :: igas ! --------- error_msg = '' if ( w < 0._wp . or . w > 1._wp ) then error_msg = 'ty_gas_concs%set_vmr(): concentrations should be >= 0, <= 1' return endif igas = this % find_gas ( gas ) if ( igas == GAS_NOT_IN_LIST ) then error_msg = 'ty_gas_concs%set_vmr(): trying to set ' // trim ( gas ) // ' but name not provided at initialization' return end if ! ! Deallocate anything existing -- could be more efficient to test if it's already the correct size ! ! This cannot be made a function, because we need all the hierarchy for the correct OpenACC attach if ( associated ( this % concs ( igas )% conc )) then if ( any ( shape ( this % concs ( igas )% conc ) /= [ 1 , 1 ]) ) then !$acc exit data delete(this%concs(igas)%conc) !$omp target exit data map(release:this%concs(igas)%conc) deallocate ( this % concs ( igas )% conc ) nullify ( this % concs ( igas )% conc ) end if end if if (. not . associated ( this % concs ( igas )% conc )) then allocate ( this % concs ( igas )% conc ( 1 , 1 )) !$acc enter data create(this%concs(igas)%conc) !$omp target enter data map(alloc:this%concs(igas)%conc) end if p => this % concs ( igas )% conc (:,:) !$acc kernels !$omp target map(to:w) #ifdef _CRAYFTN p (:,:) = w #else this % concs ( igas )% conc (:,:) = w #endif !$acc end kernels !$omp end target end function set_vmr_scalar ! ------------------------------------------------------------------------------------- function set_vmr_1d ( this , gas , w ) result ( error_msg ) ! In OpenACC context w assumed to be either on the CPU or on the GPU class ( ty_gas_concs ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: gas real ( wp ), dimension (:), & intent ( in ) :: w character ( len = 128 ) :: error_msg ! --------- real ( wp ), dimension (:,:), pointer :: p integer :: igas ! --------- error_msg = '' if ( check_values ) then if ( any_vals_outside ( w , 0._wp , 1._wp )) & error_msg = 'ty_gas_concs%set_vmr: concentrations should be >= 0, <= 1' end if if ( this % nlay > 0 ) then if ( size ( w ) /= this % nlay ) error_msg = 'ty_gas_concs%set_vmr: different dimension (nlay)' else this % nlay = size ( w ) end if if ( error_msg /= \"\" ) return igas = this % find_gas ( gas ) if ( igas == GAS_NOT_IN_LIST ) then error_msg = 'ty_gas_concs%set_vmr(): trying to set ' // trim ( gas ) // ' but name not provided at initialization' return end if ! ! Deallocate anything existing -- could be more efficient to test if it's already the correct size ! ! This cannot be made a function, because we need all the hierarchy for the correct OpenACC attach if ( associated ( this % concs ( igas )% conc )) then if ( any ( shape ( this % concs ( igas )% conc ) /= [ 1 , this % nlay ]) ) then !$acc exit data delete(this%concs(igas)%conc) !$omp target exit data map(release:this%concs(igas)%conc) deallocate ( this % concs ( igas )% conc ) nullify ( this % concs ( igas )% conc ) end if end if if (. not . associated ( this % concs ( igas )% conc )) then allocate ( this % concs ( igas )% conc ( 1 , this % nlay )) !$acc enter data create(this%concs(igas)%conc) !$omp target enter data map(alloc:this%concs(igas)%conc) end if p => this % concs ( igas )% conc (:,:) !$acc kernels copyin(w) !$omp target map(to:w) #ifdef _CRAYFTN p ( 1 ,:) = w #else this % concs ( igas )% conc ( 1 ,:) = w #endif !$acc end kernels !$omp end target !$acc exit data delete(w) end function set_vmr_1d ! ------------------------------------------------------------------------------------- function set_vmr_2d ( this , gas , w ) result ( error_msg ) ! In OpenACC context w assumed to be either on the CPU or on the GPU class ( ty_gas_concs ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: gas real ( wp ), dimension (:,:), & intent ( in ) :: w character ( len = 128 ) :: error_msg ! --------- real ( wp ), dimension (:,:), pointer :: p integer :: igas ! --------- error_msg = '' if ( check_values ) then if ( any_vals_outside ( w , 0._wp , 1._wp )) & error_msg = 'ty_gas_concs%set_vmr: concentrations should be >= 0, <= 1' end if if ( this % ncol > 0 . and . size ( w , 1 ) /= this % ncol ) then error_msg = 'ty_gas_concs%set_vmr: different dimension (ncol)' else this % ncol = size ( w , 1 ) end if if ( this % nlay > 0 . and . size ( w , 2 ) /= this % nlay ) then error_msg = 'ty_gas_concs%set_vmr: different dimension (nlay)' else this % nlay = size ( w , 2 ) end if if ( error_msg /= \"\" ) return igas = this % find_gas ( gas ) if ( igas == GAS_NOT_IN_LIST ) then error_msg = 'ty_gas_concs%set_vmr(): trying to set ' // trim ( gas ) // 'but name not provided at initialization' return end if ! ! Deallocate anything existing -- could be more efficient to test if it's already the correct size ! ! This cannot be made a function, because we need all the hierarchy for the correct OpenACC attach if ( associated ( this % concs ( igas )% conc )) then if ( any ( shape ( this % concs ( igas )% conc ) /= [ this % ncol , this % nlay ]) ) then !$acc exit data delete(this%concs(igas)%conc) !$omp target exit data map(release:this%concs(igas)%conc) deallocate ( this % concs ( igas )% conc ) nullify ( this % concs ( igas )% conc ) end if end if if (. not . associated ( this % concs ( igas )% conc )) then allocate ( this % concs ( igas )% conc ( this % ncol , this % nlay )) !$acc enter data create(this%concs(igas)%conc) !$omp target enter data map(alloc:this%concs(igas)%conc) end if p => this % concs ( igas )% conc (:,:) !$acc kernels copyin(w) !$omp target map(to:w) #ifdef _CRAYFTN p (:,:) = w (:,:) #else this % concs ( igas )% conc (:,:) = w (:,:) #endif !$acc end kernels !$omp end target end function set_vmr_2d ! ------------------------------------------------------------------------------------- ! ! Return volume mixing ratio as 1D or 2D array ! ! ------------------------------------------------------------------------------------- ! ! 1D array ( lay depdendence only) ! function get_vmr_1d ( this , gas , array ) result ( error_msg ) class ( ty_gas_concs ) :: this character ( len =* ), intent ( in ) :: gas real ( wp ), dimension (:), intent ( out ) :: array character ( len = 128 ) :: error_msg ! --------------------- real ( wp ), dimension (:,:), pointer :: p integer :: igas ! --------------------- error_msg = '' igas = this % find_gas ( gas ) if ( igas == GAS_NOT_IN_LIST ) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // ' not found' else if (. not . associated ( this % concs ( igas )% conc )) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // \" concentration hasn't been set\" else if ( size ( this % concs ( igas )% conc , 1 ) > 1 ) then ! Are we requesting a single profile when many are present? error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // ' requesting single profile but many are available' end if if ( this % nlay > 0 . and . this % nlay /= size ( array )) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // ' array is wrong size (nlay)' end if if ( error_msg /= \"\" ) return p => this % concs ( igas )% conc (:,:) !$acc data copyout (array) present(this) !$omp target data map(from:array) if ( size ( this % concs ( igas )% conc , 2 ) > 1 ) then !$acc kernels default(none) !$omp target #ifdef _CRAYFTN array (:) = p ( 1 ,:) #else array (:) = this % concs ( igas )% conc ( 1 ,:) #endif !$acc end kernels !$omp end target else !$acc kernels default(none) !$omp target #ifdef _CRAYFTN array (:) = p ( 1 , 1 ) #else array (:) = this % concs ( igas )% conc ( 1 , 1 ) #endif !$acc end kernels !$omp end target end if !$acc end data !$omp end target data end function get_vmr_1d ! ------------------------------------------------------------------------------------- ! ! 2D array (col, lay) ! function get_vmr_2d ( this , gas , array ) result ( error_msg ) class ( ty_gas_concs ) :: this character ( len =* ), intent ( in ) :: gas real ( wp ), dimension (:,:), intent ( out ) :: array character ( len = 128 ) :: error_msg ! --------------------- real ( wp ), dimension (:,:), pointer :: p integer :: icol , ilay , igas ! --------------------- error_msg = '' igas = this % find_gas ( gas ) if ( igas == GAS_NOT_IN_LIST ) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // ' not found' else if (. not . associated ( this % concs ( igas )% conc )) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // \" concentration hasn't been set\" end if ! ! Is the requested array the correct size? ! if ( this % ncol > 0 . and . this % ncol /= size ( array , 1 )) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // ' array is wrong size (ncol)' end if if ( this % nlay > 0 . and . this % nlay /= size ( array , 2 )) then error_msg = 'ty_gas_concs%get_vmr; gas ' // trim ( gas ) // ' array is wrong size (nlay)' end if if ( error_msg /= \"\" ) return p => this % concs ( igas )% conc (:,:) !$acc data copyout (array) present(this, this%concs) !$omp target data map(from:array) if ( size ( this % concs ( igas )% conc , 1 ) > 1 ) then ! Concentration stored as 2D !$acc parallel loop collapse(2) default(none) !$omp target teams distribute parallel do simd do ilay = 1 , size ( array , 2 ) do icol = 1 , size ( array , 1 ) !print *, (size(this%concs)) #ifdef _CRAYFTN array ( icol , ilay ) = p ( icol , ilay ) #else array ( icol , ilay ) = this % concs ( igas )% conc ( icol , ilay ) #endif end do end do else if ( size ( this % concs ( igas )% conc , 2 ) > 1 ) then ! Concentration stored as 1D !$acc parallel loop collapse(2) default(none) !$omp target teams distribute parallel do simd do ilay = 1 , size ( array , 2 ) do icol = 1 , size ( array , 1 ) #ifdef _CRAYFTN array ( icol , ilay ) = p ( 1 , ilay ) #else array ( icol , ilay ) = this % concs ( igas )% conc ( 1 , ilay ) #endif end do end do else ! Concentration stored as scalar !$acc parallel loop collapse(2) default(none) !$omp target teams distribute parallel do simd do ilay = 1 , size ( array , 2 ) do icol = 1 , size ( array , 1 ) #ifdef _CRAYFTN array ( icol , ilay ) = p ( 1 , 1 ) #else array ( icol , ilay ) = this % concs ( igas )% conc ( 1 , 1 ) #endif end do end do end if !$acc end data !$omp end target data end function get_vmr_2d ! ------------------------------------------------------------------------------------- ! ! Extract a subset of n columns starting with column 'start' ! ! ------------------------------------------------------------------------------------- function get_subset_range ( this , start , n , subset ) result ( error_msg ) class ( ty_gas_concs ), intent ( in ) :: this integer , intent ( in ) :: start , n class ( ty_gas_concs ), intent ( inout ) :: subset character ( len = 128 ) :: error_msg ! --------------------- real ( wp ), dimension (:,:), pointer :: p1 , p2 integer :: i ! --------------------- error_msg = '' if ( n <= 0 ) & error_msg = \"gas_concs%get_vmr: Asking for 0 or fewer columns \" if ( start < 1 ) & error_msg = \"gas_concs%get_vmr: Asking for columns outside range\" if ( this % ncol > 0 . and . start > this % ncol . or . start + n - 1 > this % ncol ) & error_msg = \"gas_concs%get_vmr: Asking for columns outside range\" if ( error_msg /= \"\" ) return call subset % reset () allocate ( subset % gas_name ( size ( this % gas_name )), & subset % concs ( size ( this % concs ))) ! These two arrays should be the same length !$acc enter data create(subset, subset%concs) !$omp target enter data map(alloc:subset%concs) subset % nlay = this % nlay subset % ncol = merge ( n , 0 , this % ncol > 0 ) subset % gas_name (:) = this % gas_name (:) do i = 1 , size ( this % gas_name ) ! ! Preserve scalar/1D/2D representation in subset, !   but need to ensure at least extent 1 in col dimension (ncol = 0 means no gas exploits this dimension) ! allocate ( subset % concs ( i )% conc ( min ( max ( subset % ncol , 1 ), size ( this % concs ( i )% conc , 1 )), & min ( subset % nlay , size ( this % concs ( i )% conc , 2 )))) p1 => subset % concs ( i )% conc (:,:) p2 => this % concs ( i )% conc (:,:) !$acc enter data create(subset%concs(i)%conc) !$omp target enter data map(alloc:subset%concs(i)%conc) if ( size ( this % concs ( i )% conc , 1 ) > 1 ) then ! Concentration stored as 2D !$acc kernels !$omp target #ifdef _CRAYFTN p1 (:,:) = p2 ( start :( start + n - 1 ),:) #else subset % concs ( i )% conc (:,:) = this % concs ( i )% conc ( start :( start + n - 1 ),:) #endif !$acc end kernels !$omp end target else !$acc kernels !$omp target #ifdef _CRAYFTN p1 (:,:) = p2 (:,:) #else subset % concs ( i )% conc (:,:) = this % concs ( i )% conc (:,:) #endif !$acc end kernels !$omp end target end if end do end function get_subset_range ! ------------------------------------------------------------------------------------- ! ! Deallocate memory ! ! ------------------------------------------------------------------------------------- subroutine reset ( this ) class ( ty_gas_concs ), intent ( inout ) :: this ! ----------------- integer :: i ! ----------------- this % nlay = 0 this % ncol = 0 if ( allocated ( this % gas_name )) deallocate ( this % gas_name ) if ( allocated ( this % concs )) then do i = 1 , size ( this % concs ) if ( associated ( this % concs ( i )% conc )) then !$acc exit data delete(this%concs(i)%conc) !$omp target exit data map(release:this%concs(i)%conc) deallocate ( this % concs ( i )% conc ) nullify ( this % concs ( i )% conc ) end if end do !$acc exit data delete(this%concs) !$omp target exit data map(release:this%concs) deallocate ( this % concs ) end if end subroutine reset ! ------------------------------------------------------------------------------------- ! ! Inquiry functions ! ! ------------------------------------------------------------------------------------- pure function get_num_gases ( this ) class ( ty_gas_concs ), intent ( in ) :: this integer :: get_num_gases get_num_gases = size ( this % gas_name ) return end function get_num_gases ! ------------------------------------------------------------------------------------- pure function get_gas_names ( this ) class ( ty_gas_concs ), intent ( in ) :: this character ( len = 32 ), dimension ( this % get_num_gases ()) :: get_gas_names get_gas_names (:) = this % gas_name (:) return end function get_gas_names ! ------------------------------------------------------------------------------------- ! ! Private procedures ! ! ------------------------------------------------------------------------------------- ! ! find gas in list; GAS_NOT_IN_LIST if not found ! function find_gas ( this , gas ) character ( len =* ), intent ( in ) :: gas class ( ty_gas_concs ), intent ( in ) :: this integer :: find_gas ! ----------------- integer :: igas ! ----------------- find_gas = GAS_NOT_IN_LIST if (. not . allocated ( this % gas_name )) return ! search gases using a loop. Fortran intrinsic findloc would be faster, but only supported since gfortran 9 do igas = 1 , size ( this % gas_name ) if ( lower_case ( trim ( this % gas_name ( igas ))) == lower_case ( trim ( gas ))) then find_gas = igas end if end do end function ! ------------------------------------------------------------------------------------- subroutine del ( this ) type ( ty_gas_concs ), intent ( inout ) :: this call this % reset () !$acc exit data delete(this) end subroutine del ! ------------------------------------------------------------------------------------- end module mo_gas_concentrations","tags":"","loc":"sourcefile/mo_gas_concentrations.f90.html"},{"title":"mo_gas_optics.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_gas_optics.f90~~EfferentGraph sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_gas_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rrtmgp_util_string.f90 mo_rrtmgp_util_string.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_gas_optics.f90~~AfferentGraph sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_gas_optics Source Code mo_gas_optics.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! ------------------------------------------------------------------------------------------------- module mo_gas_optics use mo_rte_kind , only : wp use mo_source_functions , only : ty_source_func_lw use mo_gas_concentrations , only : ty_gas_concs use mo_optical_props , only : ty_optical_props , ty_optical_props_arry type , abstract , extends ( ty_optical_props ), public :: ty_gas_optics contains generic , public :: gas_optics => gas_optics_int , gas_optics_ext ! ! Deferred procedures -- each must be implemented in each child class with !   arguments following the abstract interface (defined below) ! ! gas_optics_int and gas_optics_ext should be declared private in concrete classes !    but need to be visible in the abstract type or the interfaces won't be inherited ! See https://software.intel.com/en-us/forums/intel-fortran-compiler-for-linux-and-mac-os-x/topic/681705 ! procedure ( gas_optics_int_abstract ), deferred :: gas_optics_int procedure ( gas_optics_ext_abstract ), deferred :: gas_optics_ext procedure ( logical_abstract ), deferred , public :: source_is_internal procedure ( logical_abstract ), deferred , public :: source_is_external procedure ( real_abstract ), deferred , public :: get_press_min procedure ( real_abstract ), deferred , public :: get_press_max procedure ( real_abstract ), deferred , public :: get_temp_min procedure ( real_abstract ), deferred , public :: get_temp_max end type ! ! Interfaces for the methods to be implemented ! abstract interface !-------------------------------------------------------------------------------------------------------------------- ! ! Compute gas optical depth given temperature, pressure, and composition ! function gas_optics_ext_abstract ( this , & play , plev , tlay , gas_desc , & ! mandatory inputs optical_props , toa_src , & ! mandatory outputs col_dry ) result ( error_msg ) ! optional input import ty_gas_optics , wp , ty_gas_concs , ty_optical_props_arry class ( ty_gas_optics ), intent ( in ) :: this real ( wp ), dimension (:,:), intent ( in ) :: play , & ! layer pressures [Pa, mb]; (ncol,nlay) plev , & ! level pressures [Pa, mb]; (ncol,nlay+1) tlay ! layer temperatures [K]; (ncol,nlay) type ( ty_gas_concs ), intent ( in ) :: gas_desc ! Gas volume mixing ratios class ( ty_optical_props_arry ), & intent ( inout ) :: optical_props real ( wp ), dimension (:,:), intent ( out ) :: toa_src ! Incoming solar irradiance(ncol,ngpt) character ( len = 128 ) :: error_msg ! Optional inputs real ( wp ), dimension (:,:), intent ( in ), & optional , target :: col_dry ! Column dry amount; dim(ncol,nlay) end function gas_optics_ext_abstract !-------------------------------------------------------------------------------------------------------------------- ! ! Compute gas optical depth and Planck source functions, !  given temperature, pressure, and composition ! function gas_optics_int_abstract ( this , & play , plev , tlay , tsfc , gas_desc , & optical_props , sources , & col_dry , tlev ) result ( error_msg ) import ty_gas_optics , wp , ty_gas_concs , ty_optical_props_arry , ty_source_func_lw class ( ty_gas_optics ), intent ( in ) :: this real ( wp ), dimension (:,:), intent ( in ) :: play , & ! layer pressures [Pa, mb]; (ncol,nlay) plev , & ! level pressures [Pa, mb]; (ncol,nlay+1) tlay ! layer temperatures [K]; (ncol,nlay) real ( wp ), dimension (:), intent ( in ) :: tsfc ! surface skin temperatures [K]; (ncol) type ( ty_gas_concs ), intent ( in ) :: gas_desc ! Gas volume mixing ratios class ( ty_optical_props_arry ), & intent ( inout ) :: optical_props ! Optical properties class ( ty_source_func_lw ), & intent ( inout ) :: sources ! Planck sources character ( len = 128 ) :: error_msg real ( wp ), dimension (:,:), intent ( in ), & optional , target :: col_dry , & ! Column dry amount; dim(ncol,nlay) tlev ! level temperatures [K]l (ncol,nlay+1) end function gas_optics_int_abstract !-------------------------------------------------------------------------------------------------------------------- function logical_abstract ( this ) import ty_gas_optics class ( ty_gas_optics ), intent ( in ) :: this logical :: logical_abstract end function logical_abstract !-------------------------------------------------------------------------------------------------------------------- function real_abstract ( this ) import ty_gas_optics , wp class ( ty_gas_optics ), intent ( in ) :: this real ( wp ) :: real_abstract end function real_abstract !-------------------------------------------------------------------------------------------------------------------- end interface end module mo_gas_optics","tags":"","loc":"sourcefile/mo_gas_optics.f90.html"},{"title":"mo_gas_optics_rrtmgp.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_gas_optics_rrtmgp.f90~~EfferentGraph sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rrtmgp_util_string.f90 mo_rrtmgp_util_string.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rrtmgp_util_reorder.f90 mo_rrtmgp_util_reorder.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_util_reorder.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics_kernels.f90 mo_gas_optics_kernels.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics_kernels.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rrtmgp_constants.f90 mo_rrtmgp_constants.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_constants.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_rrtmgp_util_reorder.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rrtmgp_util_reorder_kernels.f90 mo_rrtmgp_util_reorder_kernels.F90 sourcefile~mo_rrtmgp_util_reorder.f90->sourcefile~mo_rrtmgp_util_reorder_kernels.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics_kernels.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_gas_optics_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rrtmgp_constants.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rrtmgp_util_reorder_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_gas_optics_rrtmgp Source Code mo_gas_optics_rrtmgp.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! Class for computing spectrally-resolved gas optical properties and source functions !   given atmopsheric physical properties (profiles of temperature, pressure, and gas concentrations) !   The class must be initialized with data (provided as a netCDF file) before being used. ! ! Two variants apply to internal Planck sources (longwave radiation in the Earth's atmosphere) and to !   external stellar radiation (shortwave radiation in the Earth's atmosphere). !   The variant is chosen based on what information is supplied during initialization. !   (It might make more sense to define two sub-classes) ! ! ------------------------------------------------------------------------------------------------- module mo_gas_optics_rrtmgp use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_extents , check_values use mo_rte_util_array , only : zero_array , any_vals_less_than , any_vals_outside , extents_are use mo_optical_props , only : ty_optical_props use mo_source_functions , only : ty_source_func_lw use mo_gas_optics_kernels , only : interpolation , & compute_tau_absorption , compute_tau_rayleigh , compute_Planck_source use mo_rrtmgp_constants , only : avogad , m_dry , m_h2o , grav use mo_rrtmgp_util_string , only : lower_case , string_in_array , string_loc_in_array use mo_gas_concentrations , only : ty_gas_concs use mo_optical_props , only : ty_optical_props_arry , ty_optical_props_1scl , ty_optical_props_2str , ty_optical_props_nstr use mo_gas_optics , only : ty_gas_optics use mo_rrtmgp_util_reorder implicit none private real ( wp ), parameter :: pi = acos ( - 1._wp ) ! ------------------------------------------------------------------------------------------------- type , extends ( ty_gas_optics ), public :: ty_gas_optics_rrtmgp private ! ! RRTMGP computes absorption in each band arising from !   two major species in each band, which are combined to make !     a relative mixing ratio eta and a total column amount (col_mix) !   contributions from zero or more minor species whose concentrations !     may be scaled by other components of the atmosphere ! ! Absorption coefficients are interpolated from tables on a pressure/temperature/(eta) grid ! ! ------------------------------------ ! Interpolation variables: Temperature and pressure grids ! real ( wp ), dimension (:), allocatable :: press_ref , press_ref_log , temp_ref ! ! Derived and stored for convenience: !   Min and max for temperature and pressure intepolation grids !   difference in ln pressure between consecutive reference levels !   log of reference pressure separating the lower and upper atmosphere ! real ( wp ) :: press_ref_min , press_ref_max , & temp_ref_min , temp_ref_max real ( wp ) :: press_ref_log_delta , temp_ref_delta , press_ref_trop_log ! ------------------------------------ ! Major absorbers (\"key species\") !   Each unique set of major species is called a flavor. ! ! Names  and reference volume mixing ratios of major gases ! character ( 32 ), dimension (:), allocatable :: gas_names ! gas names real ( wp ), dimension (:,:,:), allocatable :: vmr_ref ! vmr_ref(lower or upper atmosphere, gas, temp) ! ! Which two gases are in each flavor? By index ! integer , dimension (:,:), allocatable :: flavor ! major species pair; (2,nflav) ! ! Which flavor for each g-point? One each for lower, upper atmosphere ! integer , dimension (:,:), allocatable :: gpoint_flavor ! flavor = gpoint_flavor(2, g-point) ! ! Major gas absorption coefficients ! real ( wp ), dimension (:,:,:,:), allocatable :: kmajor !  kmajor(g-point,eta,pressure,temperature) ! ! ------------------------------------ ! Minor species, independently for upper and lower atmospheres !   Array extents in the n_minor dimension will differ between upper and lower atmospheres !   Each contribution has starting and ending g-points ! integer , dimension (:,:), allocatable :: minor_limits_gpt_lower , & minor_limits_gpt_upper ! ! Minor gas contributions might be scaled by other gas amounts; if so we need to know !   the total density and whether the contribution is scaled by the partner gas !   or its complement (i.e. all other gases) ! Water vapor self- and foreign continua work like this, as do !   all collision-induced abosption pairs ! logical ( wl ), dimension (:), allocatable :: minor_scales_with_density_lower , & minor_scales_with_density_upper logical ( wl ), dimension (:), allocatable :: scale_by_complement_lower , scale_by_complement_upper integer , dimension (:), allocatable :: idx_minor_lower , idx_minor_upper integer , dimension (:), allocatable :: idx_minor_scaling_lower , idx_minor_scaling_upper ! ! Index into table of absorption coefficients ! integer , dimension (:), allocatable :: kminor_start_lower , kminor_start_upper ! ! The absorption coefficients themselves ! real ( wp ), dimension (:,:,:), allocatable :: kminor_lower , kminor_upper ! kminor_lower(n_minor,eta,temperature) ! ! ----------------------------------------------------------------------------------- ! ! Rayleigh scattering coefficients ! real ( wp ), dimension (:,:,:,:), allocatable :: krayl ! krayl(g-point,eta,temperature,upper/lower atmosphere) ! ! ----------------------------------------------------------------------------------- ! Planck function spectral mapping !   Allocated only when gas optics object is internal-source ! real ( wp ), dimension (:,:,:,:), allocatable :: planck_frac ! stored fraction of Planck irradiance in band for given g-point ! planck_frac(g-point, eta, pressure, temperature) real ( wp ), dimension (:,:), allocatable :: totplnk ! integrated Planck irradiance by band; (Planck temperatures,band) real ( wp ) :: totplnk_delta ! temperature steps in totplnk real ( wp ), dimension (:,:), allocatable :: optimal_angle_fit ! coefficients of linear function ! of vertical path clear-sky transmittance that is used to ! determine the secant of single angle used for the ! no-scattering calculation, ! optimal_angle_fit(coefficient, band) ! ----------------------------------------------------------------------------------- ! Solar source function spectral mapping with solar variability capability !   Allocated  when gas optics object is external-source !   n-solar-terms: quiet sun, facular brightening and sunspot dimming components !   following the NRLSSI2 model of Coddington et al. 2016, doi:10.1175/BAMS-D-14-00265.1. ! real ( wp ), dimension (:), allocatable :: solar_source ! incoming solar irradiance, computed from other three terms (g-point) real ( wp ), dimension (:), allocatable :: solar_source_quiet ! incoming solar irradiance, quiet sun term (g-point) real ( wp ), dimension (:), allocatable :: solar_source_facular ! incoming solar irradiance, facular term (g-point) real ( wp ), dimension (:), allocatable :: solar_source_sunspot ! incoming solar irradiance, sunspot term (g-point) ! ! ----------------------------------------------------------------------------------- ! Ancillary ! ----------------------------------------------------------------------------------- ! Index into %gas_names -- is this a key species in any band? logical , dimension (:), allocatable :: is_key ! ----------------------------------------------------------------------------------- contains ! Type-bound procedures ! Public procedures ! public interface generic , public :: load => load_int , load_ext procedure , public :: source_is_internal procedure , public :: source_is_external procedure , public :: get_ngas procedure , public :: get_gases procedure , public :: get_press_min procedure , public :: get_press_max procedure , public :: get_temp_min procedure , public :: get_temp_max procedure , public :: compute_optimal_angles procedure , public :: set_solar_variability procedure , public :: set_tsi ! Internal procedures procedure , private :: load_int procedure , private :: load_ext procedure , public :: gas_optics_int procedure , public :: gas_optics_ext procedure , private :: check_key_species_present ! Interpolation table dimensions procedure , private :: get_nflav procedure , private :: get_neta procedure , private :: get_npres procedure , private :: get_ntemp procedure , private :: get_nPlanckTemp end type ! ------------------------------------------------------------------------------------------------- ! ! col_dry is the number of molecules per cm-2 of dry air ! public :: get_col_dry ! Utility function, not type-bound contains ! -------------------------------------------------------------------------------------- ! ! Public procedures ! ! -------------------------------------------------------------------------------------- ! ! Two functions to define array sizes needed by gas_optics() ! pure function get_ngas ( this ) ! return the number of gases registered in the spectral configuration class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer :: get_ngas get_ngas = size ( this % gas_names ) end function get_ngas !-------------------------------------------------------------------------------------------------------------------- ! ! return the number of distinct major gas pairs in the spectral bands (referred to as ! \"flavors\" - all bands have a flavor even if there is one or no major gas) ! pure function get_nflav ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer :: get_nflav get_nflav = size ( this % flavor , dim = 2 ) end function get_nflav !-------------------------------------------------------------------------------------------------------------------- ! ! Compute gas optical depth and Planck source functions, !  given temperature, pressure, and composition ! function gas_optics_int ( this , & play , plev , tlay , tsfc , gas_desc , & optical_props , sources , & col_dry , tlev ) result ( error_msg ) ! inputs class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this real ( wp ), dimension (:,:), intent ( in ) :: play , & ! layer pressures [Pa, mb]; (ncol,nlay) plev , & ! level pressures [Pa, mb]; (ncol,nlay+1) tlay ! layer temperatures [K]; (ncol,nlay) real ( wp ), dimension (:), intent ( in ) :: tsfc ! surface skin temperatures [K]; (ncol) type ( ty_gas_concs ), intent ( in ) :: gas_desc ! Gas volume mixing ratios ! output class ( ty_optical_props_arry ), & intent ( inout ) :: optical_props ! Optical properties class ( ty_source_func_lw ), & intent ( inout ) :: sources ! Planck sources character ( len = 128 ) :: error_msg ! Optional inputs real ( wp ), dimension (:,:), intent ( in ), & optional , target :: col_dry , & ! Column dry amount; dim(ncol,nlay) tlev ! level temperatures [K]; (ncol,nlay+1) ! ---------------------------------------------------------- ! Local variables ! Interpolation coefficients for use in source function integer , dimension ( size ( play , dim = 1 ), size ( play , dim = 2 )) :: jtemp , jpress logical ( wl ), dimension ( size ( play , dim = 1 ), size ( play , dim = 2 )) :: tropo real ( wp ), dimension ( 2 , 2 , 2 , size ( play , dim = 1 ), size ( play , dim = 2 ), get_nflav ( this )) :: fmajor integer , dimension ( 2 , size ( play , dim = 1 ), size ( play , dim = 2 ), get_nflav ( this )) :: jeta integer :: ncol , nlay , ngpt , nband ! ---------------------------------------------------------- ncol = size ( play , dim = 1 ) nlay = size ( play , dim = 2 ) ngpt = this % get_ngpt () nband = this % get_nband () ! ! Gas optics ! !$acc enter data create(jtemp, jpress, tropo, fmajor, jeta) !$omp target enter data map(alloc:jtemp, jpress, tropo, fmajor, jeta) error_msg = compute_gas_taus ( this , & ncol , nlay , ngpt , nband , & play , plev , tlay , gas_desc , & optical_props , & jtemp , jpress , jeta , tropo , fmajor , & col_dry ) if ( error_msg /= '' ) return ! ---------------------------------------------------------- ! ! External source -- check arrays sizes and values ! input data sizes and values ! !$acc enter data copyin(tsfc, tlev) ! Should be fine even if tlev is not supplied !$omp target enter data map(to:tsfc, tlev) if ( check_extents ) then if (. not . extents_are ( tsfc , ncol )) & error_msg = \"gas_optics(): array tsfc has wrong size\" if ( present ( tlev )) then if (. not . extents_are ( tlev , ncol , nlay + 1 )) & error_msg = \"gas_optics(): array tlev has wrong size\" end if ! !   output extents ! if ( any ([ sources % get_ncol (), sources % get_nlay (), sources % get_ngpt ()] /= [ ncol , nlay , ngpt ])) & error_msg = \"gas_optics%gas_optics: source function arrays inconsistently sized\" end if if ( error_msg /= '' ) return if ( check_values ) then if ( any_vals_outside ( tsfc , this % temp_ref_min , this % temp_ref_max )) & error_msg = \"gas_optics(): array tsfc has values outside range\" if ( present ( tlev )) then if ( any_vals_outside ( tlev , this % temp_ref_min , this % temp_ref_max )) & error_msg = \"gas_optics(): array tlev has values outside range\" end if end if if ( error_msg /= '' ) return ! ! Interpolate source function ! if ( present ( tlev )) then ! ! present status of optional argument should be passed to source() !   but isn't with PGI 19.10 ! error_msg = source ( this , & ncol , nlay , nband , ngpt , & play , plev , tlay , tsfc , & jtemp , jpress , jeta , tropo , fmajor , & sources , & tlev ) !$acc exit data delete(tlev) !$omp target exit data map(release:tlev) else error_msg = source ( this , & ncol , nlay , nband , ngpt , & play , plev , tlay , tsfc , & jtemp , jpress , jeta , tropo , fmajor , & sources ) end if !$acc exit data delete(tsfc) !$omp target exit data map(release:tsfc) !$acc exit data delete(jtemp, jpress, tropo, fmajor, jeta) !$omp target exit data map(release:jtemp, jpress, tropo, fmajor, jeta) end function gas_optics_int !------------------------------------------------------------------------------------------ ! ! Compute gas optical depth given temperature, pressure, and composition ! function gas_optics_ext ( this , & play , plev , tlay , gas_desc , & ! mandatory inputs optical_props , toa_src , & ! mandatory outputs col_dry ) result ( error_msg ) ! optional input class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this real ( wp ), dimension (:,:), intent ( in ) :: play , & ! layer pressures [Pa, mb]; (ncol,nlay) plev , & ! level pressures [Pa, mb]; (ncol,nlay+1) tlay ! layer temperatures [K]; (ncol,nlay) type ( ty_gas_concs ), intent ( in ) :: gas_desc ! Gas volume mixing ratios ! output class ( ty_optical_props_arry ), & intent ( inout ) :: optical_props real ( wp ), dimension (:,:), intent ( out ) :: toa_src ! Incoming solar irradiance(ncol,ngpt) character ( len = 128 ) :: error_msg ! Optional inputs real ( wp ), dimension (:,:), intent ( in ), & optional , target :: col_dry ! Column dry amount; dim(ncol,nlay) ! ---------------------------------------------------------- ! Local variables ! Interpolation coefficients for use in source function integer , dimension ( size ( play , dim = 1 ), size ( play , dim = 2 )) :: jtemp , jpress logical ( wl ), dimension ( size ( play , dim = 1 ), size ( play , dim = 2 )) :: tropo real ( wp ), dimension ( 2 , 2 , 2 , size ( play , dim = 1 ), size ( play , dim = 2 ), get_nflav ( this )) :: fmajor integer , dimension ( 2 , size ( play , dim = 1 ), size ( play , dim = 2 ), get_nflav ( this )) :: jeta integer :: ncol , nlay , ngpt , nband , ngas , nflav integer :: igpt , icol ! ---------------------------------------------------------- ncol = size ( play , dim = 1 ) nlay = size ( play , dim = 2 ) ngpt = this % get_ngpt () nband = this % get_nband () ngas = this % get_ngas () nflav = get_nflav ( this ) ! ! Gas optics ! !$acc enter data create(jtemp, jpress, tropo, fmajor, jeta) !$omp target enter data map(alloc:jtemp, jpress, tropo, fmajor, jeta) error_msg = compute_gas_taus ( this , & ncol , nlay , ngpt , nband , & play , plev , tlay , gas_desc , & optical_props , & jtemp , jpress , jeta , tropo , fmajor , & col_dry ) !$acc exit data delete(jtemp, jpress, tropo, fmajor, jeta) !$omp target exit data map(release:jtemp, jpress, tropo, fmajor, jeta) if ( error_msg /= '' ) return ! ---------------------------------------------------------- ! ! External source function is constant ! !$acc enter data create(toa_src) !$omp target enter data map(alloc:toa_src) if ( check_extents ) then if (. not . extents_are ( toa_src , ncol , ngpt )) & error_msg = \"gas_optics(): array toa_src has wrong size\" end if if ( error_msg /= '' ) return !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do igpt = 1 , ngpt do icol = 1 , ncol toa_src ( icol , igpt ) = this % solar_source ( igpt ) end do end do !$acc exit data copyout(toa_src) !$omp target exit data map(from:toa_src) end function gas_optics_ext !------------------------------------------------------------------------------------------ ! ! Returns optical properties and interpolation coefficients ! function compute_gas_taus ( this , & ncol , nlay , ngpt , nband , & play , plev , tlay , gas_desc , & optical_props , & jtemp , jpress , jeta , tropo , fmajor , & col_dry ) result ( error_msg ) class ( ty_gas_optics_rrtmgp ), & intent ( in ) :: this integer , intent ( in ) :: ncol , nlay , ngpt , nband real ( wp ), dimension (:,:), intent ( in ) :: play , & ! layer pressures [Pa, mb]; (ncol,nlay) plev , & ! level pressures [Pa, mb]; (ncol,nlay+1) tlay ! layer temperatures [K]; (ncol,nlay) type ( ty_gas_concs ), intent ( in ) :: gas_desc ! Gas volume mixing ratios class ( ty_optical_props_arry ), intent ( inout ) :: optical_props !inout because components are allocated ! Interpolation coefficients for use in internal source function integer , dimension ( ncol , nlay ), intent ( out ) :: jtemp , jpress integer , dimension ( 2 , ncol , nlay , get_nflav ( this )), intent ( out ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( out ) :: tropo real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , get_nflav ( this )), intent ( out ) :: fmajor character ( len = 128 ) :: error_msg ! Optional inputs real ( wp ), dimension (:,:), intent ( in ), & optional , target :: col_dry ! Column dry amount; dim(ncol,nlay) ! ---------------------------------------------------------- ! Local variables real ( wp ), dimension ( ncol , nlay , ngpt ) :: tau , tau_rayleigh ! absorption, Rayleigh scattering optical depths ! Number of molecules per cm&#94;2 real ( wp ), dimension ( ncol , nlay ), target :: col_dry_arr real ( wp ), dimension (:,:), pointer :: col_dry_wk ! ! Interpolation variables used in major gas but not elsewhere, so don't need exporting ! real ( wp ), dimension ( ncol , nlay , this % get_ngas ()) :: vmr ! volume mixing ratios real ( wp ), dimension ( ncol , nlay , 0 : this % get_ngas ()) :: col_gas ! column amounts for each gas, plus col_dry real ( wp ), dimension ( 2 , ncol , nlay , get_nflav ( this )) :: col_mix ! combination of major species's column amounts ! index(1) : reference temperature level ! index(2) : flavor ! index(3) : layer real ( wp ), dimension ( 2 , 2 , ncol , nlay , get_nflav ( this )) :: fminor ! interpolation fractions for minor species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference temperature level ! index(3) : flavor ! index(4) : layer integer :: ngas , nflav , neta , npres , ntemp integer :: icol , ilay , igas integer :: idx_h2o ! index of water vapor integer :: nminorlower , nminorklower , nminorupper , nminorkupper logical :: use_rayl ! ---------------------------------------------------------- ! ! Error checking ! use_rayl = allocated ( this % krayl ) error_msg = '' ! Check for initialization if (. not . this % is_initialized ()) then error_msg = 'ERROR: spectral configuration not loaded' return end if ! ! Check for presence of key species in ty_gas_concs; return error if any key species are not present ! error_msg = this % check_key_species_present ( gas_desc ) if ( error_msg /= '' ) return ! ! Check input data sizes and values ! !$acc        data copyin(play,plev,tlay) create(   vmr,col_gas) !$omp target data map(to:play,plev,tlay) map(alloc:vmr,col_gas) if ( check_extents ) then if (. not . extents_are ( play , ncol , nlay )) & error_msg = \"gas_optics(): array play has wrong size\" if (. not . extents_are ( tlay , ncol , nlay )) & error_msg = \"gas_optics(): array tlay has wrong size\" if (. not . extents_are ( plev , ncol , nlay + 1 )) & error_msg = \"gas_optics(): array plev has wrong size\" if ( optical_props % get_ncol () /= ncol . or . & optical_props % get_nlay () /= nlay . or . & optical_props % get_ngpt () /= ngpt ) & error_msg = \"gas_optics(): optical properties have the wrong extents\" if ( present ( col_dry )) then if (. not . extents_are ( col_dry , ncol , nlay )) & error_msg = \"gas_optics(): array col_dry has wrong size\" end if end if if ( error_msg == '' ) then if ( check_values ) then if ( any_vals_outside ( play , this % press_ref_min , this % press_ref_max )) & error_msg = \"gas_optics(): array play has values outside range\" if ( any_vals_less_than ( plev , 0._wp )) & error_msg = \"gas_optics(): array plev has values outside range\" if ( any_vals_outside ( tlay , this % temp_ref_min , this % temp_ref_max )) & error_msg = \"gas_optics(): array tlay has values outside range\" if ( present ( col_dry )) then if ( any_vals_less_than ( col_dry , 0._wp )) & error_msg = \"gas_optics(): array col_dry has values outside range\" end if end if end if ! ---------------------------------------------------------- if ( error_msg == '' ) then ngas = this % get_ngas () nflav = get_nflav ( this ) neta = this % get_neta () npres = this % get_npres () ntemp = this % get_ntemp () ! number of minor contributors, total num absorption coeffs nminorlower = size ( this % minor_scales_with_density_lower ) nminorklower = size ( this % kminor_lower , 3 ) nminorupper = size ( this % minor_scales_with_density_upper ) nminorkupper = size ( this % kminor_upper , 3 ) ! ! Fill out the array of volume mixing ratios ! do igas = 1 , ngas ! ! Get vmr if  gas is provided in ty_gas_concs ! if ( any ( lower_case ( this % gas_names ( igas )) == gas_desc % gas_name (:))) then error_msg = gas_desc % get_vmr ( this % gas_names ( igas ), vmr (:,:, igas )) endif end do end if if ( error_msg == '' ) then select type ( optical_props ) type is ( ty_optical_props_1scl ) !$acc        enter data copyin(optical_props) create(   optical_props%tau) !$omp target enter data                       map(alloc:optical_props%tau) type is ( ty_optical_props_2str ) !$acc        enter data copyin(optical_props) create(   optical_props%tau, optical_props%ssa, optical_props%g) !$omp target enter data                       map(alloc:optical_props%tau, optical_props%ssa, optical_props%g) type is ( ty_optical_props_nstr ) !$acc        enter data copyin(optical_props) create(   optical_props%tau, optical_props%ssa, optical_props%p) !$omp target enter data                       map(alloc:optical_props%tau, optical_props%ssa, optical_props%p) end select ! ! Compute dry air column amounts (number of molecule per cm&#94;2) if user hasn't provided them ! idx_h2o = string_loc_in_array ( 'h2o' , this % gas_names ) if ( present ( col_dry )) then !$acc        enter data copyin(col_dry) !$omp target enter data map(to:col_dry) col_dry_wk => col_dry else !$acc        enter data create(   col_dry_arr) !$omp target enter data map(alloc:col_dry_arr) col_dry_arr = get_col_dry ( vmr (:,:, idx_h2o ), plev ) ! dry air column amounts computation col_dry_wk => col_dry_arr end if ! ! compute column gas amounts [molec/cm&#94;2] ! !$acc parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol col_gas ( icol , ilay , 0 ) = col_dry_wk ( icol , ilay ) end do end do !$acc parallel loop gang vector collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igas = 1 , ngas do ilay = 1 , nlay do icol = 1 , ncol col_gas ( icol , ilay , igas ) = vmr ( icol , ilay , igas ) * col_dry_wk ( icol , ilay ) end do end do end do ! ! ---- calculate gas optical depths ---- ! !$acc        data copyout( jtemp, jpress, jeta, tropo, fmajor) create(   col_mix, fminor) !$omp target data map(from:jtemp, jpress, jeta, tropo, fmajor) map(alloc:col_mix, fminor) call interpolation ( & ncol , nlay , & ! problem dimensions ngas , nflav , neta , npres , ntemp , & ! interpolation dimensions this % flavor , & this % press_ref_log , & this % temp_ref , & this % press_ref_log_delta , & this % temp_ref_min , & this % temp_ref_delta , & this % press_ref_trop_log , & this % vmr_ref , & play , & tlay , & col_gas , & jtemp , & ! outputs fmajor , fminor ,& col_mix , & tropo , & jeta , jpress ) if ( allocated ( this % krayl )) then !$acc        data copyin(this%gpoint_flavor, this%krayl)    create(tau, tau_rayleigh) !$omp target data map(to:this%gpoint_flavor, this%krayl) map(alloc:tau, tau_rayleigh) call zero_array ( ngpt , nlay , ncol , tau ) call compute_tau_absorption ( & ncol , nlay , nband , ngpt , & ! dimensions ngas , nflav , neta , npres , ntemp , & nminorlower , nminorklower , & ! number of minor contributors, total num absorption coeffs nminorupper , nminorkupper , & idx_h2o , & this % gpoint_flavor , & this % get_band_lims_gpoint (), & this % kmajor , & this % kminor_lower , & this % kminor_upper , & this % minor_limits_gpt_lower , & this % minor_limits_gpt_upper , & this % minor_scales_with_density_lower , & this % minor_scales_with_density_upper , & this % scale_by_complement_lower , & this % scale_by_complement_upper , & this % idx_minor_lower , & this % idx_minor_upper , & this % idx_minor_scaling_lower , & this % idx_minor_scaling_upper , & this % kminor_start_lower , & this % kminor_start_upper , & tropo , & col_mix , fmajor , fminor , & play , tlay , col_gas , & jeta , jtemp , jpress , & tau ) call compute_tau_rayleigh ( & !Rayleigh scattering optical depths ncol , nlay , nband , ngpt , & ngas , nflav , neta , npres , ntemp , & ! dimensions this % gpoint_flavor , & this % get_band_lims_gpoint (), & this % krayl , & ! inputs from object idx_h2o , col_dry_wk , col_gas , & fminor , jeta , tropo , jtemp , & ! local input tau_rayleigh ) call combine_abs_and_rayleigh ( tau , tau_rayleigh , optical_props ) !$acc end        data !$omp end target data else call zero_array ( ngpt , nlay , ncol , optical_props % tau ) call compute_tau_absorption ( & ncol , nlay , nband , ngpt , & ! dimensions ngas , nflav , neta , npres , ntemp , & nminorlower , nminorklower , & ! number of minor contributors, total num absorption coeffs nminorupper , nminorkupper , & idx_h2o , & this % gpoint_flavor , & this % get_band_lims_gpoint (), & this % kmajor , & this % kminor_lower , & this % kminor_upper , & this % minor_limits_gpt_lower , & this % minor_limits_gpt_upper , & this % minor_scales_with_density_lower , & this % minor_scales_with_density_upper , & this % scale_by_complement_lower , & this % scale_by_complement_upper , & this % idx_minor_lower , & this % idx_minor_upper , & this % idx_minor_scaling_lower , & this % idx_minor_scaling_upper , & this % kminor_start_lower , & this % kminor_start_upper , & tropo , & col_mix , fmajor , fminor , & play , tlay , col_gas , & jeta , jtemp , jpress , & optical_props % tau ) ! select type ( optical_props ) type is ( ty_optical_props_2str ) call zero_array ( ncol , nlay , ngpt , optical_props % ssa ) call zero_array ( ncol , nlay , ngpt , optical_props % g ) type is ( ty_optical_props_nstr ) call zero_array ( ncol , nlay , ngpt , optical_props % ssa ) call zero_array ( optical_props % get_nmom (), & ncol , nlay , ngpt , optical_props % p ) end select end if !$acc end        data !$omp end target data end if !$acc end        data !$omp end target data !$acc        exit data delete(     col_dry_wk) !$omp target exit data map(release:col_dry_wk) select type ( optical_props ) type is ( ty_optical_props_1scl ) !$acc        exit data delete(optical_props) copyout( optical_props%tau) !$omp target exit data                       map(from:optical_props%tau) type is ( ty_optical_props_2str ) !$acc        exit data delete(optical_props) copyout( optical_props%tau, optical_props%ssa, optical_props%g) !$omp target exit data                       map(from:optical_props%tau, optical_props%ssa, optical_props%g) type is ( ty_optical_props_nstr ) !$acc        exit data delete(optical_props) copyout( optical_props%tau, optical_props%ssa, optical_props%p) !$omp target exit data                       map(from:optical_props%tau, optical_props%ssa, optical_props%p) end select end function compute_gas_taus !------------------------------------------------------------------------------------------ ! ! Compute the spectral solar source function adjusted to account for solar variability !   following the NRLSSI2 model of Coddington et al. 2016, doi:10.1175/BAMS-D-14-00265.1. ! as specified by the facular brightening (mg_index) and sunspot dimming (sb_index) ! indices provided as input. ! ! Users provide the NRLSSI2 facular (\"Bremen\") index and sunspot (\"SPOT67\") index. !   Changing either of these indicies will change the total solar irradiance (TSI) !   Code in extensions/mo_solar_variability may be used to compute the value of these !   indices through an average solar cycle ! Users may also specify the TSI, either alone or in conjunction with the facular and sunspot indices ! !------------------------------------------------------------------------------------------ function set_solar_variability ( this , & mg_index , sb_index , tsi ) & result ( error_msg ) ! ! Updates the spectral distribution and, optionally, !   the integrated value of the solar source function !   Modifying either index will change the total solar irradiance ! class ( ty_gas_optics_rrtmgp ), intent ( inout ) :: this ! real ( wp ), intent ( in ) :: mg_index , & ! facular brightening index (NRLSSI2 facular \"Bremen\" index) sb_index ! sunspot dimming index     (NRLSSI2 sunspot \"SPOT67\" index) real ( wp ), optional , intent ( in ) :: tsi ! total solar irradiance character ( len = 128 ) :: error_msg ! ---------------------------------------------------------- integer :: igpt real ( wp ), parameter :: a_offset = 0.1495954_wp real ( wp ), parameter :: b_offset = 0.00066696_wp ! ---------------------------------------------------------- error_msg = \"\" if ( mg_index < 0._wp ) error_msg = 'mg_index out of range' if ( sb_index < 0._wp ) error_msg = 'sb_index out of range' if ( error_msg /= \"\" ) return ! ! Calculate solar source function for provided facular and sunspot indices ! !$acc parallel loop !$omp target teams distribute parallel do simd do igpt = 1 , size ( this % solar_source_quiet ) this % solar_source ( igpt ) = this % solar_source_quiet ( igpt ) + & ( mg_index - a_offset ) * this % solar_source_facular ( igpt ) + & ( sb_index - b_offset ) * this % solar_source_sunspot ( igpt ) end do ! ! Scale solar source to input TSI value ! if ( present ( tsi )) error_msg = this % set_tsi ( tsi ) end function set_solar_variability !------------------------------------------------------------------------------------------ function set_tsi ( this , tsi ) result ( error_msg ) ! ! Scale the solar source function without changing the spectral distribution ! class ( ty_gas_optics_rrtmgp ), intent ( inout ) :: this real ( wp ), intent ( in ) :: tsi ! user-specified total solar irradiance; character ( len = 128 ) :: error_msg real ( wp ) :: norm ! ---------------------------------------------------------- error_msg = \"\" if ( tsi < 0._wp ) then error_msg = 'tsi out of range' else ! ! Scale the solar source function to the input tsi ! !$acc kernels !$omp target norm = 1._wp / sum ( this % solar_source (:)) this % solar_source (:) = this % solar_source (:) * tsi * norm !$acc end kernels !$omp end target end if end function set_tsi !------------------------------------------------------------------------------------------ ! ! Compute Planck source functions at layer centers and levels ! function source ( this , & ncol , nlay , nbnd , ngpt , & play , plev , tlay , tsfc , & jtemp , jpress , jeta , tropo , fmajor , & sources , & ! Planck sources tlev ) & ! optional input result ( error_msg ) ! inputs class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer , intent ( in ) :: ncol , nlay , nbnd , ngpt real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play ! layer pressures [Pa, mb] real ( wp ), dimension ( ncol , nlay + 1 ), intent ( in ) :: plev ! level pressures [Pa, mb] real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: tlay ! layer temperatures [K] real ( wp ), dimension ( ncol ), intent ( in ) :: tsfc ! surface skin temperatures [K] ! Interplation coefficients integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , get_nflav ( this )), & intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , get_nflav ( this )), & intent ( in ) :: jeta class ( ty_source_func_lw ), intent ( inout ) :: sources real ( wp ), dimension ( ncol , nlay + 1 ), intent ( in ), & optional , target :: tlev ! level temperatures [K] character ( len = 128 ) :: error_msg ! ---------------------------------------------------------- logical ( wl ) :: top_at_1 integer :: icol , ilay , igpt ! Variables for temperature at layer edges [K] (ncol, nlay+1) real ( wp ), dimension ( ncol , nlay + 1 ), target :: tlev_arr real ( wp ), dimension (:,:), pointer :: tlev_wk ! ---------------------------------------------------------- error_msg = \"\" ! ! Source function needs temperature at interfaces/levels and at layer centers ! if ( present ( tlev )) then !   Users might have provided these tlev_wk => tlev else tlev_wk => tlev_arr ! ! Interpolate temperature to levels if not provided !   Interpolation and extrapolation at boundaries is weighted by pressure ! do icol = 1 , ncol tlev_arr ( icol , 1 ) = tlay ( icol , 1 ) & + ( plev ( icol , 1 ) - play ( icol , 1 )) * ( tlay ( icol , 2 ) - tlay ( icol , 1 )) & & / ( play ( icol , 2 ) - play ( icol , 1 )) end do do ilay = 2 , nlay do icol = 1 , ncol tlev_arr ( icol , ilay ) = ( play ( icol , ilay - 1 ) * tlay ( icol , ilay - 1 ) * ( plev ( icol , ilay ) - play ( icol , ilay )) & + play ( icol , ilay ) * tlay ( icol , ilay ) * ( play ( icol , ilay - 1 ) - plev ( icol , ilay ))) / & ( plev ( icol , ilay ) * ( play ( icol , ilay - 1 ) - play ( icol , ilay ))) end do end do do icol = 1 , ncol tlev_arr ( icol , nlay + 1 ) = tlay ( icol , nlay ) & + ( plev ( icol , nlay + 1 ) - play ( icol , nlay )) * ( tlay ( icol , nlay ) - tlay ( icol , nlay - 1 )) & / ( play ( icol , nlay ) - play ( icol , nlay - 1 )) end do end if !------------------------------------------------------------------- ! Compute internal (Planck) source functions at layers and levels, !  which depend on mapping from spectral space that creates k-distribution. !$acc        data copyin(sources) copyout( sources%lay_source, sources%lev_source_inc, sources%lev_source_dec) & !$acc                             copyout( sources%sfc_source, sources%sfc_source_Jac) !$omp target data                 map(from:sources%lay_source, sources%lev_source_inc, sources%lev_source_dec) & !$omp                             map(from:sources%sfc_source, sources%sfc_source_Jac) !$acc kernels copyout(top_at_1) !$omp target map(from:top_at_1) top_at_1 = play ( 1 , 1 ) < play ( 1 , nlay ) !$acc end kernels !$omp end target call compute_Planck_source ( ncol , nlay , nbnd , ngpt , & get_nflav ( this ), this % get_neta (), this % get_npres (), this % get_ntemp (), this % get_nPlanckTemp (), & tlay , tlev_wk , tsfc , merge ( nlay , 1 , top_at_1 ), & fmajor , jeta , tropo , jtemp , jpress , & this % get_gpoint_bands (), this % get_band_lims_gpoint (), this % planck_frac , this % temp_ref_min ,& this % totplnk_delta , this % totplnk , this % gpoint_flavor , & sources % sfc_source , sources % lay_source , sources % lev_source_inc , sources % lev_source_dec , & sources % sfc_source_Jac ) !$acc end        data !$omp end target data end function source !-------------------------------------------------------------------------------------------------------------------- ! ! Initialization ! !-------------------------------------------------------------------------------------------------------------------- ! Initialize object based on data read from netCDF file however the user desires. !  Rayleigh scattering tables may or may not be present; this is indicated with allocation status ! This interface is for the internal-sources object -- includes Plank functions and fractions ! function load_int ( this , available_gases , gas_names , key_species , & band2gpt , band_lims_wavenum , & press_ref , press_ref_trop , temp_ref , & temp_ref_p , temp_ref_t , vmr_ref , & kmajor , kminor_lower , kminor_upper , & gas_minor , identifier_minor , & minor_gases_lower , minor_gases_upper , & minor_limits_gpt_lower , minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scaling_gas_lower , scaling_gas_upper , & scale_by_complement_lower , & scale_by_complement_upper , & kminor_start_lower , & kminor_start_upper , & totplnk , planck_frac , & rayl_lower , rayl_upper , & optimal_angle_fit ) result ( err_message ) class ( ty_gas_optics_rrtmgp ), intent ( inout ) :: this class ( ty_gas_concs ), intent ( in ) :: available_gases ! Which gases does the host model have available? character ( len =* ), dimension (:), intent ( in ) :: gas_names integer , dimension (:,:,:), intent ( in ) :: key_species integer , dimension (:,:), intent ( in ) :: band2gpt real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wavenum real ( wp ), dimension (:), intent ( in ) :: press_ref , temp_ref real ( wp ), intent ( in ) :: press_ref_trop , temp_ref_p , temp_ref_t real ( wp ), dimension (:,:,:), intent ( in ) :: vmr_ref real ( wp ), dimension (:,:,:,:), intent ( in ) :: kmajor real ( wp ), dimension (:,:,:), intent ( in ) :: kminor_lower , kminor_upper real ( wp ), dimension (:,:), intent ( in ) :: totplnk real ( wp ), dimension (:,:,:,:), intent ( in ) :: planck_frac real ( wp ), dimension (:,:,:), intent ( in ), & allocatable :: rayl_lower , rayl_upper real ( wp ), dimension (:,:), intent ( in ) :: optimal_angle_fit character ( len =* ), dimension (:), intent ( in ) :: gas_minor , identifier_minor character ( len =* ), dimension (:), intent ( in ) :: minor_gases_lower , & minor_gases_upper integer , dimension (:,:), intent ( in ) :: minor_limits_gpt_lower , & minor_limits_gpt_upper logical ( wl ), dimension (:), intent ( in ) :: minor_scales_with_density_lower , & minor_scales_with_density_upper character ( len =* ), dimension (:), intent ( in ) :: scaling_gas_lower , & scaling_gas_upper logical ( wl ), dimension (:), intent ( in ) :: scale_by_complement_lower ,& scale_by_complement_upper integer , dimension (:), intent ( in ) :: kminor_start_lower ,& kminor_start_upper character ( len = 128 ) :: err_message ! ---- !$acc enter data copyin(this) err_message = init_abs_coeffs ( this , & available_gases , & gas_names , key_species , & band2gpt , band_lims_wavenum , & press_ref , temp_ref , & press_ref_trop , temp_ref_p , temp_ref_t , & vmr_ref , & kmajor , kminor_lower , kminor_upper , & gas_minor , identifier_minor ,& minor_gases_lower , minor_gases_upper , & minor_limits_gpt_lower , & minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scaling_gas_lower , scaling_gas_upper , & scale_by_complement_lower , & scale_by_complement_upper , & kminor_start_lower , & kminor_start_upper , & rayl_lower , rayl_upper ) ! Planck function tables ! allocate ( this % totplnk ( size ( totplnk , 1 ), size ( totplnk , 2 )), & this % planck_frac ( size ( planck_frac , 4 ), size ( planck_frac , 2 ), size ( planck_frac , 3 ), size ( planck_frac , 1 )), & this % optimal_angle_fit ( size ( optimal_angle_fit , 1 ), size ( optimal_angle_fit , 2 ))) this % totplnk = totplnk !    this%planck_frac = planck_frac this % planck_frac = RESHAPE ( planck_frac ,( / size ( planck_frac , 4 ), size ( planck_frac , 2 ), size ( planck_frac , 3 ), size ( planck_frac , 1 ) / ), ORDER = ( / 4 , 2 , 3 , 1 / )) this % optimal_angle_fit = optimal_angle_fit !$acc        enter data copyin(this%totplnk, this%planck_frac, this%optimal_angle_fit) !$omp target enter data map(to:this%totplnk, this%planck_frac, this%optimal_angle_fit) ! Temperature steps for Planck function interpolation !   Assumes that temperature minimum and max are the same for the absorption coefficient grid and the !   Planck grid and the Planck grid is equally spaced this % totplnk_delta = ( this % temp_ref_max - this % temp_ref_min ) / ( size ( this % totplnk , dim = 1 ) - 1 ) end function load_int !-------------------------------------------------------------------------------------------------------------------- ! ! Initialize object based on data read from netCDF file however the user desires. !  Rayleigh scattering tables may or may not be present; this is indicated with allocation status ! This interface is for the external-sources object -- includes TOA source function table ! function load_ext ( this , available_gases , gas_names , key_species , & band2gpt , band_lims_wavenum , & press_ref , press_ref_trop , temp_ref , & temp_ref_p , temp_ref_t , vmr_ref , & kmajor , kminor_lower , kminor_upper , & gas_minor , identifier_minor , & minor_gases_lower , minor_gases_upper , & minor_limits_gpt_lower , minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scaling_gas_lower , scaling_gas_upper , & scale_by_complement_lower , & scale_by_complement_upper , & kminor_start_lower , & kminor_start_upper , & solar_quiet , solar_facular , solar_sunspot , & tsi_default , mg_default , sb_default , & rayl_lower , rayl_upper ) result ( err_message ) class ( ty_gas_optics_rrtmgp ), intent ( inout ) :: this class ( ty_gas_concs ), intent ( in ) :: available_gases ! Which gases does the host model have available? character ( len =* ), & dimension (:), intent ( in ) :: gas_names integer , dimension (:,:,:), intent ( in ) :: key_species integer , dimension (:,:), intent ( in ) :: band2gpt real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wavenum real ( wp ), dimension (:), intent ( in ) :: press_ref , temp_ref real ( wp ), intent ( in ) :: press_ref_trop , temp_ref_p , temp_ref_t real ( wp ), dimension (:,:,:), intent ( in ) :: vmr_ref real ( wp ), dimension (:,:,:,:), intent ( in ) :: kmajor real ( wp ), dimension (:,:,:), intent ( in ) :: kminor_lower , kminor_upper character ( len =* ), dimension (:), & intent ( in ) :: gas_minor , & identifier_minor character ( len =* ), dimension (:), & intent ( in ) :: minor_gases_lower , & minor_gases_upper integer , dimension (:,:), intent ( in ) :: & minor_limits_gpt_lower , & minor_limits_gpt_upper logical ( wl ), dimension (:), intent ( in ) :: & minor_scales_with_density_lower , & minor_scales_with_density_upper character ( len =* ), dimension (:), intent ( in ) :: & scaling_gas_lower , & scaling_gas_upper logical ( wl ), dimension (:), intent ( in ) :: & scale_by_complement_lower , & scale_by_complement_upper integer , dimension (:), intent ( in ) :: & kminor_start_lower , & kminor_start_upper real ( wp ), dimension (:), intent ( in ) :: solar_quiet , & solar_facular , & solar_sunspot real ( wp ), intent ( in ) :: tsi_default , & mg_default , sb_default real ( wp ), dimension (:,:,:), intent ( in ), & allocatable :: rayl_lower , rayl_upper character ( len = 128 ) err_message integer :: ngpt ! ---- !$acc enter data copyin(this) err_message = init_abs_coeffs ( this , & available_gases , & gas_names , key_species , & band2gpt , band_lims_wavenum , & press_ref , temp_ref , & press_ref_trop , temp_ref_p , temp_ref_t , & vmr_ref , & kmajor , kminor_lower , kminor_upper , & gas_minor , identifier_minor , & minor_gases_lower , minor_gases_upper , & minor_limits_gpt_lower , & minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scaling_gas_lower , scaling_gas_upper , & scale_by_complement_lower , & scale_by_complement_upper , & kminor_start_lower , & kminor_start_upper , & rayl_lower , rayl_upper ) if ( err_message /= \"\" ) return ! ! Spectral solar irradiance terms init ! ngpt = size ( solar_quiet ) allocate ( this % solar_source_quiet ( ngpt ), this % solar_source_facular ( ngpt ), & this % solar_source_sunspot ( ngpt ), this % solar_source ( ngpt )) !$acc        enter data create(   this%solar_source_quiet, this%solar_source_facular, this%solar_source_sunspot, this%solar_source) !$omp target enter data map(alloc:this%solar_source_quiet, this%solar_source_facular, this%solar_source_sunspot, this%solar_source) !$acc kernels !$omp target this % solar_source_quiet = solar_quiet this % solar_source_facular = solar_facular this % solar_source_sunspot = solar_sunspot !$acc end kernels !$omp end target err_message = this % set_solar_variability ( mg_default , sb_default ) end function load_ext !-------------------------------------------------------------------------------------------------------------------- ! ! Initialize absorption coefficient arrays, !   including Rayleigh scattering tables if provided (allocated) ! function init_abs_coeffs ( this , & available_gases , & gas_names , key_species , & band2gpt , band_lims_wavenum , & press_ref , temp_ref , & press_ref_trop , temp_ref_p , temp_ref_t , & vmr_ref , & kmajor , kminor_lower , kminor_upper , & gas_minor , identifier_minor ,& minor_gases_lower , minor_gases_upper , & minor_limits_gpt_lower , & minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scaling_gas_lower , scaling_gas_upper , & scale_by_complement_lower , & scale_by_complement_upper , & kminor_start_lower , & kminor_start_upper , & rayl_lower , rayl_upper ) result ( err_message ) class ( ty_gas_optics_rrtmgp ), intent ( inout ) :: this class ( ty_gas_concs ), intent ( in ) :: available_gases character ( len =* ), & dimension (:), intent ( in ) :: gas_names integer , dimension (:,:,:), intent ( in ) :: key_species integer , dimension (:,:), intent ( in ) :: band2gpt real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wavenum real ( wp ), dimension (:), intent ( in ) :: press_ref , temp_ref real ( wp ), intent ( in ) :: press_ref_trop , temp_ref_p , temp_ref_t real ( wp ), dimension (:,:,:), intent ( in ) :: vmr_ref real ( wp ), dimension (:,:,:,:), intent ( in ) :: kmajor real ( wp ), dimension (:,:,:), intent ( in ) :: kminor_lower , kminor_upper real ( wp ), dimension (:,:,:), allocatable :: kminor_lower_t , kminor_upper_t character ( len =* ), dimension (:), & intent ( in ) :: gas_minor , & identifier_minor character ( len =* ), dimension (:), & intent ( in ) :: minor_gases_lower , & minor_gases_upper integer , dimension (:,:), intent ( in ) :: minor_limits_gpt_lower , & minor_limits_gpt_upper logical ( wl ), dimension (:), intent ( in ) :: minor_scales_with_density_lower , & minor_scales_with_density_upper character ( len =* ), dimension (:),& intent ( in ) :: scaling_gas_lower , & scaling_gas_upper logical ( wl ), dimension (:), intent ( in ) :: scale_by_complement_lower , & scale_by_complement_upper integer , dimension (:), intent ( in ) :: kminor_start_lower , & kminor_start_upper real ( wp ), dimension (:,:,:), intent ( in ), & allocatable :: rayl_lower , rayl_upper character ( len = 128 ) :: err_message ! -------------------------------------------------------------------------- logical , dimension (:), allocatable :: gas_is_present logical , dimension (:), allocatable :: key_species_present_init integer , dimension (:,:,:), allocatable :: key_species_red real ( wp ), dimension (:,:,:), allocatable :: vmr_ref_red character ( len = 256 ), & dimension (:), allocatable :: minor_gases_lower_red , & minor_gases_upper_red character ( len = 256 ), & dimension (:), allocatable :: scaling_gas_lower_red , & scaling_gas_upper_red integer :: i , j , idx integer :: ngas ! -------------------------------------- err_message = this % ty_optical_props % init ( band_lims_wavenum , band2gpt ) if ( len_trim ( err_message ) /= 0 ) return ! ! Which gases known to the gas optics are present in the host model (available_gases)? ! ngas = size ( gas_names ) allocate ( gas_is_present ( ngas )) do i = 1 , ngas gas_is_present ( i ) = string_in_array ( gas_names ( i ), available_gases % gas_name ) end do ! ! Now the number of gases is the union of those known to the k-distribution and provided !   by the host model ! ngas = count ( gas_is_present ) ! ! Initialize the gas optics object, keeping only those gases known to the !   gas optics and also present in the host model ! this % gas_names = pack ( gas_names , mask = gas_is_present ) ! Copy-ins below allocate ( vmr_ref_red ( size ( vmr_ref , dim = 1 ), 0 : ngas , & size ( vmr_ref , dim = 3 ))) ! Gas 0 is used in single-key species method, set to 1.0 (col_dry) vmr_ref_red (:, 0 ,:) = vmr_ref (:, 1 ,:) do i = 1 , ngas idx = string_loc_in_array ( this % gas_names ( i ), gas_names ) vmr_ref_red (:, i ,:) = vmr_ref (:, idx + 1 ,:) enddo call move_alloc ( vmr_ref_red , this % vmr_ref ) !$acc        enter data copyin(this%vmr_ref, this%gas_names) !$omp target enter data map(to:this%vmr_ref, this%gas_names) ! ! Reduce minor arrays so variables only contain minor gases that are available ! Reduce size of minor Arrays ! call reduce_minor_arrays ( available_gases , & gas_names , & gas_minor , identifier_minor , & kminor_lower , & minor_gases_lower , & minor_limits_gpt_lower , & minor_scales_with_density_lower , & scaling_gas_lower , & scale_by_complement_lower , & kminor_start_lower , & this % kminor_lower , & minor_gases_lower_red , & this % minor_limits_gpt_lower , & this % minor_scales_with_density_lower , & scaling_gas_lower_red , & this % scale_by_complement_lower , & this % kminor_start_lower ) call reduce_minor_arrays ( available_gases , & gas_names , & gas_minor , identifier_minor ,& kminor_upper , & minor_gases_upper , & minor_limits_gpt_upper , & minor_scales_with_density_upper , & scaling_gas_upper , & scale_by_complement_upper , & kminor_start_upper , & this % kminor_upper , & minor_gases_upper_red , & this % minor_limits_gpt_upper , & this % minor_scales_with_density_upper , & scaling_gas_upper_red , & this % scale_by_complement_upper , & this % kminor_start_upper ) !$acc        enter data copyin(this%minor_limits_gpt_lower, this%minor_limits_gpt_upper) !$omp target enter data map(to:this%minor_limits_gpt_lower, this%minor_limits_gpt_upper) !$acc        enter data copyin(this%minor_scales_with_density_lower, this%minor_scales_with_density_upper) !$omp target enter data map(to:this%minor_scales_with_density_lower, this%minor_scales_with_density_upper) !$acc        enter data copyin(this%scale_by_complement_lower, this%scale_by_complement_upper) !$omp target enter data map(to:this%scale_by_complement_lower, this%scale_by_complement_upper) !$acc        enter data copyin(this%kminor_start_lower, this%kminor_start_upper) !$omp target enter data map(to:this%kminor_start_lower, this%kminor_start_upper) !$acc        enter data copyin(this%kminor_lower, this%kminor_upper) !$omp target enter data map(to:this%kminor_lower, this%kminor_upper) ! Arrays not reduced by the presence, or lack thereof, of a gas allocate ( this % press_ref ( size ( press_ref )), this % temp_ref ( size ( temp_ref )), & this % kmajor ( size ( kmajor , 4 ), size ( kmajor , 2 ), size ( kmajor , 3 ), size ( kmajor , 1 ))) this % press_ref (:) = press_ref (:) this % temp_ref (:) = temp_ref (:) this % kmajor = RESHAPE ( kmajor ,( / size ( kmajor , 4 ), size ( kmajor , 2 ), size ( kmajor , 3 ), size ( kmajor , 1 ) / ), ORDER = ( / 4 , 2 , 3 , 1 / )) !$acc        enter data copyin(this%press_ref, this%temp_ref, this%kmajor) !$omp target enter data map(to:this%press_ref, this%temp_ref, this%kmajor) if ( allocated ( rayl_lower ) . neqv . allocated ( rayl_upper )) then err_message = \"rayl_lower and rayl_upper must have the same allocation status\" return end if if ( allocated ( rayl_lower )) then allocate ( this % krayl ( size ( rayl_lower , dim = 3 ), size ( rayl_lower , dim = 2 ), size ( rayl_lower , dim = 1 ), 2 )) this % krayl (:,:,:, 1 ) = RESHAPE ( rayl_lower ,( / size ( rayl_lower , dim = 3 ), size ( rayl_lower , dim = 2 ), size ( rayl_lower , dim = 1 ) / ), ORDER = ( / 3 , 2 , 1 / )) this % krayl (:,:,:, 2 ) = RESHAPE ( rayl_upper ,( / size ( rayl_lower , dim = 3 ), size ( rayl_lower , dim = 2 ), size ( rayl_lower , dim = 1 ) / ), ORDER = ( / 3 , 2 , 1 / )) !$acc        enter data copyin(this%krayl) !$omp target enter data map(to:this%krayl) end if ! ---- post processing ---- ! creates log reference pressure allocate ( this % press_ref_log ( size ( this % press_ref ))) this % press_ref_log (:) = log ( this % press_ref (:)) !$acc        enter data copyin(this%press_ref_log) !$omp target enter data map(to:this%press_ref_log) ! log scale of reference pressure this % press_ref_trop_log = log ( press_ref_trop ) ! Get index of gas (if present) for determining col_gas call create_idx_minor ( this % gas_names , gas_minor , identifier_minor , minor_gases_lower_red , this % idx_minor_lower ) call create_idx_minor ( this % gas_names , gas_minor , identifier_minor , minor_gases_upper_red , this % idx_minor_upper ) ! Get index of gas (if present) that has special treatment in density scaling call create_idx_minor_scaling ( this % gas_names , scaling_gas_lower_red , this % idx_minor_scaling_lower ) call create_idx_minor_scaling ( this % gas_names , scaling_gas_upper_red , this % idx_minor_scaling_upper ) !$acc        enter data copyin(this%idx_minor_lower, this%idx_minor_upper) !$omp target enter data map(to:this%idx_minor_lower, this%idx_minor_upper) !$acc        enter data copyin(this%idx_minor_scaling_lower, this%idx_minor_scaling_upper) !$omp target enter data map(to:this%idx_minor_scaling_lower, this%idx_minor_scaling_upper) ! create flavor list ! Reduce (remap) key_species list; checks that all key gases are present in incoming call create_key_species_reduce ( gas_names , this % gas_names , & key_species , key_species_red , key_species_present_init ) err_message = check_key_species_present_init ( gas_names , key_species_present_init ) if ( len_trim ( err_message ) /= 0 ) return ! create flavor list call create_flavor ( key_species_red , this % flavor ) ! create gpoint_flavor list call create_gpoint_flavor ( key_species_red , this % get_gpoint_bands (), this % flavor , this % gpoint_flavor ) !Copy-ins at end of subroutine ! minimum, maximum reference temperature, pressure -- assumes low-to-high ordering !   for T, high-to-low ordering for p this % temp_ref_min = this % temp_ref ( 1 ) this % temp_ref_max = this % temp_ref ( size ( this % temp_ref )) this % press_ref_min = this % press_ref ( size ( this % press_ref )) this % press_ref_max = this % press_ref ( 1 ) ! creates press_ref_log, temp_ref_delta this % press_ref_log_delta = ( log ( this % press_ref_min ) - log ( this % press_ref_max )) / ( size ( this % press_ref ) - 1 ) this % temp_ref_delta = ( this % temp_ref_max - this % temp_ref_min ) / ( size ( this % temp_ref ) - 1 ) ! Which species are key in one or more bands? !   this%flavor is an index into this%gas_names ! if ( allocated ( this % is_key )) deallocate ( this % is_key ) ! Shouldn't ever happen... allocate ( this % is_key ( this % get_ngas ())) this % is_key (:) = . False . do j = 1 , size ( this % flavor , 2 ) do i = 1 , size ( this % flavor , 1 ) ! extents should be 2 if ( this % flavor ( i , j ) /= 0 ) this % is_key ( this % flavor ( i , j )) = . true . end do end do !$acc        enter data copyin(this%flavor, this%gpoint_flavor, this%is_key) !$omp target enter data map(to:this%flavor, this%gpoint_flavor, this%is_key) end function init_abs_coeffs ! ---------------------------------------------------------------------------------------------------- function check_key_species_present_init ( gas_names , key_species_present_init ) result ( err_message ) logical , dimension (:), intent ( in ) :: key_species_present_init character ( len =* ), dimension (:), intent ( in ) :: gas_names character ( len = 128 ) :: err_message integer :: i err_message = '' do i = 1 , size ( key_species_present_init ) if (. not . key_species_present_init ( i )) & err_message = ' ' // trim ( gas_names ( i )) // trim ( err_message ) end do if ( len_trim ( err_message ) > 0 ) err_message = \"gas_optics: required gases\" // trim ( err_message ) // \" are not provided\" end function check_key_species_present_init !------------------------------------------------------------------------------------------ ! ! Ensure that every key gas required by the k-distribution is !    present in the gas concentration object ! function check_key_species_present ( this , gas_desc ) result ( error_msg ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this class ( ty_gas_concs ), intent ( in ) :: gas_desc character ( len = 128 ) :: error_msg ! Local variables character ( len = 32 ), dimension ( count ( this % is_key (:) )) :: key_gas_names integer :: igas ! -------------------------------------- error_msg = \"\" key_gas_names = pack ( this % gas_names , mask = this % is_key ) do igas = 1 , size ( key_gas_names ) if (. not . string_in_array ( key_gas_names ( igas ), gas_desc % gas_name )) & error_msg = ' ' // trim ( lower_case ( key_gas_names ( igas ))) // trim ( error_msg ) end do if ( len_trim ( error_msg ) > 0 ) error_msg = \"gas_optics: required gases\" // trim ( error_msg ) // \" are not provided\" end function check_key_species_present !-------------------------------------------------------------------------------------------------------------------- ! ! Inquiry functions ! !-------------------------------------------------------------------------------------------------------------------- ! ! return true if initialized for internal sources, false otherwise ! pure function source_is_internal ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this logical :: source_is_internal source_is_internal = allocated ( this % totplnk ) . and . allocated ( this % planck_frac ) end function source_is_internal !-------------------------------------------------------------------------------------------------------------------- ! ! return true if initialized for external sources, false otherwise ! pure function source_is_external ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this logical :: source_is_external source_is_external = allocated ( this % solar_source ) end function source_is_external !-------------------------------------------------------------------------------------------------------------------- ! ! return the gas names ! pure function get_gases ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this character ( 32 ), dimension ( get_ngas ( this )) :: get_gases get_gases = this % gas_names end function get_gases !-------------------------------------------------------------------------------------------------------------------- ! ! return the minimum pressure on the interpolation grids ! pure function get_press_min ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this real ( wp ) :: get_press_min get_press_min = this % press_ref_min end function get_press_min !-------------------------------------------------------------------------------------------------------------------- ! ! return the maximum pressure on the interpolation grids ! pure function get_press_max ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this real ( wp ) :: get_press_max get_press_max = this % press_ref_max end function get_press_max !-------------------------------------------------------------------------------------------------------------------- ! ! return the minimum temparature on the interpolation grids ! pure function get_temp_min ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this real ( wp ) :: get_temp_min get_temp_min = this % temp_ref_min end function get_temp_min !-------------------------------------------------------------------------------------------------------------------- ! ! return the maximum temparature on the interpolation grids ! pure function get_temp_max ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this real ( wp ) :: get_temp_max get_temp_max = this % temp_ref_max end function get_temp_max !-------------------------------------------------------------------------------------------------------------------- ! ! Utility function, provided for user convenience ! computes column amounts of dry air using hydrostatic equation ! function get_col_dry ( vmr_h2o , plev , latitude ) result ( col_dry ) ! input real ( wp ), dimension (:,:), intent ( in ) :: vmr_h2o ! volume mixing ratio of water vapor to dry air; (ncol,nlay) real ( wp ), dimension (:,:), intent ( in ) :: plev ! Layer boundary pressures [Pa] (ncol,nlay+1) real ( wp ), dimension (:), optional , & intent ( in ) :: latitude ! Latitude [degrees] (ncol) ! output real ( wp ), dimension ( size ( plev , dim = 1 ), size ( plev , dim = 2 ) - 1 ) :: col_dry ! Column dry amount (ncol,nlay) ! ------------------------------------------------ ! first and second term of Helmert formula real ( wp ), parameter :: helmert1 = 9.80665_wp real ( wp ), parameter :: helmert2 = 0.02586_wp ! local variables real ( wp ), dimension ( size ( plev , dim = 1 )) :: g0 ! (ncol) real ( wp ) :: delta_plev , m_air , fact integer :: ncol , nlev integer :: icol , ilev ! nlay = nlev-1 ! ------------------------------------------------ ncol = size ( plev , dim = 1 ) nlev = size ( plev , dim = 2 ) !$acc        data    create(g0) !$omp target data map(alloc:g0) if ( present ( latitude )) then ! A purely OpenACC implementation would probably compute g0 within the kernel below !$acc parallel loop !$omp target teams distribute parallel do simd do icol = 1 , ncol g0 ( icol ) = helmert1 - helmert2 * cos ( 2.0_wp * pi * latitude ( icol ) / 18 0.0_wp ) ! acceleration due to gravity [m/s&#94;2] end do else !$acc parallel loop !$omp target teams distribute parallel do simd do icol = 1 , ncol g0 ( icol ) = grav end do end if !$acc                parallel loop gang vector collapse(2) copyin(plev,vmr_h2o)  copyout(col_dry) !$omp target teams distribute parallel do simd collapse(2) map(to:plev,vmr_h2o) map(from:col_dry) do ilev = 1 , nlev - 1 do icol = 1 , ncol delta_plev = abs ( plev ( icol , ilev ) - plev ( icol , ilev + 1 )) ! Get average mass of moist air per mole of moist air fact = 1._wp / ( 1. + vmr_h2o ( icol , ilev )) m_air = ( m_dry + m_h2o * vmr_h2o ( icol , ilev )) * fact col_dry ( icol , ilev ) = 1 0._wp * delta_plev * avogad * fact / ( 100 0._wp * m_air * 10 0._wp * g0 ( icol )) end do end do !$acc end        data !$omp end target data end function get_col_dry !-------------------------------------------------------------------------------------------------------------------- ! ! Compute a transport angle that minimizes flux errors at surface and TOA based on empirical fits ! function compute_optimal_angles ( this , optical_props , optimal_angles ) result ( err_msg ) ! input class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this class ( ty_optical_props_arry ), intent ( in ) :: optical_props real ( wp ), dimension (:,:), intent ( out ) :: optimal_angles character ( len = 128 ) :: err_msg !---------------------------- integer :: ncol , nlay , ngpt integer :: icol , ilay , igpt , bnd real ( wp ) :: t , trans_total !---------------------------- ncol = optical_props % get_ncol () nlay = optical_props % get_nlay () ngpt = optical_props % get_ngpt () err_msg = \"\" if (. not . this % gpoints_are_equal ( optical_props )) & err_msg = \"gas_optics%compute_optimal_angles: optical_props has different spectral discretization than gas_optics\" if (. not . extents_are ( optimal_angles , ncol , ngpt )) & err_msg = \"gas_optics%compute_optimal_angles: optimal_angles different dimension (ncol)\" if ( err_msg /= \"\" ) return ! ! column transmissivity ! !$acc                parallel loop gang vector collapse(2) copyin(optical_props, optical_props%tau, optical_props%gpt2band) copyout(optimal_angles) !$omp target teams distribute parallel do simd collapse(2) map(to:optical_props%tau, optical_props%gpt2band) map(from:optimal_angles) do icol = 1 , ncol do igpt = 1 , ngpt ! ! Column transmissivity ! t = 0._wp trans_total = 0._wp do ilay = 1 , nlay t = t + optical_props % tau ( icol , ilay , igpt ) end do trans_total = exp ( - t ) ! ! Optimal transport angle is a linear fit to column transmissivity ! bnd = optical_props % gpt2band ( igpt ) optimal_angles ( icol , igpt ) = this % optimal_angle_fit ( 1 , bnd ) * trans_total + & this % optimal_angle_fit ( 2 , bnd ) end do end do end function compute_optimal_angles !-------------------------------------------------------------------------------------------------------------------- ! ! Internal procedures ! !-------------------------------------------------------------------------------------------------------------------- pure function rewrite_key_species_pair ( key_species_pair ) ! (0,0) becomes (2,2) -- because absorption coefficients for these g-points will be 0. integer , dimension ( 2 ) :: rewrite_key_species_pair integer , dimension ( 2 ), intent ( in ) :: key_species_pair rewrite_key_species_pair = key_species_pair if ( all ( key_species_pair (:). eq .( / 0 , 0 / ))) then rewrite_key_species_pair (:) = ( / 2 , 2 / ) end if end function ! --------------------------------------------------------------------------------------- ! true is key_species_pair exists in key_species_list pure function key_species_pair_exists ( key_species_list , key_species_pair ) logical :: key_species_pair_exists integer , dimension (:,:), intent ( in ) :: key_species_list integer , dimension ( 2 ), intent ( in ) :: key_species_pair integer :: i do i = 1 , size ( key_species_list , dim = 2 ) if ( all ( key_species_list (:, i ). eq . key_species_pair (:))) then key_species_pair_exists = . true . return end if end do key_species_pair_exists = . false . end function key_species_pair_exists ! --------------------------------------------------------------------------------------- ! create flavor list -- !   an unordered array of extent (2,:) containing all possible pairs of key species !   used in either upper or lower atmos ! subroutine create_flavor ( key_species , flavor ) integer , dimension (:,:,:), intent ( in ) :: key_species integer , dimension (:,:), allocatable , intent ( out ) :: flavor integer , dimension ( 2 , size ( key_species , 3 ) * 2 ) :: key_species_list integer :: ibnd , iatm , i , iflavor ! prepare list of key_species i = 1 do ibnd = 1 , size ( key_species , 3 ) ! bands do iatm = 1 , size ( key_species , 2 ) ! upper/lower atmosphere key_species_list (:, i ) = key_species (:, iatm , ibnd ) i = i + 1 end do end do ! rewrite single key_species pairs do i = 1 , size ( key_species_list , 2 ) key_species_list (:, i ) = rewrite_key_species_pair ( key_species_list (:, i )) end do ! count unique key species pairs iflavor = 0 do i = 1 , size ( key_species_list , 2 ) if (. not . key_species_pair_exists ( key_species_list (:, 1 : i - 1 ), key_species_list (:, i ))) then iflavor = iflavor + 1 end if end do ! fill flavors allocate ( flavor ( 2 , iflavor )) iflavor = 0 do i = 1 , size ( key_species_list , 2 ) if (. not . key_species_pair_exists ( key_species_list (:, 1 : i - 1 ), key_species_list (:, i ))) then iflavor = iflavor + 1 flavor (:, iflavor ) = key_species_list (:, i ) end if end do end subroutine create_flavor ! --------------------------------------------------------------------------------------- ! ! create index list for extracting col_gas needed for minor gas optical depth calculations ! subroutine create_idx_minor ( gas_names , & gas_minor , identifier_minor , minor_gases_atm , idx_minor_atm ) character ( len =* ), dimension (:), intent ( in ) :: gas_names character ( len =* ), dimension (:), intent ( in ) :: & gas_minor , & identifier_minor character ( len =* ), dimension (:), intent ( in ) :: minor_gases_atm integer , dimension (:), allocatable , & intent ( out ) :: idx_minor_atm ! local integer :: imnr integer :: idx_mnr allocate ( idx_minor_atm ( size ( minor_gases_atm , dim = 1 ))) do imnr = 1 , size ( minor_gases_atm , dim = 1 ) ! loop over minor absorbers in each band ! Find identifying string for minor species in list of possible identifiers (e.g. h2o_slf) idx_mnr = string_loc_in_array ( minor_gases_atm ( imnr ), identifier_minor ) ! Find name of gas associated with minor species identifier (e.g. h2o) idx_minor_atm ( imnr ) = string_loc_in_array ( gas_minor ( idx_mnr ), gas_names ) enddo end subroutine create_idx_minor ! --------------------------------------------------------------------------------------- ! ! create index for special treatment in density scaling of minor gases ! subroutine create_idx_minor_scaling ( gas_names , & scaling_gas_atm , idx_minor_scaling_atm ) character ( len =* ), dimension (:), intent ( in ) :: gas_names character ( len =* ), dimension (:), intent ( in ) :: scaling_gas_atm integer , dimension (:), allocatable , & intent ( out ) :: idx_minor_scaling_atm ! local integer :: imnr allocate ( idx_minor_scaling_atm ( size ( scaling_gas_atm , dim = 1 ))) do imnr = 1 , size ( scaling_gas_atm , dim = 1 ) ! loop over minor absorbers in each band ! This will be -1 if there's no interacting gas idx_minor_scaling_atm ( imnr ) = string_loc_in_array ( scaling_gas_atm ( imnr ), gas_names ) enddo end subroutine create_idx_minor_scaling ! --------------------------------------------------------------------------------------- subroutine create_key_species_reduce ( gas_names , gas_names_red , & key_species , key_species_red , key_species_present_init ) character ( len =* ), & dimension (:), intent ( in ) :: gas_names character ( len =* ), & dimension (:), intent ( in ) :: gas_names_red integer , dimension (:,:,:), intent ( in ) :: key_species integer , dimension (:,:,:), allocatable , intent ( out ) :: key_species_red logical , dimension (:), allocatable , intent ( out ) :: key_species_present_init integer :: ip , ia , it , np , na , nt np = size ( key_species , dim = 1 ) na = size ( key_species , dim = 2 ) nt = size ( key_species , dim = 3 ) allocate ( key_species_red ( size ( key_species , dim = 1 ), & size ( key_species , dim = 2 ), & size ( key_species , dim = 3 ))) allocate ( key_species_present_init ( size ( gas_names ))) key_species_present_init = . true . do ip = 1 , np do ia = 1 , na do it = 1 , nt if ( key_species ( ip , ia , it ) . ne . 0 ) then key_species_red ( ip , ia , it ) = string_loc_in_array ( gas_names ( key_species ( ip , ia , it )), gas_names_red ) if ( key_species_red ( ip , ia , it ) . eq . - 1 ) key_species_present_init ( key_species ( ip , ia , it )) = . false . else key_species_red ( ip , ia , it ) = key_species ( ip , ia , it ) endif enddo end do enddo end subroutine create_key_species_reduce ! --------------------------------------------------------------------------------------- subroutine reduce_minor_arrays ( available_gases , & gas_names , & gas_minor , identifier_minor ,& kminor_atm , & minor_gases_atm , & minor_limits_gpt_atm , & minor_scales_with_density_atm , & scaling_gas_atm , & scale_by_complement_atm , & kminor_start_atm , & kminor_atm_red , & minor_gases_atm_red , & minor_limits_gpt_atm_red , & minor_scales_with_density_atm_red , & scaling_gas_atm_red , & scale_by_complement_atm_red , & kminor_start_atm_red ) class ( ty_gas_concs ), intent ( in ) :: available_gases character ( len =* ), dimension (:), intent ( in ) :: gas_names real ( wp ), dimension (:,:,:), intent ( in ) :: kminor_atm character ( len =* ), dimension (:), intent ( in ) :: gas_minor , & identifier_minor character ( len =* ), dimension (:), intent ( in ) :: minor_gases_atm integer , dimension (:,:), intent ( in ) :: minor_limits_gpt_atm logical ( wl ), dimension (:), intent ( in ) :: minor_scales_with_density_atm character ( len =* ), dimension (:), intent ( in ) :: scaling_gas_atm logical ( wl ), dimension (:), intent ( in ) :: scale_by_complement_atm integer , dimension (:), intent ( in ) :: kminor_start_atm real ( wp ), dimension (:,:,:), allocatable , & intent ( out ) :: kminor_atm_red character ( len =* ), dimension (:), allocatable , & intent ( out ) :: minor_gases_atm_red integer , dimension (:,:), allocatable , & intent ( out ) :: minor_limits_gpt_atm_red logical ( wl ), dimension (:), allocatable , & intent ( out ) :: minor_scales_with_density_atm_red character ( len =* ), dimension (:), allocatable , & intent ( out ) :: scaling_gas_atm_red logical ( wl ), dimension (:), allocatable , intent ( out ) :: & scale_by_complement_atm_red integer , dimension (:), allocatable , intent ( out ) :: & kminor_start_atm_red ! Local variables integer :: i , j , ks integer :: idx_mnr , nm , tot_g , red_nm integer :: icnt , n_elim , ng logical , dimension (:), allocatable :: gas_is_present integer , dimension (:), allocatable :: indexes real ( wp ), dimension (:,:,:), allocatable :: kminor_atm_red_t nm = size ( minor_gases_atm ) tot_g = 0 allocate ( gas_is_present ( nm )) do i = 1 , size ( minor_gases_atm ) idx_mnr = string_loc_in_array ( minor_gases_atm ( i ), identifier_minor ) gas_is_present ( i ) = string_in_array ( gas_minor ( idx_mnr ), available_gases % gas_name ) if ( gas_is_present ( i )) then tot_g = tot_g + ( minor_limits_gpt_atm ( 2 , i ) - minor_limits_gpt_atm ( 1 , i ) + 1 ) endif enddo red_nm = count ( gas_is_present ) allocate ( minor_gases_atm_red ( red_nm ),& minor_scales_with_density_atm_red ( red_nm ), & scaling_gas_atm_red ( red_nm ), & scale_by_complement_atm_red ( red_nm ), & kminor_start_atm_red ( red_nm )) allocate ( minor_limits_gpt_atm_red ( 2 , red_nm )) allocate ( kminor_atm_red_t ( tot_g , size ( kminor_atm , 2 ), size ( kminor_atm , 3 ))) allocate ( kminor_atm_red ( size ( kminor_atm , 3 ), size ( kminor_atm , 2 ), tot_g )) if (( red_nm . eq . nm )) then ! Character data not allowed in OpenACC regions? minor_gases_atm_red = minor_gases_atm scaling_gas_atm_red = scaling_gas_atm kminor_atm_red_t = kminor_atm minor_limits_gpt_atm_red = minor_limits_gpt_atm minor_scales_with_density_atm_red = minor_scales_with_density_atm scale_by_complement_atm_red = scale_by_complement_atm kminor_start_atm_red = kminor_start_atm else allocate ( indexes ( red_nm )) ! Find the integer indexes for the gases that are present indexes = pack ([( i , i = 1 , size ( minor_gases_atm ))], mask = gas_is_present ) minor_gases_atm_red = minor_gases_atm ( indexes ) scaling_gas_atm_red = scaling_gas_atm ( indexes ) minor_scales_with_density_atm_red = & minor_scales_with_density_atm ( indexes ) scale_by_complement_atm_red = & scale_by_complement_atm ( indexes ) kminor_start_atm_red = kminor_start_atm ( indexes ) icnt = 0 n_elim = 0 do i = 1 , nm ng = minor_limits_gpt_atm ( 2 , i ) - minor_limits_gpt_atm ( 1 , i ) + 1 if ( gas_is_present ( i )) then icnt = icnt + 1 minor_limits_gpt_atm_red ( 1 : 2 , icnt ) = minor_limits_gpt_atm ( 1 : 2 , i ) kminor_start_atm_red ( icnt ) = kminor_start_atm ( i ) - n_elim ks = kminor_start_atm_red ( icnt ) do j = 1 , ng kminor_atm_red_t ( kminor_start_atm_red ( icnt ) + j - 1 ,:,:) = & kminor_atm ( kminor_start_atm ( i ) + j - 1 ,:,:) enddo else n_elim = n_elim + ng endif enddo endif kminor_atm_red = RESHAPE ( kminor_atm_red_t ,( / size ( kminor_atm_red_t , dim = 3 ), size ( kminor_atm_red_t , dim = 2 ), size ( kminor_atm_red_t , dim = 1 ) / ), ORDER = ( / 3 , 2 , 1 / )) deallocate ( kminor_atm_red_t ) end subroutine reduce_minor_arrays ! --------------------------------------------------------------------------------------- ! returns flavor index; -1 if not found pure function key_species_pair2flavor ( flavor , key_species_pair ) integer :: key_species_pair2flavor integer , dimension (:,:), intent ( in ) :: flavor integer , dimension ( 2 ), intent ( in ) :: key_species_pair integer :: iflav do iflav = 1 , size ( flavor , 2 ) if ( all ( key_species_pair (:). eq . flavor (:, iflav ))) then key_species_pair2flavor = iflav return end if end do key_species_pair2flavor = - 1 end function key_species_pair2flavor ! --------------------------------------------------------------------------------------- ! ! create gpoint_flavor list !   a map pointing from each g-point to the corresponding entry in the \"flavor list\" ! subroutine create_gpoint_flavor ( key_species , gpt2band , flavor , gpoint_flavor ) integer , dimension (:,:,:), intent ( in ) :: key_species integer , dimension (:), intent ( in ) :: gpt2band integer , dimension (:,:), intent ( in ) :: flavor integer , dimension (:,:), intent ( out ), allocatable :: gpoint_flavor integer :: ngpt , igpt , iatm ngpt = size ( gpt2band ) allocate ( gpoint_flavor ( 2 , ngpt )) do igpt = 1 , ngpt do iatm = 1 , 2 gpoint_flavor ( iatm , igpt ) = key_species_pair2flavor ( & flavor , & rewrite_key_species_pair ( key_species (:, iatm , gpt2band ( igpt ))) & ) end do end do end subroutine create_gpoint_flavor !-------------------------------------------------------------------------------------------------------------------- ! ! Utility function to combine optical depths from gas absorption and Rayleigh scattering !   (and reorder them for convenience, while we're at it) ! subroutine combine_abs_and_rayleigh ( tau , tau_rayleigh , optical_props ) real ( wp ), dimension (:,:,:), intent ( in ) :: tau real ( wp ), dimension (:,:,:), intent ( in ) :: tau_rayleigh class ( ty_optical_props_arry ), intent ( inout ) :: optical_props integer :: icol , ilay , igpt , ncol , nlay , ngpt , nmom real ( wp ) :: t ncol = size ( tau , 1 ) nlay = size ( tau , 2 ) ngpt = size ( tau , 3 ) select type ( optical_props ) type is ( ty_optical_props_1scl ) ! ! Extinction optical depth ! !$acc parallel loop gang vector                collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol optical_props % tau ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) + & tau_rayleigh ( icol , ilay , igpt ) end do end do end do ! ! asymmetry factor or phase function moments ! type is ( ty_optical_props_2str ) ! ! Extinction optical depth and single scattering albedo ! !$acc parallel loop gang vector                collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol t = tau ( icol , ilay , igpt ) + tau_rayleigh ( icol , ilay , igpt ) if ( t > 2._wp * tiny ( t )) then optical_props % ssa ( icol , ilay , igpt ) = tau_rayleigh ( icol , ilay , igpt ) / t else optical_props % ssa ( icol , ilay , igpt ) = 0._wp end if optical_props % tau ( icol , ilay , igpt ) = t end do end do end do call zero_array ( ncol , nlay , ngpt , optical_props % g ) type is ( ty_optical_props_nstr ) ! ! Extinction optical depth and single scattering albedo ! !$acc parallel loop gang vector                collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol t = tau ( icol , ilay , igpt ) + tau_rayleigh ( icol , ilay , igpt ) if ( t > 2._wp * tiny ( t )) then optical_props % ssa ( icol , ilay , igpt ) = tau_rayleigh ( icol , ilay , igpt ) / t else optical_props % ssa ( icol , ilay , igpt ) = 0._wp end if optical_props % tau ( icol , ilay , igpt ) = t end do end do end do nmom = size ( optical_props % p , 1 ) call zero_array ( nmom , ncol , nlay , ngpt , optical_props % p ) if ( nmom >= 2 ) then !$acc parallel loop gang vector                collapse(3) !$omp target teams distribute parallel do simd collapse(3) do igpt = 1 , ngpt do ilay = 1 , nlay do icol = 1 , ncol optical_props % p ( 2 , icol , ilay , igpt ) = 0.1_wp end do end do end do end if end select end subroutine combine_abs_and_rayleigh !-------------------------------------------------------------------------------------------------------------------- ! Sizes of tables: pressure, temperate, eta (mixing fraction) !   Equivalent routines for the number of gases and flavors (get_ngas(), get_nflav()) are defined above because they're !   used in function defintions ! Table kmajor has dimensions (ngpt, neta, npres, ntemp) !-------------------------------------------------------------------------------------------------------------------- ! ! return extent of eta dimension ! pure function get_neta ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer :: get_neta get_neta = size ( this % kmajor , dim = 2 ) end function ! -------------------------------------------------------------------------------------- ! ! return the number of pressures in reference profile !   absorption coefficient table is one bigger since a pressure is repeated in upper/lower atmos ! pure function get_npres ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer :: get_npres get_npres = size ( this % kmajor , dim = 3 ) - 1 end function get_npres ! -------------------------------------------------------------------------------------- ! ! return the number of temperatures ! pure function get_ntemp ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer :: get_ntemp get_ntemp = size ( this % kmajor , dim = 1 ) end function get_ntemp ! -------------------------------------------------------------------------------------- ! ! return the number of temperatures for Planck function ! pure function get_nPlanckTemp ( this ) class ( ty_gas_optics_rrtmgp ), intent ( in ) :: this integer :: get_nPlanckTemp get_nPlanckTemp = size ( this % totplnk , dim = 1 ) ! dimensions are Planck-temperature, band end function get_nPlanckTemp end module mo_gas_optics_rrtmgp","tags":"","loc":"sourcefile/mo_gas_optics_rrtmgp.f90.html"},{"title":"mo_rrtmgp_constants.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rrtmgp_constants.f90~~EfferentGraph sourcefile~mo_rrtmgp_constants.f90 mo_rrtmgp_constants.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rrtmgp_constants.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rrtmgp_constants.f90~~AfferentGraph sourcefile~mo_rrtmgp_constants.f90 mo_rrtmgp_constants.F90 sourcefile~mo_heating_rates.f90 mo_heating_rates.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rrtmgp_constants.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rrtmgp_constants Source Code mo_rrtmgp_constants.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! Physical and mathematical constants used in gas optics calculation !   If the host model in which RRTGMP is embedded has defined these constants elsewhere !   the model definitions can be used instead by renaming. For example, ! use  mo_model_constants, only k_boltz => boltzman_k, ... !   where the syntax is local_name => original_name !   and all the local names need to be defined ! ! \"Constants\" specific to the earth's atmosphere should also be made consistent with the !   host model but may be changed in a call to init_constants(), normally at initialization ! ------------------------------------------------------------------------------------------------- module mo_rrtmgp_constants use mo_rte_kind , only : wp public ! ----------------------------------------- ! Physical constants, 2018 SI defintion of metric system !   doi:10.1088/1681-7575/aa950a (see also https://www.nist.gov/si-redefinition/meet-constants) ! Boltzmann constant [J/K] = [(kg m&#94;2)/(K s&#94;2)] real ( wp ), parameter :: k_boltz = 1.380649e-23_wp !  molecular weight of water [kg/mol] real ( wp ), parameter :: m_h2o = 0.018016_wp ! Avogadro's number [molec/mol] real ( wp ), parameter :: avogad = 6.02214076e23_wp ! Universal gas constant [J/(mol K)] real ( wp ), parameter :: R_univ_gconst = avogad * k_boltz ! ----------------------------------------- ! ! Constants specific to the earth's atmosphere -- changeable in init() because they !   might be different on e.g. other planets ! molecular weight of dry air [kg/mol] real ( wp ), protected :: m_dry = 0.028964_wp ! Gravity at Earth's surface [m/s2] real ( wp ), protected :: grav = 9.80665_wp ! Specific heat at constant pressure for dry air [J/(K kg)] real ( wp ), protected :: cp_dry = 100 4.64_wp contains ! ----------------------------------------- subroutine init_constants ( gravity , mol_weight_dry_air , heat_capacity_dry_air ) real ( wp ), optional , intent ( in ) :: gravity , mol_weight_dry_air , heat_capacity_dry_air if ( present ( gravity )) grav = gravity if ( present ( mol_weight_dry_air )) m_dry = mol_weight_dry_air if ( present ( heat_capacity_dry_air )) cp_dry = heat_capacity_dry_air end subroutine init_constants ! ----------------------------------------- end module mo_rrtmgp_constants","tags":"","loc":"sourcefile/mo_rrtmgp_constants.f90.html"},{"title":"mo_gas_optics_kernels.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_gas_optics_kernels.f90~~EfferentGraph sourcefile~mo_gas_optics_kernels.f90 mo_gas_optics_kernels.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_gas_optics_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_gas_optics_kernels.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_gas_optics_kernels.f90~~AfferentGraph sourcefile~mo_gas_optics_kernels.f90 mo_gas_optics_kernels.F90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_gas_optics_kernels.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_gas_optics_kernels Source Code mo_gas_optics_kernels.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2015,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! Description: Numeric calculations for gas optics. Absorption and Rayleigh optical depths, !   source functions. module mo_gas_optics_kernels use mo_rte_kind , only : wp , wl use mo_rte_util_array , only : zero_array implicit none public contains ! -------------------------------------------------------------------------------------- ! Compute interpolation coefficients ! for calculations of major optical depths, minor optical depths, Rayleigh, ! and Planck fractions subroutine interpolation ( & ncol , nlay , ngas , nflav , neta , npres , ntemp , & flavor , & press_ref_log , temp_ref , press_ref_log_delta , & temp_ref_min , temp_ref_delta , press_ref_trop_log , & vmr_ref , & play , tlay , col_gas , & jtemp , fmajor , fminor , col_mix , tropo , jeta , jpress ) bind ( C , name = \"interpolation\" ) ! input dimensions integer , intent ( in ) :: ncol , nlay integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , dimension ( 2 , nflav ), intent ( in ) :: flavor real ( wp ), dimension ( npres ), intent ( in ) :: press_ref_log real ( wp ), dimension ( ntemp ), intent ( in ) :: temp_ref real ( wp ), intent ( in ) :: press_ref_log_delta , & temp_ref_min , temp_ref_delta , & press_ref_trop_log real ( wp ), dimension ( 2 , 0 : ngas , ntemp ), intent ( in ) :: vmr_ref ! inputs from profile or parent function real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas ! outputs integer , dimension ( ncol , nlay ), intent ( out ) :: jtemp , jpress logical ( wl ), dimension ( ncol , nlay ), intent ( out ) :: tropo integer , dimension ( 2 , ncol , nlay , nflav ), intent ( out ) :: jeta real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( out ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( out ) :: fmajor real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( out ) :: fminor ! ----------------- ! local real ( wp ), dimension ( ncol , nlay ) :: ftemp , fpress ! interpolation fraction for temperature, pressure real ( wp ) :: locpress ! needed to find location in pressure grid real ( wp ) :: ratio_eta_half ! ratio of vmrs of major species that defines eta=0.5 ! for given flavor and reference temperature level real ( wp ) :: eta , feta ! binary_species_parameter, interpolation variable for eta real ( wp ) :: loceta ! needed to find location in eta grid real ( wp ) :: ftemp_term ! ----------------- ! local indexes integer :: icol , ilay , iflav , igases ( 2 ), itropo , itemp !$acc data copyin(flavor,press_ref_log,temp_ref,vmr_ref,play,tlay,col_gas) & !$acc      copyout(jtemp,jpress,tropo,jeta,col_mix,fmajor,fminor) & !$acc      create(ftemp,fpress) !$omp target data map(to:flavor, press_ref_log, temp_ref, vmr_ref, play, tlay, col_gas) & !$omp             map(alloc:jtemp, jpress, tropo, jeta, col_mix, fmajor, fminor) & !$omp             map(alloc:ftemp, fpress) !$acc parallel loop gang vector collapse(2) default(none) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol ! index and factor for temperature interpolation jtemp ( icol , ilay ) = int (( tlay ( icol , ilay ) - ( temp_ref_min - temp_ref_delta )) / temp_ref_delta ) jtemp ( icol , ilay ) = min ( ntemp - 1 , max ( 1 , jtemp ( icol , ilay ))) ! limit the index range ftemp ( icol , ilay ) = ( tlay ( icol , ilay ) - temp_ref ( jtemp ( icol , ilay ))) / temp_ref_delta ! index and factor for pressure interpolation locpress = 1._wp + ( log ( play ( icol , ilay )) - press_ref_log ( 1 )) / press_ref_log_delta jpress ( icol , ilay ) = min ( npres - 1 , max ( 1 , int ( locpress ))) fpress ( icol , ilay ) = locpress - float ( jpress ( icol , ilay )) ! determine if in lower or upper part of atmosphere tropo ( icol , ilay ) = log ( play ( icol , ilay )) > press_ref_trop_log end do end do ! loop over implemented combinations of major species ! PGI BUG WORKAROUND: if present(vmr_ref) isn't there, OpenACC runtime ! thinks it isn't present. !$acc parallel loop gang vector collapse(4) default(none) private(igases) present(vmr_ref) !$omp target teams distribute parallel do simd collapse(4) private(igases) do iflav = 1 , nflav do ilay = 1 , nlay ! loop over implemented combinations of major species do icol = 1 , ncol do itemp = 1 , 2 igases (:) = flavor (:, iflav ) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! compute interpolation fractions needed for lower, then upper reference temperature level ! compute binary species parameter (eta) for flavor and temperature and !  associated interpolation index and factors ratio_eta_half = vmr_ref ( itropo , igases ( 1 ),( jtemp ( icol , ilay ) + itemp - 1 )) / & vmr_ref ( itropo , igases ( 2 ),( jtemp ( icol , ilay ) + itemp - 1 )) col_mix ( itemp , icol , ilay , iflav ) = col_gas ( icol , ilay , igases ( 1 )) + ratio_eta_half * col_gas ( icol , ilay , igases ( 2 )) eta = merge ( col_gas ( icol , ilay , igases ( 1 )) / col_mix ( itemp , icol , ilay , iflav ), 0.5_wp , & col_mix ( itemp , icol , ilay , iflav ) > 2._wp * tiny ( col_mix )) loceta = eta * float ( neta - 1 ) jeta ( itemp , icol , ilay , iflav ) = min ( int ( loceta ) + 1 , neta - 1 ) feta = mod ( loceta , 1.0_wp ) ! compute interpolation fractions needed for minor species ! ftemp_term = (1._wp-ftemp(icol,ilay)) for itemp = 1, ftemp(icol,ilay) for itemp=2 ftemp_term = ( real ( 2 - itemp , wp ) + real ( 2 * itemp - 3 , wp ) * ftemp ( icol , ilay )) fminor ( 1 , itemp , icol , ilay , iflav ) = ( 1._wp - feta ) * ftemp_term fminor ( 2 , itemp , icol , ilay , iflav ) = feta * ftemp_term ! compute interpolation fractions needed for major species fmajor ( 1 , 1 , itemp , icol , ilay , iflav ) = ( 1._wp - fpress ( icol , ilay )) * fminor ( 1 , itemp , icol , ilay , iflav ) fmajor ( 2 , 1 , itemp , icol , ilay , iflav ) = ( 1._wp - fpress ( icol , ilay )) * fminor ( 2 , itemp , icol , ilay , iflav ) fmajor ( 1 , 2 , itemp , icol , ilay , iflav ) = fpress ( icol , ilay ) * fminor ( 1 , itemp , icol , ilay , iflav ) fmajor ( 2 , 2 , itemp , icol , ilay , iflav ) = fpress ( icol , ilay ) * fminor ( 2 , itemp , icol , ilay , iflav ) end do ! reference temperatures end do ! icol end do ! ilay end do ! iflav !$acc end data !$omp end target data end subroutine interpolation ! -------------------------------------------------------------------------------------- ! ! Compute minor and major species opitcal depth from pre-computed interpolation coefficients !   (jeta,jtemp,jpress) ! subroutine compute_tau_absorption ( & ncol , nlay , nbnd , ngpt , & ! dimensions ngas , nflav , neta , npres , ntemp , & nminorlower , nminorklower , & ! number of minor contributors, total num absorption coeffs nminorupper , nminorkupper , & idx_h2o , & gpoint_flavor , & band_lims_gpt , & kmajor , & kminor_lower , & kminor_upper , & minor_limits_gpt_lower , & minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scale_by_complement_lower , & scale_by_complement_upper , & idx_minor_lower , & idx_minor_upper , & idx_minor_scaling_lower , & idx_minor_scaling_upper , & kminor_start_lower , & kminor_start_upper , & tropo , & col_mix , fmajor , fminor , & play , tlay , col_gas , & jeta , jtemp , jpress , & tau ) bind ( C , name = \"compute_tau_absorption\" ) ! --------------------- ! input dimensions integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , intent ( in ) :: nminorlower , nminorklower , nminorupper , nminorkupper integer , intent ( in ) :: idx_h2o ! --------------------- ! inputs from object integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: kmajor real ( wp ), dimension ( ntemp , neta , nminorklower ), intent ( in ) :: kminor_lower real ( wp ), dimension ( ntemp , neta , nminorkupper ), intent ( in ) :: kminor_upper integer , dimension ( 2 , nminorlower ), intent ( in ) :: minor_limits_gpt_lower integer , dimension ( 2 , nminorupper ), intent ( in ) :: minor_limits_gpt_upper logical ( wl ), dimension ( nminorlower ), intent ( in ) :: minor_scales_with_density_lower logical ( wl ), dimension ( nminorupper ), intent ( in ) :: minor_scales_with_density_upper logical ( wl ), dimension ( nminorlower ), intent ( in ) :: scale_by_complement_lower logical ( wl ), dimension ( nminorupper ), intent ( in ) :: scale_by_complement_upper integer , dimension ( nminorlower ), intent ( in ) :: idx_minor_lower integer , dimension ( nminorupper ), intent ( in ) :: idx_minor_upper integer , dimension ( nminorlower ), intent ( in ) :: idx_minor_scaling_lower integer , dimension ( nminorupper ), intent ( in ) :: idx_minor_scaling_upper integer , dimension ( nminorlower ), intent ( in ) :: kminor_start_lower integer , dimension ( nminorupper ), intent ( in ) :: kminor_start_upper logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo ! --------------------- ! inputs from profile or parent function real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay ! pressure and temperature real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp integer , dimension ( ncol , nlay ), intent ( in ) :: jpress ! --------------------- ! output - optical depth real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! --------------------- ! Local variables ! logical ( wl ) :: top_at_1 integer , dimension ( ncol , 2 ) :: itropo_lower , itropo_upper integer :: icol , idx_tropo ! ---------------------------------------------------------------- !$acc enter data create(itropo_lower, itropo_upper) !$omp target enter data map(alloc:itropo_lower, itropo_upper) !$acc enter data copyin(play, tlay, tropo, gpoint_flavor, jeta, jtemp, col_gas, fminor, tau) !$omp target enter data map(to:play, tlay, tropo, gpoint_flavor, jeta, jtemp, col_gas, fminor, tau) ! --------------------- ! Layer limits of upper, lower atmospheres ! --------------------- !$acc kernels copyout(top_at_1) !$omp target map(from:top_at_1) top_at_1 = play ( 1 , 1 ) < play ( 1 , nlay ) !$acc end kernels !$omp end target if ( top_at_1 ) then !$acc parallel loop !$omp target teams distribute parallel do simd do icol = 1 , ncol itropo_lower ( icol , 2 ) = nlay #if defined(_CRAYFTN) || defined(__NVCOMPILER) itropo_upper ( icol , 1 ) = 1 call minmaxloc ( icol , tropo , play , itropo_lower ( icol , 1 ), itropo_upper ( icol , 2 )) #else itropo_lower ( icol , 1 ) = minloc ( play ( icol ,:), dim = 1 , mask = tropo ( icol ,:)) itropo_upper ( icol , 1 ) = 1 itropo_upper ( icol , 2 ) = maxloc ( play ( icol ,:), dim = 1 , mask = (. not . tropo ( icol ,:))) #endif end do else !$acc parallel loop !$omp target teams distribute parallel do simd do icol = 1 , ncol itropo_lower ( icol , 1 ) = 1 #if defined(_CRAYFTN) || defined(__NVCOMPILER) itropo_upper ( icol , 2 ) = nlay call minmaxloc ( icol , tropo , play , itropo_lower ( icol , 2 ), itropo_upper ( icol , 1 )) #else itropo_lower ( icol , 2 ) = minloc ( play ( icol ,:), dim = 1 , mask = tropo ( icol ,:)) itropo_upper ( icol , 2 ) = nlay itropo_upper ( icol , 1 ) = maxloc ( play ( icol ,:), dim = 1 , mask = (. not . tropo ( icol ,:))) #endif end do end if ! --------------------- ! Major Species ! --------------------- call gas_optical_depths_major ( & ncol , nlay , nbnd , ngpt , & ! dimensions nflav , neta , npres , ntemp , & gpoint_flavor , & band_lims_gpt , & kmajor , & col_mix , fmajor , & jeta , tropo , jtemp , jpress , & tau ) ! --------------------- ! Minor Species - lower ! --------------------- idx_tropo = 1 call gas_optical_depths_minor ( & ncol , nlay , ngpt , & ! dimensions ngas , nflav , ntemp , neta , & nminorlower , nminorklower , & idx_h2o , idx_tropo , & gpoint_flavor , & kminor_lower , & minor_limits_gpt_lower , & minor_scales_with_density_lower , & scale_by_complement_lower , & idx_minor_lower , & idx_minor_scaling_lower , & kminor_start_lower , & play , tlay , & col_gas , fminor , jeta , & itropo_lower , jtemp , & tau ) ! --------------------- ! Minor Species - upper ! --------------------- idx_tropo = 2 call gas_optical_depths_minor ( & ncol , nlay , ngpt , & ! dimensions ngas , nflav , ntemp , neta , & nminorupper , nminorkupper , & idx_h2o , idx_tropo , & gpoint_flavor , & kminor_upper , & minor_limits_gpt_upper , & minor_scales_with_density_upper , & scale_by_complement_upper , & idx_minor_upper , & idx_minor_scaling_upper , & kminor_start_upper , & play , tlay , & col_gas , fminor , jeta , & itropo_upper , jtemp , & tau ) !$acc exit data delete(itropo_lower,itropo_upper) !$omp target exit data map(release:itropo_lower, itropo_upper) !$acc exit data delete(play, tlay, tropo, gpoint_flavor, jeta, jtemp, col_gas, fminor) !$omp target exit data map(release:play, tlay, tropo, gpoint_flavor, jeta, jtemp, col_gas, fminor) !$acc exit data copyout(tau) !$omp target exit data map(from:tau) end subroutine compute_tau_absorption ! -------------------------------------------------------------------------------------- ! -------------------------------------------------------------------------------------- ! ! compute minor species optical depths ! subroutine gas_optical_depths_major ( ncol , nlay , nbnd , ngpt ,& nflav , neta , npres , ntemp , & ! dimensions gpoint_flavor , band_lims_gpt , & ! inputs from object kmajor , & col_mix , fmajor , & jeta , tropo , jtemp , jpress , & ! local input tau ) bind ( C , name = \"gas_optical_depths_major\" ) ! input dimensions integer , intent ( in ) :: ncol , nlay , nbnd , ngpt , nflav , neta , npres , ntemp ! dimensions ! inputs from object integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: kmajor ! inputs from profile or parent function real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress ! outputs real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! ----------------- ! local variables real ( wp ) :: tau_major ! major species optical depth ! local index integer :: icol , ilay , iflav , igpt , itropo ! ----------------- ! ----------------- ! optical depth calculation for major species !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol !$acc loop seq do igpt = 1 , ngpt ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! WS: moved inside innermost loop ! binary species parameter (eta) and col_mix depend on band flavor iflav = gpoint_flavor ( itropo , igpt ) tau_major = & ! interpolation in temperature, pressure, and eta interpolate3D ( col_mix (:, icol , ilay , iflav ), & fmajor (:,:,:, icol , ilay , iflav ), kmajor , & igpt , jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay ), jpress ( icol , ilay ) + itropo ) tau ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) + tau_major end do ! igpt end do end do ! ilay end subroutine gas_optical_depths_major ! ---------------------------------------------------------- ! ! compute minor species optical depths ! subroutine gas_optical_depths_minor ( ncol , nlay , ngpt , & ngas , nflav , ntemp , neta , & nminor , nminork , & idx_h2o , idx_tropo , & gpt_flv , & kminor , & minor_limits_gpt , & minor_scales_with_density , & scale_by_complement , & idx_minor , idx_minor_scaling , & kminor_start , & play , tlay , & col_gas , fminor , jeta , & layer_limits , jtemp , & tau ) bind ( C , name = \"gas_optical_depths_minor\" ) integer , intent ( in ) :: ncol , nlay , ngpt integer , intent ( in ) :: ngas , nflav integer , intent ( in ) :: ntemp , neta , nminor , nminork integer , intent ( in ) :: idx_h2o , idx_tropo integer , dimension ( 2 , ngpt ), intent ( in ) :: gpt_flv real ( wp ), dimension ( ntemp , neta , nminork ), intent ( in ) :: kminor integer , dimension ( 2 , nminor ), intent ( in ) :: minor_limits_gpt logical ( wl ), dimension ( nminor ), intent ( in ) :: minor_scales_with_density logical ( wl ), dimension ( nminor ), intent ( in ) :: scale_by_complement integer , dimension ( nminor ), intent ( in ) :: kminor_start integer , dimension ( nminor ), intent ( in ) :: idx_minor , idx_minor_scaling real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta integer , dimension ( ncol , 2 ), intent ( in ) :: layer_limits integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! ----------------- ! local variables real ( wp ), parameter :: PaTohPa = 0.01_wp real ( wp ) :: vmr_fact , dry_fact ! conversion from column abundance to dry vol. mixing ratio; real ( wp ) :: scaling , kminor_loc , tau_minor ! minor species absorption coefficient, optical depth integer :: icol , ilay , iflav , igpt , imnr integer :: minor_start , minor_loc , extent real ( wp ) :: myplay , mytlay , mycol_gas_h2o , mycol_gas_imnr , mycol_gas_0 real ( wp ) :: myfminor ( 2 , 2 ) integer :: myjtemp , myjeta ( 2 ) ! ----------------- extent = size ( scale_by_complement , dim = 1 ) !$acc parallel loop gang vector collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol ! ! This check skips individual columns with no pressures in range ! if ( layer_limits ( icol , 1 ) <= 0 . or . ilay < layer_limits ( icol , 1 ) . or . ilay > layer_limits ( icol , 2 ) ) cycle myplay = play ( icol , ilay ) mytlay = tlay ( icol , ilay ) myjtemp = jtemp ( icol , ilay ) mycol_gas_h2o = col_gas ( icol , ilay , idx_h2o ) mycol_gas_0 = col_gas ( icol , ilay , 0 ) !$acc loop seq do imnr = 1 , extent ! What is the starting point in the stored array of minor absorption coefficients? minor_start = kminor_start ( imnr ) !$acc loop seq do igpt = minor_limits_gpt ( 1 , imnr ), minor_limits_gpt ( 2 , imnr ) scaling = col_gas ( icol , ilay , idx_minor ( imnr )) if ( minor_scales_with_density ( imnr )) then ! ! NOTE: P needed in hPa to properly handle density scaling. ! scaling = scaling * ( PaTohPa * myplay / mytlay ) if ( idx_minor_scaling ( imnr ) > 0 ) then ! there is a second gas that affects this gas's absorption mycol_gas_imnr = col_gas ( icol , ilay , idx_minor_scaling ( imnr )) vmr_fact = 1._wp / mycol_gas_0 dry_fact = 1._wp / ( 1._wp + mycol_gas_h2o * vmr_fact ) ! scale by density of special gas if ( scale_by_complement ( imnr )) then ! scale by densities of all gases but the special one scaling = scaling * ( 1._wp - mycol_gas_imnr * vmr_fact * dry_fact ) else scaling = scaling * ( mycol_gas_imnr * vmr_fact * dry_fact ) endif endif endif ! ! Interpolation of absorption coefficient and calculation of optical depth ! tau_minor = 0._wp iflav = gpt_flv ( idx_tropo , igpt ) ! eta interpolation depends on flavor minor_loc = minor_start + ( igpt - minor_limits_gpt ( 1 , imnr )) ! add offset to starting point kminor_loc = interpolate2D ( fminor (:,:, icol , ilay , iflav ), kminor , minor_loc , & jeta (:, icol , ilay , iflav ), myjtemp ) tau_minor = kminor_loc * scaling tau ( icol , ilay , igpt ) = tau ( icol , ilay , igpt ) + tau_minor enddo enddo enddo enddo end subroutine gas_optical_depths_minor ! ---------------------------------------------------------- ! ! compute Rayleigh scattering optical depths ! subroutine compute_tau_rayleigh ( ncol , nlay , nbnd , ngpt , & ngas , nflav , neta , npres , ntemp , & gpoint_flavor , band_lims_gpt , & krayl , & idx_h2o , col_dry , col_gas , & fminor , jeta , tropo , jtemp , & tau_rayleigh ) bind ( C , name = \"compute_tau_rayleigh\" ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), dimension ( ntemp , neta , ngpt , 2 ), intent ( in ) :: krayl integer , intent ( in ) :: idx_h2o real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: col_dry real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp ! outputs real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: tau_rayleigh ! ----------------- ! local variables real ( wp ) :: k ! rayleigh scattering coefficient integer :: icol , ilay , iflav , igpt integer :: itropo ! ----------------- !$acc parallel loop collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol !$acc loop seq do igpt = 1 , ngpt itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere iflav = gpoint_flavor ( itropo , igpt ) k = interpolate2D ( fminor (:,:, icol , ilay , iflav ), & krayl (:,:,:, itropo ), & igpt , jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay )) tau_rayleigh ( icol , ilay , igpt ) = k * ( col_gas ( icol , ilay , idx_h2o ) + col_dry ( icol , ilay )) end do end do end do end subroutine compute_tau_rayleigh ! ---------------------------------------------------------- subroutine compute_Planck_source ( & ncol , nlay , nbnd , ngpt , & nflav , neta , npres , ntemp , nPlanckTemp ,& tlay , tlev , tsfc , sfc_lay , & fmajor , jeta , tropo , jtemp , jpress , & gpoint_bands , band_lims_gpt , & pfracin , temp_ref_min , totplnk_delta , totplnk , gpoint_flavor , & sfc_src , lay_src , lev_src_inc , lev_src_dec , sfc_source_Jac ) bind ( C , name = \"compute_Planck_source\" ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: nflav , neta , npres , ntemp , nPlanckTemp real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: tlay real ( wp ), dimension ( ncol , nlay + 1 ), intent ( in ) :: tlev real ( wp ), dimension ( ncol ), intent ( in ) :: tsfc integer , intent ( in ) :: sfc_lay ! Interpolation variables real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress ! Table-specific integer , dimension ( ngpt ), intent ( in ) :: gpoint_bands ! start and end g-point for each band integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), intent ( in ) :: temp_ref_min , totplnk_delta real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: pfracin real ( wp ), dimension ( nPlanckTemp , nbnd ), intent ( in ) :: totplnk integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: sfc_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: lay_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: lev_src_inc , lev_src_dec real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: sfc_source_Jac ! ----------------- ! local real ( wp ), parameter :: delta_Tsurf = 1.0_wp integer :: ilay , icol , igpt , ibnd , itropo , iflav integer :: gptS , gptE real ( wp ), dimension ( 2 ), parameter :: one = [ 1._wp , 1._wp ] real ( wp ) :: pfrac real ( wp ) :: planck_function_1 , planck_function_2 ! ----------------- !$acc        data copyin(   tlay,tlev,tsfc,fmajor,jeta,tropo,jtemp,jpress,gpoint_bands,pfracin,totplnk,gpoint_flavor) & !$acc             copyout(  sfc_src,lay_src,lev_src_inc,lev_src_dec,sfc_source_Jac) !$omp target data map(   to:tlay,tlev,tsfc,fmajor,jeta,tropo,jtemp,jpress,gpoint_bands,pfracin,totplnk,gpoint_flavor) & !$omp             map(from: sfc_src,lay_src,lev_src_inc,lev_src_dec,sfc_source_Jac) ! Calculation of fraction of band's Planck irradiance associated with each g-point !$acc parallel loop tile(128,2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol !$acc loop seq do igpt = 1 , ngpt ibnd = gpoint_bands ( igpt ) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) !WS moved itropo inside loop for GPU iflav = gpoint_flavor ( itropo , igpt ) !eta interpolation depends on band's flavor pfrac = & ! interpolation in temperature, pressure, and eta interpolate3D ( one , fmajor (:,:,:, icol , ilay , iflav ), pfracin , & igpt , jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay ), jpress ( icol , ilay ) + itropo ) ! Compute layer source irradiance for g-point, equals band irradiance x fraction for g-point planck_function_1 = interpolate1D ( tlay ( icol , ilay ), temp_ref_min , totplnk_delta , totplnk (:, ibnd )) lay_src ( icol , ilay , igpt ) = pfrac * planck_function_1 ! Compute layer source irradiance for g-point, equals band irradiance x fraction for g-point planck_function_1 = interpolate1D ( tlev ( icol , ilay ), temp_ref_min , totplnk_delta , totplnk (:, ibnd )) planck_function_2 = interpolate1D ( tlev ( icol , ilay + 1 ), temp_ref_min , totplnk_delta , totplnk (:, ibnd )) lev_src_dec ( icol , ilay , igpt ) = pfrac * planck_function_1 lev_src_inc ( icol , ilay , igpt ) = pfrac * planck_function_2 if ( ilay == sfc_lay ) then planck_function_1 = interpolate1D ( tsfc ( icol ) , temp_ref_min , totplnk_delta , totplnk (:, ibnd )) planck_function_2 = interpolate1D ( tsfc ( icol ) + delta_Tsurf , temp_ref_min , totplnk_delta , totplnk (:, ibnd )) sfc_src ( icol , igpt ) = pfrac * planck_function_1 sfc_source_Jac ( icol , igpt ) = pfrac * ( planck_function_2 - planck_function_1 ) end if end do ! igpt end do ! icol end do ! ilay !$acc end        data !$omp end target data end subroutine compute_Planck_source ! ---------------------------------------------------------- ! ! One dimensional interpolation ! function interpolate1D ( val , offset , delta , table ) result ( res ) !$acc routine seq !$omp declare target ! input real ( wp ), intent ( in ) :: val , & ! axis value at which to evaluate table offset , & ! minimum of table axis delta ! step size of table axis real ( wp ), dimension (:), & intent ( in ) :: table ! dimensions (axis, values) ! output real ( wp ) :: res ! local real ( wp ) :: val0 ! fraction index adjusted by offset and delta integer :: index ! index term real ( wp ) :: frac ! fractional term ! ------------------------------------- val0 = ( val - offset ) / delta frac = val0 - int ( val0 ) ! get fractional part index = min ( size ( table , dim = 1 ) - 1 , max ( 1 , int ( val0 ) + 1 )) ! limit the index range res = table ( index ) + frac * ( table ( index + 1 ) - table ( index )) end function interpolate1D ! ------------ !   This function returns a single value from a subset (in gpoint) of the k table ! function interpolate2D ( fminor , k , igpt , jeta , jtemp ) result ( res ) !$acc routine seq !$omp declare target real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: fminor ! interpolation fractions for minor species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference temperature level real ( wp ), dimension (:,:,:), intent ( in ) :: k ! (g-point, eta, temp) integer , intent ( in ) :: igpt , jtemp ! interpolation index for temperature integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) real ( wp ) :: res ! the result res = & fminor ( 1 , 1 ) * k ( jtemp , jeta ( 1 ) , igpt ) + & fminor ( 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , igpt ) + & fminor ( 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , igpt ) + & fminor ( 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , igpt ) end function interpolate2D ! ---------------------------------------------------------- ! interpolation in temperature, pressure, and eta function interpolate3D ( scaling , fmajor , k , igpt , jeta , jtemp , jpress ) result ( res ) !$acc routine seq !$omp declare target real ( wp ), dimension ( 2 ), intent ( in ) :: scaling real ( wp ), dimension ( 2 , 2 , 2 ), intent ( in ) :: fmajor ! interpolation fractions for major species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference pressure level ! index(3) : reference temperature level real ( wp ), dimension (:,:,:,:), intent ( in ) :: k ! (gpt, eta,temp,press) integer , intent ( in ) :: igpt integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) integer , intent ( in ) :: jtemp ! interpolation index for temperature integer , intent ( in ) :: jpress ! interpolation index for pressure real ( wp ) :: res ! the result ! each code block is for a different reference temperature res = & scaling ( 1 ) * & ( fmajor ( 1 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress , igpt ) ) + & scaling ( 2 ) * & ( fmajor ( 1 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress , igpt ) ) end function interpolate3D ! ---------------------------------------------------------- ! ! In-house subroutine for handling minloc and maxloc for ! compilers which do not support GPU versions ! subroutine minmaxloc ( i , mask , a , minl , maxl ) implicit none !$acc routine seq !$omp declare target integer :: i , minl , maxl logical ( wl ) :: mask (:,:) real ( wp ) :: a (:,:) integer :: j , n real ( wp ) :: aij , amax , amin n = size ( a , 2 ) amax = - huge ( amax ) amin = huge ( amin ) do j = 1 , n aij = a ( i , j ) if ( mask ( i , j )) then if ( aij . lt . amin ) then amin = aij minl = j end if else if ( aij . gt . amax ) then amax = aij maxl = j end if end if end do end subroutine ! ---------------------------------------------------------- end module mo_gas_optics_kernels","tags":"","loc":"sourcefile/mo_gas_optics_kernels.f90.html"},{"title":"mo_rrtmgp_util_reorder_kernels.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rrtmgp_util_reorder_kernels.f90~~EfferentGraph sourcefile~mo_rrtmgp_util_reorder_kernels.f90 mo_rrtmgp_util_reorder_kernels.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rrtmgp_util_reorder_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_rrtmgp_util_reorder_kernels.f90~~AfferentGraph sourcefile~mo_rrtmgp_util_reorder_kernels.f90 mo_rrtmgp_util_reorder_kernels.F90 sourcefile~mo_rrtmgp_util_reorder.f90 mo_rrtmgp_util_reorder.F90 sourcefile~mo_rrtmgp_util_reorder.f90->sourcefile~mo_rrtmgp_util_reorder_kernels.f90 sourcefile~mo_gas_optics_rrtmgp.f90 mo_gas_optics_rrtmgp.F90 sourcefile~mo_gas_optics_rrtmgp.f90->sourcefile~mo_rrtmgp_util_reorder.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rrtmgp_util_reorder_kernels Source Code mo_rrtmgp_util_reorder_kernels.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! Description: Kernels to permute arrays module mo_rrtmgp_util_reorder_kernels use mo_rte_kind , only : wp implicit none public contains ! ---------------------------------------------------------------------------- subroutine reorder_123x321_kernel ( d1 , d2 , d3 , array_in , array_out ) & bind ( C , name = \"reorder_123x321_kernel\" ) integer , intent ( in ) :: d1 , d2 , d3 real ( wp ), dimension ( d1 , d2 , d3 ), intent ( in ) :: array_in real ( wp ), dimension ( d3 , d2 , d1 ), intent ( out ) :: array_out integer :: i1 , i2 , i3 , i10 , i30 , i1diff , i3diff integer , parameter :: tile = 32 ! This kernel uses blocking to speed-up the transposition ! We read the data block by block (three outer loops) !  such that a block fits into fastest cache and the memory reads !  are resolved in the cache. The writes are contiguous here, so !  shouldn't be a problem. !  Tile size of 32x32 is empirical: big enough to read from the whole !  cache line, and small enough to fit into cache. Other numbers !  may give slightly better performance on different hardware. ! !$acc parallel vector_length(tile*tile) & !$acc&     copyout(array_out) & !$acc&     copyin(array_in) !$acc loop gang collapse(3) ! private(cache(:,:)) !$omp target teams distribute parallel do simd collapse(3) map(to:array_in) map(from:array_out) do i2 = 1 , d2 do i10 = 1 , d1 , tile do i30 = 1 , d3 , tile !$acc loop vector collapse(2) do i1diff = 0 , tile - 1 do i3diff = 0 , tile - 1 i1 = i10 + i1diff i3 = i30 + i3diff if ( i1 > d1 . or . i3 > d3 ) cycle array_out ( i3 , i2 , i1 ) = array_in ( i1 , i2 , i3 ) end do end do end do end do end do !$acc end parallel end subroutine reorder_123x321_kernel ! ---------------------------------------------------------------------------- end module mo_rrtmgp_util_reorder_kernels","tags":"","loc":"sourcefile/mo_rrtmgp_util_reorder_kernels.f90.html"},{"title":"mo_gas_optics_kernels.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_gas_optics_kernels.f90~2~~EfferentGraph sourcefile~mo_gas_optics_kernels.f90~2 mo_gas_optics_kernels.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_gas_optics_kernels.f90~2->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_gas_optics_kernels.f90~2->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_gas_optics_kernels Source Code mo_gas_optics_kernels.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2015,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! Description: Numeric calculations for gas optics. Absorption and Rayleigh optical depths, !   source functions. module mo_gas_optics_kernels use mo_rte_kind , only : wp , wl use mo_rte_util_array , only : zero_array implicit none public contains ! -------------------------------------------------------------------------------------- ! Compute interpolation coefficients ! for calculations of major optical depths, minor optical depths, Rayleigh, ! and Planck fractions subroutine interpolation ( & ncol , nlay , ngas , nflav , neta , npres , ntemp , & flavor , & press_ref_log , temp_ref , press_ref_log_delta , & temp_ref_min , temp_ref_delta , press_ref_trop_log , & vmr_ref , & play , tlay , col_gas , & jtemp , fmajor , fminor , col_mix , tropo , jeta , jpress ) bind ( C , name = \"interpolation\" ) ! input dimensions integer , intent ( in ) :: ncol , nlay integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , dimension ( 2 , nflav ), intent ( in ) :: flavor real ( wp ), dimension ( npres ), intent ( in ) :: press_ref_log real ( wp ), dimension ( ntemp ), intent ( in ) :: temp_ref real ( wp ), intent ( in ) :: press_ref_log_delta , & temp_ref_min , temp_ref_delta , & press_ref_trop_log real ( wp ), dimension ( 2 , 0 : ngas , ntemp ), intent ( in ) :: vmr_ref ! inputs from profile or parent function real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas ! outputs integer , dimension ( ncol , nlay ), intent ( out ) :: jtemp , jpress logical ( wl ), dimension ( ncol , nlay ), intent ( out ) :: tropo integer , dimension ( 2 , ncol , nlay , nflav ), intent ( out ) :: jeta real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( out ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( out ) :: fmajor real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( out ) :: fminor ! ----------------- ! local real ( wp ), dimension ( ncol , nlay ) :: ftemp , fpress ! interpolation fraction for temperature, pressure real ( wp ) :: locpress ! needed to find location in pressure grid real ( wp ) :: ratio_eta_half ! ratio of vmrs of major species that defines eta=0.5 ! for given flavor and reference temperature level real ( wp ) :: eta , feta ! binary_species_parameter, interpolation variable for eta real ( wp ) :: loceta ! needed to find location in eta grid real ( wp ) :: ftemp_term ! ----------------- ! local indexes integer :: icol , ilay , iflav , igases ( 2 ), itropo , itemp do ilay = 1 , nlay do icol = 1 , ncol ! index and factor for temperature interpolation jtemp ( icol , ilay ) = int (( tlay ( icol , ilay ) - ( temp_ref_min - temp_ref_delta )) / temp_ref_delta ) jtemp ( icol , ilay ) = min ( ntemp - 1 , max ( 1 , jtemp ( icol , ilay ))) ! limit the index range ftemp ( icol , ilay ) = ( tlay ( icol , ilay ) - temp_ref ( jtemp ( icol , ilay ))) / temp_ref_delta ! index and factor for pressure interpolation locpress = 1._wp + ( log ( play ( icol , ilay )) - press_ref_log ( 1 )) / press_ref_log_delta jpress ( icol , ilay ) = min ( npres - 1 , max ( 1 , int ( locpress ))) fpress ( icol , ilay ) = locpress - float ( jpress ( icol , ilay )) ! determine if in lower or upper part of atmosphere tropo ( icol , ilay ) = log ( play ( icol , ilay )) > press_ref_trop_log end do end do do iflav = 1 , nflav igases (:) = flavor (:, iflav ) do ilay = 1 , nlay do icol = 1 , ncol ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! loop over implemented combinations of major species do itemp = 1 , 2 ! compute interpolation fractions needed for lower, then upper reference temperature level ! compute binary species parameter (eta) for flavor and temperature and !  associated interpolation index and factors ratio_eta_half = vmr_ref ( itropo , igases ( 1 ),( jtemp ( icol , ilay ) + itemp - 1 )) / & vmr_ref ( itropo , igases ( 2 ),( jtemp ( icol , ilay ) + itemp - 1 )) col_mix ( itemp , icol , ilay , iflav ) = col_gas ( icol , ilay , igases ( 1 )) + ratio_eta_half * col_gas ( icol , ilay , igases ( 2 )) eta = merge ( col_gas ( icol , ilay , igases ( 1 )) / col_mix ( itemp , icol , ilay , iflav ), 0.5_wp , & col_mix ( itemp , icol , ilay , iflav ) > 2._wp * tiny ( col_mix )) loceta = eta * float ( neta - 1 ) jeta ( itemp , icol , ilay , iflav ) = min ( int ( loceta ) + 1 , neta - 1 ) feta = mod ( loceta , 1.0_wp ) ! compute interpolation fractions needed for minor species ! ftemp_term = (1._wp-ftemp(icol,ilay)) for itemp = 1, ftemp(icol,ilay) for itemp=2 ftemp_term = ( real ( 2 - itemp , wp ) + real ( 2 * itemp - 3 , wp ) * ftemp ( icol , ilay )) fminor ( 1 , itemp , icol , ilay , iflav ) = ( 1._wp - feta ) * ftemp_term fminor ( 2 , itemp , icol , ilay , iflav ) = feta * ftemp_term ! compute interpolation fractions needed for major species fmajor ( 1 , 1 , itemp , icol , ilay , iflav ) = ( 1._wp - fpress ( icol , ilay )) * fminor ( 1 , itemp , icol , ilay , iflav ) fmajor ( 2 , 1 , itemp , icol , ilay , iflav ) = ( 1._wp - fpress ( icol , ilay )) * fminor ( 2 , itemp , icol , ilay , iflav ) fmajor ( 1 , 2 , itemp , icol , ilay , iflav ) = fpress ( icol , ilay ) * fminor ( 1 , itemp , icol , ilay , iflav ) fmajor ( 2 , 2 , itemp , icol , ilay , iflav ) = fpress ( icol , ilay ) * fminor ( 2 , itemp , icol , ilay , iflav ) end do ! reference temperatures end do ! icol end do ! ilay end do ! iflav end subroutine interpolation ! -------------------------------------------------------------------------------------- ! ! Compute minor and major species opitcal depth from pre-computed interpolation coefficients !   (jeta,jtemp,jpress) ! subroutine compute_tau_absorption ( & ncol , nlay , nbnd , ngpt , & ! dimensions ngas , nflav , neta , npres , ntemp , & nminorlower , nminorklower , & ! number of minor contributors, total num absorption coeffs nminorupper , nminorkupper , & idx_h2o , & gpoint_flavor , & band_lims_gpt , & kmajor , & kminor_lower , & kminor_upper , & minor_limits_gpt_lower , & minor_limits_gpt_upper , & minor_scales_with_density_lower , & minor_scales_with_density_upper , & scale_by_complement_lower , & scale_by_complement_upper , & idx_minor_lower , & idx_minor_upper , & idx_minor_scaling_lower , & idx_minor_scaling_upper , & kminor_start_lower , & kminor_start_upper , & tropo , & col_mix , fmajor , fminor , & play , tlay , col_gas , & jeta , jtemp , jpress , & tau ) bind ( C , name = \"compute_tau_absorption\" ) ! --------------------- ! input dimensions integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , intent ( in ) :: nminorlower , nminorklower , nminorupper , nminorkupper integer , intent ( in ) :: idx_h2o ! --------------------- ! inputs from object integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: kmajor real ( wp ), dimension ( ntemp , neta , nminorklower ), intent ( in ) :: kminor_lower real ( wp ), dimension ( ntemp , neta , nminorkupper ), intent ( in ) :: kminor_upper integer , dimension ( 2 , nminorlower ), intent ( in ) :: minor_limits_gpt_lower integer , dimension ( 2 , nminorupper ), intent ( in ) :: minor_limits_gpt_upper logical ( wl ), dimension ( nminorlower ), intent ( in ) :: minor_scales_with_density_lower logical ( wl ), dimension ( nminorupper ), intent ( in ) :: minor_scales_with_density_upper logical ( wl ), dimension ( nminorlower ), intent ( in ) :: scale_by_complement_lower logical ( wl ), dimension ( nminorupper ), intent ( in ) :: scale_by_complement_upper integer , dimension ( nminorlower ), intent ( in ) :: idx_minor_lower integer , dimension ( nminorupper ), intent ( in ) :: idx_minor_upper integer , dimension ( nminorlower ), intent ( in ) :: idx_minor_scaling_lower integer , dimension ( nminorupper ), intent ( in ) :: idx_minor_scaling_upper integer , dimension ( nminorlower ), intent ( in ) :: kminor_start_lower integer , dimension ( nminorupper ), intent ( in ) :: kminor_start_upper logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo ! --------------------- ! inputs from profile or parent function real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay ! pressure and temperature real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp integer , dimension ( ncol , nlay ), intent ( in ) :: jpress ! --------------------- ! output - optical depth real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! --------------------- ! Local variables ! logical :: top_at_1 integer , dimension ( ncol , 2 ) :: itropo_lower , itropo_upper ! ---------------------------------------------------------------- ! --------------------- ! Layer limits of upper, lower atmospheres ! --------------------- top_at_1 = play ( 1 , 1 ) < play ( 1 , nlay ) if ( top_at_1 ) then itropo_lower (:, 1 ) = minloc ( play , dim = 2 , mask = tropo ) itropo_lower (:, 2 ) = nlay itropo_upper (:, 1 ) = 1 itropo_upper (:, 2 ) = maxloc ( play , dim = 2 , mask = (. not . tropo )) else itropo_lower (:, 1 ) = 1 itropo_lower (:, 2 ) = minloc ( play , dim = 2 , mask = tropo ) itropo_upper (:, 1 ) = maxloc ( play , dim = 2 , mask = (. not . tropo )) itropo_upper (:, 2 ) = nlay end if ! --------------------- ! Major Species ! --------------------- call gas_optical_depths_major ( & ncol , nlay , nbnd , ngpt , & ! dimensions nflav , neta , npres , ntemp , & gpoint_flavor , & band_lims_gpt , & kmajor , & col_mix , fmajor , & jeta , tropo , jtemp , jpress , & tau ) ! --------------------- ! Minor Species - lower ! --------------------- call gas_optical_depths_minor ( & ncol , nlay , ngpt , & ! dimensions ngas , nflav , ntemp , neta , & nminorlower , nminorklower , & idx_h2o , & gpoint_flavor ( 1 ,:), & kminor_lower , & minor_limits_gpt_lower , & minor_scales_with_density_lower , & scale_by_complement_lower , & idx_minor_lower , & idx_minor_scaling_lower , & kminor_start_lower , & play , tlay , & col_gas , fminor , jeta , & itropo_lower , jtemp , & tau ) ! --------------------- ! Minor Species - upper ! --------------------- call gas_optical_depths_minor ( & ncol , nlay , ngpt , & ! dimensions ngas , nflav , ntemp , neta , & nminorupper , nminorkupper , & idx_h2o , & gpoint_flavor ( 2 ,:), & kminor_upper , & minor_limits_gpt_upper , & minor_scales_with_density_upper , & scale_by_complement_upper , & idx_minor_upper , & idx_minor_scaling_upper , & kminor_start_upper , & play , tlay , & col_gas , fminor , jeta , & itropo_upper , jtemp , & tau ) end subroutine compute_tau_absorption ! -------------------------------------------------------------------------------------- ! -------------------------------------------------------------------------------------- ! ! compute minor species optical depths ! subroutine gas_optical_depths_major ( ncol , nlay , nbnd , ngpt ,& nflav , neta , npres , ntemp , & ! dimensions gpoint_flavor , band_lims_gpt , & ! inputs from object kmajor , & col_mix , fmajor , & jeta , tropo , jtemp , jpress , & ! local input tau ) bind ( C , name = \"gas_optical_depths_major\" ) ! input dimensions integer , intent ( in ) :: ncol , nlay , nbnd , ngpt , nflav , neta , npres , ntemp ! dimensions ! inputs from object integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: kmajor ! inputs from profile or parent function real ( wp ), dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: col_mix real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress ! outputs real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! ----------------- ! local variables real ( wp ) :: tau_major ( ngpt ) ! major species optical depth ! local index integer :: icol , ilay , iflav , ibnd , itropo integer :: gptS , gptE ! optical depth calculation for major species do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) iflav = gpoint_flavor ( itropo , gptS ) !eta interpolation depends on band's flavor tau_major ( gptS : gptE ) = & ! interpolation in temperature, pressure, and eta interpolate3D_byflav ( col_mix (:, icol , ilay , iflav ), & fmajor (:,:,:, icol , ilay , iflav ), kmajor , & band_lims_gpt ( 1 , ibnd ), band_lims_gpt ( 2 , ibnd ), & jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay ), jpress ( icol , ilay ) + itropo ) tau ( icol , ilay , gptS : gptE ) = tau ( icol , ilay , gptS : gptE ) + tau_major ( gptS : gptE ) end do end do end do end subroutine gas_optical_depths_major ! ---------------------------------------------------------- ! ! compute minor species optical depths ! subroutine gas_optical_depths_minor ( ncol , nlay , ngpt , & ngas , nflav , ntemp , neta , & nminor , nminork , & idx_h2o , & gpt_flv , & kminor , & minor_limits_gpt , & minor_scales_with_density , & scale_by_complement , & idx_minor , idx_minor_scaling , & kminor_start , & play , tlay , & col_gas , fminor , jeta , & layer_limits , jtemp , & tau ) bind ( C , name = \"gas_optical_depths_minor\" ) integer , intent ( in ) :: ncol , nlay , ngpt integer , intent ( in ) :: ngas , nflav integer , intent ( in ) :: ntemp , neta , nminor , nminork integer , intent ( in ) :: idx_h2o integer , dimension ( ngpt ), intent ( in ) :: gpt_flv real ( wp ), dimension ( ntemp , neta , nminork ), intent ( in ) :: kminor integer , dimension ( 2 , nminor ), intent ( in ) :: minor_limits_gpt logical ( wl ), dimension ( nminor ), intent ( in ) :: minor_scales_with_density logical ( wl ), dimension ( nminor ), intent ( in ) :: scale_by_complement integer , dimension ( nminor ), intent ( in ) :: kminor_start integer , dimension ( nminor ), intent ( in ) :: idx_minor , idx_minor_scaling real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: play , tlay real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta integer , dimension ( ncol , 2 ), intent ( in ) :: layer_limits integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( inout ) :: tau ! ----------------- ! local variables real ( wp ), parameter :: PaTohPa = 0.01_wp real ( wp ) :: vmr_fact , dry_fact ! conversion from column abundance to dry vol. mixing ratio; real ( wp ) :: scaling ! optical depth integer :: icol , ilay , iflav , imnr integer :: gptS , gptE real ( wp ), dimension ( ngpt ) :: tau_minor ! ----------------- ! ! Guard against layer limits being 0 -- that means don't do anything i.e. there are no !   layers with pressures in the upper or lower atmosphere respectively ! First check skips the routine entirely if all columns are out of bounds... ! if ( any ( layer_limits (:, 1 ) > 0 )) then do imnr = 1 , size ( scale_by_complement , dim = 1 ) ! loop over minor absorbers in each band do icol = 1 , ncol ! ! This check skips individual columns with no pressures in range ! if ( layer_limits ( icol , 1 ) > 0 ) then do ilay = layer_limits ( icol , 1 ), layer_limits ( icol , 2 ) ! ! Scaling of minor gas absortion coefficient begins with column amount of minor gas ! scaling = col_gas ( icol , ilay , idx_minor ( imnr )) ! ! Density scaling (e.g. for h2o continuum, collision-induced absorption) ! if ( minor_scales_with_density ( imnr )) then ! ! NOTE: P needed in hPa to properly handle density scaling. ! scaling = scaling * ( PaTohPa * play ( icol , ilay ) / tlay ( icol , ilay )) if ( idx_minor_scaling ( imnr ) > 0 ) then ! there is a second gas that affects this gas's absorption vmr_fact = 1._wp / col_gas ( icol , ilay , 0 ) dry_fact = 1._wp / ( 1._wp + col_gas ( icol , ilay , idx_h2o ) * vmr_fact ) ! scale by density of special gas if ( scale_by_complement ( imnr )) then ! scale by densities of all gases but the special one scaling = scaling * ( 1._wp - col_gas ( icol , ilay , idx_minor_scaling ( imnr )) * vmr_fact * dry_fact ) else scaling = scaling * ( col_gas ( icol , ilay , idx_minor_scaling ( imnr )) * vmr_fact * dry_fact ) endif endif endif ! ! Interpolation of absorption coefficient and calculation of optical depth ! ! Which gpoint range does this minor gas affect? gptS = minor_limits_gpt ( 1 , imnr ) gptE = minor_limits_gpt ( 2 , imnr ) iflav = gpt_flv ( gptS ) tau_minor ( gptS : gptE ) = scaling * & interpolate2D_byflav ( fminor (:,:, icol , ilay , iflav ), & kminor , & kminor_start ( imnr ), kminor_start ( imnr ) + ( gptE - gptS ), & jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay )) tau ( icol , ilay , gptS : gptE ) = tau ( icol , ilay , gptS : gptE ) + tau_minor ( gptS : gptE ) enddo end if enddo enddo end if end subroutine gas_optical_depths_minor ! ---------------------------------------------------------- ! ! compute Rayleigh scattering optical depths ! subroutine compute_tau_rayleigh ( ncol , nlay , nbnd , ngpt , & ngas , nflav , neta , npres , ntemp , & gpoint_flavor , band_lims_gpt , & krayl , & idx_h2o , col_dry , col_gas , & fminor , jeta , tropo , jtemp , & tau_rayleigh ) bind ( C , name = \"compute_tau_rayleigh\" ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: ngas , nflav , neta , npres , ntemp integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), dimension ( ntemp , neta , ngpt , 2 ), intent ( in ) :: krayl integer , intent ( in ) :: idx_h2o real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: col_dry real ( wp ), dimension ( ncol , nlay , 0 : ngas ), intent ( in ) :: col_gas real ( wp ), dimension ( 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fminor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp ! outputs real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: tau_rayleigh ! ----------------- ! local variables real ( wp ) :: k ( ngpt ) ! rayleigh scattering coefficient integer :: icol , ilay , iflav , ibnd , igpt , gptS , gptE integer :: itropo ! ----------------- do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol itropo = merge ( 1 , 2 , tropo ( icol , ilay )) ! itropo = 1 lower atmosphere;itropo = 2 upper atmosphere iflav = gpoint_flavor ( itropo , gptS ) !eta interpolation depends on band's flavor k ( gptS : gptE ) = interpolate2D_byflav ( fminor (:,:, icol , ilay , iflav ), & krayl (:,:,:, itropo ), & gptS , gptE , jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay )) tau_rayleigh ( icol , ilay , gptS : gptE ) = k ( gptS : gptE ) * & ( col_gas ( icol , ilay , idx_h2o ) + col_dry ( icol , ilay )) end do end do end do end subroutine compute_tau_rayleigh ! ---------------------------------------------------------- subroutine compute_Planck_source ( & ncol , nlay , nbnd , ngpt , & nflav , neta , npres , ntemp , nPlanckTemp ,& tlay , tlev , tsfc , sfc_lay , & fmajor , jeta , tropo , jtemp , jpress , & gpoint_bands , band_lims_gpt , & pfracin , temp_ref_min , totplnk_delta , totplnk , gpoint_flavor , & sfc_src , lay_src , lev_src_inc , lev_src_dec , sfc_source_Jac ) bind ( C , name = \"compute_Planck_source\" ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , intent ( in ) :: nflav , neta , npres , ntemp , nPlanckTemp real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: tlay real ( wp ), dimension ( ncol , nlay + 1 ), intent ( in ) :: tlev real ( wp ), dimension ( ncol ), intent ( in ) :: tsfc integer , intent ( in ) :: sfc_lay ! Interpolation variables real ( wp ), dimension ( 2 , 2 , 2 , ncol , nlay , nflav ), intent ( in ) :: fmajor integer , dimension ( 2 , ncol , nlay , nflav ), intent ( in ) :: jeta logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: tropo integer , dimension ( ncol , nlay ), intent ( in ) :: jtemp , jpress ! Table-specific integer , dimension ( ngpt ), intent ( in ) :: gpoint_bands ! start and end g-point for each band integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt ! start and end g-point for each band real ( wp ), intent ( in ) :: temp_ref_min , totplnk_delta real ( wp ), dimension ( ntemp , neta , npres + 1 , ngpt ), intent ( in ) :: pfracin real ( wp ), dimension ( nPlanckTemp , nbnd ), intent ( in ) :: totplnk integer , dimension ( 2 , ngpt ), intent ( in ) :: gpoint_flavor real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: sfc_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: lay_src real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: lev_src_inc , lev_src_dec real ( wp ), dimension ( ncol , ngpt ), intent ( out ) :: sfc_source_Jac ! ----------------- ! local real ( wp ), parameter :: delta_Tsurf = 1.0_wp integer :: ilay , icol , igpt , ibnd , itropo , iflav integer :: gptS , gptE real ( wp ), dimension ( 2 ), parameter :: one = [ 1._wp , 1._wp ] real ( wp ) :: pfrac ( ncol , nlay , ngpt ) real ( wp ) :: planck_function ( ncol , nlay + 1 , nbnd ) ! ----------------- ! Calculation of fraction of band's Planck irradiance associated with each g-point do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do ilay = 1 , nlay do icol = 1 , ncol ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere itropo = merge ( 1 , 2 , tropo ( icol , ilay )) iflav = gpoint_flavor ( itropo , gptS ) !eta interpolation depends on band's flavor pfrac ( icol , ilay , gptS : gptE ) = & ! interpolation in temp-m64 -O3 -g -traceback -heap-arrays -assume ! realloc_lhs -extend-source 132erature, pressure, and eta interpolate3D_byflav ( one , fmajor (:,:,:, icol , ilay , iflav ), pfracin , & band_lims_gpt ( 1 , ibnd ), band_lims_gpt ( 2 , ibnd ), & jeta (:, icol , ilay , iflav ), jtemp ( icol , ilay ), jpress ( icol , ilay ) + itropo ) end do ! column end do ! layer end do ! band ! ! Planck function by band for the surface ! Compute surface source irradiance for g-point, equals band irradiance x fraction for g-point ! do icol = 1 , ncol planck_function ( icol , 1 , 1 : nbnd ) = interpolate1D ( tsfc ( icol ), temp_ref_min , totplnk_delta , totplnk ) planck_function ( icol , 2 , 1 : nbnd ) = interpolate1D ( tsfc ( icol ) + delta_Tsurf , temp_ref_min , totplnk_delta , totplnk ) ! ! Map to g-points ! do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do igpt = gptS , gptE sfc_src ( icol , igpt ) = pfrac ( icol , sfc_lay , igpt ) * planck_function ( icol , 1 , ibnd ) sfc_source_Jac ( icol , igpt ) = pfrac ( icol , sfc_lay , igpt ) * & ( planck_function ( icol , 2 , ibnd ) - planck_function ( icol , 1 , ibnd )) end do end do end do !icol do ilay = 1 , nlay do icol = 1 , ncol ! Compute layer source irradiance for g-point, equals band irradiance x fraction for g-point planck_function ( icol , ilay , 1 : nbnd ) = interpolate1D ( tlay ( icol , ilay ), temp_ref_min , totplnk_delta , totplnk ) end do end do ! ! Map to g-points ! do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do igpt = gptS , gptE do ilay = 1 , nlay do icol = 1 , ncol lay_src ( icol , ilay , igpt ) = pfrac ( icol , ilay , igpt ) * planck_function ( icol , ilay , ibnd ) end do end do end do end do ! compute level source irradiances for each g-point, one each for upward and downward paths do ilay = 1 , nlay do icol = 1 , ncol planck_function ( icol , 1 , 1 : nbnd ) = interpolate1D ( tlev ( icol , 1 ), temp_ref_min , totplnk_delta , totplnk ) planck_function ( icol , ilay + 1 , 1 : nbnd ) = interpolate1D ( tlev ( icol , ilay + 1 ), temp_ref_min , totplnk_delta , totplnk ) end do end do ! ! Map to g-points ! do ibnd = 1 , nbnd gptS = band_lims_gpt ( 1 , ibnd ) gptE = band_lims_gpt ( 2 , ibnd ) do igpt = gptS , gptE do ilay = 1 , nlay do icol = 1 , ncol lev_src_inc ( icol , ilay , igpt ) = pfrac ( icol , ilay , igpt ) * planck_function ( icol , ilay + 1 , ibnd ) lev_src_dec ( icol , ilay , igpt ) = pfrac ( icol , ilay , igpt ) * planck_function ( icol , ilay , ibnd ) end do end do end do end do end subroutine compute_Planck_source ! ---------------------------------------------------------- ! ! One dimensional interpolation -- return all values along second table dimension ! pure function interpolate1D ( val , offset , delta , table ) result ( res ) ! input real ( wp ), intent ( in ) :: val , & ! axis value at which to evaluate table offset , & ! minimum of table axis delta ! step size of table axis real ( wp ), dimension (:,:), & intent ( in ) :: table ! dimensions (axis, values) ! output real ( wp ), dimension ( size ( table , dim = 2 )) :: res ! local real ( wp ) :: val0 ! fraction index adjusted by offset and delta integer :: index ! index term real ( wp ) :: frac ! fractional term ! ------------------------------------- val0 = ( val - offset ) / delta frac = val0 - int ( val0 ) ! get fractional part index = min ( size ( table , dim = 1 ) - 1 , max ( 1 , int ( val0 ) + 1 )) ! limit the index range res (:) = table ( index ,:) + frac * ( table ( index + 1 ,:) - table ( index ,:)) end function interpolate1D ! ---------------------------------------------------------------------------------------- !   This function returns a single value from a subset (in gpoint) of the k table ! pure function interpolate2D ( fminor , k , igpt , jeta , jtemp ) result ( res ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: fminor ! interpolation fractions for minor species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference temperature level real ( wp ), dimension (:,:,:), intent ( in ) :: k ! (g-point, eta, temp) integer , intent ( in ) :: igpt , jtemp ! interpolation index for temperature integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) real ( wp ) :: res ! the result res = & fminor ( 1 , 1 ) * k ( jtemp , jeta ( 1 ) , igpt ) + & fminor ( 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , igpt ) + & fminor ( 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , igpt ) + & fminor ( 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , igpt ) end function interpolate2D ! ---------------------------------------------------------- !   This function returns a range of values from a subset (in gpoint) of the k table ! pure function interpolate2D_byflav ( fminor , k , gptS , gptE , jeta , jtemp ) result ( res ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: fminor ! interpolation fractions for minor species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference temperature level real ( wp ), dimension (:,:,:), intent ( in ) :: k ! (g-point, eta, temp) integer , intent ( in ) :: gptS , gptE , jtemp ! interpolation index for temperature integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) real ( wp ), dimension ( gptE - gptS + 1 ) :: res ! the result ! Local variable integer :: igpt ! each code block is for a different reference temperature do igpt = 1 , gptE - gptS + 1 res ( igpt ) = fminor ( 1 , 1 ) * k ( jtemp , jeta ( 1 ) , gptS + igpt - 1 ) + & fminor ( 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , gptS + igpt - 1 ) + & fminor ( 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , gptS + igpt - 1 ) + & fminor ( 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , gptS + igpt - 1 ) end do end function interpolate2D_byflav ! ---------------------------------------------------------- ! interpolation in temperature, pressure, and eta pure function interpolate3D ( scaling , fmajor , k , igpt , jeta , jtemp , jpress ) result ( res ) real ( wp ), dimension ( 2 ), intent ( in ) :: scaling real ( wp ), dimension ( 2 , 2 , 2 ), intent ( in ) :: fmajor ! interpolation fractions for major species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference pressure level ! index(3) : reference temperature level real ( wp ), dimension (:,:,:,:), intent ( in ) :: k ! (gpt, eta,temp,press) integer , intent ( in ) :: igpt integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) integer , intent ( in ) :: jtemp ! interpolation index for temperature integer , intent ( in ) :: jpress ! interpolation index for pressure real ( wp ) :: res ! the result ! each code block is for a different reference temperature res = & scaling ( 1 ) * & ( fmajor ( 1 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress , igpt ) ) + & scaling ( 2 ) * & ( fmajor ( 1 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress - 1 , igpt ) + & fmajor ( 2 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress - 1 , igpt ) + & fmajor ( 1 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress , igpt ) + & fmajor ( 2 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress , igpt ) ) end function interpolate3D ! ---------------------------------------------------------- pure function interpolate3D_byflav ( scaling , fmajor , k , gptS , gptE , jeta , jtemp , jpress ) result ( res ) real ( wp ), dimension ( 2 ), intent ( in ) :: scaling real ( wp ), dimension ( 2 , 2 , 2 ), intent ( in ) :: fmajor ! interpolation fractions for major species ! index(1) : reference eta level (temperature dependent) ! index(2) : reference pressure level ! index(3) : reference temperature level real ( wp ), dimension (:,:,:,:), intent ( in ) :: k ! (gpt, eta,temp,press) integer , intent ( in ) :: gptS , gptE integer , dimension ( 2 ), intent ( in ) :: jeta ! interpolation index for binary species parameter (eta) integer , intent ( in ) :: jtemp ! interpolation index for temperature integer , intent ( in ) :: jpress ! interpolation index for pressure real ( wp ), dimension ( gptE - gptS + 1 ) :: res ! the result ! Local variable integer :: igpt ! each code block is for a different reference temperature do igpt = 1 , gptE - gptS + 1 res ( igpt ) = & scaling ( 1 ) * & ( fmajor ( 1 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress - 1 , gptS + igpt - 1 ) + & fmajor ( 2 , 1 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress - 1 , gptS + igpt - 1 ) + & fmajor ( 1 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) , jpress , gptS + igpt - 1 ) + & fmajor ( 2 , 2 , 1 ) * k ( jtemp , jeta ( 1 ) + 1 , jpress , gptS + igpt - 1 ) ) + & scaling ( 2 ) * & ( fmajor ( 1 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress - 1 , gptS + igpt - 1 ) + & fmajor ( 2 , 1 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress - 1 , gptS + igpt - 1 ) + & fmajor ( 1 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) , jpress , gptS + igpt - 1 ) + & fmajor ( 2 , 2 , 2 ) * k ( jtemp + 1 , jeta ( 2 ) + 1 , jpress , gptS + igpt - 1 ) ) end do end function interpolate3D_byflav end module mo_gas_optics_kernels","tags":"","loc":"sourcefile/mo_gas_optics_kernels.f90~2.html"},{"title":"mo_heating_rates.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_heating_rates.f90~~EfferentGraph sourcefile~mo_heating_rates.f90 mo_heating_rates.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rrtmgp_constants.f90 mo_rrtmgp_constants.F90 sourcefile~mo_heating_rates.f90->sourcefile~mo_rrtmgp_constants.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rrtmgp_constants.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_heating_rates Source Code mo_heating_rates.F90 Source Code ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2016-2017,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! Description:  Heating rate calculation module mo_heating_rates use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_extents use mo_rte_util_array , only : extents_are use mo_rrtmgp_constants , only : cp_dry , grav ! Only needed for heating rate calculation implicit none private public :: compute_heating_rate contains ! Compute heating rate from fluxes ! heating rate H [K/sec] = 1/(rho cp) d f_net/d z ! Here use hydrostatic equation for density and heat capacity of dry air function compute_heating_rate ( flux_up , flux_dn , plev , heating_rate ) result ( error_msg ) real ( wp ), dimension (:,:), intent ( in ) :: flux_up , flux_dn , & !< fluxes at interfaces [W/m2] plev !< pressure at interfaces [Pa] real ( wp ), dimension (:,:), intent ( out ) :: heating_rate !< heating rate within layer [K/sec] character ( len = 128 ) :: error_msg ! --------- integer :: ncol , nlay , ilay ! --------- error_msg = \"\" ncol = size ( flux_up , 1 ) nlay = size ( flux_up , 2 ) - 1 if ( check_extents ) then if (. not . extents_are ( flux_dn , ncol , nlay + 1 )) & error_msg = \"heating_rate: flux_dn array inconsistently sized.\" if (. not . extents_are ( plev , ncol , nlay + 1 )) & error_msg = \"heating_rate: plev array inconsistently sized.\" if (. not . extents_are ( heating_rate , ncol , nlay )) & error_msg = \"heating_rate: heating_rate array inconsistently sized.\" if ( error_msg /= \"\" ) return end if do ilay = 1 , nlay heating_rate ( 1 : ncol , ilay ) = ( flux_up ( 1 : ncol , ilay + 1 ) - flux_up ( 1 : ncol , ilay ) - & flux_dn ( 1 : ncol , ilay + 1 ) + flux_dn ( 1 : ncol , ilay )) * & grav / ( cp_dry * ( plev ( 1 : ncol , ilay + 1 ) - plev ( 1 : ncol , ilay ))) end do end function compute_heating_rate end module mo_heating_rates","tags":"","loc":"sourcefile/mo_heating_rates.f90.html"},{"title":"mo_compute_bc.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_compute_bc.f90~~EfferentGraph sourcefile~mo_compute_bc.f90 mo_compute_bc.F90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_compute_bc.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_solver_kernels.f90 mo_rte_solver_kernels.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_solver_kernels.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_solver_kernels.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_broadband_kernels.f90 mo_fluxes_broadband_kernels.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_fluxes_broadband_kernels.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rrtmgp_util_string.f90 mo_rrtmgp_util_string.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_solver_kernels.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_solver_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_broadband_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_compute_bc Source Code mo_compute_bc.F90 Source Code module mo_compute_bc ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! This modules lets users determine upper boundary condition by !   computing the spectrally-resolved fluxes at the bottom of an isothermal layer !   extending from the lowest supplied pressure to the minimum pressure allowed by !   RRTMGP. ! This is only sensible if the user's domain extends nearly to the top of the atmosphere. ! Adding this thin extra layer makes heating rates in the top-most layer more reasonable !   especially in the longwave ! The boundary condition is on diffuse flux in the LW and direct flux in the SW ! ------------------------------------------------------------------------------------------------- use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_extents use mo_rte_util_array , only : extents_are use mo_source_functions , only : ty_source_func_lw use mo_gas_concentrations , only : ty_gas_concs use mo_optical_props , only : ty_optical_props , ty_optical_props_arry , & ty_optical_props_1scl , ty_optical_props_2str use mo_gas_optics , only : ty_gas_optics use mo_fluxes , only : ty_fluxes use mo_rte_lw , only : rte_lw use mo_rte_sw , only : rte_sw implicit none private public :: compute_bc ! ! Extend ty_fluxes to report spectrally-resolved downwelling flux at a single layer ! type , extends ( ty_fluxes ) :: ty_fluxes_1lev real ( wp ), dimension (:,:), pointer :: gpt_flux_dn => NULL () ! (ncol, nlev, nband) contains procedure :: reduce => reduce_1lev procedure :: are_desired => are_desired_1lev end type ty_fluxes_1lev contains !-------------------------------------------------------------------------------------------------------------------- ! ! The arguments to this routine follow those to the gas_optics routines ! function compute_bc ( k_dist , & play , plev , tlay , gas_concs , & flux_bc , mu0 ) result ( error_msg ) class ( ty_gas_optics ), intent ( in ) :: k_dist real ( wp ), dimension (:,:), intent ( in ) :: play , & ! layer pressures [Pa, mb]; (ncol,nlay) plev , & ! level pressures [Pa, mb]; (ncol,nlay+1) tlay ! layer temperatures [K]; (ncol,nlay) type ( ty_gas_concs ), intent ( in ) :: gas_concs ! Gas volume mixing ratios real ( wp ), dimension (:,:), target , & intent ( out ) :: flux_bc ! Boundary condition to be applied (ncol,ngpt) real ( wp ), dimension (:), optional , & intent ( in ) :: mu0 ! Must be provided for solar problems character ( len = 128 ) :: error_msg ! ---------------------------------------------------------- ! ! Local variables ! logical :: top_at_1 integer :: ncol , nlay , ngpt integer :: igas , ngases character ( len = 32 ), dimension (:), allocatable :: gas_names real ( wp ), dimension ( size ( play , 1 ), size ( play , 2 )) :: vmr integer :: top_lay real ( wp ), dimension ( size ( play , 1 ), 1 ) :: play_1lay , tlay_1lay real ( wp ), dimension ( size ( play , 1 ), 2 ) :: plev_1lay , tlev_1lay real ( wp ), dimension ( k_dist % get_nband (), size ( play , 1 )) & :: lower_bc ! emissivity or surface albedo type ( ty_gas_concs ) :: gas_concs_1lay ! Gas volume mixing ratios class ( ty_optical_props_arry ), & allocatable :: optical_props_1lay type ( ty_fluxes_1lev ) :: fluxes_1lev type ( ty_source_func_lw ) :: lw_sources_1lay real ( wp ), dimension ( size ( play , 1 ), k_dist % get_ngpt ()) :: solar_src ! ---------------------------------------------------------- ! ! Problem extent ! ncol = size ( play , dim = 1 ) nlay = size ( play , dim = 2 ) ngpt = k_dist % get_ngpt () if ( check_extents ) then if (. not . extents_are ( plev , ncol , nlay + 1 )) & error_msg = \"compute_bc: array plev has wrong dimensions\" if (. not . extents_are ( tlay , ncol , nlay )) & error_msg = \"compute_bc: array tlay has wrong dimensions\" if ( present ( mu0 )) then if ( size ( mu0 ) /= ncol ) & error_msg = \"compute bc: array mu0 has wrong dimensions\" end if if ( error_msg /= \"\" ) return end if ! ! Vertical ordering? ! top_at_1 = play ( 1 , 1 ) < play ( 1 , nlay ) top_lay = merge ( 1 , nlay , top_at_1 ) if ( any ( plev (:, top_lay ) <= & k_dist % get_press_min () + 2._wp * spacing ( k_dist % get_press_min ()))) then error_msg = \"compute_bc: pressures are too close to (or less than) min in gas optics \" return end if ! ! Make a single-layer isothermal atmosphere ! tlay_1lay ( 1 : ncol , 1 ) = tlay ( 1 : ncol , top_lay ) tlev_1lay ( 1 : ncol , 1 ) = tlay ( 1 : ncol , top_lay ) tlev_1lay ( 1 : ncol , 2 ) = tlay ( 1 : ncol , top_lay ) plev_1lay ( 1 : ncol , 1 ) = k_dist % get_press_min () plev_1lay ( 1 : ncol , 2 ) = plev ( 1 : ncol , top_lay + 1 ) ! ! Maybe there are better ways to interpolate pressure but the single layer !   should be thin enough that interpolation doesn't have much impact ! play_1lay ( 1 : ncol , 1 ) = 0.5 * ( plev_1lay ( 1 : ncol , 1 ) + plev_1lay ( 1 : ncol , 2 )) ! ! Gas concentrations in the single layer are the same as in the top layer ! ngases = gas_concs % get_num_gases () allocate ( gas_names ( ngases )) gas_names = gas_concs % get_gas_names () do igas = 1 , ngases error_msg = gas_concs % get_vmr ( gas_names ( igas ), vmr ) if ( error_msg /= \"\" ) return error_msg = gas_concs_1lay % set_vmr ( gas_names ( igas ), vmr (:, top_lay )) if ( error_msg /= \"\" ) return end do lower_bc (:,:) = 1._wp ! Value doesn't affect downward flux fluxes_1lev % gpt_flux_dn => flux_bc ! --------------------------------------------------- if ( k_dist % source_is_internal ()) then ! ! Longwave specific variables ! allocate ( ty_optical_props_1scl :: optical_props_1lay ) select type ( optical_props_1lay ) type is ( ty_optical_props_1scl ) error_msg = optical_props_1lay % alloc_1scl ( ncol , 1 , k_dist ) if ( error_msg /= \"\" ) return end select error_msg = lw_sources_1lay % alloc ( ncol , 1 , k_dist ) if ( error_msg /= \"\" ) return ! ! Gas optics and sources ! error_msg = k_dist % gas_optics ( play_1lay , plev_1lay , & tlay_1lay , tlay_1lay ( 1 : ncol , 1 ), & gas_concs_1lay , optical_props_1lay , & lw_sources_1lay , tlev = tlev_1lay ) !                                                                  ! ! Compute fluxes ! error_msg = rte_lw ( optical_props_1lay , & top_at_1 , & lw_sources_1lay , & lower_bc , fluxes_1lev ) else ! ! Shortwave specific variables ! if (. not . present ( mu0 )) then error_msg = \"compute_bc: have to supply mu0 for solar calculations\" return end if allocate ( ty_optical_props_2str :: optical_props_1lay ) select type ( optical_props_1lay ) type is ( ty_optical_props_2str ) error_msg = optical_props_1lay % alloc_2str ( ncol , 1 , k_dist ) if ( error_msg /= \"\" ) return end select ! ! Gas optics and sources ! error_msg = k_dist % gas_optics ( play_1lay , plev_1lay , & tlay_1lay , gas_concs_1lay , & optical_props_1lay , & solar_src ) error_msg = rte_sw ( optical_props_1lay , & top_at_1 , mu0 , & solar_src , & lower_bc , lower_bc , fluxes_1lev ) endif end function ! -------------------------------------------------------------------------------------- function reduce_1lev ( this , gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) result ( error_msg ) class ( ty_fluxes_1lev ), intent ( inout ) :: this real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_up ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_dn ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) class ( ty_optical_props ), intent ( in ) :: spectral_disc !< derived type with spectral information logical , intent ( in ) :: top_at_1 real ( kind = wp ), dimension (:,:,:), optional , & intent ( in ) :: gpt_flux_dn_dir ! Direct flux down character ( len = 128 ) :: error_msg ! ------ integer :: ncol , nlev , ngpt , bottom_lev ! ------ error_msg = \"\" ncol = size ( gpt_flux_up , DIM = 1 ) nlev = size ( gpt_flux_up , DIM = 2 ) ngpt = size ( gpt_flux_up , DIM = 3 ) if ( nlev /= 2 ) then error_msg = \"reduce: expecting only two layers when computing boundary condition fluxes\" return end if bottom_lev = merge ( 2 , 1 , top_at_1 ) ! ! Return the g-point flux at the bottomw of a two-layer domain ! if ( associated ( this % gpt_flux_dn )) then if ( any ([ size ( this % gpt_flux_dn , 1 ) /= ncol , & size ( this % gpt_flux_dn , 2 ) /= ngpt ])) then error_msg = \"reduce: gpt_flux_dn array incorrectly sized\" else if ( present ( gpt_flux_dn_dir )) then this % gpt_flux_dn (:,:) = gpt_flux_dn_dir (:, bottom_lev ,:) else this % gpt_flux_dn (:,:) = gpt_flux_dn (:, bottom_lev ,:) end if end if end if end function reduce_1lev ! -------------------------------------------------------------------------------------- ! Are any fluxes desired from this set of g-point fluxes? We can tell because memory will !   be allocated for output ! function are_desired_1lev ( this ) class ( ty_fluxes_1lev ), intent ( in ) :: this logical :: are_desired_1lev are_desired_1lev = associated ( this % gpt_flux_dn ) end function are_desired_1lev end module mo_compute_bc","tags":"","loc":"sourcefile/mo_compute_bc.f90.html"},{"title":"mo_rrtmgp_clr_all_sky.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_rrtmgp_clr_all_sky.f90~~EfferentGraph sourcefile~mo_rrtmgp_clr_all_sky.f90 mo_rrtmgp_clr_all_sky.F90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_lw.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_sw.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_gas_concentrations.f90 mo_gas_concentrations.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics.f90 mo_gas_optics.F90 sourcefile~mo_rrtmgp_clr_all_sky.f90->sourcefile~mo_gas_optics.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_solver_kernels.f90 mo_rte_solver_kernels.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_solver_kernels.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_solver_kernels.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes_broadband_kernels.f90 mo_fluxes_broadband_kernels.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_fluxes_broadband_kernels.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rrtmgp_util_string.f90 mo_rrtmgp_util_string.F90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rrtmgp_util_string.f90 sourcefile~mo_gas_concentrations.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_gas_concentrations.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_gas_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_broadband_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_solver_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_solver_kernels.f90->sourcefile~mo_rte_util_array.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rrtmgp_clr_all_sky Source Code mo_rrtmgp_clr_all_sky.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2017,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! ! This module provides an interface to RRTMGP for a common use case -- !   users want to start from gas concentrations, pressures, and temperatures, !   and compute clear-sky (aerosol plus gases) and all-sky fluxes. ! The routines here have the same names as those in mo_rrtmgp_[ls]w; normally users !   will use either this module or the underling modules, but not both ! module mo_rrtmgp_clr_all_sky use mo_rte_kind , only : wp use mo_gas_optics , & only : ty_gas_optics use mo_gas_concentrations , & only : ty_gas_concs use mo_optical_props , only : ty_optical_props , & ty_optical_props_arry , ty_optical_props_1scl , ty_optical_props_2str , ty_optical_props_nstr use mo_source_functions , & only : ty_source_func_lw use mo_fluxes , only : ty_fluxes use mo_rte_lw , only : base_rte_lw => rte_lw use mo_rte_sw , only : base_rte_sw => rte_sw implicit none private public :: rte_lw , rte_sw contains ! -------------------------------------------------- ! ! Interfaces using clear (gas + aerosol) and all-sky categories, starting from !   pressures, temperatures, and gas amounts for the gas contribution ! ! -------------------------------------------------- function rte_lw ( k_dist , gas_concs , p_lay , t_lay , p_lev , & t_sfc , sfc_emis , cloud_props , & allsky_fluxes , clrsky_fluxes , & aer_props , col_dry , t_lev , inc_flux , n_gauss_angles ) result ( error_msg ) class ( ty_gas_optics ), intent ( in ) :: k_dist !< derived type with spectral information type ( ty_gas_concs ), intent ( in ) :: gas_concs !< derived type encapsulating gas concentrations real ( wp ), dimension (:,:), intent ( in ) :: p_lay , t_lay !< pressure [Pa], temperature [K] at layer centers (ncol,nlay) real ( wp ), dimension (:,:), intent ( in ) :: p_lev !< pressure at levels/interfaces [Pa] (ncol,nlay+1) real ( wp ), dimension (:), intent ( in ) :: t_sfc !< surface temperature           [K]  (ncol) real ( wp ), dimension (:,:), intent ( in ) :: sfc_emis !< emissivity at surface         []   (nband, ncol) class ( ty_optical_props_arry ), intent ( in ) :: cloud_props !< cloud optical properties (ncol,nlay,ngpt) class ( ty_fluxes ), intent ( inout ) :: allsky_fluxes , clrsky_fluxes ! Optional inputs class ( ty_optical_props_arry ), & optional , intent ( in ) :: aer_props !< aerosol optical properties real ( wp ), dimension (:,:), & optional , intent ( in ) :: col_dry !< Molecular number density (ncol, nlay) real ( wp ), dimension (:,:), target , & optional , intent ( in ) :: t_lev !< temperature at levels [K] (ncol, nlay+1) real ( wp ), dimension (:,:), target , & optional , intent ( in ) :: inc_flux !< incident flux at domain top [W/m2] (ncol, ngpts) integer , optional , intent ( in ) :: n_gauss_angles ! Number of angles used in Gaussian quadrature (no-scattering solution) character ( len = 128 ) :: error_msg ! -------------------------------- ! Local variables ! class ( ty_optical_props_arry ), allocatable :: optical_props type ( ty_source_func_lw ) :: sources integer :: ncol , nlay , ngpt , nband , nstr logical :: top_at_1 ! -------------------------------- ! Problem sizes ! error_msg = \"\" ncol = size ( p_lay , 1 ) nlay = size ( p_lay , 2 ) ngpt = k_dist % get_ngpt () nband = k_dist % get_nband () !$acc kernels copyout(top_at_1) !$omp target map(from:top_at_1) top_at_1 = p_lay ( 1 , 1 ) < p_lay ( 1 , nlay ) !$acc end kernels !$omp end target ! ------------------------------------------------------------------------------------ !  Error checking ! if ( present ( aer_props )) then if ( any ([ aer_props % get_ncol (), & aer_props % get_nlay ()] /= [ ncol , nlay ])) & error_msg = \"rrtmpg_lw: aerosol properties inconsistently sized\" if (. not . any ( aer_props % get_ngpt () /= [ ngpt , nband ])) & error_msg = \"rrtmpg_lw: aerosol properties inconsistently sized\" end if if ( present ( t_lev )) then if ( any ([ size ( t_lev , 1 ), & size ( t_lev , 2 )] /= [ ncol , nlay + 1 ])) & error_msg = \"rrtmpg_lw: t_lev inconsistently sized\" end if if ( present ( inc_flux )) then if ( any ([ size ( inc_flux , 1 ), & size ( inc_flux , 2 )] /= [ ncol , ngpt ])) & error_msg = \"rrtmpg_lw: incident flux inconsistently sized\" end if if ( len_trim ( error_msg ) > 0 ) return ! ------------------------------------------------------------------------------------ ! Optical properties arrays ! select type ( cloud_props ) class is ( ty_optical_props_1scl ) ! No scattering allocate ( ty_optical_props_1scl :: optical_props ) class is ( ty_optical_props_2str ) allocate ( ty_optical_props_2str :: optical_props ) class is ( ty_optical_props_nstr ) allocate ( ty_optical_props_nstr :: optical_props ) nstr = size ( cloud_props % tau , 1 ) end select error_msg = optical_props % init ( k_dist ) if ( len_trim ( error_msg ) > 0 ) return select type ( optical_props ) class is ( ty_optical_props_1scl ) ! No scattering error_msg = optical_props % alloc_1scl ( ncol , nlay ) class is ( ty_optical_props_2str ) error_msg = optical_props % alloc_2str ( ncol , nlay ) class is ( ty_optical_props_nstr ) error_msg = optical_props % alloc_nstr ( nstr , ncol , nlay ) end select if ( error_msg /= '' ) return ! ! Source function ! error_msg = sources % init ( k_dist ) error_msg = sources % alloc ( ncol , nlay ) if ( error_msg /= '' ) return ! ------------------------------------------------------------------------------------ ! Clear skies ! ! Gas optical depth -- pressure need to be expressed as Pa ! error_msg = k_dist % gas_optics ( p_lay , p_lev , t_lay , t_sfc , gas_concs , & optical_props , sources , & col_dry , t_lev ) if ( error_msg /= '' ) return ! ---------------------------------------------------- ! Clear sky is gases + aerosols (if they're supplied) ! if ( present ( aer_props )) error_msg = aer_props % increment ( optical_props ) if ( error_msg /= '' ) return error_msg = base_rte_lw ( optical_props , top_at_1 , sources , & sfc_emis , clrsky_fluxes , & inc_flux , n_gauss_angles ) if ( error_msg /= '' ) return ! ------------------------------------------------------------------------------------ ! All-sky fluxes = clear skies + clouds ! error_msg = cloud_props % increment ( optical_props ) if ( error_msg /= '' ) return error_msg = base_rte_lw ( optical_props , top_at_1 , sources , & sfc_emis , allsky_fluxes , & inc_flux , n_gauss_angles ) call sources % finalize () call optical_props % finalize () end function rte_lw ! -------------------------------------------------- function rte_sw ( k_dist , gas_concs , p_lay , t_lay , p_lev , & mu0 , sfc_alb_dir , sfc_alb_dif , cloud_props , & allsky_fluxes , clrsky_fluxes , & aer_props , col_dry , inc_flux ) result ( error_msg ) class ( ty_gas_optics ), intent ( in ) :: k_dist !< derived type with spectral information type ( ty_gas_concs ), intent ( in ) :: gas_concs !< derived type encapsulating gas concentrations real ( wp ), dimension (:,:), intent ( in ) :: p_lay , t_lay !< pressure [Pa], temperature [K] at layer centers (ncol,nlay) real ( wp ), dimension (:,:), intent ( in ) :: p_lev !< pressure at levels/interfaces [Pa] (ncol,nlay+1) real ( wp ), dimension (: ), intent ( in ) :: mu0 !< cosine of solar zenith angle real ( wp ), dimension (:,:), intent ( in ) :: sfc_alb_dir , sfc_alb_dif !  surface albedo for direct and diffuse radiation (band, col) class ( ty_optical_props_arry ), intent ( in ) :: cloud_props !< cloud optical properties (ncol,nlay,ngpt) class ( ty_fluxes ), intent ( inout ) :: allsky_fluxes , clrsky_fluxes ! Optional inputs class ( ty_optical_props_arry ), target , & optional , intent ( in ) :: aer_props !< aerosol optical properties real ( wp ), dimension (:,:), & optional , intent ( in ) :: col_dry , & !< Molecular number density (ncol, nlay) inc_flux !< incident flux at domain top [W/m2] (ncol, ngpts) character ( len = 128 ) :: error_msg ! -------------------------------- ! Local variables ! class ( ty_optical_props_arry ), allocatable :: optical_props real ( wp ), dimension (:,:), allocatable :: toa_flux integer :: ncol , nlay , ngpt , nband , nstr logical :: top_at_1 ! -------------------------------- ! Problem sizes ! error_msg = \"\" ncol = size ( p_lay , 1 ) nlay = size ( p_lay , 2 ) ngpt = k_dist % get_ngpt () nband = k_dist % get_nband () !$acc kernels copyout(top_at_1) !$omp target map(from:top_at_1) top_at_1 = p_lay ( 1 , 1 ) < p_lay ( 1 , nlay ) !$acc end kernels !$omp end target ! ------------------------------------------------------------------------------------ !  Error checking ! if ( present ( aer_props )) then if ( any ([ aer_props % get_ncol (), & aer_props % get_nlay ()] /= [ ncol , nlay ])) & error_msg = \"rrtmpg_sw: aerosol properties inconsistently sized\" if (. not . any ( aer_props % get_ngpt () /= [ ngpt , nband ])) & error_msg = \"rrtmpg_sw: aerosol properties inconsistently sized\" end if if ( present ( inc_flux )) then if ( any ([ size ( inc_flux , 1 ), & size ( inc_flux , 2 )] /= [ ncol , ngpt ])) & error_msg = \"rrtmpg_sw: incident flux inconsistently sized\" end if if ( len_trim ( error_msg ) > 0 ) return ! ------------------------------------------------------------------------------------ ! ! Optical properties arrays ! select type ( cloud_props ) class is ( ty_optical_props_1scl ) ! No scattering allocate ( ty_optical_props_1scl :: optical_props ) class is ( ty_optical_props_2str ) allocate ( ty_optical_props_2str :: optical_props ) class is ( ty_optical_props_nstr ) allocate ( ty_optical_props_nstr :: optical_props ) nstr = cloud_props % get_nmom () end select error_msg = optical_props % init ( k_dist % get_band_lims_wavenumber (), & k_dist % get_band_lims_gpoint ()) if ( len_trim ( error_msg ) > 0 ) return select type ( optical_props ) class is ( ty_optical_props_1scl ) ! No scattering error_msg = optical_props % alloc_1scl ( ncol , nlay ) class is ( ty_optical_props_2str ) error_msg = optical_props % alloc_2str ( ncol , nlay ) class is ( ty_optical_props_nstr ) error_msg = optical_props % alloc_nstr ( nstr , ncol , nlay ) end select if ( error_msg /= '' ) return allocate ( toa_flux ( ncol , ngpt )) ! ------------------------------------------------------------------------------------ ! Clear skies ! ! Gas optical depth -- pressure need to be expressed as Pa ! error_msg = k_dist % gas_optics ( p_lay , p_lev , t_lay , gas_concs , & optical_props , toa_flux , & col_dry ) if ( error_msg /= '' ) return ! ! If users have supplied an incident flux, use that ! if ( present ( inc_flux )) toa_flux (:,:) = inc_flux (:,:) ! ---------------------------------------------------- ! Clear sky is gases + aerosols (if they're supplied) ! if ( present ( aer_props )) error_msg = aer_props % increment ( optical_props ) if ( error_msg /= '' ) return error_msg = base_rte_sw ( optical_props , top_at_1 , & mu0 , toa_flux , & sfc_alb_dir , sfc_alb_dif , & clrsky_fluxes ) if ( error_msg /= '' ) return ! ------------------------------------------------------------------------------------ ! All-sky fluxes = clear skies + clouds ! error_msg = cloud_props % increment ( optical_props ) if ( error_msg /= '' ) return error_msg = base_rte_sw ( optical_props , top_at_1 , & mu0 , toa_flux , & sfc_alb_dir , sfc_alb_dif , & allsky_fluxes ) call optical_props % finalize () end function rte_sw end module mo_rrtmgp_clr_all_sky","tags":"","loc":"sourcefile/mo_rrtmgp_clr_all_sky.f90.html"},{"title":"mo_fluxes_byband.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_fluxes_byband.f90~~EfferentGraph sourcefile~mo_fluxes_byband.f90 mo_fluxes_byband.F90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_fluxes_byband.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_broadband_kernels.f90 mo_fluxes_broadband_kernels.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_fluxes_broadband_kernels.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes_broadband_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_fluxes_byband Source Code mo_fluxes_byband.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2015,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! ! This module is for packaging output quantities from RRTMGP based on spectral flux profiles !    This implementation provides band-by-band flux profiles ! module mo_fluxes_byband use mo_rte_kind , only : wp use mo_rte_config , only : check_extents use mo_rte_util_array , only : extents_are use mo_fluxes , only : ty_fluxes , ty_fluxes_broadband use mo_optical_props , only : ty_optical_props implicit none ! Output from radiation calculations !   Data components are pointers so results can be written directly into memory !   reduce() function accepts spectral flux profiles type , extends ( ty_fluxes_broadband ) :: ty_fluxes_byband real ( wp ), dimension (:,:,:), pointer :: bnd_flux_up => NULL (), & ! Band-by-band fluxes bnd_flux_dn => NULL () ! (ncol, nlev, nband) real ( wp ), dimension (:,:,:), pointer :: bnd_flux_net => NULL () ! Net (down - up) real ( wp ), dimension (:,:,:), pointer :: bnd_flux_dn_dir => NULL () ! Direct flux down contains procedure :: reduce => reduce_byband procedure :: are_desired => are_desired_byband end type ty_fluxes_byband interface net_byband module procedure net_byband_full , net_byband_precalc end interface net_byband contains ! -------------------------------------------------------------------------------------- function reduce_byband ( this , gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) result ( error_msg ) class ( ty_fluxes_byband ), intent ( inout ) :: this real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_up ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_dn ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) class ( ty_optical_props ), intent ( in ) :: spectral_disc !< derived type with spectral information logical , intent ( in ) :: top_at_1 real ( kind = wp ), dimension (:,:,:), optional , & intent ( in ) :: gpt_flux_dn_dir ! Direct flux down character ( len = 128 ) :: error_msg ! ------ integer :: ncol , nlev , ngpt , nbnd integer , dimension ( 2 , spectral_disc % get_nband ()) :: band_lims ! ------ ncol = size ( gpt_flux_up , DIM = 1 ) nlev = size ( gpt_flux_up , DIM = 2 ) ngpt = spectral_disc % get_ngpt () nbnd = spectral_disc % get_nband () band_lims (:,:) = spectral_disc % get_band_lims_gpoint () ! Compute broadband fluxes !   This also checks that input arrays are consistently sized ! error_msg = this % ty_fluxes_broadband % reduce ( gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) if ( error_msg /= '' ) return if ( size ( gpt_flux_up , 3 ) /= ngpt ) then error_msg = \"reduce: spectral discretization and g-point flux arrays have differing number of g-points\" return end if ! Check sizes of output arrays if ( check_extents ) then if ( associated ( this % bnd_flux_up )) then if (. not . extents_are ( this % bnd_flux_up , ncol , nlev , nbnd )) & error_msg = \"reduce: bnd_flux_up array incorrectly sized (can't compute net flux either)\" end if if ( associated ( this % bnd_flux_dn )) then if (. not . extents_are ( this % bnd_flux_dn , ncol , nlev , nbnd )) & error_msg = \"reduce: bnd_flux_dn array incorrectly sized (can't compute net flux either)\" end if if ( associated ( this % bnd_flux_dn_dir )) then if (. not . extents_are ( this % bnd_flux_dn_dir , ncol , nlev , nbnd )) & error_msg = \"reduce: bnd_flux_dn_dir array incorrectly sized\" end if if ( associated ( this % bnd_flux_net )) then if (. not . extents_are ( this % bnd_flux_net , ncol , nlev , nbnd )) & error_msg = \"reduce: bnd_flux_net array incorrectly sized (can't compute net flux either)\" end if if ( error_msg /= \"\" ) return end if ! ! Self-consistency -- shouldn't be asking for direct beam flux if it isn't supplied if ( associated ( this % bnd_flux_dn_dir ) . and . . not . present ( gpt_flux_dn_dir )) then error_msg = \"reduce: requesting bnd_flux_dn_dir but direct flux hasn't been supplied\" return end if ! ------- !$acc enter data copyin(band_lims) !$omp target enter data map(to:band_lims) ! Band-by-band fluxes ! Up flux if ( associated ( this % bnd_flux_up )) then call sum_byband ( ncol , nlev , ngpt , nbnd , band_lims , gpt_flux_up , this % bnd_flux_up ) end if ! ------- ! Down flux if ( associated ( this % bnd_flux_dn )) then call sum_byband ( ncol , nlev , ngpt , nbnd , band_lims , gpt_flux_dn , this % bnd_flux_dn ) end if if ( associated ( this % bnd_flux_dn_dir )) then call sum_byband ( ncol , nlev , ngpt , nbnd , band_lims , gpt_flux_dn_dir , this % bnd_flux_dn_dir ) end if ! ------- ! Net flux ! if ( associated ( this % bnd_flux_net )) then ! !  Reuse down and up results if possible ! if ( associated ( this % bnd_flux_dn ) . and . associated ( this % bnd_flux_up )) then call net_byband ( ncol , nlev , nbnd , this % bnd_flux_dn , this % bnd_flux_up , this % bnd_flux_net ) else call net_byband ( ncol , nlev , ngpt , nbnd , band_lims , gpt_flux_dn , gpt_flux_up , this % bnd_flux_net ) end if end if !$acc exit data delete(band_lims) !$omp target exit data map(release:band_lims) end function reduce_byband ! -------------------------------------------------------------------------------------- ! Are any fluxes desired from this set of g-point fluxes? We can tell because memory will !   be allocated for output ! function are_desired_byband ( this ) class ( ty_fluxes_byband ), intent ( in ) :: this logical :: are_desired_byband are_desired_byband = any ([ associated ( this % bnd_flux_up ), & associated ( this % bnd_flux_dn ), & associated ( this % bnd_flux_dn_dir ), & associated ( this % bnd_flux_net ), & this % ty_fluxes_broadband % are_desired ()]) end function are_desired_byband ! ---------------------------------------------------------------------------- ! Kernels (private to this module) ! ---------------------------------------------------------------------------- ! ! Spectral reduction over all points ! subroutine sum_byband ( ncol , nlev , ngpt , nbnd , band_lims , spectral_flux , byband_flux ) bind ( C ) integer , intent ( in ) :: ncol , nlev , ngpt , nbnd integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( in ) :: spectral_flux real ( wp ), dimension ( ncol , nlev , nbnd ), intent ( out ) :: byband_flux integer :: icol , ilev , igpt , ibnd !$acc parallel loop collapse(3) copyin(spectral_flux, band_lims) copyout(byband_flux) !$omp target teams distribute parallel do collapse(3) map(to:spectral_flux, band_lims) map(from:byband_flux) do ibnd = 1 , nbnd do ilev = 1 , nlev do icol = 1 , ncol byband_flux ( icol , ilev , ibnd ) = spectral_flux ( icol , ilev , band_lims ( 1 , ibnd )) do igpt = band_lims ( 1 , ibnd ) + 1 , band_lims ( 2 , ibnd ) byband_flux ( icol , ilev , ibnd ) = byband_flux ( icol , ilev , ibnd ) + & spectral_flux ( icol , ilev , igpt ) end do end do end do enddo end subroutine sum_byband ! ---------------------------------------------------------------------------- ! ! Net flux: Spectral reduction over all points ! subroutine net_byband_full ( ncol , nlev , ngpt , nbnd , band_lims , spectral_flux_dn , spectral_flux_up , byband_flux_net ) bind ( C ) integer , intent ( in ) :: ncol , nlev , ngpt , nbnd integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims real ( wp ), dimension ( ncol , nlev , ngpt ), intent ( in ) :: spectral_flux_dn , spectral_flux_up real ( wp ), dimension ( ncol , nlev , nbnd ), intent ( out ) :: byband_flux_net integer :: icol , ilev , igpt , ibnd !$acc parallel loop collapse(3) copyin(spectral_flux_dn, spectral_flux_up, band_lims) copyout(byband_flux_net) !$omp target teams distribute parallel do collapse(3) map(to:spectral_flux_dn, spectral_flux_up, band_lims) map(from:byband_flux_net) do ibnd = 1 , nbnd do ilev = 1 , nlev do icol = 1 , ncol igpt = band_lims ( 1 , ibnd ) byband_flux_net ( icol , ilev , ibnd ) = spectral_flux_dn ( icol , ilev , igpt ) - & spectral_flux_up ( icol , ilev , igpt ) do igpt = band_lims ( 1 , ibnd ) + 1 , band_lims ( 2 , ibnd ) byband_flux_net ( icol , ilev , ibnd ) = byband_flux_net ( icol , ilev , ibnd ) + & spectral_flux_dn ( icol , ilev , igpt ) - & spectral_flux_up ( icol , ilev , igpt ) end do end do end do end do end subroutine net_byband_full ! ---------------------------------------------------------------------------- subroutine net_byband_precalc ( ncol , nlev , nbnd , byband_flux_dn , byband_flux_up , byband_flux_net ) bind ( C ) integer , intent ( in ) :: ncol , nlev , nbnd real ( wp ), dimension ( ncol , nlev , nbnd ), intent ( in ) :: byband_flux_dn , byband_flux_up real ( wp ), dimension ( ncol , nlev , nbnd ), intent ( out ) :: byband_flux_net byband_flux_net ( 1 : ncol , 1 : nlev , 1 : nbnd ) = byband_flux_dn ( 1 : ncol , 1 : nlev , 1 : nbnd ) - byband_flux_up ( 1 : ncol , 1 : nlev , 1 : nbnd ) end subroutine net_byband_precalc ! ---------------------------------------------------------------------------- end module mo_fluxes_byband","tags":"","loc":"sourcefile/mo_fluxes_byband.f90.html"},{"title":"mo_fluxes_bygpoint.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_fluxes_bygpoint.f90~~EfferentGraph sourcefile~mo_fluxes_bygpoint.f90 mo_fluxes_bygpoint.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_fluxes_bygpoint.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes_broadband_kernels.f90 mo_fluxes_broadband_kernels.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_fluxes_broadband_kernels.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes_broadband_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_fluxes_bygpoint Source Code mo_fluxes_bygpoint.F90 Source Code ! This code is part of ! RRTM for GCM Applications - Parallel (RRTMGP) ! ! Eli Mlawer and Robert Pincus ! Andre Wehe and Jennifer Delamere ! email:  rrtmgp@aer.com ! ! Copyright 2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ! This module is for packaging output quantities from RRTMGP based on spectral flux profiles !    This implementation reports the g-point fluxes ! module mo_fluxes_bygpoint use mo_rte_kind , only : wp use mo_rte_util_array , only : extents_are use mo_fluxes , only : ty_fluxes use mo_optical_props , only : ty_optical_props implicit none ! Output from radiation calculations !   Data components are pointers so results can be written directly into memory !   reduce() function accepts spectral flux profiles type , extends ( ty_fluxes ) :: ty_fluxes_bygpoint real ( wp ), dimension (:,:,:), pointer :: gpt_flux_up => NULL (), & ! Band-by-band fluxes gpt_flux_dn => NULL () ! (ncol, nlev, nband) real ( wp ), dimension (:,:,:), pointer :: gpt_flux_net => NULL () ! Net (down - up) real ( wp ), dimension (:,:,:), pointer :: gpt_flux_dn_dir => NULL () ! Direct flux down contains procedure :: reduce => reduce_bygpoint procedure :: are_desired => are_desired_bygpoint end type ty_fluxes_bygpoint contains ! -------------------------------------------------------------------------------------- function reduce_bygpoint ( this , gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) result ( error_msg ) class ( ty_fluxes_bygpoint ), intent ( inout ) :: this real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_up ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_dn ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) class ( ty_optical_props ), intent ( in ) :: spectral_disc !< derived type with spectral information logical , intent ( in ) :: top_at_1 real ( kind = wp ), dimension (:,:,:), optional , & intent ( in ) :: gpt_flux_dn_dir ! Direct flux down character ( len = 128 ) :: error_msg ! ------ integer :: ncol , nlev , ngpt , nbnd ! ------ error_msg = \"\" ncol = size ( gpt_flux_up , DIM = 1 ) nlev = size ( gpt_flux_up , DIM = 2 ) ngpt = size ( gpt_flux_up , DIM = 3 ) if ( associated ( this % gpt_flux_up )) then if (. not . extents_are ( this % gpt_flux_up , ncol , nlev , ngpt )) then error_msg = \"reduce: gpt_flux_up array incorrectly sized (can't compute net flux either)\" else this % gpt_flux_up (:,:,:) = gpt_flux_up (:,:,:) end if end if if ( associated ( this % gpt_flux_dn )) then if (. not . extents_are ( this % gpt_flux_dn , ncol , nlev , ngpt )) then error_msg = \"reduce: gpt_flux_dn array incorrectly sized (can't compute net flux either)\" else this % gpt_flux_dn (:,:,:) = gpt_flux_dn (:,:,:) end if end if if ( associated ( this % gpt_flux_net )) then if (. not . extents_are ( this % gpt_flux_net , ncol , nlev , ngpt )) then error_msg = \"reduce: gpt_flux_net array incorrectly sized (can't compute net flux either)\" else this % gpt_flux_net (:,:,:) = gpt_flux_dn (:,:,:) - gpt_flux_up (:,:,:) end if end if if ( associated ( this % gpt_flux_dn_dir )) then if (. not . extents_are ( this % gpt_flux_dn_dir , ncol , nlev , ngpt )) then error_msg = \"reduce: gpt_flux_dn_dir array incorrectly sized (can't compute net flux either)\" else if ( present ( gpt_flux_dn_dir )) then this % gpt_flux_dn_dir (:,:,:) = gpt_flux_dn_dir (:,:,:) end if end if end function reduce_bygpoint ! -------------------------------------------------------------------------------------- ! Are any fluxes desired from this set of g-point fluxes? We can tell because memory will !   be allocated for output ! function are_desired_bygpoint ( this ) class ( ty_fluxes_bygpoint ), intent ( in ) :: this logical :: are_desired_bygpoint are_desired_bygpoint = any ([ associated ( this % gpt_flux_up ), & associated ( this % gpt_flux_dn ), & associated ( this % gpt_flux_dn_dir ), & associated ( this % gpt_flux_net )]) end function are_desired_bygpoint end module mo_fluxes_bygpoint","tags":"","loc":"sourcefile/mo_fluxes_bygpoint.f90.html"},{"title":"mo_solar_variability.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_solar_variability.f90~~EfferentGraph sourcefile~mo_solar_variability.f90 mo_solar_variability.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_solar_variability.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_solar_variability Source Code mo_solar_variability.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2020,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! Description: Optional calculation of solar variability facular and ! sunspot indices module mo_solar_variability use mo_rte_kind , only : wp implicit none private type , public :: ty_solar_var ! ! Data ! real ( wp ), dimension (:,:), allocatable :: avgcyc_ind ! solar variabilty index lookup table ! time-averaged over solar cycles 13-24. ! (NRLSSI2 facular \"Bremen\" index and ! sunspot \"SPOT67\" index) ! (nsolarterms, nsolarfrac) -> (2,134) contains ! ! Public procedures ! procedure , public :: solar_var_ind_interp procedure , public :: load procedure , public :: finalize ! end type ty_solar_var contains ! ------------------------------------------------------------------------------ ! ! Routine to load mean facular and sunspot index tables ! ! ------------------------------------------------------------------------------ function load ( this , avgcyc_ind ) result ( error_msg ) class ( ty_solar_var ), intent ( inout ) :: this ! Lookup table of mean solar cycle facular brightening and sunspot dimming indices real ( wp ), dimension (:,:), intent ( in ) :: avgcyc_ind character ( len = 128 ) :: error_msg ! ------- ! ! Local variables ! integer :: nsolarterms , nsolarfrac error_msg = \"\" ! ! LUT index dimensions ! nsolarterms = size ( avgcyc_ind , dim = 1 ) nsolarfrac = size ( avgcyc_ind , dim = 2 ) ! ! Allocate LUT index array allocate ( this % avgcyc_ind ( nsolarterms , nsolarfrac )) ! Load LUT index array this % avgcyc_ind = avgcyc_ind end function load !-------------------------------------------------------------------------------------------------------------------- ! ! Finalize ! !-------------------------------------------------------------------------------------------------------------------- subroutine finalize ( this ) class ( ty_solar_var ), intent ( inout ) :: this ! Lookup table solar variability indices if ( allocated ( this % avgcyc_ind )) then deallocate ( this % avgcyc_ind ) end if end subroutine finalize ! ------------------------------------------------------------------------------ ! ! Facular brightening and sunspot dimming indices are derived from the ! averaged solar cycle, which is the mean of Solar Cycles 13-24. The user specifices ! the solar cycle fraction (0 to 1) and the indices are interpolated to the ! requested fractional position within the cycle, where 0 is close to solar minimum. ! function solar_var_ind_interp ( this , & solcycfrac , & mg_index , sb_index ) & result ( error_msg ) class ( ty_solar_var ), intent ( in ) :: this ! Solar variability real ( wp ), intent ( in ) :: solcycfrac ! solar cycle fraction real ( wp ), intent ( out ) :: mg_index ! Facular brightening NRLSSI2 index ! interpolated from the mean solar cycle ! to the provided solar cycle fraction real ( wp ), intent ( out ) :: sb_index ! Sunspot dimmng NRLSSI2 index ! interpolated from the mean solar cycle ! to the provided solar cycle fraction character ( len = 128 ) :: error_msg ! ---------------------------------------------------------- ! Local variables ! integer :: nsolfrac ! Number of solar fraction points in facular ! and sunspot tables integer :: sfid ! Solar variability solar cycle fraction index real ( wp ) :: intrvl_len ! Fractional interval length of mgavgcyc and sbavgcyc real ( wp ) :: intrvl_len_hf ! Fractional half interval length of mgavgcyc and sbavgcyc real ( wp ) :: fraclo , frachi , intfrac ! Solar variability interpolation factors ! ---------------------------------------------------------- ! Error checking error_msg = \"\" ! ! Check input data sizes and values ! if ( solcycfrac . lt . 0._wp . or . solcycfrac . gt . 1._wp ) & error_msg = 'solar_var_ind_interp: solcycfrac out of range' if ( error_msg /= '' ) return ! ! Interpolate solar variability indices to requested solar cycle fraction, ! and derive final facular and sunspot indices ! ! nsolfrac is the length of the time dimension of the interpolation tables ! of facular and sunspot indices over the mean solar cycle (this%avgcyc_ind). ! The end-points of avgcyc_ind represent the indices at solcycfrac values of ! 0 (first day of the first year) and 1 (last day of the 11th year), while ! the intervening values of avgcyc_ind represent the indices at the center ! of each month over the mean 11-year solar cycle. if ( allocated ( this % avgcyc_ind )) then nsolfrac = size ( this % avgcyc_ind , 2 ) ! Define indices for the lowest allowable value of solcycfrac if ( solcycfrac . eq . 0._wp ) then mg_index = this % avgcyc_ind ( 1 , 1 ) sb_index = this % avgcyc_ind ( 2 , 1 ) ! Define indices for the highest allowable value of solcycfrac elseif ( solcycfrac . eq . 1._wp ) then mg_index = this % avgcyc_ind ( 1 , nsolfrac ) sb_index = this % avgcyc_ind ( 2 , nsolfrac ) ! Define indices for intervening values of solcycfrac else intrvl_len = 1._wp / ( nsolfrac - 2 ) intrvl_len_hf = 0.5_wp * intrvl_len ! Define interpolation fractions for the first interval, which represents ! the first half of the first month of the first year of the mean 11-year ! solar cycle if ( solcycfrac . le . intrvl_len_hf ) then sfid = 1 fraclo = 0._wp frachi = intrvl_len_hf endif ! Define interpolation fractions for the intervening intervals, which represent ! the center point of each month in each year of the mean 11-year solar cycle if ( solcycfrac . gt . intrvl_len_hf . and . solcycfrac . lt . 1._wp - intrvl_len_hf ) then sfid = floor (( solcycfrac - intrvl_len_hf ) * ( nsolfrac - 2 )) + 2 fraclo = ( sfid - 2 ) * intrvl_len + intrvl_len_hf frachi = fraclo + intrvl_len endif ! Define interpolation fractions for the last interval, which represents ! the last half of the last month of the last year of the mean 11-year ! solar cycle if ( solcycfrac . ge . 1._wp - intrvl_len_hf ) then sfid = ( nsolfrac - 2 ) + 1 fraclo = 1._wp - intrvl_len_hf frachi = 1._wp endif ! Interpolate the facular (mg_index) and sunspot (sb_index) indices for the ! requested value of solcycfrac intfrac = ( solcycfrac - fraclo ) / ( frachi - fraclo ) mg_index = this % avgcyc_ind ( 1 , sfid ) + & intfrac * ( this % avgcyc_ind ( 1 , sfid + 1 ) - this % avgcyc_ind ( 1 , sfid )) sb_index = this % avgcyc_ind ( 2 , sfid ) + & intfrac * ( this % avgcyc_ind ( 2 , sfid + 1 ) - this % avgcyc_ind ( 2 , sfid )) endif endif end function solar_var_ind_interp ! -------------------------------------------------------------------------------------- end module mo_solar_variability","tags":"","loc":"sourcefile/mo_solar_variability.f90.html"},{"title":"mo_cloud_sampling.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_cloud_sampling.f90~~EfferentGraph sourcefile~mo_cloud_sampling.f90 mo_cloud_sampling.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_cloud_sampling.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_cloud_sampling Source Code mo_cloud_sampling.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2019,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! ! This module provides a simple implementation of sampling for the !   Monte Carlo Independent Pixel Approximation (McICA, doi:10.1029/2002jd003322) ! Cloud optical properties, defined by band and assumed homogenous within each cell (column/layer), !   are randomly sampled to preserve the mean cloud fraction and one of several possible overlap assumptions ! Users supply random numbers with order ngpt,nlay,ncol !   These are only accessed if cloud_fraction(icol,ilay) > 0 so many values don't need to be filled in ! ! ------------------------------------------------------------------------------------------------- module mo_cloud_sampling use mo_rte_kind , only : wp , wl use mo_optical_props , only : ty_optical_props_arry , & ty_optical_props_1scl , & ty_optical_props_2str , & ty_optical_props_nstr implicit none private public :: draw_samples , sampled_mask_max_ran , sampled_mask_exp_ran contains ! ------------------------------------------------------------------------------------------------- ! ! Apply a T/F sampled cloud mask to cloud optical properties defined by band to produce !   McICA-sampled cloud optical properties ! function draw_samples ( cloud_mask , clouds , clouds_sampled ) result ( error_msg ) logical , dimension (:,:,:), intent ( in ) :: cloud_mask ! Dimensions ncol,nlay,ngpt class ( ty_optical_props_arry ), intent ( in ) :: clouds ! Defined by band class ( ty_optical_props_arry ), intent ( inout ) :: clouds_sampled ! Defined by g-point character ( len = 128 ) :: error_msg ! ------------------------ integer :: ncol , nlay , nbnd , ngpt integer :: imom ! ------------------------ ! ! Error checking ! error_msg = \"\" if (. not . clouds % is_initialized ()) then error_msg = \"draw_samples: cloud optical properties are not initialized\" return end if if (. not . clouds_sampled % is_initialized ()) then error_msg = \"draw_samples: sampled cloud optical properties are not initialized\" return end if ! ! Variables clouds and clouds_sampled have to be of the same type (have the same set of fields) !   nstr isn't supported !   2str is checked at assignment ! select type ( clouds ) type is ( ty_optical_props_1scl ) select type ( clouds_sampled ) type is ( ty_optical_props_2str ) error_msg = \"draw_samples: by-band and sampled cloud properties need to be the same variable type\" return type is ( ty_optical_props_nstr ) error_msg = \"draw_samples: by-band and sampled cloud properties need to be the same variable type\" return end select type is ( ty_optical_props_nstr ) error_msg = \"draw_samples: sampling isn't implemented yet for ty_optical_props_nstr\" return end select ! ! Spectral discretization ! if (. not . clouds % bands_are_equal ( clouds_sampled )) then error_msg = \"draw_samples: by-band and sampled cloud properties spectral structure is different\" return end if ! ! Array extents ! ncol = clouds % get_ncol () nlay = clouds % get_nlay () nbnd = clouds % get_nband () ngpt = clouds_sampled % get_ngpt () if ( any ([ size ( cloud_mask , 1 ), size ( cloud_mask , 2 ), size ( cloud_mask , 3 )] /= [ ncol , nlay , ngpt ])) then error_msg = \"draw_samples: cloud mask and cloud optical properties have different ncol and/or nlay\" return end if if ( any ([ clouds_sampled % get_ncol (), clouds_sampled % get_nlay ()] /= [ ncol , nlay ])) then error_msg = \"draw_samples: sampled/unsampled cloud optical properties have different ncol and/or nlay\" return end if ! ------------------------ ! ! Finally - sample fields according to the cloud mask ! ! Optical depth assignment works for 1scl, 2str (also nstr) call apply_cloud_mask ( ncol , nlay , nbnd , ngpt , clouds_sampled % get_band_lims_gpoint (), cloud_mask , clouds % tau , clouds_sampled % tau ) ! ! For 2-stream ! select type ( clouds ) type is ( ty_optical_props_2str ) select type ( clouds_sampled ) type is ( ty_optical_props_2str ) call apply_cloud_mask ( ncol , nlay , nbnd , ngpt , clouds_sampled % get_band_lims_gpoint (), cloud_mask , clouds % ssa , clouds_sampled % ssa ) call apply_cloud_mask ( ncol , nlay , nbnd , ngpt , clouds_sampled % get_band_lims_gpoint (), cloud_mask , clouds % g , clouds_sampled % g ) class default error_msg = \"draw_samples: by-band and sampled cloud properties need to be the same variable type\" end select end select end function draw_samples ! ------------------------------------------------------------------------------------------------- ! ! Generate a McICA-sampled cloud mask for maximum-random overlap ! function sampled_mask_max_ran ( randoms , cloud_frac , cloud_mask ) result ( error_msg ) real ( wp ), dimension (:,:,:), intent ( in ) :: randoms !ngpt,nlay,ncol real ( wp ), dimension (:,:), intent ( in ) :: cloud_frac ! ncol,nlay logical , dimension (:,:,:), intent ( out ) :: cloud_mask ! ncol,nlay,ngpt character ( len = 128 ) :: error_msg ! ------------------------ integer :: ncol , nlay , ngpt , icol , ilay , igpt integer :: cloud_lay_fst , cloud_lay_lst real ( wp ), dimension ( size ( randoms , 1 )) :: local_rands logical , dimension ( size ( randoms , 2 )) :: cloud_mask_layer ! ------------------------ ! ! Error checking ! error_msg = \"\" ncol = size ( randoms , 3 ) nlay = size ( randoms , 2 ) ngpt = size ( randoms , 1 ) if ( any ([ ncol , nlay ] /= [ size ( cloud_frac , 1 ), size ( cloud_frac , 2 )])) then error_msg = \"sampled_mask_max_ran: sizes of randoms(ngpt,nlay,ncol) and cloud_frac(ncol,nlay) are inconsistent\" return end if if ( any ([ ncol , nlay , ngpt ] /= [ size ( cloud_mask , 1 ), size ( cloud_mask , 2 ), size ( cloud_mask , 3 )])) then error_msg = \"sampled_mask_max_ran: sizes of randoms(ngpt,nlay,ncol) and cloud_mask(ncol,nlay,ngpt) are inconsistent\" return end if if ( any ( cloud_frac > 1._wp ) . or . any ( cloud_frac < 0._wp )) then error_msg = \"sampled_mask_max_ran: cloud fraction values out of range [0,1]\" return end if ! ! We chould check the random numbers but that would be computationally heavy ! ! ------------------------ ! ! Construct the cloud mask for each column ! do icol = 1 , ncol cloud_mask_layer ( 1 : nlay ) = cloud_frac ( icol , 1 : nlay ) > 0._wp if (. not . any ( cloud_mask_layer )) then cloud_mask ( icol , 1 : nlay , 1 : ngpt ) = . false . cycle end if cloud_lay_fst = findloc ( cloud_mask_layer , . true ., dim = 1 ) cloud_lay_lst = findloc ( cloud_mask_layer , . true ., dim = 1 , back = . true .) cloud_mask ( icol , 1 : cloud_lay_fst , 1 : ngpt ) = . false . ilay = cloud_lay_fst local_rands ( 1 : ngpt ) = randoms ( 1 : ngpt , cloud_lay_fst , icol ) cloud_mask ( icol , ilay , 1 : ngpt ) = local_rands ( 1 : ngpt ) > ( 1._wp - cloud_frac ( icol , ilay )) do ilay = cloud_lay_fst + 1 , cloud_lay_lst if ( cloud_mask_layer ( ilay )) then ! ! Max-random overlap: !   new  random deviates if the adjacent layer isn't cloudy !   same random deviates if the adjacent layer is    cloudy ! if (. not . cloud_mask_layer ( ilay - 1 )) local_rands ( 1 : ngpt ) = randoms ( 1 : ngpt , ilay , icol ) cloud_mask ( icol , ilay , 1 : ngpt ) = local_rands ( 1 : ngpt ) > ( 1._wp - cloud_frac ( icol , ilay )) else cloud_mask ( icol , ilay , 1 : ngpt ) = . false . end if end do cloud_mask ( icol , cloud_lay_lst + 1 : nlay , 1 : ngpt ) = . false . end do end function sampled_mask_max_ran ! ------------------------------------------------------------------------------------------------- ! ! Generate a McICA-sampled cloud mask for exponential-random overlap !   The overlap parameter alpha is defined between pairs of layers !   for layer i, alpha(i) describes the overlap betwen cloud_frac(i) and cloud_frac(i+1) !   By skipping layers with 0 cloud fraction the code forces alpha(i) = 0 for cloud_frac(i) = 0. ! function sampled_mask_exp_ran ( randoms , cloud_frac , overlap_param , cloud_mask ) result ( error_msg ) real ( wp ), dimension (:,:,:), intent ( in ) :: randoms ! ngpt,nlay,ncol real ( wp ), dimension (:,:), intent ( in ) :: cloud_frac ! ncol,nlay real ( wp ), dimension (:,:), intent ( in ) :: overlap_param ! ncol,nlay-1 logical , dimension (:,:,:), intent ( out ) :: cloud_mask ! ncol,nlay,ngpt character ( len = 128 ) :: error_msg ! ------------------------ integer :: ncol , nlay , ngpt , icol , ilay , igpt integer :: cloud_lay_fst , cloud_lay_lst real ( wp ) :: rho ! correlation coefficient real ( wp ), dimension ( size ( randoms , 1 )) :: local_rands logical , dimension ( size ( randoms , 2 )) :: cloud_mask_layer ! ------------------------ ! ! Error checking ! error_msg = \"\" ncol = size ( randoms , 3 ) nlay = size ( randoms , 2 ) ngpt = size ( randoms , 1 ) if ( any ([ ncol , nlay ] /= [ size ( cloud_frac , 1 ), size ( cloud_frac , 2 )])) then error_msg = \"sampled_mask_max_ran: sizes of randoms(ngpt,nlay,ncol) and cloud_frac(ncol,nlay) are inconsistent\" return end if if ( any ([ ncol , nlay - 1 ] /= [ size ( overlap_param , 1 ), size ( overlap_param , 2 )])) then error_msg = \"sampled_mask_max_ran: sizes of randoms(ngpt,nlay,ncol) and overlap_param(ncol,nlay-1) are inconsistent\" return end if if ( any ([ ncol , nlay , ngpt ] /= [ size ( cloud_mask , 1 ), size ( cloud_mask , 2 ), size ( cloud_mask , 3 )])) then error_msg = \"sampled_mask_max_ran: sizes of randoms(ngpt,nlay,ncol) and cloud_mask(ncol,nlay,ngpt) are inconsistent\" return end if if ( any ( cloud_frac > 1._wp ) . or . any ( cloud_frac < 0._wp )) then error_msg = \"sampled_mask_max_ran: cloud fraction values out of range [0,1]\" return end if if ( any ( overlap_param > 1._wp ) . or . any ( overlap_param < - 1._wp )) then error_msg = \"sampled_mask_max_ran: overlap_param values out of range [-1,1]\" return end if ! ! We chould check the random numbers but that would be computationally heavy ! ! ------------------------ ! Construct the cloud mask for each column ! do icol = 1 , ncol cloud_mask_layer ( 1 : nlay ) = cloud_frac ( icol , 1 : nlay ) > 0._wp if (. not . any ( cloud_mask_layer )) then cloud_mask ( icol , 1 : nlay , 1 : ngpt ) = . false . cycle end if cloud_lay_fst = findloc ( cloud_mask_layer , . true ., dim = 1 ) cloud_lay_lst = findloc ( cloud_mask_layer , . true ., dim = 1 , back = . true .) cloud_mask ( icol , 1 : cloud_lay_fst , 1 : ngpt ) = . false . ilay = cloud_lay_fst local_rands ( 1 : ngpt ) = randoms ( 1 : ngpt , ilay , icol ) cloud_mask ( icol , ilay , 1 : ngpt ) = local_rands ( 1 : ngpt ) > ( 1._wp - cloud_frac ( icol , ilay )) do ilay = cloud_lay_fst + 1 , cloud_lay_lst if ( cloud_mask_layer ( ilay )) then ! ! Exponential-random overlap: !   new  random deviates if the adjacent layer isn't cloudy !   correlated  deviates if the adjacent layer is    cloudy ! if ( cloud_mask_layer ( ilay - 1 )) then ! ! Create random deviates correlated between this layer and the previous layer !    (have to remove mean value before enforcing correlation) ! rho = overlap_param ( icol , ilay - 1 ) local_rands ( 1 : ngpt ) = rho * ( local_rands ( 1 : ngpt ) - 0.5_wp ) + & sqrt ( 1._wp - rho * rho ) * ( randoms ( 1 : ngpt , ilay , icol ) - 0.5_wp ) + 0.5_wp else local_rands ( 1 : ngpt ) = randoms ( 1 : ngpt , ilay , icol ) end if cloud_mask ( icol , ilay , 1 : ngpt ) = local_rands ( 1 : ngpt ) > ( 1._wp - cloud_frac ( icol , ilay )) end if end do cloud_mask ( icol , cloud_lay_lst + 1 : nlay , 1 : ngpt ) = . false . end do end function sampled_mask_exp_ran ! ------------------------------------------------------------------------------------------------- ! ! Apply a true/false cloud mask to a homogeneous field !   This could be a kernel ! subroutine apply_cloud_mask ( ncol , nlay , nbnd , ngpt , band_lims_gpt , cloud_mask , input_field , sampled_field ) integer , intent ( in ) :: ncol , nlay , nbnd , ngpt integer , dimension ( 2 , nbnd ), intent ( in ) :: band_lims_gpt logical , dimension ( ncol , nlay , ngpt ), intent ( in ) :: cloud_mask real ( wp ), dimension ( ncol , nlay , nbnd ), intent ( in ) :: input_field real ( wp ), dimension ( ncol , nlay , ngpt ), intent ( out ) :: sampled_field integer :: icol , ilay , ibnd , igpt do ibnd = 1 , nbnd do igpt = band_lims_gpt ( 1 , ibnd ), band_lims_gpt ( 2 , ibnd ) do ilay = 1 , nlay sampled_field ( 1 : ncol , ilay , igpt ) = merge ( input_field ( 1 : ncol , ilay , ibnd ), 0._wp , cloud_mask ( 1 : ncol , ilay , igpt )) end do end do end do end subroutine apply_cloud_mask end module mo_cloud_sampling","tags":"","loc":"sourcefile/mo_cloud_sampling.f90.html"},{"title":"mo_cloud_optics.F90 – rte-rrtmgp","text":"This file depends on sourcefile~~mo_cloud_optics.f90~~EfferentGraph sourcefile~mo_cloud_optics.f90 mo_cloud_optics.F90 sourcefile~mo_rte_kind.f90 mo_rte_kind.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_util_array.f90 mo_rte_util_array.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_cloud_optics.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_util_array.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_rte_config.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_kind.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props_kernels.f90 mo_optical_props_kernels.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_optical_props_kernels.f90 sourcefile~mo_optical_props_kernels.f90->sourcefile~mo_rte_kind.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_cloud_optics Source Code mo_cloud_optics.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-2018,  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! Provides cloud optical properties as a function of effective radius for the RRTMGP bands !   Based on Mie calculations for liquid !     and results from doi:10.1175/JAS-D-12-039.1 for ice with variable surface roughness !   Can use either look-up tables or Pade approximates according to which data has been loaded !   Mike Iacono (AER) is the original author ! ! The class can be used as-is but is also intended as an example of how to extend the RTE framework ! ------------------------------------------------------------------------------------------------- module mo_cloud_optics use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_values , check_extents use mo_rte_util_array , only : any_vals_less_than , any_vals_outside , extents_are use mo_optical_props , only : ty_optical_props , & ty_optical_props_arry , & ty_optical_props_1scl , & ty_optical_props_2str , & ty_optical_props_nstr implicit none interface pade_eval module procedure pade_eval_nbnd , pade_eval_1 end interface pade_eval private ! ----------------------------------------------------------------------------------- type , extends ( ty_optical_props ), public :: ty_cloud_optics private ! ! Ice surface roughness category - needed for Yang (2013) ice optics parameterization ! integer :: icergh = 0 ! (1 = none, 2 = medium, 3 = high) ! ! Lookup table information ! ! Upper and lower limits of the tables real ( wp ) :: radliq_lwr = 0._wp , radliq_upr = 0._wp real ( wp ) :: radice_lwr = 0._wp , radice_upr = 0._wp ! How many steps in the table? (for convenience) integer :: liq_nsteps = 0 , ice_nsteps = 0 ! How big is each step in the table? real ( wp ) :: liq_step_size = 0._wp , ice_step_size = 0._wp ! ! The tables themselves. ! real ( wp ), dimension (:,: ), allocatable :: lut_extliq , lut_ssaliq , lut_asyliq ! (nsize_liq, nbnd) real ( wp ), dimension (:,:,: ), allocatable :: lut_extice , lut_ssaice , lut_asyice ! (nsize_ice, nbnd, nrghice) ! ! Pade approximant coefficients ! real ( wp ), dimension (:,:,: ), allocatable :: pade_extliq ! (nbnd, nsizereg, ncoeff_ext) real ( wp ), dimension (:,:,: ), allocatable :: pade_ssaliq , pade_asyliq ! (nbnd, nsizereg, ncoeff_ssa_g) real ( wp ), dimension (:,:,:,:), allocatable :: pade_extice ! (nbnd, nsizereg, ncoeff_ext, nrghice) real ( wp ), dimension (:,:,:,:), allocatable :: pade_ssaice , pade_asyice ! (nbnd, nsizereg, ncoeff_ssa_g, nrghice) ! Particle size regimes for Pade formulations real ( wp ), dimension (:), allocatable :: pade_sizreg_extliq , pade_sizreg_ssaliq , pade_sizreg_asyliq ! (nbound) real ( wp ), dimension (:), allocatable :: pade_sizreg_extice , pade_sizreg_ssaice , pade_sizreg_asyice ! (nbound) ! ----- contains generic , public :: load => load_lut , load_pade procedure , public :: finalize procedure , public :: cloud_optics procedure , public :: get_min_radius_liq procedure , public :: get_min_radius_ice procedure , public :: get_max_radius_liq procedure , public :: get_max_radius_ice procedure , public :: get_num_ice_roughness_types procedure , public :: set_ice_roughness ! Internal procedures procedure , private :: load_lut procedure , private :: load_pade end type ty_cloud_optics contains ! ------------------------------------------------------------------------------ ! ! Routines to load data needed for cloud optics calculations. Two routines: one to load !    lookup-tables and one for coefficients for Pade approximates ! ! ------------------------------------------------------------------------------ function load_lut ( this , band_lims_wvn , & radliq_lwr , radliq_upr , radliq_fac , & radice_lwr , radice_upr , radice_fac , & lut_extliq , lut_ssaliq , lut_asyliq , & lut_extice , lut_ssaice , lut_asyice ) result ( error_msg ) class ( ty_cloud_optics ), intent ( inout ) :: this real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn ! Spectral discretization ! Lookup table interpolation constants ! Lower and upper bounds of the tables; also the constant for calculating interpolation indices for liquid real ( wp ), intent ( in ) :: radliq_lwr , radliq_upr , radliq_fac real ( wp ), intent ( in ) :: radice_lwr , radice_upr , radice_fac ! LUT coefficients ! Extinction, single-scattering albedo, and asymmetry parameter for liquid and ice respectively real ( wp ), dimension (:,:), intent ( in ) :: lut_extliq , lut_ssaliq , lut_asyliq real ( wp ), dimension (:,:,:), intent ( in ) :: lut_extice , lut_ssaice , lut_asyice character ( len = 128 ) :: error_msg ! ------- ! ! Local variables ! integer :: nbnd , nrghice , nsize_liq , nsize_ice error_msg = this % init ( band_lims_wvn , name = \"RRTMGP cloud optics\" ) ! ! LUT coefficient dimensions ! nsize_liq = size ( lut_extliq , dim = 1 ) nsize_ice = size ( lut_extice , dim = 1 ) nbnd = size ( lut_extliq , dim = 2 ) nrghice = size ( lut_extice , dim = 3 ) ! ! Error checking !   Can we check for consistency between table bounds and _fac? ! if ( nbnd /= this % get_nband ()) & error_msg = \"cloud_optics%init(): number of bands inconsistent between lookup tables, spectral discretization\" if ( size ( lut_extice , 2 ) /= nbnd ) & error_msg = \"cloud_optics%init(): array lut_extice has the wrong number of bands\" if (. not . extents_are ( lut_ssaliq , nsize_liq , nbnd )) & error_msg = \"cloud_optics%init(): array lut_ssaliq isn't consistently sized\" if (. not . extents_are ( lut_asyliq , nsize_liq , nbnd )) & error_msg = \"cloud_optics%init(): array lut_asyliq isn't consistently sized\" if (. not . extents_are ( lut_ssaice , nsize_ice , nbnd , nrghice )) & error_msg = \"cloud_optics%init(): array lut_ssaice  isn't consistently sized\" if (. not . extents_are ( lut_asyice , nsize_ice , nbnd , nrghice )) & error_msg = \"cloud_optics%init(): array lut_asyice  isn't consistently sized\" if ( error_msg /= \"\" ) return this % liq_nsteps = nsize_liq this % ice_nsteps = nsize_ice this % liq_step_size = ( radliq_upr - radliq_lwr ) / real ( nsize_liq - 1 , wp ) this % ice_step_size = ( radice_upr - radice_lwr ) / real ( nsize_ice - 1 , wp ) ! Allocate LUT coefficients allocate ( this % lut_extliq ( nsize_liq , nbnd ), & this % lut_ssaliq ( nsize_liq , nbnd ), & this % lut_asyliq ( nsize_liq , nbnd ), & this % lut_extice ( nsize_ice , nbnd , nrghice ), & this % lut_ssaice ( nsize_ice , nbnd , nrghice ), & this % lut_asyice ( nsize_ice , nbnd , nrghice )) !$acc enter data create(this)                                               & !$acc            create(this%lut_extliq, this%lut_ssaliq, this%lut_asyliq)  & !$acc            create(this%lut_extice, this%lut_ssaice, this%lut_asyice) !$omp target enter data & !$omp map(alloc:this%lut_extliq, this%lut_ssaliq, this%lut_asyliq) & !$omp map(alloc:this%lut_extice, this%lut_ssaice, this%lut_asyice) ! Load LUT constants this % radliq_lwr = radliq_lwr this % radliq_upr = radliq_upr this % radice_lwr = radice_lwr this % radice_upr = radice_upr ! Load LUT coefficients !$acc kernels !$omp target this % lut_extliq = lut_extliq this % lut_ssaliq = lut_ssaliq this % lut_asyliq = lut_asyliq this % lut_extice = lut_extice this % lut_ssaice = lut_ssaice this % lut_asyice = lut_asyice !$acc end kernels !$omp end target ! ! Set default ice roughness - min values ! error_msg = this % set_ice_roughness ( 1 ) end function load_lut ! ------------------------------------------------------------------------------ ! ! Cloud optics initialization function - Pade ! ! ------------------------------------------------------------------------------ function load_pade ( this , band_lims_wvn , & pade_extliq , pade_ssaliq , pade_asyliq , & pade_extice , pade_ssaice , pade_asyice , & pade_sizreg_extliq , pade_sizreg_ssaliq , pade_sizreg_asyliq , & pade_sizreg_extice , pade_sizreg_ssaice , pade_sizreg_asyice ) & result ( error_msg ) class ( ty_cloud_optics ), intent ( inout ) :: this ! cloud specification data real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn ! Spectral discretization ! ! Pade coefficients: extinction, single-scattering albedo, and asymmetry factor for liquid and ice ! real ( wp ), dimension (:,:,:), intent ( in ) :: pade_extliq , pade_ssaliq , pade_asyliq real ( wp ), dimension (:,:,:,:), intent ( in ) :: pade_extice , pade_ssaice , pade_asyice ! ! Boundaries of size regimes. Liquid and ice are separate; !   extinction is fit to different numbers of size bins than single-scattering albedo and asymmetry factor ! real ( wp ), dimension (:), intent ( in ) :: pade_sizreg_extliq , pade_sizreg_ssaliq , pade_sizreg_asyliq real ( wp ), dimension (:), intent ( in ) :: pade_sizreg_extice , pade_sizreg_ssaice , pade_sizreg_asyice character ( len = 128 ) :: error_msg ! ------- Local ------- integer :: nbnd , nrghice , nsizereg , ncoeff_ext , ncoeff_ssa_g , nbound ! ------- Definitions ------- ! Pade coefficient dimensions nbnd = size ( pade_extliq , dim = 1 ) nsizereg = size ( pade_extliq , dim = 2 ) ncoeff_ext = size ( pade_extliq , dim = 3 ) ncoeff_ssa_g = size ( pade_ssaliq , dim = 3 ) nrghice = size ( pade_extice , dim = 4 ) nbound = size ( pade_sizreg_extliq ) ! The number of size regimes is assumed in the Pade evaluations if ( nsizereg /= 3 ) & error_msg = \"cloud optics: code assumes exactly three size regimes for Pade approximants but data is otherwise\" error_msg = this % init ( band_lims_wvn , name = \"RRTMGP cloud optics\" ) ! ! Error checking ! if ( nbnd /= this % get_nband ()) & error_msg = \"cloud_optics%init(): number of bands inconsistent between lookup tables, spectral discretization\" if (. not . extents_are ( pade_ssaliq , nbnd , nsizereg , ncoeff_ssa_g )) & error_msg = \"cloud_optics%init(): array pade_ssaliq isn't consistently sized\" if (. not . extents_are ( pade_asyliq , nbnd , nsizereg , ncoeff_ssa_g )) & error_msg = \"cloud_optics%init(): array pade_asyliq isn't consistently sized\" if (. not . extents_are ( pade_extice , nbnd , nsizereg , ncoeff_ext , nrghice )) & error_msg = \"cloud_optics%init(): array pade_extice isn't consistently sized\" if (. not . extents_are ( pade_ssaice , nbnd , nsizereg , ncoeff_ssa_g , nrghice )) & error_msg = \"cloud_optics%init(): array pade_ssaice isn't consistently sized\" if (. not . extents_are ( pade_asyice , nbnd , nsizereg , ncoeff_ssa_g , nrghice )) & error_msg = \"cloud_optics%init(): array pade_asyice isn't consistently sized\" if ( any ([ size ( pade_sizreg_ssaliq ), size ( pade_sizreg_asyliq ), & size ( pade_sizreg_extice ), size ( pade_sizreg_ssaice ), size ( pade_sizreg_asyice )] /= nbound )) & error_msg = \"cloud_optics%init(): one or more Pade size regime arrays are inconsistently sized\" if ( nsizereg /= 3 ) & error_msg = \"cloud_optics%init(): Expecting precisely three size regimes for Pade approximants\" if ( error_msg /= \"\" ) return ! ! Consistency among size regimes ! this % radliq_lwr = pade_sizreg_extliq ( 1 ) this % radliq_upr = pade_sizreg_extliq ( nbound ) this % radice_lwr = pade_sizreg_extice ( 1 ) this % radice_upr = pade_sizreg_extice ( nbound ) if ( error_msg /= \"\" ) return if ( any ([ pade_sizreg_ssaliq ( 1 ), pade_sizreg_asyliq ( 1 )] < this % radliq_lwr )) & error_msg = \"cloud_optics%init(): one or more Pade size regimes have inconsistent lowest values\" if ( any ([ pade_sizreg_ssaice ( 1 ), pade_sizreg_asyice ( 1 )] < this % radice_lwr )) & error_msg = \"cloud_optics%init(): one or more Pade size regimes have inconsistent lower values\" if ( any ([ pade_sizreg_ssaliq ( nbound ), pade_sizreg_asyliq ( nbound )] > this % radliq_upr )) & error_msg = \"cloud_optics%init(): one or more Pade size regimes have lowest value less than radliq_upr\" if ( any ([ pade_sizreg_ssaice ( nbound ), pade_sizreg_asyice ( nbound )] > this % radice_upr )) & error_msg = \"cloud_optics%init(): one or more Pade size regimes have lowest value less than radice_upr\" if ( error_msg /= \"\" ) return ! ! Allocate Pade coefficients ! allocate ( this % pade_extliq ( nbnd , nsizereg , ncoeff_ext ), & this % pade_ssaliq ( nbnd , nsizereg , ncoeff_ssa_g ), & this % pade_asyliq ( nbnd , nsizereg , ncoeff_ssa_g ), & this % pade_extice ( nbnd , nsizereg , ncoeff_ext , nrghice ), & this % pade_ssaice ( nbnd , nsizereg , ncoeff_ssa_g , nrghice ), & this % pade_asyice ( nbnd , nsizereg , ncoeff_ssa_g , nrghice )) ! ! Allocate Pade coefficient particle size regime boundaries ! allocate ( this % pade_sizreg_extliq ( nbound ), & this % pade_sizreg_ssaliq ( nbound ), & this % pade_sizreg_asyliq ( nbound ), & this % pade_sizreg_extice ( nbound ), & this % pade_sizreg_ssaice ( nbound ), & this % pade_sizreg_asyice ( nbound )) !$acc enter data create(this)                                                                       & !$acc            create(this%pade_extliq, this%pade_ssaliq, this%pade_asyliq)                       & !$acc            create(this%pade_extice, this%pade_ssaice, this%pade_asyice)                       & !$acc            create(this%pade_sizreg_extliq, this%pade_sizreg_ssaliq, this%pade_sizreg_asyliq)  & !$acc            create(this%pade_sizreg_extice, this%pade_sizreg_ssaice, this%pade_sizreg_asyice) !$omp target enter data & !$omp map(alloc:this%pade_extliq, this%pade_ssaliq, this%pade_asyliq) & !$omp map(alloc:this%pade_extice, this%pade_ssaice, this%pade_asyice) & !$omp map(alloc:this%pade_sizreg_extliq, this%pade_sizreg_ssaliq, this%pade_sizreg_asyliq) & !$omp map(alloc:this%pade_sizreg_extice, this%pade_sizreg_ssaice, this%pade_sizreg_asyice) ! ! Load data ! !$acc kernels !$omp target this % pade_extliq = pade_extliq this % pade_ssaliq = pade_ssaliq this % pade_asyliq = pade_asyliq this % pade_extice = pade_extice this % pade_ssaice = pade_ssaice this % pade_asyice = pade_asyice this % pade_sizreg_extliq = pade_sizreg_extliq this % pade_sizreg_ssaliq = pade_sizreg_ssaliq this % pade_sizreg_asyliq = pade_sizreg_asyliq this % pade_sizreg_extice = pade_sizreg_extice this % pade_sizreg_ssaice = pade_sizreg_ssaice this % pade_sizreg_asyice = pade_sizreg_asyice !$acc end kernels !$omp end target ! ! Set default ice roughness - min values ! error_msg = this % set_ice_roughness ( 1 ) end function load_pade !-------------------------------------------------------------------------------------------------------------------- ! ! Finalize ! !-------------------------------------------------------------------------------------------------------------------- subroutine finalize ( this ) class ( ty_cloud_optics ), intent ( inout ) :: this this % radliq_lwr = 0._wp this % radliq_upr = 0._wp this % radice_lwr = 0._wp this % radice_upr = 0._wp ! Lookup table cloud optics coefficients if ( allocated ( this % lut_extliq )) then !$acc exit data delete(this%lut_extliq, this%lut_ssaliq, this%lut_asyliq)  & !$acc           delete(this%lut_extice, this%lut_ssaice, this%lut_asyice)  & !$acc           delete(this) !$omp target exit data map(release:this%lut_extliq, this%lut_ssaliq, this%lut_asyliq) & !$omp map(release:this%lut_extice, this%lut_ssaice, this%lut_asyice) deallocate ( this % lut_extliq , this % lut_ssaliq , this % lut_asyliq , & this % lut_extice , this % lut_ssaice , this % lut_asyice ) this % liq_nsteps = 0 this % ice_nsteps = 0 this % liq_step_size = 0._wp this % ice_step_size = 0._wp end if ! Pade cloud optics coefficients if ( allocated ( this % pade_extliq )) then !$acc exit data delete(this%pade_extliq, this%pade_ssaliq, this%pade_asyliq)                       & !$acc           delete(this%pade_extice, this%pade_ssaice, this%pade_asyice)                       & !$acc           delete(this%pade_sizreg_extliq, this%pade_sizreg_ssaliq, this%pade_sizreg_asyliq)  & !$acc           delete(this%pade_sizreg_extice, this%pade_sizreg_ssaice, this%pade_sizreg_asyice)  & !$acc           delete(this) !$omp target exit data map(release:this%pade_extliq, this%pade_ssaliq, this%pade_asyliq) & !$omp map(release:this%pade_extice, this%pade_ssaice, this%pade_asyice) & !$omp map(release:this%pade_sizreg_extliq, this%pade_sizreg_ssaliq, this%pade_sizreg_asyliq) & !$omp map(release:this%pade_sizreg_extice, this%pade_sizreg_ssaice, this%pade_sizreg_asyice) deallocate ( this % pade_extliq , this % pade_ssaliq , this % pade_asyliq , & this % pade_extice , this % pade_ssaice , this % pade_asyice , & this % pade_sizreg_extliq , this % pade_sizreg_ssaliq , this % pade_sizreg_asyliq , & this % pade_sizreg_extice , this % pade_sizreg_ssaice , this % pade_sizreg_asyice ) end if end subroutine finalize ! ------------------------------------------------------------------------------ ! ! Derive cloud optical properties from provided cloud physical properties ! ! ------------------------------------------------------------------------------ ! ! Compute single-scattering properties ! function cloud_optics ( this , & clwp , ciwp , reliq , reice , & optical_props ) result ( error_msg ) class ( ty_cloud_optics ), & intent ( in ) :: this real ( wp ), intent ( in ) :: clwp (:,:), & ! cloud liquid water path (g/m2) ciwp (:,:), & ! cloud ice water path    (g/m2) reliq (:,:), & ! cloud liquid particle effective size (microns) reice (:,:) ! cloud ice particle effective radius  (microns) class ( ty_optical_props_arry ), & intent ( inout ) :: optical_props ! Dimensions: (ncol,nlay,nbnd) character ( len = 128 ) :: error_msg ! ------- Local ------- logical ( wl ), dimension ( size ( clwp , 1 ), size ( clwp , 2 )) :: liqmsk , icemsk real ( wp ), dimension ( size ( clwp , 1 ), size ( clwp , 2 ), this % get_nband ()) :: & ltau , ltaussa , ltaussag , itau , itaussa , itaussag ! Optical properties: tau, tau*ssa, tau*ssa*g ! liquid and ice separately integer :: ncol , nlay , nbnd integer :: nsizereg integer :: icol , ilay , ibnd ! scalars for total tau, tau*ssa real ( wp ) :: tau , taussa ! ---------------------------------------- ! ! Error checking ! ! ---------------------------------------- error_msg = '' if (. not .( allocated ( this % lut_extliq ) . or . allocated ( this % pade_extliq ))) then error_msg = 'cloud optics: no data has been initialized' return end if ncol = size ( clwp , 1 ) nlay = size ( clwp , 2 ) nbnd = this % get_nband () ! ! Array sizes ! if ( check_extents ) then if ( size ( liqmsk , 1 ) /= ncol . or . size ( liqmsk , 2 ) /= nlay ) & error_msg = \"cloud optics: liqmask has wrong extents\" if ( size ( icemsk , 1 ) /= ncol . or . size ( icemsk , 2 ) /= nlay ) & error_msg = \"cloud optics: icemsk has wrong extents\" if ( size ( ciwp , 1 ) /= ncol . or . size ( ciwp , 2 ) /= nlay ) & error_msg = \"cloud optics: ciwp has wrong extents\" if ( size ( reliq , 1 ) /= ncol . or . size ( reliq , 2 ) /= nlay ) & error_msg = \"cloud optics: reliq has wrong extents\" if ( size ( reice , 1 ) /= ncol . or . size ( reice , 2 ) /= nlay ) & error_msg = \"cloud optics: reice has wrong extents\" if ( optical_props % get_ncol () /= ncol . or . optical_props % get_nlay () /= nlay ) & error_msg = \"cloud optics: optical_props have wrong extents\" if ( error_msg /= \"\" ) return end if ! ! Spectral consistency ! if ( check_values ) then if (. not . this % bands_are_equal ( optical_props )) & error_msg = \"cloud optics: optical properties don't have the same band structure\" if ( optical_props % get_nband () /= optical_props % get_ngpt () ) & error_msg = \"cloud optics: optical properties must be requested by band not g-points\" if ( error_msg /= \"\" ) return end if !$acc data copyin(clwp, ciwp, reliq, reice)                         & !$acc      create(ltau, ltaussa, ltaussag, itau, itaussa, itaussag) & !$acc      create(liqmsk,icemsk) !$omp target data map(to:clwp, ciwp, reliq, reice) & !$omp map(alloc:ltau, ltaussa, ltaussag, itau, itaussa, itaussag) & !$omp map(alloc:liqmsk, icemsk) ! ! Cloud masks; don't need value re values if there's no cloud ! !$acc parallel loop gang vector default(none) collapse(2) !$omp target teams distribute parallel do simd collapse(2) do ilay = 1 , nlay do icol = 1 , ncol liqmsk ( icol , ilay ) = clwp ( icol , ilay ) > 0._wp icemsk ( icol , ilay ) = ciwp ( icol , ilay ) > 0._wp end do end do ! ! Particle size, liquid/ice water paths ! if ( check_values ) then if ( any_vals_outside ( reliq , liqmsk , this % radliq_lwr , this % radliq_upr )) & error_msg = 'cloud optics: liquid effective radius is out of bounds' if ( any_vals_outside ( reice , icemsk , this % radice_lwr , this % radice_upr )) & error_msg = 'cloud optics: ice effective radius is out of bounds' if ( any_vals_less_than ( clwp , liqmsk , 0._wp ) . or . any_vals_less_than ( ciwp , icemsk , 0._wp )) & error_msg = 'cloud optics: negative clwp or ciwp where clouds are supposed to be' end if if ( error_msg == \"\" ) then ! ! ! ---------------------------------------- ! ! The tables and Pade coefficients determing extinction coeffient, single-scattering albedo, !   and asymmetry parameter g as a function of effective raduis ! We compute the optical depth tau (=exintinction coeff * condensed water path) !   and the products tau*ssa and tau*ssa*g for liquid and ice cloud separately. ! These are used to determine the optical properties of ice and water cloud together. ! We could compute the properties for liquid and ice separately and !    use ty_optical_props_arry%increment but this involves substantially more division. ! if ( allocated ( this % lut_extliq )) then ! ! Liquid ! call compute_all_from_table ( ncol , nlay , nbnd , liqmsk , clwp , reliq , & this % liq_nsteps , this % liq_step_size , this % radliq_lwr , & this % lut_extliq , this % lut_ssaliq , this % lut_asyliq , & ltau , ltaussa , ltaussag ) ! ! Ice ! call compute_all_from_table ( ncol , nlay , nbnd , icemsk , ciwp , reice , & this % ice_nsteps , this % ice_step_size , this % radice_lwr , & this % lut_extice (:,:, this % icergh ), & this % lut_ssaice (:,:, this % icergh ), & this % lut_asyice (:,:, this % icergh ), & itau , itaussa , itaussag ) else ! ! Cloud optical properties from Pade coefficient method !   Hard coded assumptions: order of approximants, three size regimes ! nsizereg = size ( this % pade_extliq , 2 ) call compute_all_from_pade ( ncol , nlay , nbnd , nsizereg , & liqmsk , clwp , reliq , & 2 , 3 , this % pade_sizreg_extliq , this % pade_extliq , & 2 , 2 , this % pade_sizreg_ssaliq , this % pade_ssaliq , & 2 , 2 , this % pade_sizreg_asyliq , this % pade_asyliq , & ltau , ltaussa , ltaussag ) call compute_all_from_pade ( ncol , nlay , nbnd , nsizereg , & icemsk , ciwp , reice , & 2 , 3 , this % pade_sizreg_extice , this % pade_extice (:,:,:, this % icergh ), & 2 , 2 , this % pade_sizreg_ssaice , this % pade_ssaice (:,:,:, this % icergh ), & 2 , 2 , this % pade_sizreg_asyice , this % pade_asyice (:,:,:, this % icergh ), & itau , itaussa , itaussag ) endif ! ! Combine liquid and ice contributions into total cloud optical properties !   See also the increment routines in mo_optical_props_kernels ! select type ( optical_props ) type is ( ty_optical_props_1scl ) !$acc parallel loop gang vector default(none) collapse(3) & !$acc               copyin(optical_props) copyout(optical_props%tau) !$omp target teams distribute parallel do simd collapse(3) & !$omp map(from:optical_props%tau) do ibnd = 1 , nbnd do ilay = 1 , nlay do icol = 1 , ncol ! Absorption optical depth  = (1-ssa) * tau = tau - taussa optical_props % tau ( icol , ilay , ibnd ) = ( ltau ( icol , ilay , ibnd ) - ltaussa ( icol , ilay , ibnd )) + & ( itau ( icol , ilay , ibnd ) - itaussa ( icol , ilay , ibnd )) end do end do end do type is ( ty_optical_props_2str ) !$acc parallel loop gang vector default(none) collapse(3) & !$acc               copyin(optical_props) copyout(optical_props%tau, optical_props%ssa, optical_props%g) !$omp target teams distribute parallel do simd collapse(3) & !$omp map(from:optical_props%tau, optical_props%ssa, optical_props%g) do ibnd = 1 , nbnd do ilay = 1 , nlay do icol = 1 , ncol tau = ltau ( icol , ilay , ibnd ) + itau ( icol , ilay , ibnd ) taussa = ltaussa ( icol , ilay , ibnd ) + itaussa ( icol , ilay , ibnd ) optical_props % g ( icol , ilay , ibnd ) = ( ltaussag ( icol , ilay , ibnd ) + itaussag ( icol , ilay , ibnd )) / & max ( epsilon ( tau ), taussa ) optical_props % ssa ( icol , ilay , ibnd ) = taussa / max ( epsilon ( tau ), tau ) optical_props % tau ( icol , ilay , ibnd ) = tau end do end do end do type is ( ty_optical_props_nstr ) error_msg = \"cloud optics: n-stream calculations not yet supported\" end select end if !$acc end data !$omp end target data end function cloud_optics !-------------------------------------------------------------------------------------------------------------------- ! ! Inquiry functions ! !-------------------------------------------------------------------------------------------------------------------- function set_ice_roughness ( this , icergh ) result ( error_msg ) class ( ty_cloud_optics ), intent ( inout ) :: this integer , intent ( in ) :: icergh character ( len = 128 ) :: error_msg error_msg = \"\" if (. not . allocated ( this % pade_extice ) . and . . not . allocated ( this % lut_extice )) & error_msg = \"cloud_optics%set_ice_roughness(): can't set before initialization\" if ( icergh < 1 . or . icergh > this % get_num_ice_roughness_types ()) & error_msg = 'cloud optics: cloud ice surface roughness flag is out of bounds' if ( error_msg /= \"\" ) return this % icergh = icergh end function set_ice_roughness !----------------------------------------------- function get_num_ice_roughness_types ( this ) result ( i ) class ( ty_cloud_optics ), intent ( in ) :: this integer :: i i = 0 if ( allocated ( this % pade_extice )) i = size ( this % pade_extice , dim = 4 ) if ( allocated ( this % lut_extice )) i = size ( this % lut_extice , dim = 3 ) end function get_num_ice_roughness_types !----------------------------------------------- function get_min_radius_liq ( this ) result ( r ) class ( ty_cloud_optics ), intent ( in ) :: this real ( wp ) :: r r = this % radliq_lwr end function get_min_radius_liq !----------------------------------------------- function get_max_radius_liq ( this ) result ( r ) class ( ty_cloud_optics ), intent ( in ) :: this real ( wp ) :: r r = this % radliq_upr end function get_max_radius_liq !----------------------------------------------- function get_min_radius_ice ( this ) result ( r ) class ( ty_cloud_optics ), intent ( in ) :: this real ( wp ) :: r r = this % radice_lwr end function get_min_radius_ice !----------------------------------------------- function get_max_radius_ice ( this ) result ( r ) class ( ty_cloud_optics ), intent ( in ) :: this real ( wp ) :: r r = this % radice_upr end function get_max_radius_ice !-------------------------------------------------------------------------------------------------------------------- ! ! Ancillary functions ! !-------------------------------------------------------------------------------------------------------------------- ! ! Linearly interpolate values from a lookup table with \"nsteps\" evenly-spaced !   elements starting at \"offset.\" The table's second dimension is band. ! Returns 0 where the mask is false. ! We could also try gather/scatter for efficiency ! subroutine compute_all_from_table ( ncol , nlay , nbnd , mask , lwp , re , & nsteps , step_size , offset , & tau_table , ssa_table , asy_table , & tau , taussa , taussag ) integer , intent ( in ) :: ncol , nlay , nbnd , nsteps logical ( wl ), dimension ( ncol , nlay ), intent ( in ) :: mask real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: lwp , re real ( wp ), intent ( in ) :: step_size , offset real ( wp ), dimension ( nsteps , nbnd ), intent ( in ) :: tau_table , ssa_table , asy_table real ( wp ), dimension ( ncol , nlay , nbnd ) :: tau , taussa , taussag ! --------------------------- integer :: icol , ilay , ibnd integer :: index real ( wp ) :: fint real ( wp ) :: t , ts ! tau, tau*ssa, tau*ssa*g ! --------------------------- !$acc parallel loop gang vector default(present) collapse(3) !$omp target teams distribute parallel do simd collapse(3) do ibnd = 1 , nbnd do ilay = 1 , nlay do icol = 1 , ncol if ( mask ( icol , ilay )) then index = min ( floor (( re ( icol , ilay ) - offset ) / step_size ) + 1 , nsteps - 1 ) fint = ( re ( icol , ilay ) - offset ) / step_size - ( index - 1 ) t = lwp ( icol , ilay ) * & ( tau_table ( index , ibnd ) + fint * ( tau_table ( index + 1 , ibnd ) - tau_table ( index , ibnd ))) ts = t * & ( ssa_table ( index , ibnd ) + fint * ( ssa_table ( index + 1 , ibnd ) - ssa_table ( index , ibnd ))) taussag ( icol , ilay , ibnd ) = & ts * & ( asy_table ( index , ibnd ) + fint * ( asy_table ( index + 1 , ibnd ) - asy_table ( index , ibnd ))) taussa ( icol , ilay , ibnd ) = ts tau ( icol , ilay , ibnd ) = t else tau ( icol , ilay , ibnd ) = 0._wp taussa ( icol , ilay , ibnd ) = 0._wp taussag ( icol , ilay , ibnd ) = 0._wp end if end do end do end do end subroutine compute_all_from_table ! ! Pade functions ! !--------------------------------------------------------------------------- subroutine compute_all_from_pade ( ncol , nlay , nbnd , nsizes , & mask , lwp , re , & m_ext , n_ext , re_bounds_ext , coeffs_ext , & m_ssa , n_ssa , re_bounds_ssa , coeffs_ssa , & m_asy , n_asy , re_bounds_asy , coeffs_asy , & tau , taussa , taussag ) integer , intent ( in ) :: ncol , nlay , nbnd , nsizes logical ( wl ), & dimension ( ncol , nlay ), intent ( in ) :: mask real ( wp ), dimension ( ncol , nlay ), intent ( in ) :: lwp , re real ( wp ), dimension ( nsizes + 1 ), intent ( in ) :: re_bounds_ext , re_bounds_ssa , re_bounds_asy integer , intent ( in ) :: m_ext , n_ext real ( wp ), dimension ( nbnd , nsizes , 0 : m_ext + n_ext ), & intent ( in ) :: coeffs_ext integer , intent ( in ) :: m_ssa , n_ssa real ( wp ), dimension ( nbnd , nsizes , 0 : m_ssa + n_ssa ), & intent ( in ) :: coeffs_ssa integer , intent ( in ) :: m_asy , n_asy real ( wp ), dimension ( nbnd , nsizes , 0 : m_asy + n_asy ), & intent ( in ) :: coeffs_asy real ( wp ), dimension ( ncol , nlay , nbnd ) :: tau , taussa , taussag ! --------------------------- integer :: icol , ilay , ibnd , irad real ( wp ) :: t , ts !$acc parallel loop gang vector default(present) collapse(3) !$omp target teams distribute parallel do simd collapse(3) do ibnd = 1 , nbnd do ilay = 1 , nlay do icol = 1 , ncol if ( mask ( icol , ilay )) then ! ! Finds index into size regime table ! This works only if there are precisely three size regimes (four bounds) and it's !   previously guaranteed that size_bounds(1) <= size <= size_bounds(4) ! irad = min ( floor (( re ( icol , ilay ) - re_bounds_ext ( 2 )) / re_bounds_ext ( 3 )) + 2 , 3 ) t = lwp ( icol , ilay ) * & pade_eval ( ibnd , nbnd , nsizes , m_ext , n_ext , irad , re ( icol , ilay ), coeffs_ext ) irad = min ( floor (( re ( icol , ilay ) - re_bounds_ssa ( 2 )) / re_bounds_ssa ( 3 )) + 2 , 3 ) ! Pade approximants for co-albedo can sometimes be negative ts = t * ( 1._wp - max ( 0._wp , & pade_eval ( ibnd , nbnd , nsizes , m_ssa , n_ssa , irad , re ( icol , ilay ), coeffs_ssa ))) irad = min ( floor (( re ( icol , ilay ) - re_bounds_asy ( 2 )) / re_bounds_asy ( 3 )) + 2 , 3 ) taussag ( icol , ilay , ibnd ) = & ts * & pade_eval ( ibnd , nbnd , nsizes , m_asy , n_asy , irad , re ( icol , ilay ), coeffs_asy ) taussa ( icol , ilay , ibnd ) = ts tau ( icol , ilay , ibnd ) = t else tau ( icol , ilay , ibnd ) = 0._wp taussa ( icol , ilay , ibnd ) = 0._wp taussag ( icol , ilay , ibnd ) = 0._wp end if end do end do end do end subroutine compute_all_from_pade !--------------------------------------------------------------------------- ! ! Evaluate Pade approximant of order [m/n] ! function pade_eval_nbnd ( nbnd , nrads , m , n , irad , re , pade_coeffs ) integer , intent ( in ) :: nbnd , nrads , m , n , irad real ( wp ), dimension ( nbnd , nrads , 0 : m + n ), & intent ( in ) :: pade_coeffs real ( wp ), intent ( in ) :: re real ( wp ), dimension ( nbnd ) :: pade_eval_nbnd integer :: iband real ( wp ) :: numer , denom integer :: i do iband = 1 , nbnd denom = pade_coeffs ( iband , irad , n + m ) do i = n - 1 + m , 1 + m , - 1 denom = pade_coeffs ( iband , irad , i ) + re * denom end do denom = 1._wp + re * denom numer = pade_coeffs ( iband , irad , m ) do i = m - 1 , 1 , - 1 numer = pade_coeffs ( iband , irad , i ) + re * numer end do numer = pade_coeffs ( iband , irad , 0 ) + re * numer pade_eval_nbnd ( iband ) = numer / denom end do end function pade_eval_nbnd !--------------------------------------------------------------------------- ! ! Evaluate Pade approximant of order [m/n] ! function pade_eval_1 ( iband , nbnd , nrads , m , n , irad , re , pade_coeffs ) !$acc routine seq !$omp declare target ! integer , intent ( in ) :: iband , nbnd , nrads , m , n , irad real ( wp ), dimension ( nbnd , nrads , 0 : m + n ), & intent ( in ) :: pade_coeffs real ( wp ), intent ( in ) :: re real ( wp ) :: pade_eval_1 real ( wp ) :: numer , denom integer :: i denom = pade_coeffs ( iband , irad , n + m ) do i = n - 1 + m , 1 + m , - 1 denom = pade_coeffs ( iband , irad , i ) + re * denom end do denom = 1._wp + re * denom numer = pade_coeffs ( iband , irad , m ) do i = m - 1 , 1 , - 1 numer = pade_coeffs ( iband , irad , i ) + re * numer end do numer = pade_coeffs ( iband , irad , 0 ) + re * numer pade_eval_1 = numer / denom end function pade_eval_1 end module mo_cloud_optics","tags":"","loc":"sourcefile/mo_cloud_optics.f90.html"},{"title":"ty_fluxes – rte-rrtmgp ","text":"type, public, abstract :: ty_fluxes Inherited by type~~ty_fluxes~~InheritedByGraph type~ty_fluxes ty_fluxes type~ty_fluxes_1lev ty_fluxes_1lev type~ty_fluxes_1lev->type~ty_fluxes type~ty_fluxes_broadband ty_fluxes_broadband type~ty_fluxes_broadband->type~ty_fluxes type~ty_fluxes_bygpoint ty_fluxes_bygpoint type~ty_fluxes_bygpoint->type~ty_fluxes type~ty_fluxes_byband ty_fluxes_byband type~ty_fluxes_byband->type~ty_fluxes_broadband Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures are_desired reduce Type-Bound Procedures procedure(are_desired_abstract), public, deferred :: are_desired function are_desired_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_fluxes ), intent(in) :: this Return Value logical procedure(reduce_abstract), public, deferred :: reduce function reduce_abstract(this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Prototype Arguments Type Intent Optional Attributes Name class( ty_fluxes ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"type/ty_fluxes.html"},{"title":"ty_fluxes_broadband – rte-rrtmgp ","text":"type, public, extends( ty_fluxes ) :: ty_fluxes_broadband Inherits type~~ty_fluxes_broadband~~InheritsGraph type~ty_fluxes_broadband ty_fluxes_broadband type~ty_fluxes ty_fluxes type~ty_fluxes_broadband->type~ty_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~ty_fluxes_broadband~~InheritedByGraph type~ty_fluxes_broadband ty_fluxes_broadband type~ty_fluxes_byband ty_fluxes_byband type~ty_fluxes_byband->type~ty_fluxes_broadband Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures are_desired reduce Type-Bound Procedures procedure, public :: are_desired => are_desired_broadband private function are_desired_broadband(this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_broadband ), intent(in) :: this Return Value logical procedure, public :: reduce => reduce_broadband private function reduce_broadband(this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_broadband ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"type/ty_fluxes_broadband.html"},{"title":"ty_optical_props – rte-rrtmgp ","text":"type, public :: ty_optical_props Base class for optical properties\n  Describes the spectral discretization including the wavenumber limits\n  of each band (spectral region) and the mapping between g-points and bands Inherited by type~~ty_optical_props~~InheritedByGraph type~ty_optical_props ty_optical_props type~ty_source_func_lw ty_source_func_lw type~ty_source_func_lw->type~ty_optical_props type~ty_gas_optics ty_gas_optics type~ty_gas_optics->type~ty_optical_props type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_arry->type~ty_optical_props type~ty_source_func_sw ty_source_func_sw type~ty_source_func_sw->type~ty_optical_props type~ty_cloud_optics ty_cloud_optics type~ty_cloud_optics->type~ty_optical_props type~ty_optical_props_nstr ty_optical_props_nstr type~ty_optical_props_nstr->type~ty_optical_props_arry type~ty_gas_optics_rrtmgp ty_gas_optics_rrtmgp type~ty_gas_optics_rrtmgp->type~ty_gas_optics type~ty_optical_props_1scl ty_optical_props_1scl type~ty_optical_props_1scl->type~ty_optical_props_arry type~ty_optical_props_2str ty_optical_props_2str type~ty_optical_props_2str->type~ty_optical_props_arry Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name Type-Bound Procedures bands_are_equal convert_band2gpt convert_gpt2band expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ngpt gpoints_are_equal init is_initialized set_name Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name","tags":"","loc":"type/ty_optical_props.html"},{"title":"ty_optical_props_1scl – rte-rrtmgp ","text":"type, public, extends( ty_optical_props_arry ) :: ty_optical_props_1scl ty_optical_props_arry  includes only (extinction) optical depth\n   Class two-stream adds arrays for single scattering albedo ssa and\n     asymmetry parameter needed in two-stream methods\n   Class n-stream adds arrays for single scattering albedo ssa and\n     phase function moments (index 1 = g) for use with discrete ordinate methods Inherits type~~ty_optical_props_1scl~~InheritsGraph type~ty_optical_props_1scl ty_optical_props_1scl type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_1scl->type~ty_optical_props_arry type~ty_optical_props ty_optical_props type~ty_optical_props_arry->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name tau Type-Bound Procedures alloc_1scl bands_are_equal convert_band2gpt convert_gpt2band delta_scale expand finalize finalize_1scl get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_subset gpoints_are_equal increment init is_initialized set_name validate Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_1scl => alloc_only_1scl, init_and_alloc_1scl, copy_and_alloc_1scl public function alloc_only_1scl (this, ncol, nlay) result(err_message) Straight allocation routines Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function init_and_alloc_1scl (this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Initialization by specifying band limits and possibly g-point/band mapping Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function copy_and_alloc_1scl (this, ncol, nlay, spectral_desc, name) result(err_message) Initialization from an existing spectral discretization/ty_optical_props Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: delta_scale => delta_scale_1scl public function delta_scale_1scl (this, for) result(err_message) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: finalize_1scl public function finalize_1scl (this) result(err_message) Finalize routines Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this Return Value character(len=128) procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol public pure function get_ncol (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay public pure function get_nlay (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_subset => subset_1scl_range public function subset_1scl_range (full, start, n, subset) result(err_message) Routines for array classes: subsetting of optical properties arrays along x (col) direction Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: increment Increment another set of values public function increment (op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure, public :: validate => validate_1scalar public function validate_1scalar (this) result(err_message) --- Validation Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(in) :: this Return Value character(len=128)","tags":"","loc":"type/ty_optical_props_1scl.html"},{"title":"ty_optical_props_2str – rte-rrtmgp ","text":"type, public, extends( ty_optical_props_arry ) :: ty_optical_props_2str Inherits type~~ty_optical_props_2str~~InheritsGraph type~ty_optical_props_2str ty_optical_props_2str type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_2str->type~ty_optical_props_arry type~ty_optical_props ty_optical_props type~ty_optical_props_arry->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn g gpt2band name ssa tau Type-Bound Procedures alloc_2str bands_are_equal convert_band2gpt convert_gpt2band delta_scale expand finalize finalize_2str get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_subset gpoints_are_equal increment init is_initialized set_name validate Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) real(kind=wp), public, dimension(:,:,:), allocatable :: g asymmetry parameter (ncol, nlay, ngpt) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:), allocatable :: ssa single-scattering albedo (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_2str => alloc_only_2str, init_and_alloc_2str, copy_and_alloc_2str public function alloc_only_2str (this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function init_and_alloc_2str (this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function copy_and_alloc_2str (this, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: delta_scale => delta_scale_2str public function delta_scale_2str (this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Forward scattering fraction; g**2 if not provided Return Value character(len=128) procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: finalize_2str public function finalize_2str (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this Return Value character(len=128) procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol public pure function get_ncol (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay public pure function get_nlay (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_subset => subset_2str_range public function subset_2str_range (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: increment Increment another set of values public function increment (op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure, public :: validate => validate_2stream public function validate_2stream (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(in) :: this Return Value character(len=128)","tags":"","loc":"type/ty_optical_props_2str.html"},{"title":"ty_optical_props_arry – rte-rrtmgp ","text":"type, public, abstract, extends( ty_optical_props ) :: ty_optical_props_arry Optical properties as arrays, normally dimensioned ncol, nlay, ngpt/nbnd\n   The abstract base class for arrays defines what procedures will be available\n   The optical depth field is also part of the abstract base class, since\n    any representation of values as arrays needs an optical depth field Inherits type~~ty_optical_props_arry~~InheritsGraph type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props ty_optical_props type~ty_optical_props_arry->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~ty_optical_props_arry~~InheritedByGraph type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_nstr ty_optical_props_nstr type~ty_optical_props_nstr->type~ty_optical_props_arry type~ty_optical_props_1scl ty_optical_props_1scl type~ty_optical_props_1scl->type~ty_optical_props_arry type~ty_optical_props_2str ty_optical_props_2str type~ty_optical_props_2str->type~ty_optical_props_arry Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name tau Type-Bound Procedures bands_are_equal convert_band2gpt convert_gpt2band delta_scale expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_subset gpoints_are_equal increment init is_initialized set_name validate Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure( delta_scale_abstract ), public, deferred :: delta_scale function delta_scale_abstract(this, for) result(err_message) Prototype Delta-scaling Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) Forward scattering fraction; g**2 if not provided procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol public pure function get_ncol (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay public pure function get_nlay (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure( subset_range_abstract ), public, deferred :: get_subset function subset_range_abstract(full, start, n, subset) result(err_message) Prototype Subsetting -- currently there are only routines with start col and count Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: increment Increment another set of values public function increment (op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure( validate_abstract ), public, deferred :: validate Deferred procedures -- each must be implemented in each child class with\n  arguments following the abstract interface (defined below) function validate_abstract(this) result(err_message) Prototype Validation function looks only at internal data Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value character(len=128)","tags":"","loc":"type/ty_optical_props_arry.html"},{"title":"ty_optical_props_nstr – rte-rrtmgp ","text":"type, public, extends( ty_optical_props_arry ) :: ty_optical_props_nstr Inherits type~~ty_optical_props_nstr~~InheritsGraph type~ty_optical_props_nstr ty_optical_props_nstr type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_nstr->type~ty_optical_props_arry type~ty_optical_props ty_optical_props type~ty_optical_props_arry->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name p ssa tau Type-Bound Procedures alloc_nstr bands_are_equal convert_band2gpt convert_gpt2band delta_scale expand finalize finalize_nstr get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_nmom get_subset gpoints_are_equal increment init is_initialized set_name validate Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:,:), allocatable :: p phase-function moments (nmom, ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: ssa single-scattering albedo (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_nstr => alloc_only_nstr, init_and_alloc_nstr, copy_and_alloc_nstr public function alloc_only_nstr (this, nmom, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function init_and_alloc_nstr (this, nmom, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function copy_and_alloc_nstr (this, nmom, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: delta_scale => delta_scale_nstr public function delta_scale_nstr (this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: finalize_nstr public function finalize_nstr (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this Return Value character(len=128) procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol public pure function get_ncol (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay public pure function get_nlay (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_nmom public pure function get_nmom (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value integer procedure, public :: get_subset => subset_nstr_range public function subset_nstr_range (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: increment Increment another set of values public function increment (op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure, public :: validate => validate_nstream public function validate_nstream (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value character(len=128)","tags":"","loc":"type/ty_optical_props_nstr.html"},{"title":"ty_source_func_lw – rte-rrtmgp ","text":"type, public, extends( ty_optical_props ) :: ty_source_func_lw Inherits type~~ty_source_func_lw~~InheritsGraph type~ty_source_func_lw ty_source_func_lw type~ty_optical_props ty_optical_props type~ty_source_func_lw->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band lay_source lev_source_dec lev_source_inc name sfc_source sfc_source_Jac Type-Bound Procedures alloc bands_are_equal convert_band2gpt convert_gpt2band expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_subset gpoints_are_equal init is_allocated is_initialized set_name Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) real(kind=wp), public, allocatable, dimension(:,:,:) :: lay_source real(kind=wp), public, allocatable, dimension(:,:,:) :: lev_source_dec real(kind=wp), public, allocatable, dimension(:,:,:) :: lev_source_inc character(len=name_len), public :: name = \"\" real(kind=wp), public, allocatable, dimension(:,:  ) :: sfc_source real(kind=wp), public, allocatable, dimension(:,:  ) :: sfc_source_Jac Type-Bound Procedures generic, public :: alloc => alloc_lw, copy_and_alloc_lw public function alloc_lw (this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function copy_and_alloc_lw (this, ncol, nlay, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_lw public subroutine finalize_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol => get_ncol_lw public pure function get_ncol_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay => get_nlay_lw public pure function get_nlay_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer procedure, public :: get_subset => get_subset_range_lw public function get_subset_range_lw (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_lw ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_allocated => is_allocated_lw public pure function is_allocated_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value logical procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name","tags":"","loc":"type/ty_source_func_lw.html"},{"title":"ty_source_func_sw – rte-rrtmgp ","text":"type, public, extends( ty_optical_props ) :: ty_source_func_sw Inherits type~~ty_source_func_sw~~InheritsGraph type~ty_source_func_sw ty_source_func_sw type~ty_optical_props ty_optical_props type~ty_source_func_sw->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name toa_source Type-Bound Procedures alloc bands_are_equal convert_band2gpt convert_gpt2band expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_subset gpoints_are_equal init is_allocated is_initialized set_name Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, allocatable, dimension(:,:  ) :: toa_source Type-Bound Procedures generic, public :: alloc => alloc_sw, copy_and_alloc_sw public function alloc_sw (this, ncol) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol Return Value character(len=128) public function copy_and_alloc_sw (this, ncol, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_sw public subroutine finalize_sw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol => get_ncol_sw public pure function get_ncol_sw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_subset => get_subset_range_sw public function get_subset_range_sw (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_sw ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_allocated => is_allocated_sw public pure function is_allocated_sw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value logical procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name","tags":"","loc":"type/ty_source_func_sw.html"},{"title":"conc_field – rte-rrtmgp ","text":"type, public :: conc_field Inherited by type~~conc_field~~InheritedByGraph type~conc_field conc_field type~ty_gas_concs ty_gas_concs type~ty_gas_concs->type~conc_field concs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables conc Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:), pointer :: conc => NULL()","tags":"","loc":"type/conc_field.html"},{"title":"ty_gas_concs – rte-rrtmgp ","text":"type, public :: ty_gas_concs Inherits type~~ty_gas_concs~~InheritsGraph type~ty_gas_concs ty_gas_concs type~conc_field conc_field type~ty_gas_concs->type~conc_field concs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables concs gas_name ncol nlay Finalization Procedures del Type-Bound Procedures get_gas_names get_num_gases get_subset get_vmr init reset set_vmr Components Type Visibility Attributes Name Initial type( conc_field ), public, dimension(:), allocatable :: concs character(len=32), public, dimension(:), allocatable :: gas_name integer, public :: ncol = 0 integer, public :: nlay = 0 Finalization Procedures final :: del public subroutine del (this) Arguments Type Intent Optional Attributes Name type( ty_gas_concs ), intent(inout) :: this Type-Bound Procedures procedure, public :: get_gas_names public pure function get_gas_names (this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this Return Value character(len=32),\n  dimension(this%get_num_gases()) procedure, public :: get_num_gases public pure function get_num_gases (this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this Return Value integer generic, public :: get_subset => get_subset_range public function get_subset_range (this, start, n, subset) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this integer, intent(in) :: start integer, intent(in) :: n class( ty_gas_concs ), intent(inout) :: subset Return Value character(len=128) generic, public :: get_vmr => get_vmr_1d, get_vmr_2d public function get_vmr_1d (this, gas, array) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(out), dimension(:) :: array Return Value character(len=128) public function get_vmr_2d (this, gas, array) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(out), dimension(:,:) :: array Return Value character(len=128) procedure, public :: init public function init (this, gas_names) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: gas_names Return Value character(len=128) procedure, public :: reset public subroutine reset (this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this generic, public :: set_vmr => set_vmr_scalar, set_vmr_1d, set_vmr_2d public function set_vmr_scalar (this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in) :: w Return Value character(len=128) public function set_vmr_1d (this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in), dimension(:) :: w Return Value character(len=128) public function set_vmr_2d (this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in), dimension(:,:) :: w Return Value character(len=128)","tags":"","loc":"type/ty_gas_concs.html"},{"title":"ty_gas_optics – rte-rrtmgp ","text":"type, public, abstract, extends( ty_optical_props ) :: ty_gas_optics Inherits type~~ty_gas_optics~~InheritsGraph type~ty_gas_optics ty_gas_optics type~ty_optical_props ty_optical_props type~ty_gas_optics->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~ty_gas_optics~~InheritedByGraph type~ty_gas_optics ty_gas_optics type~ty_gas_optics_rrtmgp ty_gas_optics_rrtmgp type~ty_gas_optics_rrtmgp->type~ty_gas_optics Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name Type-Bound Procedures bands_are_equal convert_band2gpt convert_gpt2band expand finalize gas_optics gas_optics_ext gas_optics_int get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ngpt get_press_max get_press_min get_temp_max get_temp_min gpoints_are_equal init is_initialized set_name source_is_external source_is_internal Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this generic, public :: gas_optics => gas_optics_int , gas_optics_ext private function gas_optics_int(this, play, plev, tlay, tsfc, gas_desc, optical_props, sources, col_dry, tlev) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay real(kind=wp), intent(in), dimension(:) :: tsfc type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props class( ty_source_func_lw ), intent(inout) :: sources real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: tlev Return Value character(len=128) private function gas_optics_ext(this, play, plev, tlay, gas_desc, optical_props, toa_src, col_dry) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: toa_src real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry Return Value character(len=128) procedure( gas_optics_ext_abstract ), public, deferred :: gas_optics_ext function gas_optics_ext_abstract(this, play, plev, tlay, gas_desc, optical_props, toa_src, col_dry) result(error_msg) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: toa_src real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry Return Value character(len=128) procedure( gas_optics_int_abstract ), public, deferred :: gas_optics_int function gas_optics_int_abstract(this, play, plev, tlay, tsfc, gas_desc, optical_props, sources, col_dry, tlev) result(error_msg) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay real(kind=wp), intent(in), dimension(:) :: tsfc type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props class( ty_source_func_lw ), intent(inout) :: sources real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: tlev Return Value character(len=128) procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure( real_abstract ), public, deferred :: get_press_max function real_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value real(kind=wp) procedure( real_abstract ), public, deferred :: get_press_min function real_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value real(kind=wp) procedure( real_abstract ), public, deferred :: get_temp_max function real_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value real(kind=wp) procedure( real_abstract ), public, deferred :: get_temp_min function real_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value real(kind=wp) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure( logical_abstract ), public, deferred :: source_is_external function logical_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value logical procedure( logical_abstract ), public, deferred :: source_is_internal function logical_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value logical","tags":"","loc":"type/ty_gas_optics.html"},{"title":"ty_gas_optics_rrtmgp – rte-rrtmgp ","text":"type, public, extends( ty_gas_optics ) :: ty_gas_optics_rrtmgp Inherits type~~ty_gas_optics_rrtmgp~~InheritsGraph type~ty_gas_optics_rrtmgp ty_gas_optics_rrtmgp type~ty_gas_optics ty_gas_optics type~ty_gas_optics_rrtmgp->type~ty_gas_optics type~ty_optical_props ty_optical_props type~ty_gas_optics->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name Type-Bound Procedures bands_are_equal compute_optimal_angles convert_band2gpt convert_gpt2band expand finalize gas_optics gas_optics_ext gas_optics_int get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gases get_gpoint_bands get_name get_nband get_ngas get_ngpt get_press_max get_press_min get_temp_max get_temp_min gpoints_are_equal init is_initialized load set_name set_solar_variability set_tsi source_is_external source_is_internal Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: compute_optimal_angles private function compute_optimal_angles(this, optical_props, optimal_angles) result(err_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this class( ty_optical_props_arry ), intent(in) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: optimal_angles Return Value character(len=128) procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this generic, public :: gas_optics => gas_optics_int , gas_optics_ext private function gas_optics_int(this, play, plev, tlay, tsfc, gas_desc, optical_props, sources, col_dry, tlev) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay real(kind=wp), intent(in), dimension(:) :: tsfc type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props class( ty_source_func_lw ), intent(inout) :: sources real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: tlev Return Value character(len=128) private function gas_optics_ext(this, play, plev, tlay, gas_desc, optical_props, toa_src, col_dry) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: toa_src real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry Return Value character(len=128) procedure, public :: gas_optics_ext private function gas_optics_ext(this, play, plev, tlay, gas_desc, optical_props, toa_src, col_dry) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: toa_src real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry Return Value character(len=128) procedure, public :: gas_optics_int private function gas_optics_int(this, play, plev, tlay, tsfc, gas_desc, optical_props, sources, col_dry, tlev) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay real(kind=wp), intent(in), dimension(:) :: tsfc type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props class( ty_source_func_lw ), intent(inout) :: sources real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: tlev Return Value character(len=128) procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gases private pure function get_gases(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value character(len=32),\n  dimension(get_ngas(this)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ngas private pure function get_ngas(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_press_max private pure function get_press_max(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_press_min private pure function get_press_min(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_temp_max private pure function get_temp_max(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_temp_min private pure function get_temp_min(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value real(kind=wp) procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical generic, public :: load => load_int, load_ext private function load_int(this, available_gases, gas_names, key_species, band2gpt, band_lims_wavenum, press_ref, press_ref_trop, temp_ref, temp_ref_p, temp_ref_t, vmr_ref, kmajor, kminor_lower, kminor_upper, gas_minor, identifier_minor, minor_gases_lower, minor_gases_upper, minor_limits_gpt_lower, minor_limits_gpt_upper, minor_scales_with_density_lower, minor_scales_with_density_upper, scaling_gas_lower, scaling_gas_upper, scale_by_complement_lower, scale_by_complement_upper, kminor_start_lower, kminor_start_upper, totplnk, planck_frac, rayl_lower, rayl_upper, optimal_angle_fit) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(inout) :: this class( ty_gas_concs ), intent(in) :: available_gases character(len=*), intent(in), dimension(:) :: gas_names integer, intent(in), dimension(:,:,:) :: key_species integer, intent(in), dimension(:,:) :: band2gpt real(kind=wp), intent(in), dimension(:,:) :: band_lims_wavenum real(kind=wp), intent(in), dimension(:) :: press_ref real(kind=wp), intent(in) :: press_ref_trop real(kind=wp), intent(in), dimension(:) :: temp_ref real(kind=wp), intent(in) :: temp_ref_p real(kind=wp), intent(in) :: temp_ref_t real(kind=wp), intent(in), dimension(:,:,:) :: vmr_ref real(kind=wp), intent(in), dimension(:,:,:,:) :: kmajor real(kind=wp), intent(in), dimension(:,:,:) :: kminor_lower real(kind=wp), intent(in), dimension(:,:,:) :: kminor_upper character(len=*), intent(in), dimension(:) :: gas_minor character(len=*), intent(in), dimension(:) :: identifier_minor character(len=*), intent(in), dimension(:) :: minor_gases_lower character(len=*), intent(in), dimension(:) :: minor_gases_upper integer, intent(in), dimension(:,:) :: minor_limits_gpt_lower integer, intent(in), dimension(:,:) :: minor_limits_gpt_upper logical(kind=wl), intent(in), dimension(:) :: minor_scales_with_density_lower logical(kind=wl), intent(in), dimension(:) :: minor_scales_with_density_upper character(len=*), intent(in), dimension(:) :: scaling_gas_lower character(len=*), intent(in), dimension(:) :: scaling_gas_upper logical(kind=wl), intent(in), dimension(:) :: scale_by_complement_lower logical(kind=wl), intent(in), dimension(:) :: scale_by_complement_upper integer, intent(in), dimension(:) :: kminor_start_lower integer, intent(in), dimension(:) :: kminor_start_upper real(kind=wp), intent(in), dimension(:,:) :: totplnk real(kind=wp), intent(in), dimension(:,:,:,:) :: planck_frac real(kind=wp), intent(in), dimension(:,:,:), allocatable :: rayl_lower real(kind=wp), intent(in), dimension(:,:,:), allocatable :: rayl_upper real(kind=wp), intent(in), dimension(:,:) :: optimal_angle_fit Return Value character(len=128) private function load_ext(this, available_gases, gas_names, key_species, band2gpt, band_lims_wavenum, press_ref, press_ref_trop, temp_ref, temp_ref_p, temp_ref_t, vmr_ref, kmajor, kminor_lower, kminor_upper, gas_minor, identifier_minor, minor_gases_lower, minor_gases_upper, minor_limits_gpt_lower, minor_limits_gpt_upper, minor_scales_with_density_lower, minor_scales_with_density_upper, scaling_gas_lower, scaling_gas_upper, scale_by_complement_lower, scale_by_complement_upper, kminor_start_lower, kminor_start_upper, solar_quiet, solar_facular, solar_sunspot, tsi_default, mg_default, sb_default, rayl_lower, rayl_upper) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(inout) :: this class( ty_gas_concs ), intent(in) :: available_gases character(len=*), intent(in), dimension(:) :: gas_names integer, intent(in), dimension(:,:,:) :: key_species integer, intent(in), dimension(:,:) :: band2gpt real(kind=wp), intent(in), dimension(:,:) :: band_lims_wavenum real(kind=wp), intent(in), dimension(:) :: press_ref real(kind=wp), intent(in) :: press_ref_trop real(kind=wp), intent(in), dimension(:) :: temp_ref real(kind=wp), intent(in) :: temp_ref_p real(kind=wp), intent(in) :: temp_ref_t real(kind=wp), intent(in), dimension(:,:,:) :: vmr_ref real(kind=wp), intent(in), dimension(:,:,:,:) :: kmajor real(kind=wp), intent(in), dimension(:,:,:) :: kminor_lower real(kind=wp), intent(in), dimension(:,:,:) :: kminor_upper character(len=*), intent(in), dimension(:) :: gas_minor character(len=*), intent(in), dimension(:) :: identifier_minor character(len=*), intent(in), dimension(:) :: minor_gases_lower character(len=*), intent(in), dimension(:) :: minor_gases_upper integer, intent(in), dimension(:,:) :: minor_limits_gpt_lower integer, intent(in), dimension(:,:) :: minor_limits_gpt_upper logical(kind=wl), intent(in), dimension(:) :: minor_scales_with_density_lower logical(kind=wl), intent(in), dimension(:) :: minor_scales_with_density_upper character(len=*), intent(in), dimension(:) :: scaling_gas_lower character(len=*), intent(in), dimension(:) :: scaling_gas_upper logical(kind=wl), intent(in), dimension(:) :: scale_by_complement_lower logical(kind=wl), intent(in), dimension(:) :: scale_by_complement_upper integer, intent(in), dimension(:) :: kminor_start_lower integer, intent(in), dimension(:) :: kminor_start_upper real(kind=wp), intent(in), dimension(:) :: solar_quiet real(kind=wp), intent(in), dimension(:) :: solar_facular real(kind=wp), intent(in), dimension(:) :: solar_sunspot real(kind=wp), intent(in) :: tsi_default real(kind=wp), intent(in) :: mg_default real(kind=wp), intent(in) :: sb_default real(kind=wp), intent(in), dimension(:,:,:), allocatable :: rayl_lower real(kind=wp), intent(in), dimension(:,:,:), allocatable :: rayl_upper Return Value character(len=128) procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure, public :: set_solar_variability private function set_solar_variability(this, mg_index, sb_index, tsi) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(inout) :: this real(kind=wp), intent(in) :: mg_index real(kind=wp), intent(in) :: sb_index real(kind=wp), intent(in), optional :: tsi Return Value character(len=128) procedure, public :: set_tsi private function set_tsi(this, tsi) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(inout) :: this real(kind=wp), intent(in) :: tsi Return Value character(len=128) procedure, public :: source_is_external private pure function source_is_external(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value logical procedure, public :: source_is_internal private pure function source_is_internal(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics_rrtmgp ), intent(in) :: this Return Value logical","tags":"","loc":"type/ty_gas_optics_rrtmgp.html"},{"title":"ty_fluxes_1lev – rte-rrtmgp ","text":"type, public, extends( ty_fluxes ) :: ty_fluxes_1lev Inherits type~~ty_fluxes_1lev~~InheritsGraph type~ty_fluxes_1lev ty_fluxes_1lev type~ty_fluxes ty_fluxes type~ty_fluxes_1lev->type~ty_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures are_desired reduce Type-Bound Procedures procedure, public :: are_desired => are_desired_1lev private function are_desired_1lev(this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_1lev ), intent(in) :: this Return Value logical procedure, public :: reduce => reduce_1lev private function reduce_1lev(this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_1lev ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"type/ty_fluxes_1lev.html"},{"title":"ty_fluxes_byband – rte-rrtmgp ","text":"type, public, extends( ty_fluxes_broadband ) :: ty_fluxes_byband Inherits type~~ty_fluxes_byband~~InheritsGraph type~ty_fluxes_byband ty_fluxes_byband type~ty_fluxes_broadband ty_fluxes_broadband type~ty_fluxes_byband->type~ty_fluxes_broadband type~ty_fluxes ty_fluxes type~ty_fluxes_broadband->type~ty_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables bnd_flux_dn bnd_flux_dn_dir bnd_flux_net bnd_flux_up Type-Bound Procedures are_desired reduce Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_dn => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_dn_dir => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_net => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_up => NULL() Type-Bound Procedures procedure, public :: are_desired => are_desired_byband public function are_desired_byband (this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_byband ), intent(in) :: this Return Value logical procedure, public :: reduce => reduce_byband public function reduce_byband (this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_byband ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"type/ty_fluxes_byband.html"},{"title":"ty_fluxes_bygpoint – rte-rrtmgp ","text":"type, public, extends( ty_fluxes ) :: ty_fluxes_bygpoint Inherits type~~ty_fluxes_bygpoint~~InheritsGraph type~ty_fluxes_bygpoint ty_fluxes_bygpoint type~ty_fluxes ty_fluxes type~ty_fluxes_bygpoint->type~ty_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables gpt_flux_dn gpt_flux_dn_dir gpt_flux_net gpt_flux_up Type-Bound Procedures are_desired reduce Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_dn => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_dn_dir => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_net => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_up => NULL() Type-Bound Procedures procedure, public :: are_desired => are_desired_bygpoint public function are_desired_bygpoint (this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_bygpoint ), intent(in) :: this Return Value logical procedure, public :: reduce => reduce_bygpoint public function reduce_bygpoint (this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_bygpoint ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"type/ty_fluxes_bygpoint.html"},{"title":"ty_solar_var – rte-rrtmgp ","text":"type, public :: ty_solar_var Contents Type-Bound Procedures finalize load solar_var_ind_interp Type-Bound Procedures procedure, public :: finalize private subroutine finalize(this) Arguments Type Intent Optional Attributes Name class( ty_solar_var ), intent(inout) :: this procedure, public :: load private function load(this, avgcyc_ind) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_solar_var ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: avgcyc_ind Return Value character(len=128) procedure, public :: solar_var_ind_interp private function solar_var_ind_interp(this, solcycfrac, mg_index, sb_index) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_solar_var ), intent(in) :: this real(kind=wp), intent(in) :: solcycfrac real(kind=wp), intent(out) :: mg_index real(kind=wp), intent(out) :: sb_index Return Value character(len=128)","tags":"","loc":"type/ty_solar_var.html"},{"title":"ty_cloud_optics – rte-rrtmgp ","text":"type, public, extends( ty_optical_props ) :: ty_cloud_optics Inherits type~~ty_cloud_optics~~InheritsGraph type~ty_cloud_optics ty_cloud_optics type~ty_optical_props ty_optical_props type~ty_cloud_optics->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables band2gpt band_lims_wvn gpt2band name Type-Bound Procedures bands_are_equal cloud_optics convert_band2gpt convert_gpt2band expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_max_radius_ice get_max_radius_liq get_min_radius_ice get_min_radius_liq get_name get_nband get_ngpt get_num_ice_roughness_types gpoints_are_equal init is_initialized load set_ice_roughness set_name Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: cloud_optics private function cloud_optics(this, clwp, ciwp, reliq, reice, optical_props) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(in) :: this real(kind=wp), intent(in) :: clwp (:,:) real(kind=wp), intent(in) :: ciwp (:,:) real(kind=wp), intent(in) :: reliq (:,:) real(kind=wp), intent(in) :: reice (:,:) class( ty_optical_props_arry ), intent(inout) :: optical_props Return Value character(len=128) procedure, public :: convert_band2gpt public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) procedure, public :: convert_gpt2band public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) procedure, public :: finalize private subroutine finalize(this) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(inout) :: this procedure, public :: get_band_lims_gpoint public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) procedure, public :: get_max_radius_ice private function get_max_radius_ice(this) result(r) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_max_radius_liq private function get_max_radius_liq(this) result(r) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_min_radius_ice private function get_min_radius_ice(this) result(r) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_min_radius_liq private function get_min_radius_liq(this) result(r) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(in) :: this Return Value real(kind=wp) procedure, public :: get_name public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ngpt public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_num_ice_roughness_types private function get_num_ice_roughness_types(this) result(i) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(in) :: this Return Value integer procedure, public :: gpoints_are_equal public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical generic, public :: load => load_lut, load_pade private function load_lut(this, band_lims_wvn, radliq_lwr, radliq_upr, radliq_fac, radice_lwr, radice_upr, radice_fac, lut_extliq, lut_ssaliq, lut_asyliq, lut_extice, lut_ssaice, lut_asyice) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn real(kind=wp), intent(in) :: radliq_lwr real(kind=wp), intent(in) :: radliq_upr real(kind=wp), intent(in) :: radliq_fac real(kind=wp), intent(in) :: radice_lwr real(kind=wp), intent(in) :: radice_upr real(kind=wp), intent(in) :: radice_fac real(kind=wp), intent(in), dimension(:,:) :: lut_extliq real(kind=wp), intent(in), dimension(:,:) :: lut_ssaliq real(kind=wp), intent(in), dimension(:,:) :: lut_asyliq real(kind=wp), intent(in), dimension(:,:,:) :: lut_extice real(kind=wp), intent(in), dimension(:,:,:) :: lut_ssaice real(kind=wp), intent(in), dimension(:,:,:) :: lut_asyice Return Value character(len=128) private function load_pade(this, band_lims_wvn, pade_extliq, pade_ssaliq, pade_asyliq, pade_extice, pade_ssaice, pade_asyice, pade_sizreg_extliq, pade_sizreg_ssaliq, pade_sizreg_asyliq, pade_sizreg_extice, pade_sizreg_ssaice, pade_sizreg_asyice) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn real(kind=wp), intent(in), dimension(:,:,:) :: pade_extliq real(kind=wp), intent(in), dimension(:,:,:) :: pade_ssaliq real(kind=wp), intent(in), dimension(:,:,:) :: pade_asyliq real(kind=wp), intent(in), dimension(:,:,:,:) :: pade_extice real(kind=wp), intent(in), dimension(:,:,:,:) :: pade_ssaice real(kind=wp), intent(in), dimension(:,:,:,:) :: pade_asyice real(kind=wp), intent(in), dimension(:) :: pade_sizreg_extliq real(kind=wp), intent(in), dimension(:) :: pade_sizreg_ssaliq real(kind=wp), intent(in), dimension(:) :: pade_sizreg_asyliq real(kind=wp), intent(in), dimension(:) :: pade_sizreg_extice real(kind=wp), intent(in), dimension(:) :: pade_sizreg_ssaice real(kind=wp), intent(in), dimension(:) :: pade_sizreg_asyice Return Value character(len=128) procedure, public :: set_ice_roughness private function set_ice_roughness(this, icergh) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_cloud_optics ), intent(inout) :: this integer, intent(in) :: icergh Return Value character(len=128) procedure, public :: set_name public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name","tags":"","loc":"type/ty_cloud_optics.html"},{"title":"delta_scale_abstract – rte-rrtmgp","text":"abstract interface Interfaces for the methods to be implemented public function delta_scale_abstract(this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) Forward scattering fraction; g**2 if not provided Description Delta-scaling","tags":"","loc":"interface/delta_scale_abstract.html"},{"title":"subset_range_abstract – rte-rrtmgp","text":"abstract interface Interfaces for the methods to be implemented public function subset_range_abstract(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) Description Subsetting -- currently there are only routines with start col and count","tags":"","loc":"interface/subset_range_abstract.html"},{"title":"validate_abstract – rte-rrtmgp","text":"abstract interface Interfaces for the methods to be implemented public function validate_abstract(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value character(len=128) Description Validation function looks only at internal data","tags":"","loc":"interface/validate_abstract.html"},{"title":"gas_optics_ext_abstract – rte-rrtmgp","text":"abstract interface public function gas_optics_ext_abstract(this, play, plev, tlay, gas_desc, optical_props, toa_src, col_dry) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: toa_src real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry Return Value character(len=128)","tags":"","loc":"interface/gas_optics_ext_abstract.html"},{"title":"gas_optics_int_abstract – rte-rrtmgp","text":"abstract interface public function gas_optics_int_abstract(this, play, plev, tlay, tsfc, gas_desc, optical_props, sources, col_dry, tlev) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay real(kind=wp), intent(in), dimension(:) :: tsfc type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props class( ty_source_func_lw ), intent(inout) :: sources real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: tlev Return Value character(len=128)","tags":"","loc":"interface/gas_optics_int_abstract.html"},{"title":"logical_abstract – rte-rrtmgp","text":"abstract interface public function logical_abstract(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value logical","tags":"","loc":"interface/logical_abstract.html"},{"title":"real_abstract – rte-rrtmgp","text":"abstract interface public function real_abstract(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value real(kind=wp)","tags":"","loc":"interface/real_abstract.html"},{"title":"rte_config_checks – rte-rrtmgp","text":"public interface rte_config_checks Contents Module Procedures rte_config_checks_each rte_config_checks_all Module Procedures private subroutine rte_config_checks_each(extents, values) Arguments Type Intent Optional Attributes Name logical(kind=wl), intent(in) :: extents logical(kind=wl), intent(in) :: values private subroutine rte_config_checks_all(do_checks) Arguments Type Intent Optional Attributes Name logical(kind=wl), intent(in) :: do_checks","tags":"","loc":"interface/rte_config_checks.html"},{"title":"rte_lw – rte-rrtmgp","text":"public function rte_lw(optical_props, top_at_1, sources, sfc_emis, fluxes, inc_flux, n_gauss_angles, use_2stream, lw_Ds, flux_up_Jac) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: optical_props logical, intent(in) :: top_at_1 type( ty_source_func_lw ), intent(in) :: sources real(kind=wp), intent(in), dimension(:,:) :: sfc_emis class( ty_fluxes ), intent(inout) :: fluxes real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux integer, intent(in), optional :: n_gauss_angles logical, intent(in), optional :: use_2stream real(kind=wp), intent(in), optional dimension(:,:) :: lw_Ds real(kind=wp), intent(inout), optional dimension(:,:), target :: flux_up_Jac Return Value character(len=128) Calls proc~~rte_lw~~CallsGraph proc~rte_lw rte_lw interface~any_vals_less_than any_vals_less_than proc~rte_lw->interface~any_vals_less_than lw_solver_noscat_gaussquad lw_solver_noscat_gaussquad proc~rte_lw->lw_solver_noscat_gaussquad proc~lw_solver_2stream lw_solver_2stream proc~rte_lw->proc~lw_solver_2stream interface~extents_are extents_are proc~rte_lw->interface~extents_are interface~zero_array zero_array proc~rte_lw->interface~zero_array interface~any_vals_outside any_vals_outside proc~rte_lw->interface~any_vals_outside Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rte_lw~~CalledByGraph proc~rte_lw rte_lw proc~compute_bc compute_bc proc~compute_bc->proc~rte_lw proc~rte_lw~2 rte_lw proc~rte_lw~2->proc~rte_lw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rte_lw.html"},{"title":"rte_sw – rte-rrtmgp","text":"public function rte_sw(atmos, top_at_1, mu0, inc_flux, sfc_alb_dir, sfc_alb_dif, fluxes, inc_flux_dif) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: atmos logical, intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(:) :: mu0 real(kind=wp), intent(in), dimension(:,:) :: inc_flux real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dir real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dif class( ty_fluxes ), intent(inout) :: fluxes real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux_dif Return Value character(len=128) Calls proc~~rte_sw~~CallsGraph proc~rte_sw rte_sw interface~any_vals_less_than any_vals_less_than proc~rte_sw->interface~any_vals_less_than interface~extents_are extents_are proc~rte_sw->interface~extents_are interface~zero_array zero_array proc~rte_sw->interface~zero_array proc~sw_solver_2stream sw_solver_2stream proc~rte_sw->proc~sw_solver_2stream interface~any_vals_outside any_vals_outside proc~rte_sw->interface~any_vals_outside proc~sw_solver_noscat sw_solver_noscat proc~rte_sw->proc~sw_solver_noscat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rte_sw~~CalledByGraph proc~rte_sw rte_sw proc~compute_bc compute_bc proc~compute_bc->proc~rte_sw proc~rte_sw~2 rte_sw proc~rte_sw~2->proc~rte_sw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rte_sw.html"},{"title":"alloc_only_1scl – rte-rrtmgp","text":"public function alloc_only_1scl(this, ncol, nlay) result(err_message) Straight allocation routines --- 1 scalar ------------------------------------------------------------------------ Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) Contents None","tags":"","loc":"proc/alloc_only_1scl.html"},{"title":"alloc_only_2str – rte-rrtmgp","text":"public function alloc_only_2str(this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) Contents None","tags":"","loc":"proc/alloc_only_2str.html"},{"title":"alloc_only_nstr – rte-rrtmgp","text":"public function alloc_only_nstr(this, nmom, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) Contents None","tags":"","loc":"proc/alloc_only_nstr.html"},{"title":"bands_are_equal – rte-rrtmgp","text":"public pure function bands_are_equal(this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical Contents None","tags":"","loc":"proc/bands_are_equal.html"},{"title":"convert_band2gpt – rte-rrtmgp","text":"public pure function convert_band2gpt(this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) Contents None","tags":"","loc":"proc/convert_band2gpt.html"},{"title":"convert_gpt2band – rte-rrtmgp","text":"public pure function convert_gpt2band(this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer Contents None","tags":"","loc":"proc/convert_gpt2band.html"},{"title":"copy_and_alloc_1scl – rte-rrtmgp","text":"public function copy_and_alloc_1scl(this, ncol, nlay, spectral_desc, name) result(err_message) Initialization from an existing spectral discretization/ty_optical_props Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) Contents None","tags":"","loc":"proc/copy_and_alloc_1scl.html"},{"title":"copy_and_alloc_2str – rte-rrtmgp","text":"public function copy_and_alloc_2str(this, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) Contents None","tags":"","loc":"proc/copy_and_alloc_2str.html"},{"title":"copy_and_alloc_nstr – rte-rrtmgp","text":"public function copy_and_alloc_nstr(this, nmom, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) Contents None","tags":"","loc":"proc/copy_and_alloc_nstr.html"},{"title":"delta_scale_1scl – rte-rrtmgp","text":"public function delta_scale_1scl(this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) Contents None","tags":"","loc":"proc/delta_scale_1scl.html"},{"title":"delta_scale_2str – rte-rrtmgp","text":"public function delta_scale_2str(this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Forward scattering fraction; g**2 if not provided Return Value character(len=128) Calls proc~~delta_scale_2str~~CallsGraph proc~delta_scale_2str delta_scale_2str interface~any_vals_outside any_vals_outside proc~delta_scale_2str->interface~any_vals_outside interface~delta_scale_2str_kernel delta_scale_2str_kernel proc~delta_scale_2str->interface~delta_scale_2str_kernel interface~extents_are extents_are proc~delta_scale_2str->interface~extents_are proc~delta_scale_2str_k delta_scale_2str_k interface~delta_scale_2str_kernel->proc~delta_scale_2str_k proc~delta_scale_2str_f_k delta_scale_2str_f_k interface~delta_scale_2str_kernel->proc~delta_scale_2str_f_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/delta_scale_2str.html"},{"title":"delta_scale_nstr – rte-rrtmgp","text":"public function delta_scale_nstr(this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) Contents None","tags":"","loc":"proc/delta_scale_nstr.html"},{"title":"expand – rte-rrtmgp","text":"public pure function expand(this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) Contents None","tags":"","loc":"proc/expand.html"},{"title":"finalize_1scl – rte-rrtmgp","text":"public function finalize_1scl(this) result(err_message) Finalize routines Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this Return Value character(len=128) Contents None","tags":"","loc":"proc/finalize_1scl.html"},{"title":"finalize_2str – rte-rrtmgp","text":"public function finalize_2str(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this Return Value character(len=128) Contents None","tags":"","loc":"proc/finalize_2str.html"},{"title":"finalize_nstr – rte-rrtmgp","text":"public function finalize_nstr(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this Return Value character(len=128) Contents None","tags":"","loc":"proc/finalize_nstr.html"},{"title":"get_arry_extent – rte-rrtmgp","text":"public pure function get_arry_extent(this, dim) Routines for array classes: problem sizes Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this integer, intent(in) :: dim Return Value integer Called by proc~~get_arry_extent~~CalledByGraph proc~get_arry_extent get_arry_extent proc~get_ncol get_ncol proc~get_ncol->proc~get_arry_extent proc~get_nlay get_nlay proc~get_nlay->proc~get_arry_extent Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_arry_extent.html"},{"title":"get_band_lims_gpoint – rte-rrtmgp","text":"public pure function get_band_lims_gpoint(this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) Contents None","tags":"","loc":"proc/get_band_lims_gpoint.html"},{"title":"get_band_lims_wavelength – rte-rrtmgp","text":"public pure function get_band_lims_wavelength(this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) Contents None","tags":"","loc":"proc/get_band_lims_wavelength.html"},{"title":"get_band_lims_wavenumber – rte-rrtmgp","text":"public pure function get_band_lims_wavenumber(this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) Contents None","tags":"","loc":"proc/get_band_lims_wavenumber.html"},{"title":"get_gpoint_bands – rte-rrtmgp","text":"public pure function get_gpoint_bands(this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) Contents None","tags":"","loc":"proc/get_gpoint_bands.html"},{"title":"get_name – rte-rrtmgp","text":"public function get_name(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) Contents None","tags":"","loc":"proc/get_name.html"},{"title":"get_nband – rte-rrtmgp","text":"public pure function get_nband(this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_nband.html"},{"title":"get_ncol – rte-rrtmgp","text":"public pure function get_ncol(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer Calls proc~~get_ncol~~CallsGraph proc~get_ncol get_ncol proc~get_arry_extent get_arry_extent proc~get_ncol->proc~get_arry_extent Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_ncol.html"},{"title":"get_ngpt – rte-rrtmgp","text":"public pure function get_ngpt(this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_ngpt.html"},{"title":"get_nlay – rte-rrtmgp","text":"public pure function get_nlay(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer Calls proc~~get_nlay~~CallsGraph proc~get_nlay get_nlay proc~get_arry_extent get_arry_extent proc~get_nlay->proc~get_arry_extent Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_nlay.html"},{"title":"get_nmom – rte-rrtmgp","text":"public pure function get_nmom(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_nmom.html"},{"title":"gpoints_are_equal – rte-rrtmgp","text":"public pure function gpoints_are_equal(this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical Contents None","tags":"","loc":"proc/gpoints_are_equal.html"},{"title":"increment – rte-rrtmgp","text":"public function increment(op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) Calls proc~~increment~~CallsGraph proc~increment increment proc~inc_1scalar_by_1scalar_bybnd inc_1scalar_by_1scalar_bybnd proc~increment->proc~inc_1scalar_by_1scalar_bybnd proc~increment_2stream_by_1scalar increment_2stream_by_1scalar proc~increment->proc~increment_2stream_by_1scalar proc~inc_nstream_by_nstream_bybnd inc_nstream_by_nstream_bybnd proc~increment->proc~inc_nstream_by_nstream_bybnd proc~increment_1scalar_by_2stream increment_1scalar_by_2stream proc~increment->proc~increment_1scalar_by_2stream proc~increment_nstream_by_nstream increment_nstream_by_nstream proc~increment->proc~increment_nstream_by_nstream proc~increment_1scalar_by_1scalar increment_1scalar_by_1scalar proc~increment->proc~increment_1scalar_by_1scalar proc~increment_2stream_by_nstream increment_2stream_by_nstream proc~increment->proc~increment_2stream_by_nstream proc~inc_nstream_by_1scalar_bybnd inc_nstream_by_1scalar_bybnd proc~increment->proc~inc_nstream_by_1scalar_bybnd proc~increment_nstream_by_2stream increment_nstream_by_2stream proc~increment->proc~increment_nstream_by_2stream proc~inc_2stream_by_1scalar_bybnd inc_2stream_by_1scalar_bybnd proc~increment->proc~inc_2stream_by_1scalar_bybnd proc~increment_2stream_by_2stream increment_2stream_by_2stream proc~increment->proc~increment_2stream_by_2stream proc~increment_nstream_by_1scalar increment_nstream_by_1scalar proc~increment->proc~increment_nstream_by_1scalar proc~inc_1scalar_by_2stream_bybnd inc_1scalar_by_2stream_bybnd proc~increment->proc~inc_1scalar_by_2stream_bybnd proc~inc_1scalar_by_nstream_bybnd inc_1scalar_by_nstream_bybnd proc~increment->proc~inc_1scalar_by_nstream_bybnd proc~inc_2stream_by_2stream_bybnd inc_2stream_by_2stream_bybnd proc~increment->proc~inc_2stream_by_2stream_bybnd proc~increment_1scalar_by_nstream increment_1scalar_by_nstream proc~increment->proc~increment_1scalar_by_nstream proc~inc_2stream_by_nstream_bybnd inc_2stream_by_nstream_bybnd proc~increment->proc~inc_2stream_by_nstream_bybnd proc~inc_nstream_by_2stream_bybnd inc_nstream_by_2stream_bybnd proc~increment->proc~inc_nstream_by_2stream_bybnd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/increment.html"},{"title":"init_and_alloc_1scl – rte-rrtmgp","text":"public function init_and_alloc_1scl(this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Initialization by specifying band limits and possibly g-point/band mapping Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) Contents None","tags":"","loc":"proc/init_and_alloc_1scl.html"},{"title":"init_and_alloc_2str – rte-rrtmgp","text":"public function init_and_alloc_2str(this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) Contents None","tags":"","loc":"proc/init_and_alloc_2str.html"},{"title":"init_and_alloc_nstr – rte-rrtmgp","text":"public function init_and_alloc_nstr(this, nmom, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) Contents None","tags":"","loc":"proc/init_and_alloc_nstr.html"},{"title":"init_base – rte-rrtmgp","text":"public function init_base(this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) Calls proc~~init_base~~CallsGraph proc~init_base init_base interface~any_vals_less_than any_vals_less_than proc~init_base->interface~any_vals_less_than interface~extents_are extents_are proc~init_base->interface~extents_are Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_base.html"},{"title":"init_base_from_copy – rte-rrtmgp","text":"public function init_base_from_copy(this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) Contents None","tags":"","loc":"proc/init_base_from_copy.html"},{"title":"is_initialized_base – rte-rrtmgp","text":"public pure function is_initialized_base(this) Base class: return true if initialized, false otherwise Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/is_initialized_base.html"},{"title":"subset_1scl_range – rte-rrtmgp","text":"public function subset_1scl_range(full, start, n, subset) result(err_message) Routines for array classes: subsetting of optical properties arrays along x (col) direction Allocate class, then arrays; copy. Could probably be more efficient if\n  classes used pointers internally. This set takes start position and number as scalars Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) Calls proc~~subset_1scl_range~~CallsGraph proc~subset_1scl_range subset_1scl_range interface~extract_subset extract_subset proc~subset_1scl_range->interface~extract_subset proc~extract_subset_dim2_4d extract_subset_dim2_4d interface~extract_subset->proc~extract_subset_dim2_4d proc~extract_subset_dim1_3d extract_subset_dim1_3d interface~extract_subset->proc~extract_subset_dim1_3d proc~extract_subset_absorption_tau extract_subset_absorption_tau interface~extract_subset->proc~extract_subset_absorption_tau Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subset_1scl_range.html"},{"title":"subset_2str_range – rte-rrtmgp","text":"public function subset_2str_range(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) Calls proc~~subset_2str_range~~CallsGraph proc~subset_2str_range subset_2str_range interface~extract_subset extract_subset proc~subset_2str_range->interface~extract_subset proc~extract_subset_dim2_4d extract_subset_dim2_4d interface~extract_subset->proc~extract_subset_dim2_4d proc~extract_subset_dim1_3d extract_subset_dim1_3d interface~extract_subset->proc~extract_subset_dim1_3d proc~extract_subset_absorption_tau extract_subset_absorption_tau interface~extract_subset->proc~extract_subset_absorption_tau Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subset_2str_range.html"},{"title":"subset_nstr_range – rte-rrtmgp","text":"public function subset_nstr_range(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) Calls proc~~subset_nstr_range~~CallsGraph proc~subset_nstr_range subset_nstr_range interface~extract_subset extract_subset proc~subset_nstr_range->interface~extract_subset proc~extract_subset_dim2_4d extract_subset_dim2_4d interface~extract_subset->proc~extract_subset_dim2_4d proc~extract_subset_dim1_3d extract_subset_dim1_3d interface~extract_subset->proc~extract_subset_dim1_3d proc~extract_subset_absorption_tau extract_subset_absorption_tau interface~extract_subset->proc~extract_subset_absorption_tau Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subset_nstr_range.html"},{"title":"validate_1scalar – rte-rrtmgp","text":"public function validate_1scalar(this) result(err_message) --- Validation Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(in) :: this Return Value character(len=128) Calls proc~~validate_1scalar~~CallsGraph proc~validate_1scalar validate_1scalar interface~any_vals_less_than any_vals_less_than proc~validate_1scalar->interface~any_vals_less_than Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/validate_1scalar.html"},{"title":"validate_2stream – rte-rrtmgp","text":"public function validate_2stream(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(in) :: this Return Value character(len=128) Calls proc~~validate_2stream~~CallsGraph proc~validate_2stream validate_2stream interface~any_vals_less_than any_vals_less_than proc~validate_2stream->interface~any_vals_less_than interface~any_vals_outside any_vals_outside proc~validate_2stream->interface~any_vals_outside interface~extents_are extents_are proc~validate_2stream->interface~extents_are Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/validate_2stream.html"},{"title":"validate_nstream – rte-rrtmgp","text":"public function validate_nstream(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value character(len=128) Calls proc~~validate_nstream~~CallsGraph proc~validate_nstream validate_nstream interface~any_vals_less_than any_vals_less_than proc~validate_nstream->interface~any_vals_less_than interface~any_vals_outside any_vals_outside proc~validate_nstream->interface~any_vals_outside interface~extents_are extents_are proc~validate_nstream->interface~extents_are Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/validate_nstream.html"},{"title":"finalize_base – rte-rrtmgp","text":"public subroutine finalize_base(this) Base class: finalize (deallocate memory) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this Contents None","tags":"","loc":"proc/finalize_base.html"},{"title":"set_name – rte-rrtmgp","text":"public subroutine set_name(this, name) --- Setting/getting the name Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name Contents None","tags":"","loc":"proc/set_name.html"},{"title":"alloc_lw – rte-rrtmgp","text":"public function alloc_lw(this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) Contents None","tags":"","loc":"proc/alloc_lw.html"},{"title":"alloc_sw – rte-rrtmgp","text":"public function alloc_sw(this, ncol) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol Return Value character(len=128) Contents None","tags":"","loc":"proc/alloc_sw.html"},{"title":"copy_and_alloc_lw – rte-rrtmgp","text":"public function copy_and_alloc_lw(this, ncol, nlay, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) Contents None","tags":"","loc":"proc/copy_and_alloc_lw.html"},{"title":"copy_and_alloc_sw – rte-rrtmgp","text":"public function copy_and_alloc_sw(this, ncol, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) Contents None","tags":"","loc":"proc/copy_and_alloc_sw.html"},{"title":"get_ncol_lw – rte-rrtmgp","text":"public pure function get_ncol_lw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_ncol_lw.html"},{"title":"get_ncol_sw – rte-rrtmgp","text":"public pure function get_ncol_sw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_ncol_sw.html"},{"title":"get_nlay_lw – rte-rrtmgp","text":"public pure function get_nlay_lw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_nlay_lw.html"},{"title":"get_subset_range_lw – rte-rrtmgp","text":"public function get_subset_range_lw(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_lw ), intent(inout) :: subset Return Value character(len=128) Contents None","tags":"","loc":"proc/get_subset_range_lw.html"},{"title":"get_subset_range_sw – rte-rrtmgp","text":"public function get_subset_range_sw(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_sw ), intent(inout) :: subset Return Value character(len=128) Contents None","tags":"","loc":"proc/get_subset_range_sw.html"},{"title":"is_allocated_lw – rte-rrtmgp","text":"public pure function is_allocated_lw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/is_allocated_lw.html"},{"title":"is_allocated_sw – rte-rrtmgp","text":"public pure function is_allocated_sw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/is_allocated_sw.html"},{"title":"finalize_lw – rte-rrtmgp","text":"public subroutine finalize_lw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this Contents None","tags":"","loc":"proc/finalize_lw.html"},{"title":"finalize_sw – rte-rrtmgp","text":"public subroutine finalize_sw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this Contents None","tags":"","loc":"proc/finalize_sw.html"},{"title":"any_vals_less_than – rte-rrtmgp","text":"public interface any_vals_less_than Called by interface~~any_vals_less_than~~CalledByGraph interface~any_vals_less_than any_vals_less_than proc~validate_nstream validate_nstream proc~validate_nstream->interface~any_vals_less_than proc~init_base init_base proc~init_base->interface~any_vals_less_than proc~rte_lw rte_lw proc~rte_lw->interface~any_vals_less_than proc~rte_sw rte_sw proc~rte_sw->interface~any_vals_less_than proc~validate_2stream validate_2stream proc~validate_2stream->interface~any_vals_less_than proc~validate_1scalar validate_1scalar proc~validate_1scalar->interface~any_vals_less_than proc~compute_bc compute_bc proc~compute_bc->proc~rte_lw proc~compute_bc->proc~rte_sw proc~rte_sw~2 rte_sw proc~rte_sw~2->proc~rte_sw proc~rte_lw~2 rte_lw proc~rte_lw~2->proc~rte_lw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures any_vals_less_than_1D any_vals_less_than_2D any_vals_less_than_3D any_vals_less_than_1D_masked any_vals_less_than_2D_masked any_vals_less_than_3D_masked Module Procedures private function any_vals_less_than_1D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_2D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_3D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_1D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array logical(kind=wl), intent(in), dimension(:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_2D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array logical(kind=wl), intent(in), dimension(:,:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_3D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array logical(kind=wl), intent(in), dimension(:,:,:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical","tags":"","loc":"interface/any_vals_less_than.html"},{"title":"any_vals_outside – rte-rrtmgp","text":"public interface any_vals_outside Called by interface~~any_vals_outside~~CalledByGraph interface~any_vals_outside any_vals_outside proc~validate_nstream validate_nstream proc~validate_nstream->interface~any_vals_outside proc~rte_lw rte_lw proc~rte_lw->interface~any_vals_outside proc~delta_scale_2str delta_scale_2str proc~delta_scale_2str->interface~any_vals_outside proc~set_vmr_1d set_vmr_1d proc~set_vmr_1d->interface~any_vals_outside proc~set_vmr_2d set_vmr_2d proc~set_vmr_2d->interface~any_vals_outside proc~rte_sw rte_sw proc~rte_sw->interface~any_vals_outside proc~validate_2stream validate_2stream proc~validate_2stream->interface~any_vals_outside proc~compute_bc compute_bc proc~compute_bc->proc~rte_lw proc~compute_bc->proc~rte_sw proc~rte_sw~2 rte_sw proc~rte_sw~2->proc~rte_sw proc~rte_lw~2 rte_lw proc~rte_lw~2->proc~rte_lw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures any_vals_outside_1D any_vals_outside_2D any_vals_outside_3D any_vals_outside_1D_masked any_vals_outside_2D_masked any_vals_outside_3D_masked Module Procedures private function any_vals_outside_1D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_2D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_3D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_1D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array logical(kind=wl), intent(in), dimension(:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_2D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array logical(kind=wl), intent(in), dimension(:,:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_3D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array logical(kind=wl), intent(in), dimension(:,:,:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical","tags":"","loc":"interface/any_vals_outside.html"},{"title":"extents_are – rte-rrtmgp","text":"public interface extents_are Called by interface~~extents_are~~CalledByGraph interface~extents_are extents_are proc~validate_nstream validate_nstream proc~validate_nstream->interface~extents_are proc~init_base init_base proc~init_base->interface~extents_are proc~rte_lw rte_lw proc~rte_lw->interface~extents_are proc~delta_scale_2str delta_scale_2str proc~delta_scale_2str->interface~extents_are proc~compute_heating_rate compute_heating_rate proc~compute_heating_rate->interface~extents_are proc~reduce_bygpoint reduce_bygpoint proc~reduce_bygpoint->interface~extents_are proc~rte_sw rte_sw proc~rte_sw->interface~extents_are proc~validate_2stream validate_2stream proc~validate_2stream->interface~extents_are proc~compute_bc compute_bc proc~compute_bc->interface~extents_are proc~compute_bc->proc~rte_lw proc~compute_bc->proc~rte_sw proc~reduce_byband reduce_byband proc~reduce_byband->interface~extents_are proc~rte_sw~2 rte_sw proc~rte_sw~2->proc~rte_sw proc~rte_lw~2 rte_lw proc~rte_lw~2->proc~rte_lw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures extents_are_1D extents_are_2D extents_are_3D extents_are_4D extents_are_5D extents_are_6D extents_are_2d_int Module Procedures private function extents_are_1d(array, n1) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:          ) :: array integer, intent(in) :: n1 Return Value logical(kind=wl) private function extents_are_2d(array, n1, n2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:        ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 Return Value logical(kind=wl) private function extents_are_3d(array, n1, n2, n3) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:      ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 Return Value logical(kind=wl) private function extents_are_4d(array, n1, n2, n3, n4) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:    ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 Return Value logical(kind=wl) private function extents_are_5d(array, n1, n2, n3, n4, n5) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:,:  ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 integer, intent(in) :: n5 Return Value logical(kind=wl) private function extents_are_6d(array, n1, n2, n3, n4, n5, n6) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 integer, intent(in) :: n5 integer, intent(in) :: n6 Return Value logical(kind=wl) private function extents_are_2d_int(array, n1, n2) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:        ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 Return Value logical(kind=wl)","tags":"","loc":"interface/extents_are.html"},{"title":"zero_array – rte-rrtmgp","text":"public interface zero_array Called by interface~~zero_array~~CalledByGraph interface~zero_array zero_array proc~rte_lw rte_lw proc~rte_lw->interface~zero_array proc~rte_sw rte_sw proc~rte_sw->interface~zero_array proc~lw_solver_noscat~2 lw_solver_noscat proc~lw_solver_noscat~2->interface~zero_array proc~sw_solver_2stream~2 sw_solver_2stream proc~sw_solver_2stream~2->interface~zero_array proc~lw_solver_noscat_gaussquad~2 lw_solver_noscat_GaussQuad proc~lw_solver_noscat_gaussquad~2->proc~lw_solver_noscat~2 proc~compute_bc compute_bc proc~compute_bc->proc~rte_lw proc~compute_bc->proc~rte_sw proc~rte_sw~2 rte_sw proc~rte_sw~2->proc~rte_sw proc~rte_lw~2 rte_lw proc~rte_lw~2->proc~rte_lw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures zero_array_1D zero_array_2D zero_array_3D zero_array_4D Module Procedures private subroutine zero_array_1D(ni, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni real(kind=wp), intent(out), dimension(ni) :: array private subroutine zero_array_2D(ni, nj, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni integer, intent(in) :: nj real(kind=wp), intent(out), dimension(ni, nj) :: array private subroutine zero_array_3D(ni, nj, nk, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni integer, intent(in) :: nj integer, intent(in) :: nk real(kind=wp), intent(out), dimension(ni, nj, nk) :: array private subroutine zero_array_4D(ni, nj, nk, nl, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni integer, intent(in) :: nj integer, intent(in) :: nk integer, intent(in) :: nl real(kind=wp), intent(out), dimension(ni, nj, nk, nl) :: array","tags":"","loc":"interface/zero_array.html"},{"title":"lw_solver_2stream – rte-rrtmgp","text":"public subroutine lw_solver_2stream(ncol, nlay, ngpt, top_at_1, tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dn Called by proc~~lw_solver_2stream~~CalledByGraph proc~lw_solver_2stream lw_solver_2stream proc~rte_lw rte_lw proc~rte_lw->proc~lw_solver_2stream proc~compute_bc compute_bc proc~compute_bc->proc~rte_lw proc~rte_lw~2 rte_lw proc~rte_lw~2->proc~rte_lw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lw_solver_2stream.html"},{"title":"lw_solver_noscat – rte-rrtmgp","text":"public subroutine lw_solver_noscat(ncol, nlay, ngpt, top_at_1, D, weight, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, incident_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: D real(kind=wp), intent(in) :: weight real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: incident_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g Called by proc~~lw_solver_noscat~~CalledByGraph proc~lw_solver_noscat lw_solver_noscat proc~lw_solver_noscat_gaussquad lw_solver_noscat_GaussQuad proc~lw_solver_noscat_gaussquad->proc~lw_solver_noscat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lw_solver_noscat.html"},{"title":"lw_solver_noscat_GaussQuad – rte-rrtmgp","text":"public subroutine lw_solver_noscat_GaussQuad(ncol, nlay, ngpt, top_at_1, nmus, Ds, weights, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 integer, intent(in) :: nmus real(kind=wp), intent(in), dimension (ncol,      ngpt, nmus) :: Ds real(kind=wp), intent(in), dimension(nmus) :: weights real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(inout), dimension(ncol,nlay+1     ), target :: broadband_up real(kind=wp), intent(inout), dimension(ncol,nlay+1     ), target :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g Calls proc~~lw_solver_noscat_gaussquad~~CallsGraph proc~lw_solver_noscat_gaussquad lw_solver_noscat_GaussQuad proc~lw_solver_noscat lw_solver_noscat proc~lw_solver_noscat_gaussquad->proc~lw_solver_noscat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lw_solver_noscat_gaussquad.html"},{"title":"sw_solver_2stream – rte-rrtmgp","text":"public subroutine sw_solver_2stream(ncol, nlay, ngpt, top_at_1, tau, ssa, g, mu0, sfc_alb_dir, sfc_alb_dif, inc_flux_dir, flux_up, flux_dn, flux_dir, has_dif_bc, inc_flux_dif, do_broadband, broadband_up, broadband_dn, broadband_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dir real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dif real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dir logical(kind=wl), intent(in) :: has_dif_bc real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dif logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dir Called by proc~~sw_solver_2stream~~CalledByGraph proc~sw_solver_2stream sw_solver_2stream proc~rte_sw rte_sw proc~rte_sw->proc~sw_solver_2stream proc~compute_bc compute_bc proc~compute_bc->proc~rte_sw proc~rte_sw~2 rte_sw proc~rte_sw~2->proc~rte_sw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sw_solver_2stream.html"},{"title":"sw_solver_noscat – rte-rrtmgp","text":"public subroutine sw_solver_noscat(ncol, nlay, ngpt, top_at_1, tau, mu0, inc_flux_dir, flux_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dir Called by proc~~sw_solver_noscat~~CalledByGraph proc~sw_solver_noscat sw_solver_noscat proc~rte_sw rte_sw proc~rte_sw->proc~sw_solver_noscat proc~compute_bc compute_bc proc~compute_bc->proc~rte_sw proc~rte_sw~2 rte_sw proc~rte_sw~2->proc~rte_sw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sw_solver_noscat.html"},{"title":"delta_scale_2str_f_k – rte-rrtmgp","text":"public subroutine delta_scale_2str_f_k(ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f Called by proc~~delta_scale_2str_f_k~~CalledByGraph proc~delta_scale_2str_f_k delta_scale_2str_f_k interface~delta_scale_2str_kernel delta_scale_2str_kernel interface~delta_scale_2str_kernel->proc~delta_scale_2str_f_k proc~delta_scale_2str delta_scale_2str proc~delta_scale_2str->interface~delta_scale_2str_kernel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/delta_scale_2str_f_k.html"},{"title":"delta_scale_2str_k – rte-rrtmgp","text":"public subroutine delta_scale_2str_k(ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g Called by proc~~delta_scale_2str_k~~CalledByGraph proc~delta_scale_2str_k delta_scale_2str_k interface~delta_scale_2str_kernel delta_scale_2str_kernel interface~delta_scale_2str_kernel->proc~delta_scale_2str_k proc~delta_scale_2str delta_scale_2str proc~delta_scale_2str->interface~delta_scale_2str_kernel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/delta_scale_2str_k.html"},{"title":"extract_subset_absorption_tau – rte-rrtmgp","text":"public subroutine extract_subset_absorption_tau(ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out Called by proc~~extract_subset_absorption_tau~~CalledByGraph proc~extract_subset_absorption_tau extract_subset_absorption_tau interface~extract_subset extract_subset interface~extract_subset->proc~extract_subset_absorption_tau proc~subset_2str_range subset_2str_range proc~subset_2str_range->interface~extract_subset proc~subset_1scl_range subset_1scl_range proc~subset_1scl_range->interface~extract_subset proc~subset_nstr_range subset_nstr_range proc~subset_nstr_range->interface~extract_subset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/extract_subset_absorption_tau.html"},{"title":"extract_subset_dim1_3d – rte-rrtmgp","text":"public subroutine extract_subset_dim1_3d(ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out Called by proc~~extract_subset_dim1_3d~~CalledByGraph proc~extract_subset_dim1_3d extract_subset_dim1_3d interface~extract_subset extract_subset interface~extract_subset->proc~extract_subset_dim1_3d proc~subset_2str_range subset_2str_range proc~subset_2str_range->interface~extract_subset proc~subset_1scl_range subset_1scl_range proc~subset_1scl_range->interface~extract_subset proc~subset_nstr_range subset_nstr_range proc~subset_nstr_range->interface~extract_subset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/extract_subset_dim1_3d.html"},{"title":"extract_subset_dim2_4d – rte-rrtmgp","text":"public subroutine extract_subset_dim2_4d(nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out Called by proc~~extract_subset_dim2_4d~~CalledByGraph proc~extract_subset_dim2_4d extract_subset_dim2_4d interface~extract_subset extract_subset interface~extract_subset->proc~extract_subset_dim2_4d proc~subset_2str_range subset_2str_range proc~subset_2str_range->interface~extract_subset proc~subset_1scl_range subset_1scl_range proc~subset_1scl_range->interface~extract_subset proc~subset_nstr_range subset_nstr_range proc~subset_nstr_range->interface~extract_subset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/extract_subset_dim2_4d.html"},{"title":"inc_1scalar_by_1scalar_bybnd – rte-rrtmgp","text":"public subroutine inc_1scalar_by_1scalar_bybnd(ncol, nlay, ngpt, tau1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Called by proc~~inc_1scalar_by_1scalar_bybnd~~CalledByGraph proc~inc_1scalar_by_1scalar_bybnd inc_1scalar_by_1scalar_bybnd proc~increment increment proc~increment->proc~inc_1scalar_by_1scalar_bybnd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/inc_1scalar_by_1scalar_bybnd.html"},{"title":"inc_1scalar_by_2stream_bybnd – rte-rrtmgp","text":"public subroutine inc_1scalar_by_2stream_bybnd(ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Called by proc~~inc_1scalar_by_2stream_bybnd~~CalledByGraph proc~inc_1scalar_by_2stream_bybnd inc_1scalar_by_2stream_bybnd proc~increment increment proc~increment->proc~inc_1scalar_by_2stream_bybnd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/inc_1scalar_by_2stream_bybnd.html"},{"title":"inc_1scalar_by_nstream_bybnd – rte-rrtmgp","text":"public subroutine inc_1scalar_by_nstream_bybnd(ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Called by proc~~inc_1scalar_by_nstream_bybnd~~CalledByGraph proc~inc_1scalar_by_nstream_bybnd inc_1scalar_by_nstream_bybnd proc~increment increment proc~increment->proc~inc_1scalar_by_nstream_bybnd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/inc_1scalar_by_nstream_bybnd.html"},{"title":"inc_2stream_by_1scalar_bybnd – rte-rrtmgp","text":"public subroutine inc_2stream_by_1scalar_bybnd(ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Called by proc~~inc_2stream_by_1scalar_bybnd~~CalledByGraph proc~inc_2stream_by_1scalar_bybnd inc_2stream_by_1scalar_bybnd proc~increment increment proc~increment->proc~inc_2stream_by_1scalar_bybnd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/inc_2stream_by_1scalar_bybnd.html"},{"title":"inc_2stream_by_2stream_bybnd – rte-rrtmgp","text":"public subroutine inc_2stream_by_2stream_bybnd(ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Called by proc~~inc_2stream_by_2stream_bybnd~~CalledByGraph proc~inc_2stream_by_2stream_bybnd inc_2stream_by_2stream_bybnd proc~increment increment proc~increment->proc~inc_2stream_by_2stream_bybnd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/inc_2stream_by_2stream_bybnd.html"},{"title":"inc_2stream_by_nstream_bybnd – rte-rrtmgp","text":"public subroutine inc_2stream_by_nstream_bybnd(ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Called by proc~~inc_2stream_by_nstream_bybnd~~CalledByGraph proc~inc_2stream_by_nstream_bybnd inc_2stream_by_nstream_bybnd proc~increment increment proc~increment->proc~inc_2stream_by_nstream_bybnd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/inc_2stream_by_nstream_bybnd.html"},{"title":"inc_nstream_by_1scalar_bybnd – rte-rrtmgp","text":"public subroutine inc_nstream_by_1scalar_bybnd(ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Called by proc~~inc_nstream_by_1scalar_bybnd~~CalledByGraph proc~inc_nstream_by_1scalar_bybnd inc_nstream_by_1scalar_bybnd proc~increment increment proc~increment->proc~inc_nstream_by_1scalar_bybnd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/inc_nstream_by_1scalar_bybnd.html"},{"title":"inc_nstream_by_2stream_bybnd – rte-rrtmgp","text":"public subroutine inc_nstream_by_2stream_bybnd(ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Called by proc~~inc_nstream_by_2stream_bybnd~~CalledByGraph proc~inc_nstream_by_2stream_bybnd inc_nstream_by_2stream_bybnd proc~increment increment proc~increment->proc~inc_nstream_by_2stream_bybnd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/inc_nstream_by_2stream_bybnd.html"},{"title":"inc_nstream_by_nstream_bybnd – rte-rrtmgp","text":"public subroutine inc_nstream_by_nstream_bybnd(ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Called by proc~~inc_nstream_by_nstream_bybnd~~CalledByGraph proc~inc_nstream_by_nstream_bybnd inc_nstream_by_nstream_bybnd proc~increment increment proc~increment->proc~inc_nstream_by_nstream_bybnd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/inc_nstream_by_nstream_bybnd.html"},{"title":"increment_1scalar_by_1scalar – rte-rrtmgp","text":"public subroutine increment_1scalar_by_1scalar(ncol, nlay, ngpt, tau1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 Called by proc~~increment_1scalar_by_1scalar~~CalledByGraph proc~increment_1scalar_by_1scalar increment_1scalar_by_1scalar proc~increment increment proc~increment->proc~increment_1scalar_by_1scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/increment_1scalar_by_1scalar.html"},{"title":"increment_1scalar_by_2stream – rte-rrtmgp","text":"public subroutine increment_1scalar_by_2stream(ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 Called by proc~~increment_1scalar_by_2stream~~CalledByGraph proc~increment_1scalar_by_2stream increment_1scalar_by_2stream proc~increment increment proc~increment->proc~increment_1scalar_by_2stream Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/increment_1scalar_by_2stream.html"},{"title":"increment_1scalar_by_nstream – rte-rrtmgp","text":"public subroutine increment_1scalar_by_nstream(ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 Called by proc~~increment_1scalar_by_nstream~~CalledByGraph proc~increment_1scalar_by_nstream increment_1scalar_by_nstream proc~increment increment proc~increment->proc~increment_1scalar_by_nstream Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/increment_1scalar_by_nstream.html"},{"title":"increment_2stream_by_1scalar – rte-rrtmgp","text":"public subroutine increment_2stream_by_1scalar(ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 Called by proc~~increment_2stream_by_1scalar~~CalledByGraph proc~increment_2stream_by_1scalar increment_2stream_by_1scalar proc~increment increment proc~increment->proc~increment_2stream_by_1scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/increment_2stream_by_1scalar.html"},{"title":"increment_2stream_by_2stream – rte-rrtmgp","text":"public subroutine increment_2stream_by_2stream(ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 Called by proc~~increment_2stream_by_2stream~~CalledByGraph proc~increment_2stream_by_2stream increment_2stream_by_2stream proc~increment increment proc~increment->proc~increment_2stream_by_2stream Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/increment_2stream_by_2stream.html"},{"title":"increment_2stream_by_nstream – rte-rrtmgp","text":"public subroutine increment_2stream_by_nstream(ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2 Called by proc~~increment_2stream_by_nstream~~CalledByGraph proc~increment_2stream_by_nstream increment_2stream_by_nstream proc~increment increment proc~increment->proc~increment_2stream_by_nstream Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/increment_2stream_by_nstream.html"},{"title":"increment_nstream_by_1scalar – rte-rrtmgp","text":"public subroutine increment_nstream_by_1scalar(ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 Called by proc~~increment_nstream_by_1scalar~~CalledByGraph proc~increment_nstream_by_1scalar increment_nstream_by_1scalar proc~increment increment proc~increment->proc~increment_nstream_by_1scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/increment_nstream_by_1scalar.html"},{"title":"increment_nstream_by_2stream – rte-rrtmgp","text":"public subroutine increment_nstream_by_2stream(ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 Called by proc~~increment_nstream_by_2stream~~CalledByGraph proc~increment_nstream_by_2stream increment_nstream_by_2stream proc~increment increment proc~increment->proc~increment_nstream_by_2stream Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/increment_nstream_by_2stream.html"},{"title":"increment_nstream_by_nstream – rte-rrtmgp","text":"public subroutine increment_nstream_by_nstream(ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2 Called by proc~~increment_nstream_by_nstream~~CalledByGraph proc~increment_nstream_by_nstream increment_nstream_by_nstream proc~increment increment proc~increment->proc~increment_nstream_by_nstream Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/increment_nstream_by_nstream.html"},{"title":"delta_scale_2str_kernel – rte-rrtmgp","text":"public interface delta_scale_2str_kernel Calls interface~~delta_scale_2str_kernel~~CallsGraph interface~delta_scale_2str_kernel delta_scale_2str_kernel proc~delta_scale_2str_k delta_scale_2str_k interface~delta_scale_2str_kernel->proc~delta_scale_2str_k proc~delta_scale_2str_f_k delta_scale_2str_f_k interface~delta_scale_2str_kernel->proc~delta_scale_2str_f_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~delta_scale_2str_kernel~~CalledByGraph interface~delta_scale_2str_kernel delta_scale_2str_kernel proc~delta_scale_2str delta_scale_2str proc~delta_scale_2str->interface~delta_scale_2str_kernel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures delta_scale_2str_f_k delta_scale_2str_k Module Procedures public subroutine delta_scale_2str_f_k (ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f public subroutine delta_scale_2str_k (ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g","tags":"","loc":"interface/delta_scale_2str_kernel.html"},{"title":"extract_subset – rte-rrtmgp","text":"public interface extract_subset Calls interface~~extract_subset~~CallsGraph interface~extract_subset extract_subset proc~extract_subset_dim2_4d extract_subset_dim2_4d interface~extract_subset->proc~extract_subset_dim2_4d proc~extract_subset_dim1_3d extract_subset_dim1_3d interface~extract_subset->proc~extract_subset_dim1_3d proc~extract_subset_absorption_tau extract_subset_absorption_tau interface~extract_subset->proc~extract_subset_absorption_tau Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~extract_subset~~CalledByGraph interface~extract_subset extract_subset proc~subset_2str_range subset_2str_range proc~subset_2str_range->interface~extract_subset proc~subset_1scl_range subset_1scl_range proc~subset_1scl_range->interface~extract_subset proc~subset_nstr_range subset_nstr_range proc~subset_nstr_range->interface~extract_subset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures extract_subset_dim1_3d extract_subset_dim2_4d extract_subset_absorption_tau Module Procedures public subroutine extract_subset_dim1_3d (ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out public subroutine extract_subset_dim2_4d (nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out public subroutine extract_subset_absorption_tau (ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out","tags":"","loc":"interface/extract_subset.html"},{"title":"sum_broadband – rte-rrtmgp","text":"public subroutine sum_broadband(ncol, nlev, ngpt, spectral_flux, broadband_flux) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux real(kind=wp), intent(out), dimension(ncol, nlev) :: broadband_flux Contents None","tags":"","loc":"proc/sum_broadband.html"},{"title":"net_broadband – rte-rrtmgp","text":"public interface net_broadband Contents Module Procedures net_broadband_full net_broadband_precalc Module Procedures private subroutine net_broadband_full(ncol, nlev, ngpt, spectral_flux_dn, spectral_flux_up, broadband_flux_net) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_up real(kind=wp), intent(out), dimension(ncol, nlev) :: broadband_flux_net private subroutine net_broadband_precalc(ncol, nlev, flux_dn, flux_up, broadband_flux_net) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev real(kind=wp), intent(in), dimension(ncol, nlev) :: flux_dn real(kind=wp), intent(in), dimension(ncol, nlev) :: flux_up real(kind=wp), intent(out), dimension(ncol, nlev) :: broadband_flux_net","tags":"","loc":"interface/net_broadband.html"},{"title":"lw_solver_2stream – rte-rrtmgp","text":"public subroutine lw_solver_2stream(ncol, nlay, ngpt, top_at_1, tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dn Contents None","tags":"","loc":"proc/lw_solver_2stream~2.html"},{"title":"lw_solver_noscat – rte-rrtmgp","text":"public subroutine lw_solver_noscat(ncol, nlay, ngpt, top_at_1, D, weight, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, incident_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: D real(kind=wp), intent(in) :: weight real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: incident_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g Calls proc~~lw_solver_noscat~2~~CallsGraph proc~lw_solver_noscat~2 lw_solver_noscat interface~zero_array zero_array proc~lw_solver_noscat~2->interface~zero_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lw_solver_noscat~2~~CalledByGraph proc~lw_solver_noscat~2 lw_solver_noscat proc~lw_solver_noscat_gaussquad~2 lw_solver_noscat_GaussQuad proc~lw_solver_noscat_gaussquad~2->proc~lw_solver_noscat~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lw_solver_noscat~2.html"},{"title":"lw_solver_noscat_GaussQuad – rte-rrtmgp","text":"public subroutine lw_solver_noscat_GaussQuad(ncol, nlay, ngpt, top_at_1, nmus, Ds, weights, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 integer, intent(in) :: nmus real(kind=wp), intent(in), dimension (ncol,      ngpt, nmus) :: Ds real(kind=wp), intent(in), dimension(nmus) :: weights real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g Calls proc~~lw_solver_noscat_gaussquad~2~~CallsGraph proc~lw_solver_noscat_gaussquad~2 lw_solver_noscat_GaussQuad proc~lw_solver_noscat~2 lw_solver_noscat proc~lw_solver_noscat_gaussquad~2->proc~lw_solver_noscat~2 interface~zero_array zero_array proc~lw_solver_noscat~2->interface~zero_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lw_solver_noscat_gaussquad~2.html"},{"title":"sw_solver_2stream – rte-rrtmgp","text":"public subroutine sw_solver_2stream(ncol, nlay, ngpt, top_at_1, tau, ssa, g, mu0, sfc_alb_dir, sfc_alb_dif, inc_flux_dir, flux_up, flux_dn, flux_dir, has_dif_bc, inc_flux_dif, do_broadband, broadband_up, broadband_dn, broadband_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dir real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dif real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dir logical(kind=wl), intent(in) :: has_dif_bc real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dif logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dir Calls proc~~sw_solver_2stream~2~~CallsGraph proc~sw_solver_2stream~2 sw_solver_2stream interface~zero_array zero_array proc~sw_solver_2stream~2->interface~zero_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sw_solver_2stream~2.html"},{"title":"sw_solver_noscat – rte-rrtmgp","text":"public pure subroutine sw_solver_noscat(ncol, nlay, ngpt, top_at_1, tau, mu0, inc_flux_dir, flux_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dir Contents None","tags":"","loc":"proc/sw_solver_noscat~2.html"},{"title":"delta_scale_2str_f_k – rte-rrtmgp","text":"public pure subroutine delta_scale_2str_f_k(ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f Called by proc~~delta_scale_2str_f_k~2~~CalledByGraph proc~delta_scale_2str_f_k~2 delta_scale_2str_f_k interface~delta_scale_2str_kernel~2 delta_scale_2str_kernel interface~delta_scale_2str_kernel~2->proc~delta_scale_2str_f_k~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/delta_scale_2str_f_k~2.html"},{"title":"delta_scale_2str_k – rte-rrtmgp","text":"public pure subroutine delta_scale_2str_k(ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g Called by proc~~delta_scale_2str_k~2~~CalledByGraph proc~delta_scale_2str_k~2 delta_scale_2str_k interface~delta_scale_2str_kernel~2 delta_scale_2str_kernel interface~delta_scale_2str_kernel~2->proc~delta_scale_2str_k~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/delta_scale_2str_k~2.html"},{"title":"extract_subset_absorption_tau – rte-rrtmgp","text":"public pure subroutine extract_subset_absorption_tau(ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out Called by proc~~extract_subset_absorption_tau~2~~CalledByGraph proc~extract_subset_absorption_tau~2 extract_subset_absorption_tau interface~extract_subset~2 extract_subset interface~extract_subset~2->proc~extract_subset_absorption_tau~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/extract_subset_absorption_tau~2.html"},{"title":"extract_subset_dim1_3d – rte-rrtmgp","text":"public pure subroutine extract_subset_dim1_3d(ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out Called by proc~~extract_subset_dim1_3d~2~~CalledByGraph proc~extract_subset_dim1_3d~2 extract_subset_dim1_3d interface~extract_subset~2 extract_subset interface~extract_subset~2->proc~extract_subset_dim1_3d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/extract_subset_dim1_3d~2.html"},{"title":"extract_subset_dim2_4d – rte-rrtmgp","text":"public pure subroutine extract_subset_dim2_4d(nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out Called by proc~~extract_subset_dim2_4d~2~~CalledByGraph proc~extract_subset_dim2_4d~2 extract_subset_dim2_4d interface~extract_subset~2 extract_subset interface~extract_subset~2->proc~extract_subset_dim2_4d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/extract_subset_dim2_4d~2.html"},{"title":"inc_1scalar_by_1scalar_bybnd – rte-rrtmgp","text":"public pure subroutine inc_1scalar_by_1scalar_bybnd(ncol, nlay, ngpt, tau1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents None","tags":"","loc":"proc/inc_1scalar_by_1scalar_bybnd~2.html"},{"title":"inc_1scalar_by_2stream_bybnd – rte-rrtmgp","text":"public pure subroutine inc_1scalar_by_2stream_bybnd(ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents None","tags":"","loc":"proc/inc_1scalar_by_2stream_bybnd~2.html"},{"title":"inc_1scalar_by_nstream_bybnd – rte-rrtmgp","text":"public pure subroutine inc_1scalar_by_nstream_bybnd(ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents None","tags":"","loc":"proc/inc_1scalar_by_nstream_bybnd~2.html"},{"title":"inc_2stream_by_1scalar_bybnd – rte-rrtmgp","text":"public pure subroutine inc_2stream_by_1scalar_bybnd(ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents None","tags":"","loc":"proc/inc_2stream_by_1scalar_bybnd~2.html"},{"title":"inc_2stream_by_2stream_bybnd – rte-rrtmgp","text":"public pure subroutine inc_2stream_by_2stream_bybnd(ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents None","tags":"","loc":"proc/inc_2stream_by_2stream_bybnd~2.html"},{"title":"inc_2stream_by_nstream_bybnd – rte-rrtmgp","text":"public pure subroutine inc_2stream_by_nstream_bybnd(ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents None","tags":"","loc":"proc/inc_2stream_by_nstream_bybnd~2.html"},{"title":"inc_nstream_by_1scalar_bybnd – rte-rrtmgp","text":"public pure subroutine inc_nstream_by_1scalar_bybnd(ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents None","tags":"","loc":"proc/inc_nstream_by_1scalar_bybnd~2.html"},{"title":"inc_nstream_by_2stream_bybnd – rte-rrtmgp","text":"public pure subroutine inc_nstream_by_2stream_bybnd(ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents None","tags":"","loc":"proc/inc_nstream_by_2stream_bybnd~2.html"},{"title":"inc_nstream_by_nstream_bybnd – rte-rrtmgp","text":"public pure subroutine inc_nstream_by_nstream_bybnd(ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims Contents None","tags":"","loc":"proc/inc_nstream_by_nstream_bybnd~2.html"},{"title":"increment_1scalar_by_1scalar – rte-rrtmgp","text":"public pure subroutine increment_1scalar_by_1scalar(ncol, nlay, ngpt, tau1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 Contents None","tags":"","loc":"proc/increment_1scalar_by_1scalar~2.html"},{"title":"increment_1scalar_by_2stream – rte-rrtmgp","text":"public pure subroutine increment_1scalar_by_2stream(ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 Contents None","tags":"","loc":"proc/increment_1scalar_by_2stream~2.html"},{"title":"increment_1scalar_by_nstream – rte-rrtmgp","text":"public pure subroutine increment_1scalar_by_nstream(ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 Contents None","tags":"","loc":"proc/increment_1scalar_by_nstream~2.html"},{"title":"increment_2stream_by_1scalar – rte-rrtmgp","text":"public pure subroutine increment_2stream_by_1scalar(ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 Contents None","tags":"","loc":"proc/increment_2stream_by_1scalar~2.html"},{"title":"increment_2stream_by_2stream – rte-rrtmgp","text":"public pure subroutine increment_2stream_by_2stream(ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 Contents None","tags":"","loc":"proc/increment_2stream_by_2stream~2.html"},{"title":"increment_2stream_by_nstream – rte-rrtmgp","text":"public pure subroutine increment_2stream_by_nstream(ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2 Contents None","tags":"","loc":"proc/increment_2stream_by_nstream~2.html"},{"title":"increment_nstream_by_1scalar – rte-rrtmgp","text":"public pure subroutine increment_nstream_by_1scalar(ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 Contents None","tags":"","loc":"proc/increment_nstream_by_1scalar~2.html"},{"title":"increment_nstream_by_2stream – rte-rrtmgp","text":"public pure subroutine increment_nstream_by_2stream(ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 Contents None","tags":"","loc":"proc/increment_nstream_by_2stream~2.html"},{"title":"increment_nstream_by_nstream – rte-rrtmgp","text":"public pure subroutine increment_nstream_by_nstream(ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2 Contents None","tags":"","loc":"proc/increment_nstream_by_nstream~2.html"},{"title":"delta_scale_2str_kernel – rte-rrtmgp","text":"public interface delta_scale_2str_kernel Calls interface~~delta_scale_2str_kernel~2~~CallsGraph interface~delta_scale_2str_kernel~2 delta_scale_2str_kernel proc~delta_scale_2str_f_k~2 delta_scale_2str_f_k interface~delta_scale_2str_kernel~2->proc~delta_scale_2str_f_k~2 proc~delta_scale_2str_k~2 delta_scale_2str_k interface~delta_scale_2str_kernel~2->proc~delta_scale_2str_k~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures delta_scale_2str_f_k delta_scale_2str_k Module Procedures public pure subroutine delta_scale_2str_f_k (ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f public pure subroutine delta_scale_2str_k (ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g","tags":"","loc":"interface/delta_scale_2str_kernel~2.html"},{"title":"extract_subset – rte-rrtmgp","text":"public interface extract_subset Calls interface~~extract_subset~2~~CallsGraph interface~extract_subset~2 extract_subset proc~extract_subset_dim1_3d~2 extract_subset_dim1_3d interface~extract_subset~2->proc~extract_subset_dim1_3d~2 proc~extract_subset_dim2_4d~2 extract_subset_dim2_4d interface~extract_subset~2->proc~extract_subset_dim2_4d~2 proc~extract_subset_absorption_tau~2 extract_subset_absorption_tau interface~extract_subset~2->proc~extract_subset_absorption_tau~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures extract_subset_dim1_3d extract_subset_dim2_4d extract_subset_absorption_tau Module Procedures public pure subroutine extract_subset_dim1_3d (ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out public pure subroutine extract_subset_dim2_4d (nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out public pure subroutine extract_subset_absorption_tau (ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out","tags":"","loc":"interface/extract_subset~2.html"},{"title":"lower_case – rte-rrtmgp","text":"public pure function lower_case(input_string) result(output_string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_string Return Value character(len=len) Called by proc~~lower_case~~CalledByGraph proc~lower_case lower_case proc~string_in_array string_in_array proc~string_in_array->proc~lower_case proc~init init proc~init->proc~lower_case proc~string_loc_in_array string_loc_in_array proc~string_loc_in_array->proc~lower_case proc~find_gas find_gas proc~find_gas->proc~lower_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lower_case.html"},{"title":"string_in_array – rte-rrtmgp","text":"public pure function string_in_array(string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), dimension(:) :: array Return Value logical Calls proc~~string_in_array~~CallsGraph proc~string_in_array string_in_array proc~lower_case lower_case proc~string_in_array->proc~lower_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/string_in_array.html"},{"title":"string_loc_in_array – rte-rrtmgp","text":"public pure function string_loc_in_array(string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), dimension(:) :: array Return Value integer Calls proc~~string_loc_in_array~~CallsGraph proc~string_loc_in_array string_loc_in_array proc~lower_case lower_case proc~string_loc_in_array->proc~lower_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/string_loc_in_array.html"},{"title":"reorder123x321 – rte-rrtmgp","text":"public subroutine reorder123x321(array, array_out) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(out), dimension(:,:,:) :: array_out Calls proc~~reorder123x321~~CallsGraph proc~reorder123x321 reorder123x321 proc~reorder_123x321_kernel reorder_123x321_kernel proc~reorder123x321->proc~reorder_123x321_kernel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/reorder123x321.html"},{"title":"find_gas – rte-rrtmgp","text":"public function find_gas(this, gas) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this character(len=*), intent(in) :: gas Return Value integer Calls proc~~find_gas~~CallsGraph proc~find_gas find_gas proc~lower_case lower_case proc~find_gas->proc~lower_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_gas.html"},{"title":"get_gas_names – rte-rrtmgp","text":"public pure function get_gas_names(this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this Return Value character(len=32),\n  dimension(this%get_num_gases()) Contents None","tags":"","loc":"proc/get_gas_names.html"},{"title":"get_num_gases – rte-rrtmgp","text":"public pure function get_num_gases(this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_num_gases.html"},{"title":"get_subset_range – rte-rrtmgp","text":"public function get_subset_range(this, start, n, subset) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this integer, intent(in) :: start integer, intent(in) :: n class( ty_gas_concs ), intent(inout) :: subset Return Value character(len=128) Contents None","tags":"","loc":"proc/get_subset_range.html"},{"title":"get_vmr_1d – rte-rrtmgp","text":"public function get_vmr_1d(this, gas, array) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(out), dimension(:) :: array Return Value character(len=128) Contents None","tags":"","loc":"proc/get_vmr_1d.html"},{"title":"get_vmr_2d – rte-rrtmgp","text":"public function get_vmr_2d(this, gas, array) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(out), dimension(:,:) :: array Return Value character(len=128) Contents None","tags":"","loc":"proc/get_vmr_2d.html"},{"title":"init – rte-rrtmgp","text":"public function init(this, gas_names) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: gas_names Return Value character(len=128) Calls proc~~init~~CallsGraph proc~init init proc~lower_case lower_case proc~init->proc~lower_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init.html"},{"title":"set_vmr_1d – rte-rrtmgp","text":"public function set_vmr_1d(this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in), dimension(:) :: w Return Value character(len=128) Calls proc~~set_vmr_1d~~CallsGraph proc~set_vmr_1d set_vmr_1d interface~any_vals_outside any_vals_outside proc~set_vmr_1d->interface~any_vals_outside Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_vmr_1d.html"},{"title":"set_vmr_2d – rte-rrtmgp","text":"public function set_vmr_2d(this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in), dimension(:,:) :: w Return Value character(len=128) Calls proc~~set_vmr_2d~~CallsGraph proc~set_vmr_2d set_vmr_2d interface~any_vals_outside any_vals_outside proc~set_vmr_2d->interface~any_vals_outside Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_vmr_2d.html"},{"title":"set_vmr_scalar – rte-rrtmgp","text":"public function set_vmr_scalar(this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in) :: w Return Value character(len=128) Contents None","tags":"","loc":"proc/set_vmr_scalar.html"},{"title":"del – rte-rrtmgp","text":"public subroutine del(this) Arguments Type Intent Optional Attributes Name type( ty_gas_concs ), intent(inout) :: this Contents None","tags":"","loc":"proc/del.html"},{"title":"reset – rte-rrtmgp","text":"public subroutine reset(this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this Contents None","tags":"","loc":"proc/reset.html"},{"title":"get_col_dry – rte-rrtmgp","text":"public function get_col_dry(vmr_h2o, plev, latitude) result(col_dry) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: vmr_h2o real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), optional dimension(:) :: latitude Return Value real(kind=wp),\n  dimension(size(plev,dim=1),size(plev,dim=2)-1) Contents None","tags":"","loc":"proc/get_col_dry.html"},{"title":"init_constants – rte-rrtmgp","text":"public subroutine init_constants(gravity, mol_weight_dry_air, heat_capacity_dry_air) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), optional :: gravity real(kind=wp), intent(in), optional :: mol_weight_dry_air real(kind=wp), intent(in), optional :: heat_capacity_dry_air Contents None","tags":"","loc":"proc/init_constants.html"},{"title":"interpolate1D – rte-rrtmgp","text":"public function interpolate1D(val, offset, delta, table) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: val real(kind=wp), intent(in) :: offset real(kind=wp), intent(in) :: delta real(kind=wp), intent(in), dimension(:) :: table Return Value real(kind=wp) Called by proc~~interpolate1d~~CalledByGraph proc~interpolate1d interpolate1D proc~compute_planck_source compute_Planck_source proc~compute_planck_source->proc~interpolate1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpolate1d.html"},{"title":"interpolate2D – rte-rrtmgp","text":"public function interpolate2D(fminor, k, igpt, jeta, jtemp) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: fminor real(kind=wp), intent(in), dimension(:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp Return Value real(kind=wp) Called by proc~~interpolate2d~~CalledByGraph proc~interpolate2d interpolate2D proc~compute_tau_rayleigh compute_tau_rayleigh proc~compute_tau_rayleigh->proc~interpolate2d proc~gas_optical_depths_minor gas_optical_depths_minor proc~gas_optical_depths_minor->proc~interpolate2d proc~compute_tau_absorption compute_tau_absorption proc~compute_tau_absorption->proc~gas_optical_depths_minor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpolate2d.html"},{"title":"interpolate3D – rte-rrtmgp","text":"public function interpolate3D(scaling, fmajor, k, igpt, jeta, jtemp, jpress) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: scaling real(kind=wp), intent(in), dimension(2,2,2) :: fmajor real(kind=wp), intent(in), dimension(:,:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp integer, intent(in) :: jpress Return Value real(kind=wp) Called by proc~~interpolate3d~~CalledByGraph proc~interpolate3d interpolate3D proc~compute_planck_source compute_Planck_source proc~compute_planck_source->proc~interpolate3d proc~gas_optical_depths_major gas_optical_depths_major proc~gas_optical_depths_major->proc~interpolate3d proc~compute_tau_absorption compute_tau_absorption proc~compute_tau_absorption->proc~gas_optical_depths_major Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpolate3d.html"},{"title":"compute_Planck_source – rte-rrtmgp","text":"public subroutine compute_Planck_source(ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, nPlanckTemp, tlay, tlev, tsfc, sfc_lay, fmajor, jeta, tropo, jtemp, jpress, gpoint_bands, band_lims_gpt, pfracin, temp_ref_min, totplnk_delta, totplnk, gpoint_flavor, sfc_src, lay_src, lev_src_inc, lev_src_dec, sfc_source_Jac) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nPlanckTemp real(kind=wp), intent(in), dimension(ncol,nlay  ) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay+1) :: tlev real(kind=wp), intent(in), dimension(ncol       ) :: tsfc integer, intent(in) :: sfc_lay real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(            ncol,nlay) :: tropo integer, intent(in), dimension(            ncol,nlay) :: jtemp integer, intent(in), dimension(            ncol,nlay) :: jpress integer, intent(in), dimension(ngpt) :: gpoint_bands integer, intent(in), dimension(2, nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: pfracin real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: totplnk_delta real(kind=wp), intent(in), dimension(nPlanckTemp,nbnd) :: totplnk integer, intent(in), dimension(2,ngpt) :: gpoint_flavor real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lay_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_inc real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_dec real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_source_Jac Calls proc~~compute_planck_source~~CallsGraph proc~compute_planck_source compute_Planck_source proc~interpolate3d interpolate3D proc~compute_planck_source->proc~interpolate3d proc~interpolate1d interpolate1D proc~compute_planck_source->proc~interpolate1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/compute_planck_source.html"},{"title":"compute_tau_absorption – rte-rrtmgp","text":"public subroutine compute_tau_absorption(ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, nminorlower, nminorklower, nminorupper, nminorkupper, idx_h2o, gpoint_flavor, band_lims_gpt, kmajor, kminor_lower, kminor_upper, minor_limits_gpt_lower, minor_limits_gpt_upper, minor_scales_with_density_lower, minor_scales_with_density_upper, scale_by_complement_lower, scale_by_complement_upper, idx_minor_lower, idx_minor_upper, idx_minor_scaling_lower, idx_minor_scaling_upper, kminor_start_lower, kminor_start_upper, tropo, col_mix, fmajor, fminor, play, tlay, col_gas, jeta, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nminorlower integer, intent(in) :: nminorklower integer, intent(in) :: nminorupper integer, intent(in) :: nminorkupper integer, intent(in) :: idx_h2o integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(ntemp,neta,nminorklower) :: kminor_lower real(kind=wp), intent(in), dimension(ntemp,neta,nminorkupper) :: kminor_upper integer, intent(in), dimension(2,nminorlower) :: minor_limits_gpt_lower integer, intent(in), dimension(2,nminorupper) :: minor_limits_gpt_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: minor_scales_with_density_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: minor_scales_with_density_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: scale_by_complement_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: scale_by_complement_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_scaling_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_scaling_upper integer, intent(in), dimension(  nminorlower) :: kminor_start_lower integer, intent(in), dimension(  nminorupper) :: kminor_start_upper logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav       ) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav       ) :: fmajor real(kind=wp), intent(in), dimension(2,2,  ncol,nlay,nflav       ) :: fminor real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: play real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: tlay real(kind=wp), intent(in), dimension(            ncol,nlay,0:ngas) :: col_gas integer, intent(in), dimension(2,    ncol,nlay,nflav       ) :: jeta integer, intent(in), dimension(            ncol,nlay       ) :: jtemp integer, intent(in), dimension(            ncol,nlay       ) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau Calls proc~~compute_tau_absorption~~CallsGraph proc~compute_tau_absorption compute_tau_absorption proc~gas_optical_depths_major gas_optical_depths_major proc~compute_tau_absorption->proc~gas_optical_depths_major proc~gas_optical_depths_minor gas_optical_depths_minor proc~compute_tau_absorption->proc~gas_optical_depths_minor proc~interpolate3d interpolate3D proc~gas_optical_depths_major->proc~interpolate3d proc~interpolate2d interpolate2D proc~gas_optical_depths_minor->proc~interpolate2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/compute_tau_absorption.html"},{"title":"compute_tau_rayleigh – rte-rrtmgp","text":"public subroutine compute_tau_rayleigh(ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, krayl, idx_h2o, col_dry, col_gas, fminor, jeta, tropo, jtemp, tau_rayleigh) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,ngpt,2) :: krayl integer, intent(in) :: idx_h2o real(kind=wp), intent(in), dimension(ncol,nlay) :: col_dry real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: tau_rayleigh Calls proc~~compute_tau_rayleigh~~CallsGraph proc~compute_tau_rayleigh compute_tau_rayleigh proc~interpolate2d interpolate2D proc~compute_tau_rayleigh->proc~interpolate2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/compute_tau_rayleigh.html"},{"title":"gas_optical_depths_major – rte-rrtmgp","text":"public subroutine gas_optical_depths_major(ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, kmajor, col_mix, fmajor, jeta, tropo, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp integer, intent(in), dimension(ncol,nlay) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau Calls proc~~gas_optical_depths_major~~CallsGraph proc~gas_optical_depths_major gas_optical_depths_major proc~interpolate3d interpolate3D proc~gas_optical_depths_major->proc~interpolate3d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gas_optical_depths_major~~CalledByGraph proc~gas_optical_depths_major gas_optical_depths_major proc~compute_tau_absorption compute_tau_absorption proc~compute_tau_absorption->proc~gas_optical_depths_major Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gas_optical_depths_major.html"},{"title":"gas_optical_depths_minor – rte-rrtmgp","text":"public subroutine gas_optical_depths_minor(ncol, nlay, ngpt, ngas, nflav, ntemp, neta, nminor, nminork, idx_h2o, idx_tropo, gpt_flv, kminor, minor_limits_gpt, minor_scales_with_density, scale_by_complement, idx_minor, idx_minor_scaling, kminor_start, play, tlay, col_gas, fminor, jeta, layer_limits, jtemp, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: ntemp integer, intent(in) :: neta integer, intent(in) :: nminor integer, intent(in) :: nminork integer, intent(in) :: idx_h2o integer, intent(in) :: idx_tropo integer, intent(in), dimension(2, ngpt) :: gpt_flv real(kind=wp), intent(in), dimension(ntemp,neta,nminork) :: kminor integer, intent(in), dimension(2,nminor) :: minor_limits_gpt logical(kind=wl), intent(in), dimension(  nminor) :: minor_scales_with_density logical(kind=wl), intent(in), dimension(  nminor) :: scale_by_complement integer, intent(in), dimension(  nminor) :: idx_minor integer, intent(in), dimension(  nminor) :: idx_minor_scaling integer, intent(in), dimension(  nminor) :: kminor_start real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta integer, intent(in), dimension(ncol, 2) :: layer_limits integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau Calls proc~~gas_optical_depths_minor~~CallsGraph proc~gas_optical_depths_minor gas_optical_depths_minor proc~interpolate2d interpolate2D proc~gas_optical_depths_minor->proc~interpolate2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gas_optical_depths_minor~~CalledByGraph proc~gas_optical_depths_minor gas_optical_depths_minor proc~compute_tau_absorption compute_tau_absorption proc~compute_tau_absorption->proc~gas_optical_depths_minor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gas_optical_depths_minor.html"},{"title":"interpolation – rte-rrtmgp","text":"public subroutine interpolation(ncol, nlay, ngas, nflav, neta, npres, ntemp, flavor, press_ref_log, temp_ref, press_ref_log_delta, temp_ref_min, temp_ref_delta, press_ref_trop_log, vmr_ref, play, tlay, col_gas, jtemp, fmajor, fminor, col_mix, tropo, jeta, jpress) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,nflav) :: flavor real(kind=wp), intent(in), dimension(npres) :: press_ref_log real(kind=wp), intent(in), dimension(ntemp) :: temp_ref real(kind=wp), intent(in) :: press_ref_log_delta real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: temp_ref_delta real(kind=wp), intent(in) :: press_ref_trop_log real(kind=wp), intent(in), dimension(2,0:ngas,ntemp) :: vmr_ref real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas integer, intent(out), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(2,2,2,ncol,nlay,nflav) :: fmajor real(kind=wp), intent(out), dimension(2,2,  ncol,nlay,nflav) :: fminor real(kind=wp), intent(out), dimension(2,    ncol,nlay,nflav) :: col_mix logical(kind=wl), intent(out), dimension(ncol,nlay) :: tropo integer, intent(out), dimension(2,    ncol,nlay,nflav) :: jeta integer, intent(out), dimension(ncol,nlay) :: jpress Calls proc~~interpolation~~CallsGraph proc~interpolation interpolation float float proc~interpolation->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpolation.html"},{"title":"minmaxloc – rte-rrtmgp","text":"public subroutine minmaxloc(i, mask, a, minl, maxl) Arguments Type Intent Optional Attributes Name integer :: i logical(kind=wl) :: mask (:,:) real(kind=wp) :: a (:,:) integer :: minl integer :: maxl Contents None","tags":"","loc":"proc/minmaxloc.html"},{"title":"reorder_123x321_kernel – rte-rrtmgp","text":"public subroutine reorder_123x321_kernel(d1, d2, d3, array_in, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: d1 integer, intent(in) :: d2 integer, intent(in) :: d3 real(kind=wp), intent(in), dimension(d1, d2, d3) :: array_in real(kind=wp), intent(out), dimension(d3, d2, d1) :: array_out Called by proc~~reorder_123x321_kernel~~CalledByGraph proc~reorder_123x321_kernel reorder_123x321_kernel proc~reorder123x321 reorder123x321 proc~reorder123x321->proc~reorder_123x321_kernel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/reorder_123x321_kernel.html"},{"title":"interpolate1D – rte-rrtmgp","text":"public pure function interpolate1D(val, offset, delta, table) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: val real(kind=wp), intent(in) :: offset real(kind=wp), intent(in) :: delta real(kind=wp), intent(in), dimension(:,:) :: table Return Value real(kind=wp),\n  dimension(size(table,dim=2)) Called by proc~~interpolate1d~2~~CalledByGraph proc~interpolate1d~2 interpolate1D proc~compute_planck_source~2 compute_Planck_source proc~compute_planck_source~2->proc~interpolate1d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpolate1d~2.html"},{"title":"interpolate2D – rte-rrtmgp","text":"public pure function interpolate2D(fminor, k, igpt, jeta, jtemp) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: fminor real(kind=wp), intent(in), dimension(:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp Return Value real(kind=wp) Contents None","tags":"","loc":"proc/interpolate2d~2.html"},{"title":"interpolate2D_byflav – rte-rrtmgp","text":"public pure function interpolate2D_byflav(fminor, k, gptS, gptE, jeta, jtemp) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: fminor real(kind=wp), intent(in), dimension(:,:,:) :: k integer, intent(in) :: gptS integer, intent(in) :: gptE integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp Return Value real(kind=wp),\n  dimension(gptE-gptS+1) Called by proc~~interpolate2d_byflav~~CalledByGraph proc~interpolate2d_byflav interpolate2D_byflav proc~gas_optical_depths_minor~2 gas_optical_depths_minor proc~gas_optical_depths_minor~2->proc~interpolate2d_byflav proc~compute_tau_rayleigh~2 compute_tau_rayleigh proc~compute_tau_rayleigh~2->proc~interpolate2d_byflav proc~compute_tau_absorption~2 compute_tau_absorption proc~compute_tau_absorption~2->proc~gas_optical_depths_minor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpolate2d_byflav.html"},{"title":"interpolate3D – rte-rrtmgp","text":"public pure function interpolate3D(scaling, fmajor, k, igpt, jeta, jtemp, jpress) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: scaling real(kind=wp), intent(in), dimension(2,2,2) :: fmajor real(kind=wp), intent(in), dimension(:,:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp integer, intent(in) :: jpress Return Value real(kind=wp) Contents None","tags":"","loc":"proc/interpolate3d~2.html"},{"title":"interpolate3D_byflav – rte-rrtmgp","text":"public pure function interpolate3D_byflav(scaling, fmajor, k, gptS, gptE, jeta, jtemp, jpress) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: scaling real(kind=wp), intent(in), dimension(2,2,2) :: fmajor real(kind=wp), intent(in), dimension(:,:,:,:) :: k integer, intent(in) :: gptS integer, intent(in) :: gptE integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp integer, intent(in) :: jpress Return Value real(kind=wp),\n  dimension(gptE-gptS+1) Called by proc~~interpolate3d_byflav~~CalledByGraph proc~interpolate3d_byflav interpolate3D_byflav proc~compute_planck_source~2 compute_Planck_source proc~compute_planck_source~2->proc~interpolate3d_byflav proc~gas_optical_depths_major~2 gas_optical_depths_major proc~gas_optical_depths_major~2->proc~interpolate3d_byflav proc~compute_tau_absorption~2 compute_tau_absorption proc~compute_tau_absorption~2->proc~gas_optical_depths_major~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpolate3d_byflav.html"},{"title":"compute_Planck_source – rte-rrtmgp","text":"public subroutine compute_Planck_source(ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, nPlanckTemp, tlay, tlev, tsfc, sfc_lay, fmajor, jeta, tropo, jtemp, jpress, gpoint_bands, band_lims_gpt, pfracin, temp_ref_min, totplnk_delta, totplnk, gpoint_flavor, sfc_src, lay_src, lev_src_inc, lev_src_dec, sfc_source_Jac) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nPlanckTemp real(kind=wp), intent(in), dimension(ncol,nlay  ) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay+1) :: tlev real(kind=wp), intent(in), dimension(ncol       ) :: tsfc integer, intent(in) :: sfc_lay real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(            ncol,nlay) :: tropo integer, intent(in), dimension(            ncol,nlay) :: jtemp integer, intent(in), dimension(            ncol,nlay) :: jpress integer, intent(in), dimension(ngpt) :: gpoint_bands integer, intent(in), dimension(2, nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: pfracin real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: totplnk_delta real(kind=wp), intent(in), dimension(nPlanckTemp,nbnd) :: totplnk integer, intent(in), dimension(2,ngpt) :: gpoint_flavor real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lay_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_inc real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_dec real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_source_Jac Calls proc~~compute_planck_source~2~~CallsGraph proc~compute_planck_source~2 compute_Planck_source proc~interpolate3d_byflav interpolate3D_byflav proc~compute_planck_source~2->proc~interpolate3d_byflav proc~interpolate1d~2 interpolate1D proc~compute_planck_source~2->proc~interpolate1d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/compute_planck_source~2.html"},{"title":"compute_tau_absorption – rte-rrtmgp","text":"public subroutine compute_tau_absorption(ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, nminorlower, nminorklower, nminorupper, nminorkupper, idx_h2o, gpoint_flavor, band_lims_gpt, kmajor, kminor_lower, kminor_upper, minor_limits_gpt_lower, minor_limits_gpt_upper, minor_scales_with_density_lower, minor_scales_with_density_upper, scale_by_complement_lower, scale_by_complement_upper, idx_minor_lower, idx_minor_upper, idx_minor_scaling_lower, idx_minor_scaling_upper, kminor_start_lower, kminor_start_upper, tropo, col_mix, fmajor, fminor, play, tlay, col_gas, jeta, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nminorlower integer, intent(in) :: nminorklower integer, intent(in) :: nminorupper integer, intent(in) :: nminorkupper integer, intent(in) :: idx_h2o integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(ntemp,neta,nminorklower) :: kminor_lower real(kind=wp), intent(in), dimension(ntemp,neta,nminorkupper) :: kminor_upper integer, intent(in), dimension(2,nminorlower) :: minor_limits_gpt_lower integer, intent(in), dimension(2,nminorupper) :: minor_limits_gpt_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: minor_scales_with_density_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: minor_scales_with_density_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: scale_by_complement_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: scale_by_complement_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_scaling_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_scaling_upper integer, intent(in), dimension(  nminorlower) :: kminor_start_lower integer, intent(in), dimension(  nminorupper) :: kminor_start_upper logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav       ) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav       ) :: fmajor real(kind=wp), intent(in), dimension(2,2,  ncol,nlay,nflav       ) :: fminor real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: play real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: tlay real(kind=wp), intent(in), dimension(            ncol,nlay,0:ngas) :: col_gas integer, intent(in), dimension(2,    ncol,nlay,nflav       ) :: jeta integer, intent(in), dimension(            ncol,nlay       ) :: jtemp integer, intent(in), dimension(            ncol,nlay       ) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau Calls proc~~compute_tau_absorption~2~~CallsGraph proc~compute_tau_absorption~2 compute_tau_absorption proc~gas_optical_depths_minor~2 gas_optical_depths_minor proc~compute_tau_absorption~2->proc~gas_optical_depths_minor~2 proc~gas_optical_depths_major~2 gas_optical_depths_major proc~compute_tau_absorption~2->proc~gas_optical_depths_major~2 proc~interpolate2d_byflav interpolate2D_byflav proc~gas_optical_depths_minor~2->proc~interpolate2d_byflav proc~interpolate3d_byflav interpolate3D_byflav proc~gas_optical_depths_major~2->proc~interpolate3d_byflav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/compute_tau_absorption~2.html"},{"title":"compute_tau_rayleigh – rte-rrtmgp","text":"public subroutine compute_tau_rayleigh(ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, krayl, idx_h2o, col_dry, col_gas, fminor, jeta, tropo, jtemp, tau_rayleigh) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,ngpt,2) :: krayl integer, intent(in) :: idx_h2o real(kind=wp), intent(in), dimension(ncol,nlay) :: col_dry real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: tau_rayleigh Calls proc~~compute_tau_rayleigh~2~~CallsGraph proc~compute_tau_rayleigh~2 compute_tau_rayleigh proc~interpolate2d_byflav interpolate2D_byflav proc~compute_tau_rayleigh~2->proc~interpolate2d_byflav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/compute_tau_rayleigh~2.html"},{"title":"gas_optical_depths_major – rte-rrtmgp","text":"public subroutine gas_optical_depths_major(ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, kmajor, col_mix, fmajor, jeta, tropo, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp integer, intent(in), dimension(ncol,nlay) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau Calls proc~~gas_optical_depths_major~2~~CallsGraph proc~gas_optical_depths_major~2 gas_optical_depths_major proc~interpolate3d_byflav interpolate3D_byflav proc~gas_optical_depths_major~2->proc~interpolate3d_byflav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gas_optical_depths_major~2~~CalledByGraph proc~gas_optical_depths_major~2 gas_optical_depths_major proc~compute_tau_absorption~2 compute_tau_absorption proc~compute_tau_absorption~2->proc~gas_optical_depths_major~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gas_optical_depths_major~2.html"},{"title":"gas_optical_depths_minor – rte-rrtmgp","text":"public subroutine gas_optical_depths_minor(ncol, nlay, ngpt, ngas, nflav, ntemp, neta, nminor, nminork, idx_h2o, gpt_flv, kminor, minor_limits_gpt, minor_scales_with_density, scale_by_complement, idx_minor, idx_minor_scaling, kminor_start, play, tlay, col_gas, fminor, jeta, layer_limits, jtemp, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: ntemp integer, intent(in) :: neta integer, intent(in) :: nminor integer, intent(in) :: nminork integer, intent(in) :: idx_h2o integer, intent(in), dimension(ngpt) :: gpt_flv real(kind=wp), intent(in), dimension(ntemp,neta,nminork) :: kminor integer, intent(in), dimension(2,nminor) :: minor_limits_gpt logical(kind=wl), intent(in), dimension(  nminor) :: minor_scales_with_density logical(kind=wl), intent(in), dimension(  nminor) :: scale_by_complement integer, intent(in), dimension(  nminor) :: idx_minor integer, intent(in), dimension(  nminor) :: idx_minor_scaling integer, intent(in), dimension(  nminor) :: kminor_start real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta integer, intent(in), dimension(ncol, 2) :: layer_limits integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau Calls proc~~gas_optical_depths_minor~2~~CallsGraph proc~gas_optical_depths_minor~2 gas_optical_depths_minor proc~interpolate2d_byflav interpolate2D_byflav proc~gas_optical_depths_minor~2->proc~interpolate2d_byflav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gas_optical_depths_minor~2~~CalledByGraph proc~gas_optical_depths_minor~2 gas_optical_depths_minor proc~compute_tau_absorption~2 compute_tau_absorption proc~compute_tau_absorption~2->proc~gas_optical_depths_minor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gas_optical_depths_minor~2.html"},{"title":"interpolation – rte-rrtmgp","text":"public subroutine interpolation(ncol, nlay, ngas, nflav, neta, npres, ntemp, flavor, press_ref_log, temp_ref, press_ref_log_delta, temp_ref_min, temp_ref_delta, press_ref_trop_log, vmr_ref, play, tlay, col_gas, jtemp, fmajor, fminor, col_mix, tropo, jeta, jpress) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,nflav) :: flavor real(kind=wp), intent(in), dimension(npres) :: press_ref_log real(kind=wp), intent(in), dimension(ntemp) :: temp_ref real(kind=wp), intent(in) :: press_ref_log_delta real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: temp_ref_delta real(kind=wp), intent(in) :: press_ref_trop_log real(kind=wp), intent(in), dimension(2,0:ngas,ntemp) :: vmr_ref real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas integer, intent(out), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(2,2,2,ncol,nlay,nflav) :: fmajor real(kind=wp), intent(out), dimension(2,2,  ncol,nlay,nflav) :: fminor real(kind=wp), intent(out), dimension(2,    ncol,nlay,nflav) :: col_mix logical(kind=wl), intent(out), dimension(ncol,nlay) :: tropo integer, intent(out), dimension(2,    ncol,nlay,nflav) :: jeta integer, intent(out), dimension(ncol,nlay) :: jpress Calls proc~~interpolation~2~~CallsGraph proc~interpolation~2 interpolation float float proc~interpolation~2->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpolation~2.html"},{"title":"compute_heating_rate – rte-rrtmgp","text":"public function compute_heating_rate(flux_up, flux_dn, plev, heating_rate) result(error_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: flux_up real(kind=wp), intent(in), dimension(:,:) :: flux_dn real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(out), dimension(:,:) :: heating_rate Return Value character(len=128) Calls proc~~compute_heating_rate~~CallsGraph proc~compute_heating_rate compute_heating_rate interface~extents_are extents_are proc~compute_heating_rate->interface~extents_are Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/compute_heating_rate.html"},{"title":"compute_bc – rte-rrtmgp","text":"public function compute_bc(k_dist, play, plev, tlay, gas_concs, flux_bc, mu0) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: k_dist real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_concs real(kind=wp), intent(out), dimension(:,:), target :: flux_bc real(kind=wp), intent(in), optional dimension(:) :: mu0 Return Value character(len=128) Calls proc~~compute_bc~~CallsGraph proc~compute_bc compute_bc interface~extents_are extents_are proc~compute_bc->interface~extents_are proc~rte_lw rte_lw proc~compute_bc->proc~rte_lw proc~rte_sw rte_sw proc~compute_bc->proc~rte_sw proc~rte_lw->interface~extents_are interface~any_vals_less_than any_vals_less_than proc~rte_lw->interface~any_vals_less_than lw_solver_noscat_gaussquad lw_solver_noscat_gaussquad proc~rte_lw->lw_solver_noscat_gaussquad proc~lw_solver_2stream lw_solver_2stream proc~rte_lw->proc~lw_solver_2stream interface~zero_array zero_array proc~rte_lw->interface~zero_array interface~any_vals_outside any_vals_outside proc~rte_lw->interface~any_vals_outside proc~rte_sw->interface~extents_are proc~rte_sw->interface~any_vals_less_than proc~rte_sw->interface~zero_array proc~sw_solver_2stream sw_solver_2stream proc~rte_sw->proc~sw_solver_2stream proc~rte_sw->interface~any_vals_outside proc~sw_solver_noscat sw_solver_noscat proc~rte_sw->proc~sw_solver_noscat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/compute_bc.html"},{"title":"rte_lw – rte-rrtmgp","text":"public function rte_lw(k_dist, gas_concs, p_lay, t_lay, p_lev, t_sfc, sfc_emis, cloud_props, allsky_fluxes, clrsky_fluxes, aer_props, col_dry, t_lev, inc_flux, n_gauss_angles) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: k_dist type( ty_gas_concs ), intent(in) :: gas_concs real(kind=wp), intent(in), dimension(:,:) :: p_lay real(kind=wp), intent(in), dimension(:,:) :: t_lay real(kind=wp), intent(in), dimension(:,:) :: p_lev real(kind=wp), intent(in), dimension(:) :: t_sfc real(kind=wp), intent(in), dimension(:,:) :: sfc_emis class( ty_optical_props_arry ), intent(in) :: cloud_props class( ty_fluxes ), intent(inout) :: allsky_fluxes class( ty_fluxes ), intent(inout) :: clrsky_fluxes class( ty_optical_props_arry ), intent(in), optional :: aer_props real(kind=wp), intent(in), optional dimension(:,:) :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: t_lev real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux integer, intent(in), optional :: n_gauss_angles Return Value character(len=128) Calls proc~~rte_lw~2~~CallsGraph proc~rte_lw~2 rte_lw proc~rte_lw rte_lw proc~rte_lw~2->proc~rte_lw interface~any_vals_less_than any_vals_less_than proc~rte_lw->interface~any_vals_less_than lw_solver_noscat_gaussquad lw_solver_noscat_gaussquad proc~rte_lw->lw_solver_noscat_gaussquad proc~lw_solver_2stream lw_solver_2stream proc~rte_lw->proc~lw_solver_2stream interface~extents_are extents_are proc~rte_lw->interface~extents_are interface~zero_array zero_array proc~rte_lw->interface~zero_array interface~any_vals_outside any_vals_outside proc~rte_lw->interface~any_vals_outside Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rte_lw~2.html"},{"title":"rte_sw – rte-rrtmgp","text":"public function rte_sw(k_dist, gas_concs, p_lay, t_lay, p_lev, mu0, sfc_alb_dir, sfc_alb_dif, cloud_props, allsky_fluxes, clrsky_fluxes, aer_props, col_dry, inc_flux) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: k_dist type( ty_gas_concs ), intent(in) :: gas_concs real(kind=wp), intent(in), dimension(:,:) :: p_lay real(kind=wp), intent(in), dimension(:,:) :: t_lay real(kind=wp), intent(in), dimension(:,:) :: p_lev real(kind=wp), intent(in), dimension(:  ) :: mu0 real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dir real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dif class( ty_optical_props_arry ), intent(in) :: cloud_props class( ty_fluxes ), intent(inout) :: allsky_fluxes class( ty_fluxes ), intent(inout) :: clrsky_fluxes class( ty_optical_props_arry ), intent(in), optional target :: aer_props real(kind=wp), intent(in), optional dimension(:,:) :: col_dry real(kind=wp), intent(in), optional dimension(:,:) :: inc_flux Return Value character(len=128) Calls proc~~rte_sw~2~~CallsGraph proc~rte_sw~2 rte_sw proc~rte_sw rte_sw proc~rte_sw~2->proc~rte_sw interface~any_vals_less_than any_vals_less_than proc~rte_sw->interface~any_vals_less_than interface~extents_are extents_are proc~rte_sw->interface~extents_are interface~zero_array zero_array proc~rte_sw->interface~zero_array proc~sw_solver_2stream sw_solver_2stream proc~rte_sw->proc~sw_solver_2stream interface~any_vals_outside any_vals_outside proc~rte_sw->interface~any_vals_outside proc~sw_solver_noscat sw_solver_noscat proc~rte_sw->proc~sw_solver_noscat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rte_sw~2.html"},{"title":"are_desired_byband – rte-rrtmgp","text":"public function are_desired_byband(this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_byband ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/are_desired_byband.html"},{"title":"reduce_byband – rte-rrtmgp","text":"public function reduce_byband(this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_byband ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128) Calls proc~~reduce_byband~~CallsGraph proc~reduce_byband reduce_byband interface~net_byband net_byband proc~reduce_byband->interface~net_byband proc~sum_byband sum_byband proc~reduce_byband->proc~sum_byband interface~extents_are extents_are proc~reduce_byband->interface~extents_are proc~net_byband_full net_byband_full interface~net_byband->proc~net_byband_full proc~net_byband_precalc net_byband_precalc interface~net_byband->proc~net_byband_precalc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/reduce_byband.html"},{"title":"net_byband_full – rte-rrtmgp","text":"public subroutine net_byband_full(ncol, nlev, ngpt, nbnd, band_lims, spectral_flux_dn, spectral_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt integer, intent(in) :: nbnd integer, intent(in), dimension(2,          nbnd) :: band_lims real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net Called by proc~~net_byband_full~~CalledByGraph proc~net_byband_full net_byband_full interface~net_byband net_byband interface~net_byband->proc~net_byband_full proc~reduce_byband reduce_byband proc~reduce_byband->interface~net_byband Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/net_byband_full.html"},{"title":"net_byband_precalc – rte-rrtmgp","text":"public subroutine net_byband_precalc(ncol, nlev, nbnd, byband_flux_dn, byband_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: nbnd real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net Called by proc~~net_byband_precalc~~CalledByGraph proc~net_byband_precalc net_byband_precalc interface~net_byband net_byband interface~net_byband->proc~net_byband_precalc proc~reduce_byband reduce_byband proc~reduce_byband->interface~net_byband Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/net_byband_precalc.html"},{"title":"sum_byband – rte-rrtmgp","text":"public subroutine sum_byband(ncol, nlev, ngpt, nbnd, band_lims, spectral_flux, byband_flux) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt integer, intent(in) :: nbnd integer, intent(in), dimension(2,          nbnd) :: band_lims real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux Called by proc~~sum_byband~~CalledByGraph proc~sum_byband sum_byband proc~reduce_byband reduce_byband proc~reduce_byband->proc~sum_byband Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sum_byband.html"},{"title":"net_byband – rte-rrtmgp","text":"public interface net_byband Calls interface~~net_byband~~CallsGraph interface~net_byband net_byband proc~net_byband_full net_byband_full interface~net_byband->proc~net_byband_full proc~net_byband_precalc net_byband_precalc interface~net_byband->proc~net_byband_precalc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~net_byband~~CalledByGraph interface~net_byband net_byband proc~reduce_byband reduce_byband proc~reduce_byband->interface~net_byband Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures net_byband_full net_byband_precalc Module Procedures public subroutine net_byband_full (ncol, nlev, ngpt, nbnd, band_lims, spectral_flux_dn, spectral_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt integer, intent(in) :: nbnd integer, intent(in), dimension(2,          nbnd) :: band_lims real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net public subroutine net_byband_precalc (ncol, nlev, nbnd, byband_flux_dn, byband_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: nbnd real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net","tags":"","loc":"interface/net_byband.html"},{"title":"are_desired_bygpoint – rte-rrtmgp","text":"public function are_desired_bygpoint(this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_bygpoint ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/are_desired_bygpoint.html"},{"title":"reduce_bygpoint – rte-rrtmgp","text":"public function reduce_bygpoint(this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_bygpoint ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128) Calls proc~~reduce_bygpoint~~CallsGraph proc~reduce_bygpoint reduce_bygpoint interface~extents_are extents_are proc~reduce_bygpoint->interface~extents_are Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/reduce_bygpoint.html"},{"title":"draw_samples – rte-rrtmgp","text":"public function draw_samples(cloud_mask, clouds, clouds_sampled) result(error_msg) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:,:) :: cloud_mask class( ty_optical_props_arry ), intent(in) :: clouds class( ty_optical_props_arry ), intent(inout) :: clouds_sampled Return Value character(len=128) Contents None","tags":"","loc":"proc/draw_samples.html"},{"title":"sampled_mask_exp_ran – rte-rrtmgp","text":"public function sampled_mask_exp_ran(randoms, cloud_frac, overlap_param, cloud_mask) result(error_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: randoms real(kind=wp), intent(in), dimension(:,:) :: cloud_frac real(kind=wp), intent(in), dimension(:,:) :: overlap_param logical, intent(out), dimension(:,:,:) :: cloud_mask Return Value character(len=128) Contents None","tags":"","loc":"proc/sampled_mask_exp_ran.html"},{"title":"sampled_mask_max_ran – rte-rrtmgp","text":"public function sampled_mask_max_ran(randoms, cloud_frac, cloud_mask) result(error_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: randoms real(kind=wp), intent(in), dimension(:,:) :: cloud_frac logical, intent(out), dimension(:,:,:) :: cloud_mask Return Value character(len=128) Contents None","tags":"","loc":"proc/sampled_mask_max_ran.html"},{"title":"pade_eval – rte-rrtmgp","text":"public interface pade_eval Contents Module Procedures pade_eval_nbnd pade_eval_1 Module Procedures private function pade_eval_nbnd(nbnd, nrads, m, n, irad, re, pade_coeffs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nbnd integer, intent(in) :: nrads integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: irad real(kind=wp), intent(in) :: re real(kind=wp), intent(in), dimension(nbnd, nrads, 0:m+n) :: pade_coeffs Return Value real(kind=wp),\n  dimension(nbnd) private function pade_eval_1(iband, nbnd, nrads, m, n, irad, re, pade_coeffs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iband integer, intent(in) :: nbnd integer, intent(in) :: nrads integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: irad real(kind=wp), intent(in) :: re real(kind=wp), intent(in), dimension(nbnd, nrads, 0:m+n) :: pade_coeffs Return Value real(kind=wp)","tags":"","loc":"interface/pade_eval.html"},{"title":"mo_rte_config – rte-rrtmgp","text":"Uses mo_rte_kind module~~mo_rte_config~~UsesGraph module~mo_rte_config mo_rte_config module~mo_rte_kind mo_rte_kind module~mo_rte_config->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rte_config~~UsedByGraph module~mo_rte_config mo_rte_config module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_rte_config module~mo_optical_props mo_optical_props module~mo_rte_lw->module~mo_optical_props module~mo_fluxes mo_fluxes module~mo_rte_lw->module~mo_fluxes module~mo_source_functions mo_source_functions module~mo_rte_lw->module~mo_source_functions module~mo_rte_sw mo_rte_sw module~mo_rte_sw->module~mo_rte_config module~mo_rte_sw->module~mo_optical_props module~mo_rte_sw->module~mo_fluxes module~mo_cloud_optics mo_cloud_optics module~mo_cloud_optics->module~mo_rte_config module~mo_cloud_optics->module~mo_optical_props module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_rte_config module~mo_gas_optics_rrtmgp->module~mo_optical_props module~mo_gas_concentrations mo_gas_concentrations module~mo_gas_optics_rrtmgp->module~mo_gas_concentrations module~mo_gas_optics mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_source_functions module~mo_optical_props->module~mo_rte_config module~mo_heating_rates mo_heating_rates module~mo_heating_rates->module~mo_rte_config module~mo_gas_concentrations->module~mo_rte_config module~mo_fluxes->module~mo_rte_config module~mo_fluxes->module~mo_optical_props module~mo_fluxes_byband mo_fluxes_byband module~mo_fluxes_byband->module~mo_rte_config module~mo_fluxes_byband->module~mo_optical_props module~mo_fluxes_byband->module~mo_fluxes module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_rte_config module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_rte_sw module~mo_compute_bc->module~mo_optical_props module~mo_compute_bc->module~mo_gas_concentrations module~mo_compute_bc->module~mo_fluxes module~mo_compute_bc->module~mo_gas_optics module~mo_compute_bc->module~mo_source_functions module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_fluxes_bygpoint->module~mo_optical_props module~mo_fluxes_bygpoint->module~mo_fluxes module~mo_cloud_sampling mo_cloud_sampling module~mo_cloud_sampling->module~mo_optical_props module~mo_gas_optics->module~mo_optical_props module~mo_gas_optics->module~mo_gas_concentrations module~mo_gas_optics->module~mo_source_functions module~mo_source_functions->module~mo_optical_props module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw module~mo_rrtmgp_clr_all_sky->module~mo_optical_props module~mo_rrtmgp_clr_all_sky->module~mo_gas_concentrations module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_rrtmgp_clr_all_sky->module~mo_source_functions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables check_extents check_values Interfaces rte_config_checks Variables Type Visibility Attributes Name Initial logical(kind=wl), public :: check_extents = .true. logical(kind=wl), public :: check_values = .true. Interfaces public interface rte_config_checks private subroutine rte_config_checks_each(extents, values) Arguments Type Intent Optional Attributes Name logical(kind=wl), intent(in) :: extents logical(kind=wl), intent(in) :: values private subroutine rte_config_checks_all(do_checks) Arguments Type Intent Optional Attributes Name logical(kind=wl), intent(in) :: do_checks","tags":"","loc":"module/mo_rte_config.html"},{"title":"mo_rte_kind – rte-rrtmgp","text":"Uses iso_c_binding module~~mo_rte_kind~~UsesGraph module~mo_rte_kind mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rte_kind~~UsedByGraph module~mo_rte_kind mo_rte_kind module~mo_rte_sw mo_rte_sw module~mo_rte_sw->module~mo_rte_kind module~mo_fluxes mo_fluxes module~mo_rte_sw->module~mo_fluxes module~mo_rte_util_array mo_rte_util_array module~mo_rte_sw->module~mo_rte_util_array module~mo_rte_solver_kernels~2 mo_rte_solver_kernels module~mo_rte_sw->module~mo_rte_solver_kernels~2 module~mo_optical_props mo_optical_props module~mo_rte_sw->module~mo_optical_props module~mo_rte_config mo_rte_config module~mo_rte_sw->module~mo_rte_config module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_rte_kind module~mo_gas_optics mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_rte_util_array module~mo_rrtmgp_util_reorder mo_rrtmgp_util_reorder module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_util_reorder module~mo_source_functions mo_source_functions module~mo_gas_optics_rrtmgp->module~mo_source_functions module~mo_gas_optics_rrtmgp->module~mo_optical_props module~mo_gas_concentrations mo_gas_concentrations module~mo_gas_optics_rrtmgp->module~mo_gas_concentrations module~mo_gas_optics_rrtmgp->module~mo_rte_config module~mo_rrtmgp_constants mo_rrtmgp_constants module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_constants module~mo_gas_optics_kernels~2 mo_gas_optics_kernels module~mo_gas_optics_rrtmgp->module~mo_gas_optics_kernels~2 module~mo_solar_variability mo_solar_variability module~mo_solar_variability->module~mo_rte_kind module~mo_heating_rates mo_heating_rates module~mo_heating_rates->module~mo_rte_kind module~mo_heating_rates->module~mo_rte_util_array module~mo_heating_rates->module~mo_rte_config module~mo_heating_rates->module~mo_rrtmgp_constants module~mo_gas_optics->module~mo_rte_kind module~mo_gas_optics->module~mo_source_functions module~mo_gas_optics->module~mo_optical_props module~mo_gas_optics->module~mo_gas_concentrations module~mo_fluxes->module~mo_rte_kind module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->module~mo_fluxes_broadband_kernels module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_config module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props_kernels->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind module~mo_rrtmgp_util_reorder->module~mo_rte_kind module~mo_rrtmgp_util_reorder_kernels mo_rrtmgp_util_reorder_kernels module~mo_rrtmgp_util_reorder->module~mo_rrtmgp_util_reorder_kernels module~mo_source_functions->module~mo_rte_kind module~mo_source_functions->module~mo_optical_props module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_rte_kind module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_source_functions module~mo_rrtmgp_clr_all_sky->module~mo_optical_props module~mo_rrtmgp_clr_all_sky->module~mo_gas_concentrations module~mo_rte_lw mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_fluxes_broadband_kernels->module~mo_rte_kind module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_rte_kind module~mo_compute_bc->module~mo_rte_sw module~mo_compute_bc->module~mo_gas_optics module~mo_compute_bc->module~mo_fluxes module~mo_compute_bc->module~mo_rte_util_array module~mo_compute_bc->module~mo_source_functions module~mo_compute_bc->module~mo_optical_props module~mo_compute_bc->module~mo_gas_concentrations module~mo_compute_bc->module~mo_rte_config module~mo_compute_bc->module~mo_rte_lw module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_fluxes_bygpoint->module~mo_rte_kind module~mo_fluxes_bygpoint->module~mo_fluxes module~mo_fluxes_bygpoint->module~mo_rte_util_array module~mo_fluxes_bygpoint->module~mo_optical_props module~mo_gas_optics_kernels mo_gas_optics_kernels module~mo_gas_optics_kernels->module~mo_rte_kind module~mo_gas_optics_kernels->module~mo_rte_util_array module~mo_rte_solver_kernels~2->module~mo_rte_kind module~mo_rte_solver_kernels~2->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_kind module~mo_optical_props->module~mo_optical_props_kernels module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_config module~mo_cloud_sampling mo_cloud_sampling module~mo_cloud_sampling->module~mo_rte_kind module~mo_cloud_sampling->module~mo_optical_props module~mo_gas_concentrations->module~mo_rte_kind module~mo_gas_concentrations->module~mo_rte_util_array module~mo_gas_concentrations->module~mo_rte_config module~mo_rte_config->module~mo_rte_kind module~mo_fluxes_byband mo_fluxes_byband module~mo_fluxes_byband->module~mo_rte_kind module~mo_fluxes_byband->module~mo_fluxes module~mo_fluxes_byband->module~mo_rte_util_array module~mo_fluxes_byband->module~mo_optical_props module~mo_fluxes_byband->module~mo_rte_config module~mo_rrtmgp_constants->module~mo_rte_kind module~mo_rrtmgp_util_reorder_kernels->module~mo_rte_kind module~mo_rte_lw->module~mo_rte_kind module~mo_rte_lw->module~mo_fluxes module~mo_rte_lw->module~mo_rte_util_array module~mo_rte_lw->module~mo_source_functions module~mo_rte_lw->module~mo_rte_solver_kernels~2 module~mo_rte_lw->module~mo_optical_props module~mo_rte_lw->module~mo_rte_config module~mo_cloud_optics mo_cloud_optics module~mo_cloud_optics->module~mo_rte_kind module~mo_cloud_optics->module~mo_rte_util_array module~mo_cloud_optics->module~mo_optical_props module~mo_cloud_optics->module~mo_rte_config module~mo_rte_solver_kernels mo_rte_solver_kernels module~mo_rte_solver_kernels->module~mo_rte_kind module~mo_rte_solver_kernels->module~mo_rte_util_array module~mo_gas_optics_kernels~2->module~mo_rte_kind module~mo_gas_optics_kernels~2->module~mo_rte_util_array module~mo_optical_props_kernels~2 mo_optical_props_kernels module~mo_optical_props_kernels~2->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables dp i4 i8 sp wl wp Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = c_double integer, public, parameter :: i4 = c_int integer, public, parameter :: i8 = c_long integer, public, parameter :: sp = c_float integer, public, parameter :: wl = kind(.true.) integer, public, parameter :: wp = dp","tags":"","loc":"module/mo_rte_kind.html"},{"title":"mo_fluxes – rte-rrtmgp","text":"Uses mo_rte_config mo_rte_kind mo_rte_util_array mo_fluxes_broadband_kernels mo_optical_props module~~mo_fluxes~~UsesGraph module~mo_fluxes mo_fluxes module~mo_optical_props mo_optical_props module~mo_fluxes->module~mo_optical_props module~mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->module~mo_fluxes_broadband_kernels module~mo_rte_config mo_rte_config module~mo_fluxes->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_fluxes->module~mo_rte_util_array module~mo_rte_kind mo_rte_kind module~mo_fluxes->module~mo_rte_kind module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_kind module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->module~mo_optical_props_kernels module~mo_fluxes_broadband_kernels->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_fluxes_broadband_kernels->iso_c_binding module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind module~mo_rte_kind->iso_c_binding module~mo_optical_props_kernels->module~mo_rte_kind module~mo_optical_props_kernels->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_fluxes~~UsedByGraph module~mo_fluxes mo_fluxes module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_fluxes module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_fluxes_bygpoint->module~mo_fluxes module~mo_rte_sw mo_rte_sw module~mo_rte_sw->module~mo_fluxes module~mo_fluxes_byband mo_fluxes_byband module~mo_fluxes_byband->module~mo_fluxes module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_fluxes module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_rte_sw module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_fluxes ty_fluxes_broadband Derived Types type, public, abstract :: ty_fluxes Type-Bound Procedures procedure(are_desired_abstract), public :: are_desired procedure(reduce_abstract), public :: reduce type, public, extends( ty_fluxes ) :: ty_fluxes_broadband Type-Bound Procedures procedure, public :: are_desired => are_desired_broadband procedure, public :: reduce => reduce_broadband","tags":"","loc":"module/mo_fluxes.html"},{"title":"mo_rte_lw – rte-rrtmgp","text":"Uses mo_source_functions mo_rte_config mo_fluxes mo_rte_kind mo_rte_util_array mo_optical_props mo_rte_solver_kernels module~~mo_rte_lw~~UsesGraph module~mo_rte_lw mo_rte_lw module~mo_rte_solver_kernels~2 mo_rte_solver_kernels module~mo_rte_lw->module~mo_rte_solver_kernels~2 module~mo_optical_props mo_optical_props module~mo_rte_lw->module~mo_optical_props module~mo_fluxes mo_fluxes module~mo_rte_lw->module~mo_fluxes module~mo_rte_config mo_rte_config module~mo_rte_lw->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_rte_lw->module~mo_rte_util_array module~mo_rte_kind mo_rte_kind module~mo_rte_lw->module~mo_rte_kind module~mo_source_functions mo_source_functions module~mo_rte_lw->module~mo_source_functions module~mo_rte_solver_kernels~2->module~mo_rte_util_array module~mo_rte_solver_kernels~2->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_solver_kernels~2->iso_c_binding module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_kind module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->module~mo_optical_props_kernels module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_config module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes->module~mo_rte_kind module~mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->module~mo_fluxes_broadband_kernels module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind module~mo_rte_kind->iso_c_binding module~mo_source_functions->module~mo_optical_props module~mo_source_functions->module~mo_rte_kind module~mo_optical_props_kernels->module~mo_rte_kind module~mo_optical_props_kernels->iso_c_binding module~mo_fluxes_broadband_kernels->module~mo_rte_kind module~mo_fluxes_broadband_kernels->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rte_lw~~UsedByGraph module~mo_rte_lw mo_rte_lw module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_rte_lw module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions rte_lw Functions public function rte_lw (optical_props, top_at_1, sources, sfc_emis, fluxes, inc_flux, n_gauss_angles, use_2stream, lw_Ds, flux_up_Jac) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: optical_props logical, intent(in) :: top_at_1 type( ty_source_func_lw ), intent(in) :: sources real(kind=wp), intent(in), dimension(:,:) :: sfc_emis class( ty_fluxes ), intent(inout) :: fluxes real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux integer, intent(in), optional :: n_gauss_angles logical, intent(in), optional :: use_2stream real(kind=wp), intent(in), optional dimension(:,:) :: lw_Ds real(kind=wp), intent(inout), optional dimension(:,:), target :: flux_up_Jac Return Value character(len=128)","tags":"","loc":"module/mo_rte_lw.html"},{"title":"mo_rte_sw – rte-rrtmgp","text":"Uses mo_optical_props mo_rte_config mo_rte_kind mo_rte_util_array mo_fluxes mo_rte_solver_kernels module~~mo_rte_sw~~UsesGraph module~mo_rte_sw mo_rte_sw module~mo_rte_solver_kernels~2 mo_rte_solver_kernels module~mo_rte_sw->module~mo_rte_solver_kernels~2 module~mo_optical_props mo_optical_props module~mo_rte_sw->module~mo_optical_props module~mo_fluxes mo_fluxes module~mo_rte_sw->module~mo_fluxes module~mo_rte_config mo_rte_config module~mo_rte_sw->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_rte_sw->module~mo_rte_util_array module~mo_rte_kind mo_rte_kind module~mo_rte_sw->module~mo_rte_kind module~mo_rte_solver_kernels~2->module~mo_rte_util_array module~mo_rte_solver_kernels~2->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_solver_kernels~2->iso_c_binding module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_kind module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->module~mo_optical_props_kernels module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_config module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes->module~mo_rte_kind module~mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->module~mo_fluxes_broadband_kernels module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind module~mo_rte_kind->iso_c_binding module~mo_optical_props_kernels->module~mo_rte_kind module~mo_optical_props_kernels->iso_c_binding module~mo_fluxes_broadband_kernels->module~mo_rte_kind module~mo_fluxes_broadband_kernels->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rte_sw~~UsedByGraph module~mo_rte_sw mo_rte_sw module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_rte_sw module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions rte_sw Functions public function rte_sw (atmos, top_at_1, mu0, inc_flux, sfc_alb_dir, sfc_alb_dif, fluxes, inc_flux_dif) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: atmos logical, intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(:) :: mu0 real(kind=wp), intent(in), dimension(:,:) :: inc_flux real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dir real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dif class( ty_fluxes ), intent(inout) :: fluxes real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux_dif Return Value character(len=128)","tags":"","loc":"module/mo_rte_sw.html"},{"title":"mo_optical_props – rte-rrtmgp","text":"Encapsulate optical properties defined on a spectral grid of N bands.\n  The bands are described by their limiting wavenumbers. They need not be contiguous or complete.\n  A band may contain more than one spectral sub-point (g-point) in which case a mapping must be supplied.\n  A name may be provided and will be prepended to error messages.\n  The base class (ty_optical_props) encapsulates only this spectral discretization and must be initialized\n     with the spectral information before use. Optical properties may be represented as arrays with dimensions ncol, nlay, ngpt\n  (abstract class ty_optical_props_arry).\n  The type holds arrays depending on how much information is needed\n  There are three possibilites\n     ty_optical_props_1scl holds absorption optical depth tau, used in calculations accounting for extinction and emission\n     ty_optical_props_2str holds extincion optical depth tau, single-scattering albedo ssa, and\n       asymmetry parameter g. These fields are what's needed for two-stream calculations.\n     ty_optical_props_nstr holds extincion optical depth tau, single-scattering albedo ssa, and\n       phase function moments p with leading dimension nmom. These fields are what's needed for multi-stream calculations.\n  These classes must be allocated before use. Initialization and allocation can be combined.\n  The classes have a validate() function that checks all arrays for valid values (e.g. tau > 0.) Optical properties can be delta-scaled (though this is currently implemented only for two-stream arrays) Optical properties can increment or \"add themselves to\" a set of properties represented with arrays\n  as long as both sets have the same underlying band structure. Properties defined by band\n  may be added to properties defined by g-point; the same value is assumed for all g-points with each band. Subsets of optical properties held as arrays may be extracted along the column dimension. Uses mo_rte_config mo_rte_util_array mo_rte_kind mo_optical_props_kernels module~~mo_optical_props~~UsesGraph module~mo_optical_props mo_optical_props module~mo_rte_kind mo_rte_kind module~mo_optical_props->module~mo_rte_kind module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->module~mo_optical_props_kernels module~mo_rte_config mo_rte_config module~mo_optical_props->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_optical_props->module~mo_rte_util_array iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_optical_props_kernels->module~mo_rte_kind module~mo_optical_props_kernels->iso_c_binding module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_optical_props~~UsedByGraph module~mo_optical_props mo_optical_props module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_optical_props module~mo_fluxes mo_fluxes module~mo_rte_lw->module~mo_fluxes module~mo_source_functions mo_source_functions module~mo_rte_lw->module~mo_source_functions module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_fluxes_bygpoint->module~mo_optical_props module~mo_fluxes_bygpoint->module~mo_fluxes module~mo_rte_sw mo_rte_sw module~mo_rte_sw->module~mo_optical_props module~mo_rte_sw->module~mo_fluxes module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_optical_props module~mo_gas_optics mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_source_functions module~mo_cloud_optics mo_cloud_optics module~mo_cloud_optics->module~mo_optical_props module~mo_cloud_sampling mo_cloud_sampling module~mo_cloud_sampling->module~mo_optical_props module~mo_gas_optics->module~mo_optical_props module~mo_gas_optics->module~mo_source_functions module~mo_fluxes->module~mo_optical_props module~mo_fluxes_byband mo_fluxes_byband module~mo_fluxes_byband->module~mo_optical_props module~mo_fluxes_byband->module~mo_fluxes module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_optical_props module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_rte_sw module~mo_compute_bc->module~mo_gas_optics module~mo_compute_bc->module~mo_fluxes module~mo_compute_bc->module~mo_source_functions module~mo_source_functions->module~mo_optical_props module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_optical_props module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_source_functions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables name_len Abstract Interfaces delta_scale_abstract subset_range_abstract validate_abstract Derived Types ty_optical_props ty_optical_props_1scl ty_optical_props_2str ty_optical_props_arry ty_optical_props_nstr Functions alloc_only_1scl alloc_only_2str alloc_only_nstr bands_are_equal convert_band2gpt convert_gpt2band copy_and_alloc_1scl copy_and_alloc_2str copy_and_alloc_nstr delta_scale_1scl delta_scale_2str delta_scale_nstr expand finalize_1scl finalize_2str finalize_nstr get_arry_extent get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_nmom gpoints_are_equal increment init_and_alloc_1scl init_and_alloc_2str init_and_alloc_nstr init_base init_base_from_copy is_initialized_base subset_1scl_range subset_2str_range subset_nstr_range validate_1scalar validate_2stream validate_nstream Subroutines finalize_base set_name Variables Type Visibility Attributes Name Initial integer, public, parameter :: name_len = 32 Abstract Interfaces abstract interface Interfaces for the methods to be implemented public function delta_scale_abstract(this, for) result(err_message) Delta-scaling Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) Forward scattering fraction; g**2 if not provided abstract interface Interfaces for the methods to be implemented public function subset_range_abstract(full, start, n, subset) result(err_message) Subsetting -- currently there are only routines with start col and count Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) abstract interface Interfaces for the methods to be implemented public function validate_abstract(this) result(err_message) Validation function looks only at internal data Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value character(len=128) Derived Types type, public :: ty_optical_props Base class for optical properties\n  Describes the spectral discretization including the wavenumber limits\n  of each band (spectral region) and the mapping between g-points and bands Read more… Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ngpt procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name type, public, extends( ty_optical_props_arry ) :: ty_optical_props_1scl ty_optical_props_arry  includes only (extinction) optical depth\n   Class two-stream adds arrays for single scattering albedo ssa and\n     asymmetry parameter needed in two-stream methods\n   Class n-stream adds arrays for single scattering albedo ssa and\n     phase function moments (index 1 = g) for use with discrete ordinate methods Read more… Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_1scl => alloc_only_1scl, init_and_alloc_1scl, copy_and_alloc_1scl procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: delta_scale => delta_scale_1scl procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: finalize_1scl procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol procedure, public :: get_ngpt procedure, public :: get_nlay procedure, public :: get_subset => subset_1scl_range procedure, public :: gpoints_are_equal procedure, public :: increment Increment another set of values generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure, public :: validate => validate_1scalar type, public, extends( ty_optical_props_arry ) :: ty_optical_props_2str Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) real(kind=wp), public, dimension(:,:,:), allocatable :: g asymmetry parameter (ncol, nlay, ngpt) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:), allocatable :: ssa single-scattering albedo (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_2str => alloc_only_2str, init_and_alloc_2str, copy_and_alloc_2str procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: delta_scale => delta_scale_2str procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: finalize_2str procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol procedure, public :: get_ngpt procedure, public :: get_nlay procedure, public :: get_subset => subset_2str_range procedure, public :: gpoints_are_equal procedure, public :: increment Increment another set of values generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure, public :: validate => validate_2stream type, public, abstract, extends( ty_optical_props ) :: ty_optical_props_arry Optical properties as arrays, normally dimensioned ncol, nlay, ngpt/nbnd\n   The abstract base class for arrays defines what procedures will be available\n   The optical depth field is also part of the abstract base class, since\n    any representation of values as arrays needs an optical depth field Read more… Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure(delta_scale_abstract), public :: delta_scale procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol procedure, public :: get_ngpt procedure, public :: get_nlay procedure(subset_range_abstract), public :: get_subset procedure, public :: gpoints_are_equal procedure, public :: increment Increment another set of values generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure(validate_abstract), public :: validate Deferred procedures -- each must be implemented in each child class with\n  arguments following the abstract interface (defined below) type, public, extends( ty_optical_props_arry ) :: ty_optical_props_nstr Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, dimension(:,:,:,:), allocatable :: p phase-function moments (nmom, ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: ssa single-scattering albedo (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_nstr => alloc_only_nstr, init_and_alloc_nstr, copy_and_alloc_nstr procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: delta_scale => delta_scale_nstr procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: finalize_nstr procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol procedure, public :: get_ngpt procedure, public :: get_nlay procedure, public :: get_nmom procedure, public :: get_subset => subset_nstr_range procedure, public :: gpoints_are_equal procedure, public :: increment Increment another set of values generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure, public :: validate => validate_nstream Functions public function alloc_only_1scl (this, ncol, nlay) result(err_message) Straight allocation routines Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function alloc_only_2str (this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function alloc_only_nstr (this, nmom, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public pure function bands_are_equal (this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical public pure function convert_band2gpt (this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,\n  dimension(2) public pure function convert_gpt2band (this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer public function copy_and_alloc_1scl (this, ncol, nlay, spectral_desc, name) result(err_message) Initialization from an existing spectral discretization/ty_optical_props Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) public function copy_and_alloc_2str (this, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) public function copy_and_alloc_nstr (this, nmom, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) public function delta_scale_1scl (this, for) result(err_message) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) public function delta_scale_2str (this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Forward scattering fraction; g**2 if not provided Return Value character(len=128) public function delta_scale_nstr (this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) public pure function expand (this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),\n  dimension(size(this%gpt2band)) public function finalize_1scl (this) result(err_message) Finalize routines Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this Return Value character(len=128) public function finalize_2str (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this Return Value character(len=128) public function finalize_nstr (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this Return Value character(len=128) public pure function get_arry_extent (this, dim) Routines for array classes: problem sizes Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this integer, intent(in) :: dim Return Value integer public pure function get_band_lims_gpoint (this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) public pure function get_band_lims_wavelength (this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) public pure function get_band_lims_wavenumber (this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),\n  dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) public pure function get_gpoint_bands (this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,\n  dimension(size(this%gpt2band,dim=1)) public function get_name (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) public pure function get_nband (this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer public pure function get_ncol (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer public pure function get_ngpt (this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer public pure function get_nlay (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer public pure function get_nmom (this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value integer public pure function gpoints_are_equal (this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical public function increment (op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) public function init_and_alloc_1scl (this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Initialization by specifying band limits and possibly g-point/band mapping Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_and_alloc_2str (this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_and_alloc_nstr (this, nmom, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base (this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) public function init_base_from_copy (this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) public pure function is_initialized_base (this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical public function subset_1scl_range (full, start, n, subset) result(err_message) Routines for array classes: subsetting of optical properties arrays along x (col) direction Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) public function subset_2str_range (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) public function subset_nstr_range (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) public function validate_1scalar (this) result(err_message) --- Validation Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(in) :: this Return Value character(len=128) public function validate_2stream (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(in) :: this Return Value character(len=128) public function validate_nstream (this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value character(len=128) Subroutines public subroutine finalize_base (this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this public subroutine set_name (this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name","tags":"","loc":"module/mo_optical_props.html"},{"title":"mo_source_functions – rte-rrtmgp","text":"Uses mo_optical_props mo_rte_kind module~~mo_source_functions~~UsesGraph module~mo_source_functions mo_source_functions module~mo_optical_props mo_optical_props module~mo_source_functions->module~mo_optical_props module~mo_rte_kind mo_rte_kind module~mo_source_functions->module~mo_rte_kind module~mo_optical_props->module~mo_rte_kind module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->module~mo_optical_props_kernels module~mo_rte_config mo_rte_config module~mo_optical_props->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_optical_props->module~mo_rte_util_array iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_optical_props_kernels->module~mo_rte_kind module~mo_optical_props_kernels->iso_c_binding module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_source_functions~~UsedByGraph module~mo_source_functions mo_source_functions module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_source_functions module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_source_functions module~mo_gas_optics mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_gas_optics->module~mo_source_functions module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_source_functions module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_gas_optics module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_source_functions module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_source_func_lw ty_source_func_sw Functions alloc_lw alloc_sw copy_and_alloc_lw copy_and_alloc_sw get_ncol_lw get_ncol_sw get_nlay_lw get_subset_range_lw get_subset_range_sw is_allocated_lw is_allocated_sw Subroutines finalize_lw finalize_sw Derived Types type, public, extends( ty_optical_props ) :: ty_source_func_lw Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) real(kind=wp), public, allocatable, dimension(:,:,:) :: lay_source real(kind=wp), public, allocatable, dimension(:,:,:) :: lev_source_dec real(kind=wp), public, allocatable, dimension(:,:,:) :: lev_source_inc character(len=name_len), public :: name = \"\" real(kind=wp), public, allocatable, dimension(:,:  ) :: sfc_source real(kind=wp), public, allocatable, dimension(:,:  ) :: sfc_source_Jac Type-Bound Procedures generic, public :: alloc => alloc_lw, copy_and_alloc_lw procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize => finalize_lw procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol => get_ncol_lw procedure, public :: get_ngpt procedure, public :: get_nlay => get_nlay_lw procedure, public :: get_subset => get_subset_range_lw procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_allocated => is_allocated_lw procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name type, public, extends( ty_optical_props ) :: ty_source_func_sw Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" real(kind=wp), public, allocatable, dimension(:,:  ) :: toa_source Type-Bound Procedures generic, public :: alloc => alloc_sw, copy_and_alloc_sw procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize => finalize_sw procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol => get_ncol_sw procedure, public :: get_ngpt procedure, public :: get_subset => get_subset_range_sw procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_allocated => is_allocated_sw procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name Functions public function alloc_lw (this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) public function alloc_sw (this, ncol) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol Return Value character(len=128) public function copy_and_alloc_lw (this, ncol, nlay, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) public function copy_and_alloc_sw (this, ncol, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) public pure function get_ncol_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer public pure function get_ncol_sw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value integer public pure function get_nlay_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer public function get_subset_range_lw (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_lw ), intent(inout) :: subset Return Value character(len=128) public function get_subset_range_sw (full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_sw ), intent(inout) :: subset Return Value character(len=128) public pure function is_allocated_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value logical public pure function is_allocated_sw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value logical Subroutines public subroutine finalize_lw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this public subroutine finalize_sw (this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this","tags":"","loc":"module/mo_source_functions.html"},{"title":"mo_rte_util_array – rte-rrtmgp","text":"Uses mo_rte_kind module~~mo_rte_util_array~~UsesGraph module~mo_rte_util_array mo_rte_util_array module~mo_rte_kind mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rte_util_array~~UsedByGraph module~mo_rte_util_array mo_rte_util_array module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_rte_util_array module~mo_rte_solver_kernels~2 mo_rte_solver_kernels module~mo_rte_lw->module~mo_rte_solver_kernels~2 module~mo_optical_props mo_optical_props module~mo_rte_lw->module~mo_optical_props module~mo_fluxes mo_fluxes module~mo_rte_lw->module~mo_fluxes module~mo_source_functions mo_source_functions module~mo_rte_lw->module~mo_source_functions module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_fluxes_bygpoint->module~mo_rte_util_array module~mo_fluxes_bygpoint->module~mo_optical_props module~mo_fluxes_bygpoint->module~mo_fluxes module~mo_gas_optics_kernels mo_gas_optics_kernels module~mo_gas_optics_kernels->module~mo_rte_util_array module~mo_rte_sw mo_rte_sw module~mo_rte_sw->module~mo_rte_util_array module~mo_rte_sw->module~mo_rte_solver_kernels~2 module~mo_rte_sw->module~mo_optical_props module~mo_rte_sw->module~mo_fluxes module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_rte_util_array module~mo_gas_optics_rrtmgp->module~mo_optical_props module~mo_gas_concentrations mo_gas_concentrations module~mo_gas_optics_rrtmgp->module~mo_gas_concentrations module~mo_gas_optics_kernels~2 mo_gas_optics_kernels module~mo_gas_optics_rrtmgp->module~mo_gas_optics_kernels~2 module~mo_gas_optics mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_source_functions module~mo_rte_solver_kernels~2->module~mo_rte_util_array module~mo_cloud_optics mo_cloud_optics module~mo_cloud_optics->module~mo_rte_util_array module~mo_cloud_optics->module~mo_optical_props module~mo_optical_props->module~mo_rte_util_array module~mo_heating_rates mo_heating_rates module~mo_heating_rates->module~mo_rte_util_array module~mo_rte_solver_kernels mo_rte_solver_kernels module~mo_rte_solver_kernels->module~mo_rte_util_array module~mo_gas_concentrations->module~mo_rte_util_array module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes->module~mo_optical_props module~mo_gas_optics_kernels~2->module~mo_rte_util_array module~mo_fluxes_byband mo_fluxes_byband module~mo_fluxes_byband->module~mo_rte_util_array module~mo_fluxes_byband->module~mo_optical_props module~mo_fluxes_byband->module~mo_fluxes module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_rte_util_array module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_rte_sw module~mo_compute_bc->module~mo_optical_props module~mo_compute_bc->module~mo_gas_concentrations module~mo_compute_bc->module~mo_fluxes module~mo_compute_bc->module~mo_gas_optics module~mo_compute_bc->module~mo_source_functions module~mo_cloud_sampling mo_cloud_sampling module~mo_cloud_sampling->module~mo_optical_props module~mo_gas_optics->module~mo_optical_props module~mo_gas_optics->module~mo_gas_concentrations module~mo_gas_optics->module~mo_source_functions module~mo_source_functions->module~mo_optical_props module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw module~mo_rrtmgp_clr_all_sky->module~mo_optical_props module~mo_rrtmgp_clr_all_sky->module~mo_gas_concentrations module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_rrtmgp_clr_all_sky->module~mo_source_functions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces any_vals_less_than any_vals_outside extents_are zero_array Interfaces public interface any_vals_less_than private function any_vals_less_than_1D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_2D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_3D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_1D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array logical(kind=wl), intent(in), dimension(:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_2D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array logical(kind=wl), intent(in), dimension(:,:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_3D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array logical(kind=wl), intent(in), dimension(:,:,:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical public interface any_vals_outside private function any_vals_outside_1D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_2D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_3D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_1D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array logical(kind=wl), intent(in), dimension(:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_2D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array logical(kind=wl), intent(in), dimension(:,:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_3D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array logical(kind=wl), intent(in), dimension(:,:,:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical public interface extents_are private function extents_are_1d(array, n1) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:          ) :: array integer, intent(in) :: n1 Return Value logical(kind=wl) private function extents_are_2d(array, n1, n2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:        ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 Return Value logical(kind=wl) private function extents_are_3d(array, n1, n2, n3) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:      ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 Return Value logical(kind=wl) private function extents_are_4d(array, n1, n2, n3, n4) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:    ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 Return Value logical(kind=wl) private function extents_are_5d(array, n1, n2, n3, n4, n5) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:,:  ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 integer, intent(in) :: n5 Return Value logical(kind=wl) private function extents_are_6d(array, n1, n2, n3, n4, n5, n6) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 integer, intent(in) :: n5 integer, intent(in) :: n6 Return Value logical(kind=wl) private function extents_are_2d_int(array, n1, n2) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:        ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 Return Value logical(kind=wl) public interface zero_array private subroutine zero_array_1D(ni, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni real(kind=wp), intent(out), dimension(ni) :: array private subroutine zero_array_2D(ni, nj, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni integer, intent(in) :: nj real(kind=wp), intent(out), dimension(ni, nj) :: array private subroutine zero_array_3D(ni, nj, nk, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni integer, intent(in) :: nj integer, intent(in) :: nk real(kind=wp), intent(out), dimension(ni, nj, nk) :: array private subroutine zero_array_4D(ni, nj, nk, nl, array) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ni integer, intent(in) :: nj integer, intent(in) :: nk integer, intent(in) :: nl real(kind=wp), intent(out), dimension(ni, nj, nk, nl) :: array","tags":"","loc":"module/mo_rte_util_array.html"},{"title":"mo_rte_solver_kernels – rte-rrtmgp","text":"Uses iso_c_binding mo_rte_util_array mo_rte_kind module~~mo_rte_solver_kernels~2~~UsesGraph module~mo_rte_solver_kernels~2 mo_rte_solver_kernels iso_c_binding iso_c_binding module~mo_rte_solver_kernels~2->iso_c_binding module~mo_rte_kind mo_rte_kind module~mo_rte_solver_kernels~2->module~mo_rte_kind module~mo_rte_util_array mo_rte_util_array module~mo_rte_solver_kernels~2->module~mo_rte_util_array module~mo_rte_kind->iso_c_binding module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rte_solver_kernels~2~~UsedByGraph module~mo_rte_solver_kernels~2 mo_rte_solver_kernels module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_rte_solver_kernels~2 module~mo_rte_sw mo_rte_sw module~mo_rte_sw->module~mo_rte_solver_kernels~2 module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_rte_sw module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines lw_solver_2stream lw_solver_noscat lw_solver_noscat_GaussQuad sw_solver_2stream sw_solver_noscat Subroutines public subroutine lw_solver_2stream (ncol, nlay, ngpt, top_at_1, tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dn public subroutine lw_solver_noscat (ncol, nlay, ngpt, top_at_1, D, weight, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, incident_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: D real(kind=wp), intent(in) :: weight real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: incident_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g public subroutine lw_solver_noscat_GaussQuad (ncol, nlay, ngpt, top_at_1, nmus, Ds, weights, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 integer, intent(in) :: nmus real(kind=wp), intent(in), dimension (ncol,      ngpt, nmus) :: Ds real(kind=wp), intent(in), dimension(nmus) :: weights real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(inout), dimension(ncol,nlay+1     ), target :: broadband_up real(kind=wp), intent(inout), dimension(ncol,nlay+1     ), target :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g public subroutine sw_solver_2stream (ncol, nlay, ngpt, top_at_1, tau, ssa, g, mu0, sfc_alb_dir, sfc_alb_dif, inc_flux_dir, flux_up, flux_dn, flux_dir, has_dif_bc, inc_flux_dif, do_broadband, broadband_up, broadband_dn, broadband_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dir real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dif real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dir logical(kind=wl), intent(in) :: has_dif_bc real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dif logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dir public subroutine sw_solver_noscat (ncol, nlay, ngpt, top_at_1, tau, mu0, inc_flux_dir, flux_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dir","tags":"","loc":"module/mo_rte_solver_kernels~2.html"},{"title":"mo_optical_props_kernels – rte-rrtmgp","text":"Uses iso_c_binding mo_rte_kind module~~mo_optical_props_kernels~~UsesGraph module~mo_optical_props_kernels mo_optical_props_kernels iso_c_binding iso_c_binding module~mo_optical_props_kernels->iso_c_binding module~mo_rte_kind mo_rte_kind module~mo_optical_props_kernels->module~mo_rte_kind module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_optical_props_kernels~~UsedByGraph module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props mo_optical_props module~mo_optical_props->module~mo_optical_props_kernels module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_optical_props module~mo_fluxes mo_fluxes module~mo_rte_lw->module~mo_fluxes module~mo_source_functions mo_source_functions module~mo_rte_lw->module~mo_source_functions module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_fluxes_bygpoint->module~mo_optical_props module~mo_fluxes_bygpoint->module~mo_fluxes module~mo_rte_sw mo_rte_sw module~mo_rte_sw->module~mo_optical_props module~mo_rte_sw->module~mo_fluxes module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_optical_props module~mo_gas_optics mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_source_functions module~mo_cloud_optics mo_cloud_optics module~mo_cloud_optics->module~mo_optical_props module~mo_cloud_sampling mo_cloud_sampling module~mo_cloud_sampling->module~mo_optical_props module~mo_gas_optics->module~mo_optical_props module~mo_gas_optics->module~mo_source_functions module~mo_fluxes->module~mo_optical_props module~mo_fluxes_byband mo_fluxes_byband module~mo_fluxes_byband->module~mo_optical_props module~mo_fluxes_byband->module~mo_fluxes module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_optical_props module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_rte_sw module~mo_compute_bc->module~mo_gas_optics module~mo_compute_bc->module~mo_fluxes module~mo_compute_bc->module~mo_source_functions module~mo_source_functions->module~mo_optical_props module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_optical_props module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_source_functions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces delta_scale_2str_kernel extract_subset Subroutines delta_scale_2str_f_k delta_scale_2str_k extract_subset_absorption_tau extract_subset_dim1_3d extract_subset_dim2_4d inc_1scalar_by_1scalar_bybnd inc_1scalar_by_2stream_bybnd inc_1scalar_by_nstream_bybnd inc_2stream_by_1scalar_bybnd inc_2stream_by_2stream_bybnd inc_2stream_by_nstream_bybnd inc_nstream_by_1scalar_bybnd inc_nstream_by_2stream_bybnd inc_nstream_by_nstream_bybnd increment_1scalar_by_1scalar increment_1scalar_by_2stream increment_1scalar_by_nstream increment_2stream_by_1scalar increment_2stream_by_2stream increment_2stream_by_nstream increment_nstream_by_1scalar increment_nstream_by_2stream increment_nstream_by_nstream Interfaces public interface delta_scale_2str_kernel public subroutine delta_scale_2str_f_k (ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f public subroutine delta_scale_2str_k (ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g public interface extract_subset public subroutine extract_subset_dim1_3d (ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out public subroutine extract_subset_dim2_4d (nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out public subroutine extract_subset_absorption_tau (ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out Subroutines public subroutine delta_scale_2str_f_k (ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f public subroutine delta_scale_2str_k (ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g public subroutine extract_subset_absorption_tau (ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out public subroutine extract_subset_dim1_3d (ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out public subroutine extract_subset_dim2_4d (nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out public subroutine inc_1scalar_by_1scalar_bybnd (ncol, nlay, ngpt, tau1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_1scalar_by_2stream_bybnd (ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_1scalar_by_nstream_bybnd (ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_2stream_by_1scalar_bybnd (ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_2stream_by_2stream_bybnd (ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_2stream_by_nstream_bybnd (ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_nstream_by_1scalar_bybnd (ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_nstream_by_2stream_bybnd (ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine inc_nstream_by_nstream_bybnd (ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public subroutine increment_1scalar_by_1scalar (ncol, nlay, ngpt, tau1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 public subroutine increment_1scalar_by_2stream (ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 public subroutine increment_1scalar_by_nstream (ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 public subroutine increment_2stream_by_1scalar (ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 public subroutine increment_2stream_by_2stream (ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 public subroutine increment_2stream_by_nstream (ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2 public subroutine increment_nstream_by_1scalar (ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 public subroutine increment_nstream_by_2stream (ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 public subroutine increment_nstream_by_nstream (ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2","tags":"","loc":"module/mo_optical_props_kernels.html"},{"title":"mo_fluxes_broadband_kernels – rte-rrtmgp","text":"Uses iso_c_binding mo_rte_kind module~~mo_fluxes_broadband_kernels~~UsesGraph module~mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels iso_c_binding iso_c_binding module~mo_fluxes_broadband_kernels->iso_c_binding module~mo_rte_kind mo_rte_kind module~mo_fluxes_broadband_kernels->module~mo_rte_kind module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_fluxes_broadband_kernels~~UsedByGraph module~mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes mo_fluxes module~mo_fluxes->module~mo_fluxes_broadband_kernels module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_fluxes module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_fluxes_bygpoint->module~mo_fluxes module~mo_rte_sw mo_rte_sw module~mo_rte_sw->module~mo_fluxes module~mo_fluxes_byband mo_fluxes_byband module~mo_fluxes_byband->module~mo_fluxes module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_fluxes module~mo_compute_bc->module~mo_rte_lw module~mo_compute_bc->module~mo_rte_sw module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces net_broadband Subroutines sum_broadband Interfaces public interface net_broadband private subroutine net_broadband_full(ncol, nlev, ngpt, spectral_flux_dn, spectral_flux_up, broadband_flux_net) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_up real(kind=wp), intent(out), dimension(ncol, nlev) :: broadband_flux_net private subroutine net_broadband_precalc(ncol, nlev, flux_dn, flux_up, broadband_flux_net) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev real(kind=wp), intent(in), dimension(ncol, nlev) :: flux_dn real(kind=wp), intent(in), dimension(ncol, nlev) :: flux_up real(kind=wp), intent(out), dimension(ncol, nlev) :: broadband_flux_net Subroutines public subroutine sum_broadband (ncol, nlev, ngpt, spectral_flux, broadband_flux) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux real(kind=wp), intent(out), dimension(ncol, nlev) :: broadband_flux","tags":"","loc":"module/mo_fluxes_broadband_kernels.html"},{"title":"mo_rte_solver_kernels – rte-rrtmgp","text":"Uses iso_c_binding mo_rte_util_array mo_rte_kind module~~mo_rte_solver_kernels~~UsesGraph module~mo_rte_solver_kernels mo_rte_solver_kernels iso_c_binding iso_c_binding module~mo_rte_solver_kernels->iso_c_binding module~mo_rte_kind mo_rte_kind module~mo_rte_solver_kernels->module~mo_rte_kind module~mo_rte_util_array mo_rte_util_array module~mo_rte_solver_kernels->module~mo_rte_util_array module~mo_rte_kind->iso_c_binding module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines lw_solver_2stream lw_solver_noscat lw_solver_noscat_GaussQuad sw_solver_2stream sw_solver_noscat Subroutines public subroutine lw_solver_2stream (ncol, nlay, ngpt, top_at_1, tau, ssa, g, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dn public subroutine lw_solver_noscat (ncol, nlay, ngpt, top_at_1, D, weight, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, incident_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: D real(kind=wp), intent(in) :: weight real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt), target :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: incident_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g public subroutine lw_solver_noscat_GaussQuad (ncol, nlay, ngpt, top_at_1, nmus, Ds, weights, tau, lay_source, lev_source_inc, lev_source_dec, sfc_emis, sfc_src, inc_flux, flux_up, flux_dn, do_broadband, broadband_up, broadband_dn, do_Jacobians, sfc_srcJac, flux_upJac, do_rescaling, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 integer, intent(in) :: nmus real(kind=wp), intent(in), dimension (ncol,      ngpt, nmus) :: Ds real(kind=wp), intent(in), dimension(nmus) :: weights real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lay_source real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_inc real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: lev_source_dec real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_emis real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_src real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: broadband_dn logical(kind=wl), intent(in) :: do_Jacobians real(kind=wp), intent(in), dimension(ncol       ,ngpt) :: sfc_srcJac real(kind=wp), intent(out), dimension(ncol,nlay+1     ), target :: flux_upJac logical(kind=wl), intent(in) :: do_rescaling real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay  ,ngpt) :: g public subroutine sw_solver_2stream (ncol, nlay, ngpt, top_at_1, tau, ssa, g, mu0, sfc_alb_dir, sfc_alb_dif, inc_flux_dir, flux_up, flux_dn, flux_dir, has_dif_bc, inc_flux_dif, do_broadband, broadband_up, broadband_dn, broadband_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: ssa real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: g real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dir real(kind=wp), intent(in), dimension(ncol,       ngpt) :: sfc_alb_dif real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_up real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dn real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt), target :: flux_dir logical(kind=wl), intent(in) :: has_dif_bc real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dif logical(kind=wl), intent(in) :: do_broadband real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_up real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dn real(kind=wp), intent(out), dimension(ncol,nlay+1     ) :: broadband_dir public pure subroutine sw_solver_noscat (ncol, nlay, ngpt, top_at_1, tau, mu0, inc_flux_dir, flux_dir) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt logical(kind=wl), intent(in) :: top_at_1 real(kind=wp), intent(in), dimension(ncol,nlay,  ngpt) :: tau real(kind=wp), intent(in), dimension(ncol            ) :: mu0 real(kind=wp), intent(in), dimension(ncol,       ngpt) :: inc_flux_dir real(kind=wp), intent(out), dimension(ncol,nlay+1,ngpt) :: flux_dir","tags":"","loc":"module/mo_rte_solver_kernels.html"},{"title":"mo_optical_props_kernels – rte-rrtmgp","text":"Uses iso_c_binding mo_rte_kind module~~mo_optical_props_kernels~2~~UsesGraph module~mo_optical_props_kernels~2 mo_optical_props_kernels iso_c_binding iso_c_binding module~mo_optical_props_kernels~2->iso_c_binding module~mo_rte_kind mo_rte_kind module~mo_optical_props_kernels~2->module~mo_rte_kind module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces delta_scale_2str_kernel extract_subset Subroutines delta_scale_2str_f_k delta_scale_2str_k extract_subset_absorption_tau extract_subset_dim1_3d extract_subset_dim2_4d inc_1scalar_by_1scalar_bybnd inc_1scalar_by_2stream_bybnd inc_1scalar_by_nstream_bybnd inc_2stream_by_1scalar_bybnd inc_2stream_by_2stream_bybnd inc_2stream_by_nstream_bybnd inc_nstream_by_1scalar_bybnd inc_nstream_by_2stream_bybnd inc_nstream_by_nstream_bybnd increment_1scalar_by_1scalar increment_1scalar_by_2stream increment_1scalar_by_nstream increment_2stream_by_1scalar increment_2stream_by_2stream increment_2stream_by_nstream increment_nstream_by_1scalar increment_nstream_by_2stream increment_nstream_by_nstream Interfaces public interface delta_scale_2str_kernel public pure subroutine delta_scale_2str_f_k (ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f public pure subroutine delta_scale_2str_k (ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g public interface extract_subset public pure subroutine extract_subset_dim1_3d (ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out public pure subroutine extract_subset_dim2_4d (nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out public pure subroutine extract_subset_absorption_tau (ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out Subroutines public pure subroutine delta_scale_2str_f_k (ncol, nlay, ngpt, tau, ssa, g, f) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g real(kind=wp), intent(in), dimension(ncol, nlay, ngpt) :: f public pure subroutine delta_scale_2str_k (ncol, nlay, ngpt, tau, ssa, g) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: tau real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: ssa real(kind=wp), intent(inout), dimension(ncol, nlay, ngpt) :: g public pure subroutine extract_subset_absorption_tau (ncol, nlay, ngpt, tau_in, ssa_in, colS, colE, tau_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau_in real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: tau_out public pure subroutine extract_subset_dim1_3d (ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(colE-colS+1, nlay,ngpt) :: array_out public pure subroutine extract_subset_dim2_4d (nmom, ncol, nlay, ngpt, array_in, colS, colE, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(in), dimension(nmom,ncol,nlay,ngpt) :: array_in integer, intent(in) :: colS integer, intent(in) :: colE real(kind=wp), intent(out), dimension(nmom,colE-colS+1, nlay,ngpt) :: array_out public pure subroutine inc_1scalar_by_1scalar_bybnd (ncol, nlay, ngpt, tau1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_1scalar_by_2stream_bybnd (ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_1scalar_by_nstream_bybnd (ncol, nlay, ngpt, tau1, tau2, ssa2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_2stream_by_1scalar_bybnd (ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_2stream_by_2stream_bybnd (ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_2stream_by_nstream_bybnd (ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_nstream_by_1scalar_bybnd (ncol, nlay, ngpt, tau1, ssa1, tau2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_nstream_by_2stream_bybnd (ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: g2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine inc_nstream_by_nstream_bybnd (ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2, nbnd, gpt_lims) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,nbnd) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,nbnd) :: p2 integer, intent(in) :: nbnd integer, intent(in), dimension(2,nbnd) :: gpt_lims public pure subroutine increment_1scalar_by_1scalar (ncol, nlay, ngpt, tau1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 public pure subroutine increment_1scalar_by_2stream (ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 public pure subroutine increment_1scalar_by_nstream (ncol, nlay, ngpt, tau1, tau2, ssa2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 public pure subroutine increment_2stream_by_1scalar (ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 public pure subroutine increment_2stream_by_2stream (ncol, nlay, ngpt, tau1, ssa1, g1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 public pure subroutine increment_2stream_by_nstream (ncol, nlay, ngpt, nmom2, tau1, ssa1, g1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: g1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2 public pure subroutine increment_nstream_by_1scalar (ncol, nlay, ngpt, tau1, ssa1, tau2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 public pure subroutine increment_nstream_by_2stream (ncol, nlay, ngpt, nmom1, tau1, ssa1, p1, tau2, ssa2, g2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: g2 public pure subroutine increment_nstream_by_nstream (ncol, nlay, ngpt, nmom1, nmom2, tau1, ssa1, p1, tau2, ssa2, p2) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: nmom1 integer, intent(in) :: nmom2 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau1 real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: ssa1 real(kind=wp), intent(inout), dimension(nmom1, ncol,nlay,ngpt) :: p1 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: tau2 real(kind=wp), intent(in), dimension(ncol,nlay,ngpt) :: ssa2 real(kind=wp), intent(in), dimension(nmom2, ncol,nlay,ngpt) :: p2","tags":"","loc":"module/mo_optical_props_kernels~2.html"},{"title":"mo_rrtmgp_util_string – rte-rrtmgp","text":"Used by module~~mo_rrtmgp_util_string~~UsedByGraph module~mo_rrtmgp_util_string mo_rrtmgp_util_string module~mo_gas_concentrations mo_gas_concentrations module~mo_gas_concentrations->module~mo_rrtmgp_util_string module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_util_string module~mo_gas_optics_rrtmgp->module~mo_gas_concentrations module~mo_gas_optics mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_gas_concentrations module~mo_compute_bc->module~mo_gas_optics module~mo_gas_optics->module~mo_gas_concentrations module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_gas_concentrations module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions lower_case string_in_array string_loc_in_array Functions public pure function lower_case (input_string) result(output_string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_string Return Value character(len=len) public pure function string_in_array (string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), dimension(:) :: array Return Value logical public pure function string_loc_in_array (string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), dimension(:) :: array Return Value integer","tags":"","loc":"module/mo_rrtmgp_util_string.html"},{"title":"mo_rrtmgp_util_reorder – rte-rrtmgp","text":"Uses mo_rrtmgp_util_reorder_kernels mo_rte_kind module~~mo_rrtmgp_util_reorder~~UsesGraph module~mo_rrtmgp_util_reorder mo_rrtmgp_util_reorder module~mo_rte_kind mo_rte_kind module~mo_rrtmgp_util_reorder->module~mo_rte_kind module~mo_rrtmgp_util_reorder_kernels mo_rrtmgp_util_reorder_kernels module~mo_rrtmgp_util_reorder->module~mo_rrtmgp_util_reorder_kernels iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_rrtmgp_util_reorder_kernels->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rrtmgp_util_reorder~~UsedByGraph module~mo_rrtmgp_util_reorder mo_rrtmgp_util_reorder module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_util_reorder Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines reorder123x321 Subroutines public subroutine reorder123x321 (array, array_out) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(out), dimension(:,:,:) :: array_out","tags":"","loc":"module/mo_rrtmgp_util_reorder.html"},{"title":"mo_gas_concentrations – rte-rrtmgp","text":"Uses mo_rte_config mo_rrtmgp_util_string mo_rte_kind mo_rte_util_array module~~mo_gas_concentrations~~UsesGraph module~mo_gas_concentrations mo_gas_concentrations module~mo_rrtmgp_util_string mo_rrtmgp_util_string module~mo_gas_concentrations->module~mo_rrtmgp_util_string module~mo_rte_kind mo_rte_kind module~mo_gas_concentrations->module~mo_rte_kind module~mo_rte_config mo_rte_config module~mo_gas_concentrations->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_gas_concentrations->module~mo_rte_util_array iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_gas_concentrations~~UsedByGraph module~mo_gas_concentrations mo_gas_concentrations module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_gas_concentrations module~mo_gas_optics mo_gas_optics module~mo_compute_bc->module~mo_gas_optics module~mo_gas_optics->module~mo_gas_concentrations module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_gas_concentrations module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_gas_concentrations module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables GAS_NOT_IN_LIST Derived Types conc_field ty_gas_concs Functions find_gas get_gas_names get_num_gases get_subset_range get_vmr_1d get_vmr_2d init set_vmr_1d set_vmr_2d set_vmr_scalar Subroutines del reset Variables Type Visibility Attributes Name Initial integer, public, parameter :: GAS_NOT_IN_LIST = -1 Derived Types type, public :: conc_field Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:), pointer :: conc => NULL() type, public :: ty_gas_concs Components Type Visibility Attributes Name Initial type( conc_field ), public, dimension(:), allocatable :: concs character(len=32), public, dimension(:), allocatable :: gas_name integer, public :: ncol = 0 integer, public :: nlay = 0 Finalizations Procedures final :: del Type-Bound Procedures procedure, public :: get_gas_names procedure, public :: get_num_gases generic, public :: get_subset => get_subset_range generic, public :: get_vmr => get_vmr_1d, get_vmr_2d procedure, public :: init procedure, public :: reset generic, public :: set_vmr => set_vmr_scalar, set_vmr_1d, set_vmr_2d Functions public function find_gas (this, gas) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this character(len=*), intent(in) :: gas Return Value integer public pure function get_gas_names (this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this Return Value character(len=32),\n  dimension(this%get_num_gases()) public pure function get_num_gases (this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this Return Value integer public function get_subset_range (this, start, n, subset) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(in) :: this integer, intent(in) :: start integer, intent(in) :: n class( ty_gas_concs ), intent(inout) :: subset Return Value character(len=128) public function get_vmr_1d (this, gas, array) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(out), dimension(:) :: array Return Value character(len=128) public function get_vmr_2d (this, gas, array) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(out), dimension(:,:) :: array Return Value character(len=128) public function init (this, gas_names) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in), dimension(:) :: gas_names Return Value character(len=128) public function set_vmr_1d (this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in), dimension(:) :: w Return Value character(len=128) public function set_vmr_2d (this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in), dimension(:,:) :: w Return Value character(len=128) public function set_vmr_scalar (this, gas, w) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this character(len=*), intent(in) :: gas real(kind=wp), intent(in) :: w Return Value character(len=128) Subroutines public subroutine del (this) Arguments Type Intent Optional Attributes Name type( ty_gas_concs ), intent(inout) :: this public subroutine reset (this) Arguments Type Intent Optional Attributes Name class( ty_gas_concs ), intent(inout) :: this","tags":"","loc":"module/mo_gas_concentrations.html"},{"title":"mo_gas_optics – rte-rrtmgp","text":"Uses mo_source_functions mo_gas_concentrations mo_rte_kind mo_optical_props module~~mo_gas_optics~~UsesGraph module~mo_gas_optics mo_gas_optics module~mo_optical_props mo_optical_props module~mo_gas_optics->module~mo_optical_props module~mo_rte_kind mo_rte_kind module~mo_gas_optics->module~mo_rte_kind module~mo_source_functions mo_source_functions module~mo_gas_optics->module~mo_source_functions module~mo_gas_concentrations mo_gas_concentrations module~mo_gas_optics->module~mo_gas_concentrations module~mo_optical_props->module~mo_rte_kind module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->module~mo_optical_props_kernels module~mo_rte_config mo_rte_config module~mo_optical_props->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_optical_props->module~mo_rte_util_array iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_source_functions->module~mo_optical_props module~mo_source_functions->module~mo_rte_kind module~mo_gas_concentrations->module~mo_rte_kind module~mo_rrtmgp_util_string mo_rrtmgp_util_string module~mo_gas_concentrations->module~mo_rrtmgp_util_string module~mo_gas_concentrations->module~mo_rte_config module~mo_gas_concentrations->module~mo_rte_util_array module~mo_optical_props_kernels->module~mo_rte_kind module~mo_optical_props_kernels->iso_c_binding module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_gas_optics~~UsedByGraph module~mo_gas_optics mo_gas_optics module~mo_compute_bc mo_compute_bc module~mo_compute_bc->module~mo_gas_optics module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces gas_optics_ext_abstract gas_optics_int_abstract logical_abstract real_abstract Derived Types ty_gas_optics Abstract Interfaces abstract interface public function gas_optics_ext_abstract(this, play, plev, tlay, gas_desc, optical_props, toa_src, col_dry) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props real(kind=wp), intent(out), dimension(:,:) :: toa_src real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry Return Value character(len=128) abstract interface public function gas_optics_int_abstract(this, play, plev, tlay, tsfc, gas_desc, optical_props, sources, col_dry, tlev) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay real(kind=wp), intent(in), dimension(:) :: tsfc type( ty_gas_concs ), intent(in) :: gas_desc class( ty_optical_props_arry ), intent(inout) :: optical_props class( ty_source_func_lw ), intent(inout) :: sources real(kind=wp), intent(in), optional dimension(:,:), target :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: tlev Return Value character(len=128) abstract interface public function logical_abstract(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value logical abstract interface public function real_abstract(this) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: this Return Value real(kind=wp) Derived Types type, public, abstract, extends( ty_optical_props ) :: ty_gas_optics Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize => finalize_base generic, public :: gas_optics => gas_optics_int, gas_optics_ext procedure(gas_optics_ext_abstract), public :: gas_optics_ext procedure(gas_optics_int_abstract), public :: gas_optics_int procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ngpt procedure(real_abstract), public :: get_press_max procedure(real_abstract), public :: get_press_min procedure(real_abstract), public :: get_temp_max procedure(real_abstract), public :: get_temp_min procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure(logical_abstract), public :: source_is_external procedure(logical_abstract), public :: source_is_internal","tags":"","loc":"module/mo_gas_optics.html"},{"title":"mo_gas_optics_rrtmgp – rte-rrtmgp","text":"Uses mo_gas_concentrations mo_source_functions mo_rte_config mo_rrtmgp_constants mo_rte_kind mo_gas_optics mo_rte_util_array mo_rrtmgp_util_reorder mo_gas_optics_kernels mo_optical_props mo_rrtmgp_util_string module~~mo_gas_optics_rrtmgp~~UsesGraph module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_optical_props mo_optical_props module~mo_gas_optics_rrtmgp->module~mo_optical_props module~mo_gas_optics mo_gas_optics module~mo_gas_optics_rrtmgp->module~mo_gas_optics module~mo_gas_concentrations mo_gas_concentrations module~mo_gas_optics_rrtmgp->module~mo_gas_concentrations module~mo_rrtmgp_util_string mo_rrtmgp_util_string module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_util_string module~mo_rte_config mo_rte_config module~mo_gas_optics_rrtmgp->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_gas_optics_rrtmgp->module~mo_rte_util_array module~mo_gas_optics_kernels~2 mo_gas_optics_kernels module~mo_gas_optics_rrtmgp->module~mo_gas_optics_kernels~2 module~mo_rrtmgp_constants mo_rrtmgp_constants module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_constants module~mo_rrtmgp_util_reorder mo_rrtmgp_util_reorder module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_util_reorder module~mo_rte_kind mo_rte_kind module~mo_gas_optics_rrtmgp->module~mo_rte_kind module~mo_source_functions mo_source_functions module~mo_gas_optics_rrtmgp->module~mo_source_functions module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_kind module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->module~mo_optical_props_kernels module~mo_gas_optics->module~mo_optical_props module~mo_gas_optics->module~mo_gas_concentrations module~mo_gas_optics->module~mo_rte_kind module~mo_gas_optics->module~mo_source_functions module~mo_gas_concentrations->module~mo_rrtmgp_util_string module~mo_gas_concentrations->module~mo_rte_config module~mo_gas_concentrations->module~mo_rte_util_array module~mo_gas_concentrations->module~mo_rte_kind module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind module~mo_gas_optics_kernels~2->module~mo_rte_util_array module~mo_gas_optics_kernels~2->module~mo_rte_kind module~mo_rrtmgp_constants->module~mo_rte_kind module~mo_rrtmgp_util_reorder->module~mo_rte_kind module~mo_rrtmgp_util_reorder_kernels mo_rrtmgp_util_reorder_kernels module~mo_rrtmgp_util_reorder->module~mo_rrtmgp_util_reorder_kernels iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_source_functions->module~mo_optical_props module~mo_source_functions->module~mo_rte_kind module~mo_optical_props_kernels->module~mo_rte_kind module~mo_optical_props_kernels->iso_c_binding module~mo_rrtmgp_util_reorder_kernels->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_gas_optics_rrtmgp Functions get_col_dry Derived Types type, public, extends( ty_gas_optics ) :: ty_gas_optics_rrtmgp Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal procedure, public :: compute_optimal_angles procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize => finalize_base generic, public :: gas_optics => gas_optics_int, gas_optics_ext procedure, public :: gas_optics_ext procedure, public :: gas_optics_int procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gases procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ngas procedure, public :: get_ngpt procedure, public :: get_press_max procedure, public :: get_press_min procedure, public :: get_temp_max procedure, public :: get_temp_min procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base generic, public :: load => load_int, load_ext procedure, public :: set_name procedure, public :: set_solar_variability procedure, public :: set_tsi procedure, public :: source_is_external procedure, public :: source_is_internal Functions public function get_col_dry (vmr_h2o, plev, latitude) result(col_dry) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: vmr_h2o real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), optional dimension(:) :: latitude Return Value real(kind=wp),\n  dimension(size(plev,dim=1),size(plev,dim=2)-1)","tags":"","loc":"module/mo_gas_optics_rrtmgp.html"},{"title":"mo_rrtmgp_constants – rte-rrtmgp","text":"Uses mo_rte_kind module~~mo_rrtmgp_constants~~UsesGraph module~mo_rrtmgp_constants mo_rrtmgp_constants module~mo_rte_kind mo_rte_kind module~mo_rrtmgp_constants->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rrtmgp_constants~~UsedByGraph module~mo_rrtmgp_constants mo_rrtmgp_constants module~mo_heating_rates mo_heating_rates module~mo_heating_rates->module~mo_rrtmgp_constants module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables R_univ_gconst avogad k_boltz m_h2o Subroutines init_constants Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: R_univ_gconst = avogad*k_boltz real(kind=wp), public, parameter :: avogad = 6.02214076e23_wp real(kind=wp), public, parameter :: k_boltz = 1.380649e-23_wp real(kind=wp), public, parameter :: m_h2o = 0.018016_wp Subroutines public subroutine init_constants (gravity, mol_weight_dry_air, heat_capacity_dry_air) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), optional :: gravity real(kind=wp), intent(in), optional :: mol_weight_dry_air real(kind=wp), intent(in), optional :: heat_capacity_dry_air","tags":"","loc":"module/mo_rrtmgp_constants.html"},{"title":"mo_gas_optics_kernels – rte-rrtmgp","text":"Uses mo_rte_util_array mo_rte_kind module~~mo_gas_optics_kernels~2~~UsesGraph module~mo_gas_optics_kernels~2 mo_gas_optics_kernels module~mo_rte_kind mo_rte_kind module~mo_gas_optics_kernels~2->module~mo_rte_kind module~mo_rte_util_array mo_rte_util_array module~mo_gas_optics_kernels~2->module~mo_rte_util_array iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_gas_optics_kernels~2~~UsedByGraph module~mo_gas_optics_kernels~2 mo_gas_optics_kernels module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_gas_optics_kernels~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions interpolate1D interpolate2D interpolate3D Subroutines compute_Planck_source compute_tau_absorption compute_tau_rayleigh gas_optical_depths_major gas_optical_depths_minor interpolation minmaxloc Functions public function interpolate1D (val, offset, delta, table) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: val real(kind=wp), intent(in) :: offset real(kind=wp), intent(in) :: delta real(kind=wp), intent(in), dimension(:) :: table Return Value real(kind=wp) public function interpolate2D (fminor, k, igpt, jeta, jtemp) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: fminor real(kind=wp), intent(in), dimension(:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp Return Value real(kind=wp) public function interpolate3D (scaling, fmajor, k, igpt, jeta, jtemp, jpress) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: scaling real(kind=wp), intent(in), dimension(2,2,2) :: fmajor real(kind=wp), intent(in), dimension(:,:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp integer, intent(in) :: jpress Return Value real(kind=wp) Subroutines public subroutine compute_Planck_source (ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, nPlanckTemp, tlay, tlev, tsfc, sfc_lay, fmajor, jeta, tropo, jtemp, jpress, gpoint_bands, band_lims_gpt, pfracin, temp_ref_min, totplnk_delta, totplnk, gpoint_flavor, sfc_src, lay_src, lev_src_inc, lev_src_dec, sfc_source_Jac) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nPlanckTemp real(kind=wp), intent(in), dimension(ncol,nlay  ) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay+1) :: tlev real(kind=wp), intent(in), dimension(ncol       ) :: tsfc integer, intent(in) :: sfc_lay real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(            ncol,nlay) :: tropo integer, intent(in), dimension(            ncol,nlay) :: jtemp integer, intent(in), dimension(            ncol,nlay) :: jpress integer, intent(in), dimension(ngpt) :: gpoint_bands integer, intent(in), dimension(2, nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: pfracin real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: totplnk_delta real(kind=wp), intent(in), dimension(nPlanckTemp,nbnd) :: totplnk integer, intent(in), dimension(2,ngpt) :: gpoint_flavor real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lay_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_inc real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_dec real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_source_Jac public subroutine compute_tau_absorption (ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, nminorlower, nminorklower, nminorupper, nminorkupper, idx_h2o, gpoint_flavor, band_lims_gpt, kmajor, kminor_lower, kminor_upper, minor_limits_gpt_lower, minor_limits_gpt_upper, minor_scales_with_density_lower, minor_scales_with_density_upper, scale_by_complement_lower, scale_by_complement_upper, idx_minor_lower, idx_minor_upper, idx_minor_scaling_lower, idx_minor_scaling_upper, kminor_start_lower, kminor_start_upper, tropo, col_mix, fmajor, fminor, play, tlay, col_gas, jeta, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nminorlower integer, intent(in) :: nminorklower integer, intent(in) :: nminorupper integer, intent(in) :: nminorkupper integer, intent(in) :: idx_h2o integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(ntemp,neta,nminorklower) :: kminor_lower real(kind=wp), intent(in), dimension(ntemp,neta,nminorkupper) :: kminor_upper integer, intent(in), dimension(2,nminorlower) :: minor_limits_gpt_lower integer, intent(in), dimension(2,nminorupper) :: minor_limits_gpt_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: minor_scales_with_density_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: minor_scales_with_density_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: scale_by_complement_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: scale_by_complement_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_scaling_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_scaling_upper integer, intent(in), dimension(  nminorlower) :: kminor_start_lower integer, intent(in), dimension(  nminorupper) :: kminor_start_upper logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav       ) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav       ) :: fmajor real(kind=wp), intent(in), dimension(2,2,  ncol,nlay,nflav       ) :: fminor real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: play real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: tlay real(kind=wp), intent(in), dimension(            ncol,nlay,0:ngas) :: col_gas integer, intent(in), dimension(2,    ncol,nlay,nflav       ) :: jeta integer, intent(in), dimension(            ncol,nlay       ) :: jtemp integer, intent(in), dimension(            ncol,nlay       ) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau public subroutine compute_tau_rayleigh (ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, krayl, idx_h2o, col_dry, col_gas, fminor, jeta, tropo, jtemp, tau_rayleigh) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,ngpt,2) :: krayl integer, intent(in) :: idx_h2o real(kind=wp), intent(in), dimension(ncol,nlay) :: col_dry real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: tau_rayleigh public subroutine gas_optical_depths_major (ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, kmajor, col_mix, fmajor, jeta, tropo, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp integer, intent(in), dimension(ncol,nlay) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau public subroutine gas_optical_depths_minor (ncol, nlay, ngpt, ngas, nflav, ntemp, neta, nminor, nminork, idx_h2o, idx_tropo, gpt_flv, kminor, minor_limits_gpt, minor_scales_with_density, scale_by_complement, idx_minor, idx_minor_scaling, kminor_start, play, tlay, col_gas, fminor, jeta, layer_limits, jtemp, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: ntemp integer, intent(in) :: neta integer, intent(in) :: nminor integer, intent(in) :: nminork integer, intent(in) :: idx_h2o integer, intent(in) :: idx_tropo integer, intent(in), dimension(2, ngpt) :: gpt_flv real(kind=wp), intent(in), dimension(ntemp,neta,nminork) :: kminor integer, intent(in), dimension(2,nminor) :: minor_limits_gpt logical(kind=wl), intent(in), dimension(  nminor) :: minor_scales_with_density logical(kind=wl), intent(in), dimension(  nminor) :: scale_by_complement integer, intent(in), dimension(  nminor) :: idx_minor integer, intent(in), dimension(  nminor) :: idx_minor_scaling integer, intent(in), dimension(  nminor) :: kminor_start real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta integer, intent(in), dimension(ncol, 2) :: layer_limits integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau public subroutine interpolation (ncol, nlay, ngas, nflav, neta, npres, ntemp, flavor, press_ref_log, temp_ref, press_ref_log_delta, temp_ref_min, temp_ref_delta, press_ref_trop_log, vmr_ref, play, tlay, col_gas, jtemp, fmajor, fminor, col_mix, tropo, jeta, jpress) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,nflav) :: flavor real(kind=wp), intent(in), dimension(npres) :: press_ref_log real(kind=wp), intent(in), dimension(ntemp) :: temp_ref real(kind=wp), intent(in) :: press_ref_log_delta real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: temp_ref_delta real(kind=wp), intent(in) :: press_ref_trop_log real(kind=wp), intent(in), dimension(2,0:ngas,ntemp) :: vmr_ref real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas integer, intent(out), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(2,2,2,ncol,nlay,nflav) :: fmajor real(kind=wp), intent(out), dimension(2,2,  ncol,nlay,nflav) :: fminor real(kind=wp), intent(out), dimension(2,    ncol,nlay,nflav) :: col_mix logical(kind=wl), intent(out), dimension(ncol,nlay) :: tropo integer, intent(out), dimension(2,    ncol,nlay,nflav) :: jeta integer, intent(out), dimension(ncol,nlay) :: jpress public subroutine minmaxloc (i, mask, a, minl, maxl) Arguments Type Intent Optional Attributes Name integer :: i logical(kind=wl) :: mask (:,:) real(kind=wp) :: a (:,:) integer :: minl integer :: maxl","tags":"","loc":"module/mo_gas_optics_kernels~2.html"},{"title":"mo_rrtmgp_util_reorder_kernels – rte-rrtmgp","text":"Uses mo_rte_kind module~~mo_rrtmgp_util_reorder_kernels~~UsesGraph module~mo_rrtmgp_util_reorder_kernels mo_rrtmgp_util_reorder_kernels module~mo_rte_kind mo_rte_kind module~mo_rrtmgp_util_reorder_kernels->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rrtmgp_util_reorder_kernels~~UsedByGraph module~mo_rrtmgp_util_reorder_kernels mo_rrtmgp_util_reorder_kernels module~mo_rrtmgp_util_reorder mo_rrtmgp_util_reorder module~mo_rrtmgp_util_reorder->module~mo_rrtmgp_util_reorder_kernels module~mo_gas_optics_rrtmgp mo_gas_optics_rrtmgp module~mo_gas_optics_rrtmgp->module~mo_rrtmgp_util_reorder Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines reorder_123x321_kernel Subroutines public subroutine reorder_123x321_kernel (d1, d2, d3, array_in, array_out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: d1 integer, intent(in) :: d2 integer, intent(in) :: d3 real(kind=wp), intent(in), dimension(d1, d2, d3) :: array_in real(kind=wp), intent(out), dimension(d3, d2, d1) :: array_out","tags":"","loc":"module/mo_rrtmgp_util_reorder_kernels.html"},{"title":"mo_gas_optics_kernels – rte-rrtmgp","text":"Uses mo_rte_util_array mo_rte_kind module~~mo_gas_optics_kernels~~UsesGraph module~mo_gas_optics_kernels mo_gas_optics_kernels module~mo_rte_kind mo_rte_kind module~mo_gas_optics_kernels->module~mo_rte_kind module~mo_rte_util_array mo_rte_util_array module~mo_gas_optics_kernels->module~mo_rte_util_array iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions interpolate1D interpolate2D interpolate2D_byflav interpolate3D interpolate3D_byflav Subroutines compute_Planck_source compute_tau_absorption compute_tau_rayleigh gas_optical_depths_major gas_optical_depths_minor interpolation Functions public pure function interpolate1D (val, offset, delta, table) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: val real(kind=wp), intent(in) :: offset real(kind=wp), intent(in) :: delta real(kind=wp), intent(in), dimension(:,:) :: table Return Value real(kind=wp),\n  dimension(size(table,dim=2)) public pure function interpolate2D (fminor, k, igpt, jeta, jtemp) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: fminor real(kind=wp), intent(in), dimension(:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp Return Value real(kind=wp) public pure function interpolate2D_byflav (fminor, k, gptS, gptE, jeta, jtemp) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: fminor real(kind=wp), intent(in), dimension(:,:,:) :: k integer, intent(in) :: gptS integer, intent(in) :: gptE integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp Return Value real(kind=wp),\n  dimension(gptE-gptS+1) public pure function interpolate3D (scaling, fmajor, k, igpt, jeta, jtemp, jpress) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: scaling real(kind=wp), intent(in), dimension(2,2,2) :: fmajor real(kind=wp), intent(in), dimension(:,:,:,:) :: k integer, intent(in) :: igpt integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp integer, intent(in) :: jpress Return Value real(kind=wp) public pure function interpolate3D_byflav (scaling, fmajor, k, gptS, gptE, jeta, jtemp, jpress) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: scaling real(kind=wp), intent(in), dimension(2,2,2) :: fmajor real(kind=wp), intent(in), dimension(:,:,:,:) :: k integer, intent(in) :: gptS integer, intent(in) :: gptE integer, intent(in), dimension(2) :: jeta integer, intent(in) :: jtemp integer, intent(in) :: jpress Return Value real(kind=wp),\n  dimension(gptE-gptS+1) Subroutines public subroutine compute_Planck_source (ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, nPlanckTemp, tlay, tlev, tsfc, sfc_lay, fmajor, jeta, tropo, jtemp, jpress, gpoint_bands, band_lims_gpt, pfracin, temp_ref_min, totplnk_delta, totplnk, gpoint_flavor, sfc_src, lay_src, lev_src_inc, lev_src_dec, sfc_source_Jac) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nPlanckTemp real(kind=wp), intent(in), dimension(ncol,nlay  ) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay+1) :: tlev real(kind=wp), intent(in), dimension(ncol       ) :: tsfc integer, intent(in) :: sfc_lay real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(            ncol,nlay) :: tropo integer, intent(in), dimension(            ncol,nlay) :: jtemp integer, intent(in), dimension(            ncol,nlay) :: jpress integer, intent(in), dimension(ngpt) :: gpoint_bands integer, intent(in), dimension(2, nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: pfracin real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: totplnk_delta real(kind=wp), intent(in), dimension(nPlanckTemp,nbnd) :: totplnk integer, intent(in), dimension(2,ngpt) :: gpoint_flavor real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lay_src real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_inc real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: lev_src_dec real(kind=wp), intent(out), dimension(ncol,     ngpt) :: sfc_source_Jac public subroutine compute_tau_absorption (ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, nminorlower, nminorklower, nminorupper, nminorkupper, idx_h2o, gpoint_flavor, band_lims_gpt, kmajor, kminor_lower, kminor_upper, minor_limits_gpt_lower, minor_limits_gpt_upper, minor_scales_with_density_lower, minor_scales_with_density_upper, scale_by_complement_lower, scale_by_complement_upper, idx_minor_lower, idx_minor_upper, idx_minor_scaling_lower, idx_minor_scaling_upper, kminor_start_lower, kminor_start_upper, tropo, col_mix, fmajor, fminor, play, tlay, col_gas, jeta, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in) :: nminorlower integer, intent(in) :: nminorklower integer, intent(in) :: nminorupper integer, intent(in) :: nminorkupper integer, intent(in) :: idx_h2o integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(ntemp,neta,nminorklower) :: kminor_lower real(kind=wp), intent(in), dimension(ntemp,neta,nminorkupper) :: kminor_upper integer, intent(in), dimension(2,nminorlower) :: minor_limits_gpt_lower integer, intent(in), dimension(2,nminorupper) :: minor_limits_gpt_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: minor_scales_with_density_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: minor_scales_with_density_upper logical(kind=wl), intent(in), dimension(  nminorlower) :: scale_by_complement_lower logical(kind=wl), intent(in), dimension(  nminorupper) :: scale_by_complement_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_upper integer, intent(in), dimension(  nminorlower) :: idx_minor_scaling_lower integer, intent(in), dimension(  nminorupper) :: idx_minor_scaling_upper integer, intent(in), dimension(  nminorlower) :: kminor_start_lower integer, intent(in), dimension(  nminorupper) :: kminor_start_upper logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav       ) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav       ) :: fmajor real(kind=wp), intent(in), dimension(2,2,  ncol,nlay,nflav       ) :: fminor real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: play real(kind=wp), intent(in), dimension(            ncol,nlay       ) :: tlay real(kind=wp), intent(in), dimension(            ncol,nlay,0:ngas) :: col_gas integer, intent(in), dimension(2,    ncol,nlay,nflav       ) :: jeta integer, intent(in), dimension(            ncol,nlay       ) :: jtemp integer, intent(in), dimension(            ncol,nlay       ) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau public subroutine compute_tau_rayleigh (ncol, nlay, nbnd, ngpt, ngas, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, krayl, idx_h2o, col_dry, col_gas, fminor, jeta, tropo, jtemp, tau_rayleigh) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,ngpt,2) :: krayl integer, intent(in) :: idx_h2o real(kind=wp), intent(in), dimension(ncol,nlay) :: col_dry real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(ncol,nlay,ngpt) :: tau_rayleigh public subroutine gas_optical_depths_major (ncol, nlay, nbnd, ngpt, nflav, neta, npres, ntemp, gpoint_flavor, band_lims_gpt, kmajor, col_mix, fmajor, jeta, tropo, jtemp, jpress, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: nbnd integer, intent(in) :: ngpt integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,ngpt) :: gpoint_flavor integer, intent(in), dimension(2,nbnd) :: band_lims_gpt real(kind=wp), intent(in), dimension(ntemp,neta,npres+1,ngpt) :: kmajor real(kind=wp), intent(in), dimension(2,    ncol,nlay,nflav) :: col_mix real(kind=wp), intent(in), dimension(2,2,2,ncol,nlay,nflav) :: fmajor integer, intent(in), dimension(2,    ncol,nlay,nflav) :: jeta logical(kind=wl), intent(in), dimension(ncol,nlay) :: tropo integer, intent(in), dimension(ncol,nlay) :: jtemp integer, intent(in), dimension(ncol,nlay) :: jpress real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau public subroutine gas_optical_depths_minor (ncol, nlay, ngpt, ngas, nflav, ntemp, neta, nminor, nminork, idx_h2o, gpt_flv, kminor, minor_limits_gpt, minor_scales_with_density, scale_by_complement, idx_minor, idx_minor_scaling, kminor_start, play, tlay, col_gas, fminor, jeta, layer_limits, jtemp, tau) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngpt integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: ntemp integer, intent(in) :: neta integer, intent(in) :: nminor integer, intent(in) :: nminork integer, intent(in) :: idx_h2o integer, intent(in), dimension(ngpt) :: gpt_flv real(kind=wp), intent(in), dimension(ntemp,neta,nminork) :: kminor integer, intent(in), dimension(2,nminor) :: minor_limits_gpt logical(kind=wl), intent(in), dimension(  nminor) :: minor_scales_with_density logical(kind=wl), intent(in), dimension(  nminor) :: scale_by_complement integer, intent(in), dimension(  nminor) :: idx_minor integer, intent(in), dimension(  nminor) :: idx_minor_scaling integer, intent(in), dimension(  nminor) :: kminor_start real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas real(kind=wp), intent(in), dimension(2,2,ncol,nlay,nflav) :: fminor integer, intent(in), dimension(2,  ncol,nlay,nflav) :: jeta integer, intent(in), dimension(ncol, 2) :: layer_limits integer, intent(in), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(inout), dimension(ncol,nlay,ngpt) :: tau public subroutine interpolation (ncol, nlay, ngas, nflav, neta, npres, ntemp, flavor, press_ref_log, temp_ref, press_ref_log_delta, temp_ref_min, temp_ref_delta, press_ref_trop_log, vmr_ref, play, tlay, col_gas, jtemp, fmajor, fminor, col_mix, tropo, jeta, jpress) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlay integer, intent(in) :: ngas integer, intent(in) :: nflav integer, intent(in) :: neta integer, intent(in) :: npres integer, intent(in) :: ntemp integer, intent(in), dimension(2,nflav) :: flavor real(kind=wp), intent(in), dimension(npres) :: press_ref_log real(kind=wp), intent(in), dimension(ntemp) :: temp_ref real(kind=wp), intent(in) :: press_ref_log_delta real(kind=wp), intent(in) :: temp_ref_min real(kind=wp), intent(in) :: temp_ref_delta real(kind=wp), intent(in) :: press_ref_trop_log real(kind=wp), intent(in), dimension(2,0:ngas,ntemp) :: vmr_ref real(kind=wp), intent(in), dimension(ncol,nlay) :: play real(kind=wp), intent(in), dimension(ncol,nlay) :: tlay real(kind=wp), intent(in), dimension(ncol,nlay,0:ngas) :: col_gas integer, intent(out), dimension(ncol,nlay) :: jtemp real(kind=wp), intent(out), dimension(2,2,2,ncol,nlay,nflav) :: fmajor real(kind=wp), intent(out), dimension(2,2,  ncol,nlay,nflav) :: fminor real(kind=wp), intent(out), dimension(2,    ncol,nlay,nflav) :: col_mix logical(kind=wl), intent(out), dimension(ncol,nlay) :: tropo integer, intent(out), dimension(2,    ncol,nlay,nflav) :: jeta integer, intent(out), dimension(ncol,nlay) :: jpress","tags":"","loc":"module/mo_gas_optics_kernels.html"},{"title":"mo_heating_rates – rte-rrtmgp","text":"Uses mo_rte_config mo_rte_util_array mo_rte_kind mo_rrtmgp_constants module~~mo_heating_rates~~UsesGraph module~mo_heating_rates mo_heating_rates module~mo_rrtmgp_constants mo_rrtmgp_constants module~mo_heating_rates->module~mo_rrtmgp_constants module~mo_rte_kind mo_rte_kind module~mo_heating_rates->module~mo_rte_kind module~mo_rte_config mo_rte_config module~mo_heating_rates->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_heating_rates->module~mo_rte_util_array module~mo_rrtmgp_constants->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions compute_heating_rate Functions public function compute_heating_rate (flux_up, flux_dn, plev, heating_rate) result(error_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: flux_up real(kind=wp), intent(in), dimension(:,:) :: flux_dn real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(out), dimension(:,:) :: heating_rate Return Value character(len=128)","tags":"","loc":"module/mo_heating_rates.html"},{"title":"mo_compute_bc – rte-rrtmgp","text":"Uses mo_optical_props mo_source_functions mo_rte_lw mo_rte_config mo_fluxes mo_gas_optics mo_rte_kind mo_rte_util_array mo_rte_sw mo_gas_concentrations module~~mo_compute_bc~~UsesGraph module~mo_compute_bc mo_compute_bc module~mo_rte_lw mo_rte_lw module~mo_compute_bc->module~mo_rte_lw module~mo_rte_sw mo_rte_sw module~mo_compute_bc->module~mo_rte_sw module~mo_optical_props mo_optical_props module~mo_compute_bc->module~mo_optical_props module~mo_gas_optics mo_gas_optics module~mo_compute_bc->module~mo_gas_optics module~mo_gas_concentrations mo_gas_concentrations module~mo_compute_bc->module~mo_gas_concentrations module~mo_fluxes mo_fluxes module~mo_compute_bc->module~mo_fluxes module~mo_rte_config mo_rte_config module~mo_compute_bc->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_compute_bc->module~mo_rte_util_array module~mo_rte_kind mo_rte_kind module~mo_compute_bc->module~mo_rte_kind module~mo_source_functions mo_source_functions module~mo_compute_bc->module~mo_source_functions module~mo_rte_lw->module~mo_optical_props module~mo_rte_lw->module~mo_fluxes module~mo_rte_lw->module~mo_rte_config module~mo_rte_lw->module~mo_rte_util_array module~mo_rte_lw->module~mo_rte_kind module~mo_rte_lw->module~mo_source_functions module~mo_rte_solver_kernels~2 mo_rte_solver_kernels module~mo_rte_lw->module~mo_rte_solver_kernels~2 module~mo_rte_sw->module~mo_optical_props module~mo_rte_sw->module~mo_fluxes module~mo_rte_sw->module~mo_rte_config module~mo_rte_sw->module~mo_rte_util_array module~mo_rte_sw->module~mo_rte_kind module~mo_rte_sw->module~mo_rte_solver_kernels~2 module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_kind module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->module~mo_optical_props_kernels module~mo_gas_optics->module~mo_optical_props module~mo_gas_optics->module~mo_gas_concentrations module~mo_gas_optics->module~mo_rte_kind module~mo_gas_optics->module~mo_source_functions module~mo_gas_concentrations->module~mo_rte_config module~mo_gas_concentrations->module~mo_rte_util_array module~mo_gas_concentrations->module~mo_rte_kind module~mo_rrtmgp_util_string mo_rrtmgp_util_string module~mo_gas_concentrations->module~mo_rrtmgp_util_string module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_config module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes->module~mo_rte_kind module~mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->module~mo_fluxes_broadband_kernels module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_source_functions->module~mo_optical_props module~mo_source_functions->module~mo_rte_kind module~mo_rte_solver_kernels~2->module~mo_rte_util_array module~mo_rte_solver_kernels~2->module~mo_rte_kind module~mo_rte_solver_kernels~2->iso_c_binding module~mo_fluxes_broadband_kernels->module~mo_rte_kind module~mo_fluxes_broadband_kernels->iso_c_binding module~mo_optical_props_kernels->module~mo_rte_kind module~mo_optical_props_kernels->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_fluxes_1lev Functions compute_bc Derived Types type, public, extends( ty_fluxes ) :: ty_fluxes_1lev Type-Bound Procedures procedure, public :: are_desired => are_desired_1lev procedure, public :: reduce => reduce_1lev Functions public function compute_bc (k_dist, play, plev, tlay, gas_concs, flux_bc, mu0) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: k_dist real(kind=wp), intent(in), dimension(:,:) :: play real(kind=wp), intent(in), dimension(:,:) :: plev real(kind=wp), intent(in), dimension(:,:) :: tlay type( ty_gas_concs ), intent(in) :: gas_concs real(kind=wp), intent(out), dimension(:,:), target :: flux_bc real(kind=wp), intent(in), optional dimension(:) :: mu0 Return Value character(len=128)","tags":"","loc":"module/mo_compute_bc.html"},{"title":"mo_rrtmgp_clr_all_sky – rte-rrtmgp","text":"Uses mo_optical_props mo_source_functions mo_rte_lw mo_fluxes mo_gas_optics mo_rte_kind mo_rte_sw mo_gas_concentrations module~~mo_rrtmgp_clr_all_sky~~UsesGraph module~mo_rrtmgp_clr_all_sky mo_rrtmgp_clr_all_sky module~mo_rte_lw mo_rte_lw module~mo_rrtmgp_clr_all_sky->module~mo_rte_lw module~mo_rte_sw mo_rte_sw module~mo_rrtmgp_clr_all_sky->module~mo_rte_sw module~mo_optical_props mo_optical_props module~mo_rrtmgp_clr_all_sky->module~mo_optical_props module~mo_gas_optics mo_gas_optics module~mo_rrtmgp_clr_all_sky->module~mo_gas_optics module~mo_gas_concentrations mo_gas_concentrations module~mo_rrtmgp_clr_all_sky->module~mo_gas_concentrations module~mo_fluxes mo_fluxes module~mo_rrtmgp_clr_all_sky->module~mo_fluxes module~mo_rte_kind mo_rte_kind module~mo_rrtmgp_clr_all_sky->module~mo_rte_kind module~mo_source_functions mo_source_functions module~mo_rrtmgp_clr_all_sky->module~mo_source_functions module~mo_rte_lw->module~mo_optical_props module~mo_rte_lw->module~mo_fluxes module~mo_rte_lw->module~mo_rte_kind module~mo_rte_lw->module~mo_source_functions module~mo_rte_solver_kernels~2 mo_rte_solver_kernels module~mo_rte_lw->module~mo_rte_solver_kernels~2 module~mo_rte_config mo_rte_config module~mo_rte_lw->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_rte_lw->module~mo_rte_util_array module~mo_rte_sw->module~mo_optical_props module~mo_rte_sw->module~mo_fluxes module~mo_rte_sw->module~mo_rte_kind module~mo_rte_sw->module~mo_rte_solver_kernels~2 module~mo_rte_sw->module~mo_rte_config module~mo_rte_sw->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_kind module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->module~mo_optical_props_kernels module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_util_array module~mo_gas_optics->module~mo_optical_props module~mo_gas_optics->module~mo_gas_concentrations module~mo_gas_optics->module~mo_rte_kind module~mo_gas_optics->module~mo_source_functions module~mo_gas_concentrations->module~mo_rte_kind module~mo_rrtmgp_util_string mo_rrtmgp_util_string module~mo_gas_concentrations->module~mo_rrtmgp_util_string module~mo_gas_concentrations->module~mo_rte_config module~mo_gas_concentrations->module~mo_rte_util_array module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_kind module~mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->module~mo_fluxes_broadband_kernels module~mo_fluxes->module~mo_rte_config module~mo_fluxes->module~mo_rte_util_array iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_source_functions->module~mo_optical_props module~mo_source_functions->module~mo_rte_kind module~mo_rte_solver_kernels~2->module~mo_rte_kind module~mo_rte_solver_kernels~2->iso_c_binding module~mo_rte_solver_kernels~2->module~mo_rte_util_array module~mo_fluxes_broadband_kernels->module~mo_rte_kind module~mo_fluxes_broadband_kernels->iso_c_binding module~mo_optical_props_kernels->module~mo_rte_kind module~mo_optical_props_kernels->iso_c_binding module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions rte_lw rte_sw Functions public function rte_lw (k_dist, gas_concs, p_lay, t_lay, p_lev, t_sfc, sfc_emis, cloud_props, allsky_fluxes, clrsky_fluxes, aer_props, col_dry, t_lev, inc_flux, n_gauss_angles) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: k_dist type( ty_gas_concs ), intent(in) :: gas_concs real(kind=wp), intent(in), dimension(:,:) :: p_lay real(kind=wp), intent(in), dimension(:,:) :: t_lay real(kind=wp), intent(in), dimension(:,:) :: p_lev real(kind=wp), intent(in), dimension(:) :: t_sfc real(kind=wp), intent(in), dimension(:,:) :: sfc_emis class( ty_optical_props_arry ), intent(in) :: cloud_props class( ty_fluxes ), intent(inout) :: allsky_fluxes class( ty_fluxes ), intent(inout) :: clrsky_fluxes class( ty_optical_props_arry ), intent(in), optional :: aer_props real(kind=wp), intent(in), optional dimension(:,:) :: col_dry real(kind=wp), intent(in), optional dimension(:,:), target :: t_lev real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux integer, intent(in), optional :: n_gauss_angles Return Value character(len=128) public function rte_sw (k_dist, gas_concs, p_lay, t_lay, p_lev, mu0, sfc_alb_dir, sfc_alb_dif, cloud_props, allsky_fluxes, clrsky_fluxes, aer_props, col_dry, inc_flux) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_gas_optics ), intent(in) :: k_dist type( ty_gas_concs ), intent(in) :: gas_concs real(kind=wp), intent(in), dimension(:,:) :: p_lay real(kind=wp), intent(in), dimension(:,:) :: t_lay real(kind=wp), intent(in), dimension(:,:) :: p_lev real(kind=wp), intent(in), dimension(:  ) :: mu0 real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dir real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dif class( ty_optical_props_arry ), intent(in) :: cloud_props class( ty_fluxes ), intent(inout) :: allsky_fluxes class( ty_fluxes ), intent(inout) :: clrsky_fluxes class( ty_optical_props_arry ), intent(in), optional target :: aer_props real(kind=wp), intent(in), optional dimension(:,:) :: col_dry real(kind=wp), intent(in), optional dimension(:,:) :: inc_flux Return Value character(len=128)","tags":"","loc":"module/mo_rrtmgp_clr_all_sky.html"},{"title":"mo_fluxes_byband – rte-rrtmgp","text":"Uses mo_optical_props mo_rte_config mo_rte_kind mo_rte_util_array mo_fluxes module~~mo_fluxes_byband~~UsesGraph module~mo_fluxes_byband mo_fluxes_byband module~mo_optical_props mo_optical_props module~mo_fluxes_byband->module~mo_optical_props module~mo_fluxes mo_fluxes module~mo_fluxes_byband->module~mo_fluxes module~mo_rte_config mo_rte_config module~mo_fluxes_byband->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_fluxes_byband->module~mo_rte_util_array module~mo_rte_kind mo_rte_kind module~mo_fluxes_byband->module~mo_rte_kind module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_kind module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->module~mo_optical_props_kernels module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_config module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes->module~mo_rte_kind module~mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->module~mo_fluxes_broadband_kernels module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_fluxes_broadband_kernels->module~mo_rte_kind module~mo_fluxes_broadband_kernels->iso_c_binding module~mo_optical_props_kernels->module~mo_rte_kind module~mo_optical_props_kernels->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces net_byband Derived Types ty_fluxes_byband Functions are_desired_byband reduce_byband Subroutines net_byband_full net_byband_precalc sum_byband Interfaces public interface net_byband public subroutine net_byband_full (ncol, nlev, ngpt, nbnd, band_lims, spectral_flux_dn, spectral_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt integer, intent(in) :: nbnd integer, intent(in), dimension(2,          nbnd) :: band_lims real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net public subroutine net_byband_precalc (ncol, nlev, nbnd, byband_flux_dn, byband_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: nbnd real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net Derived Types type, public, extends( ty_fluxes_broadband ) :: ty_fluxes_byband Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_dn => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_dn_dir => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_net => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: bnd_flux_up => NULL() Type-Bound Procedures procedure, public :: are_desired => are_desired_byband procedure, public :: reduce => reduce_byband Functions public function are_desired_byband (this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_byband ), intent(in) :: this Return Value logical public function reduce_byband (this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_byband ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128) Subroutines public subroutine net_byband_full (ncol, nlev, ngpt, nbnd, band_lims, spectral_flux_dn, spectral_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt integer, intent(in) :: nbnd integer, intent(in), dimension(2,          nbnd) :: band_lims real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net public subroutine net_byband_precalc (ncol, nlev, nbnd, byband_flux_dn, byband_flux_up, byband_flux_net) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: nbnd real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_dn real(kind=wp), intent(in), dimension(ncol, nlev, nbnd) :: byband_flux_up real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux_net public subroutine sum_byband (ncol, nlev, ngpt, nbnd, band_lims, spectral_flux, byband_flux) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncol integer, intent(in) :: nlev integer, intent(in) :: ngpt integer, intent(in) :: nbnd integer, intent(in), dimension(2,          nbnd) :: band_lims real(kind=wp), intent(in), dimension(ncol, nlev, ngpt) :: spectral_flux real(kind=wp), intent(out), dimension(ncol, nlev, nbnd) :: byband_flux","tags":"","loc":"module/mo_fluxes_byband.html"},{"title":"mo_fluxes_bygpoint – rte-rrtmgp","text":"Uses mo_fluxes mo_rte_util_array mo_rte_kind mo_optical_props module~~mo_fluxes_bygpoint~~UsesGraph module~mo_fluxes_bygpoint mo_fluxes_bygpoint module~mo_fluxes mo_fluxes module~mo_fluxes_bygpoint->module~mo_fluxes module~mo_optical_props mo_optical_props module~mo_fluxes_bygpoint->module~mo_optical_props module~mo_rte_kind mo_rte_kind module~mo_fluxes_bygpoint->module~mo_rte_kind module~mo_rte_util_array mo_rte_util_array module~mo_fluxes_bygpoint->module~mo_rte_util_array module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_kind module~mo_fluxes->module~mo_rte_util_array module~mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->module~mo_fluxes_broadband_kernels module~mo_rte_config mo_rte_config module~mo_fluxes->module~mo_rte_config module~mo_optical_props->module~mo_rte_kind module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->module~mo_optical_props_kernels module~mo_optical_props->module~mo_rte_config iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_rte_util_array->module~mo_rte_kind module~mo_fluxes_broadband_kernels->module~mo_rte_kind module~mo_fluxes_broadband_kernels->iso_c_binding module~mo_optical_props_kernels->module~mo_rte_kind module~mo_optical_props_kernels->iso_c_binding module~mo_rte_config->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_fluxes_bygpoint Functions are_desired_bygpoint reduce_bygpoint Derived Types type, public, extends( ty_fluxes ) :: ty_fluxes_bygpoint Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_dn => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_dn_dir => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_net => NULL() real(kind=wp), public, dimension(:,:,:), pointer :: gpt_flux_up => NULL() Type-Bound Procedures procedure, public :: are_desired => are_desired_bygpoint procedure, public :: reduce => reduce_bygpoint Functions public function are_desired_bygpoint (this) Arguments Type Intent Optional Attributes Name class( ty_fluxes_bygpoint ), intent(in) :: this Return Value logical public function reduce_bygpoint (this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_fluxes_bygpoint ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"module/mo_fluxes_bygpoint.html"},{"title":"mo_solar_variability – rte-rrtmgp","text":"Uses mo_rte_kind module~~mo_solar_variability~~UsesGraph module~mo_solar_variability mo_solar_variability module~mo_rte_kind mo_rte_kind module~mo_solar_variability->module~mo_rte_kind iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_solar_var Derived Types type, public :: ty_solar_var Type-Bound Procedures procedure, public :: finalize procedure, public :: load procedure, public :: solar_var_ind_interp","tags":"","loc":"module/mo_solar_variability.html"},{"title":"mo_cloud_sampling – rte-rrtmgp","text":"Uses mo_optical_props mo_rte_kind module~~mo_cloud_sampling~~UsesGraph module~mo_cloud_sampling mo_cloud_sampling module~mo_optical_props mo_optical_props module~mo_cloud_sampling->module~mo_optical_props module~mo_rte_kind mo_rte_kind module~mo_cloud_sampling->module~mo_rte_kind module~mo_optical_props->module~mo_rte_kind module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->module~mo_optical_props_kernels module~mo_rte_config mo_rte_config module~mo_optical_props->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_optical_props->module~mo_rte_util_array iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_optical_props_kernels->module~mo_rte_kind module~mo_optical_props_kernels->iso_c_binding module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions draw_samples sampled_mask_exp_ran sampled_mask_max_ran Functions public function draw_samples (cloud_mask, clouds, clouds_sampled) result(error_msg) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:,:) :: cloud_mask class( ty_optical_props_arry ), intent(in) :: clouds class( ty_optical_props_arry ), intent(inout) :: clouds_sampled Return Value character(len=128) public function sampled_mask_exp_ran (randoms, cloud_frac, overlap_param, cloud_mask) result(error_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: randoms real(kind=wp), intent(in), dimension(:,:) :: cloud_frac real(kind=wp), intent(in), dimension(:,:) :: overlap_param logical, intent(out), dimension(:,:,:) :: cloud_mask Return Value character(len=128) public function sampled_mask_max_ran (randoms, cloud_frac, cloud_mask) result(error_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: randoms real(kind=wp), intent(in), dimension(:,:) :: cloud_frac logical, intent(out), dimension(:,:,:) :: cloud_mask Return Value character(len=128)","tags":"","loc":"module/mo_cloud_sampling.html"},{"title":"mo_cloud_optics – rte-rrtmgp","text":"Uses mo_rte_config mo_rte_util_array mo_rte_kind mo_optical_props module~~mo_cloud_optics~~UsesGraph module~mo_cloud_optics mo_cloud_optics module~mo_optical_props mo_optical_props module~mo_cloud_optics->module~mo_optical_props module~mo_rte_kind mo_rte_kind module~mo_cloud_optics->module~mo_rte_kind module~mo_rte_config mo_rte_config module~mo_cloud_optics->module~mo_rte_config module~mo_rte_util_array mo_rte_util_array module~mo_cloud_optics->module~mo_rte_util_array module~mo_optical_props->module~mo_rte_kind module~mo_optical_props->module~mo_rte_config module~mo_optical_props->module~mo_rte_util_array module~mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->module~mo_optical_props_kernels iso_c_binding iso_c_binding module~mo_rte_kind->iso_c_binding module~mo_rte_config->module~mo_rte_kind module~mo_rte_util_array->module~mo_rte_kind module~mo_optical_props_kernels->module~mo_rte_kind module~mo_optical_props_kernels->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pade_eval Derived Types ty_cloud_optics Interfaces public interface pade_eval private function pade_eval_nbnd(nbnd, nrads, m, n, irad, re, pade_coeffs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nbnd integer, intent(in) :: nrads integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: irad real(kind=wp), intent(in) :: re real(kind=wp), intent(in), dimension(nbnd, nrads, 0:m+n) :: pade_coeffs Return Value real(kind=wp),\n  dimension(nbnd) private function pade_eval_1(iband, nbnd, nrads, m, n, irad, re, pade_coeffs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iband integer, intent(in) :: nbnd integer, intent(in) :: nrads integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: irad real(kind=wp), intent(in) :: re real(kind=wp), intent(in), dimension(nbnd, nrads, 0:m+n) :: pade_coeffs Return Value real(kind=wp) Derived Types type, public, extends( ty_optical_props ) :: ty_cloud_optics Components Type Visibility Attributes Name Initial integer, public, dimension(:,:), allocatable :: band2gpt (begin g-point, end g-point) = band2gpt(2,band) real(kind=wp), public, dimension(:,:), allocatable :: band_lims_wvn (upper and lower wavenumber by band) = band_lims_wvn(2,band) integer, public, dimension(:), allocatable :: gpt2band band = gpt2band(g-point) character(len=name_len), public :: name = \"\" Type-Bound Procedures procedure, public :: bands_are_equal procedure, public :: cloud_optics procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_max_radius_ice procedure, public :: get_max_radius_liq procedure, public :: get_min_radius_ice procedure, public :: get_min_radius_liq procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ngpt procedure, public :: get_num_ice_roughness_types procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base generic, public :: load => load_lut, load_pade procedure, public :: set_ice_roughness procedure, public :: set_name","tags":"","loc":"module/mo_cloud_optics.html"},{"title":"Additional Documentation – rte-rrtmgp","text":"This and subsequent pages contain documentation to help new users of Vegetables get started and understand how to use this documentation.\nIt contains a Tutorial , and a more [organized_listing] of the functionality of the framework.","tags":"","loc":"page//index.html"},{"title":"Organized Listing – rte-rrtmgp","text":"lists describing a providing links to specific items lists describing a providing links to specific items The most involved class structure is in [ mo_optical_props.F90 ]. Here we have an  base class ([ ty_optical_props ]) that defines ~20 type-bound procedures, an abstract sub-class ([ ty_optical_props_arry ]) that defines three more deferred interfaces, and three sub-classes of ty_optical_props_arry ([ ty_optical_props_1scl ], [ ty_optical_props_2str ], [ ty_optical_props_nstr ] that add new procedures (e.g. [ init_and_alloc_2str ])","tags":"","loc":"page/./Organized_Listing.html"},{"title":"Tutorial – rte-rrtmgp","text":"Prerequisites Getting Started With rte-rrtmgp More Documentation Prerequisites This tutorial assumes that you have working knowledge of, and are comfortable using the following tools: Getting Started With rte-rrtmgp If this is your first encounter with rte-rrtmgp,\nthe following resources might be useful.... With those installed and configured, you should be able to open a terminal and issue the following commands. *Command line example git clone https://github.com/earth-system-radiation/rte-rrtmgp.git\ncd rte-rrtmgp More Documentation You should also read through the organized listing of capabilities to get a more comprehensive view of the available functionality. The organized listing contains a more comprehensive view of the available capabilities an functionality of the code.","tags":"","loc":"page/./Tutorial.html"}]}